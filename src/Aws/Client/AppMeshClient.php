<?php
namespace AWS\AppMesh;

class AppMeshClient
{
    /**
     * @param array{clientToken?:string, gatewayRouteName:string, meshName:string, meshOwner?:string, spec:array{grpcRoute?:array{action:array{rewrite?:array{hostname?:array{defaultTargetHostname?:"ENABLED"|"DISABLED"}}, target:array{port?:int, virtualService:array{virtualServiceName:string}}}, match:array{hostname?:array{exact?:string, suffix?:string}, metadata?:array<array{invert?:bool, match?:mixed, name:string}>, port?:int, serviceName?:string}}, http2Route?:array{action:array{rewrite?:array{hostname?:array{defaultTargetHostname?:"ENABLED"|"DISABLED"}, path?:array{exact?:string}, prefix?:array{defaultPrefix?:"ENABLED"|"DISABLED", value?:string}}, target:array{port?:int, virtualService:array{virtualServiceName:string}}}, match:array{headers?:array<array{invert?:bool, match?:mixed, name:string}>, hostname?:array{exact?:string, suffix?:string}, method?:"GET"|"HEAD"|"POST"|"PUT"|"DELETE"|"CONNECT"|"OPTIONS"|"TRACE"|"PATCH", path?:array{exact?:string, regex?:string}, port?:int, prefix?:string, queryParameters?:array<array{match?:mixed, name:string}>}}, httpRoute?:array{action:array{rewrite?:array{hostname?:array{defaultTargetHostname?:"ENABLED"|"DISABLED"}, path?:array{exact?:string}, prefix?:array{defaultPrefix?:"ENABLED"|"DISABLED", value?:string}}, target:array{port?:int, virtualService:array{virtualServiceName:string}}}, match:array{headers?:array<array{invert?:bool, match?:mixed, name:string}>, hostname?:array{exact?:string, suffix?:string}, method?:"GET"|"HEAD"|"POST"|"PUT"|"DELETE"|"CONNECT"|"OPTIONS"|"TRACE"|"PATCH", path?:array{exact?:string, regex?:string}, port?:int, prefix?:string, queryParameters?:array<array{match?:mixed, name:string}>}}, priority?:int}, tags?:array<array{key:string, value:string}>, virtualGatewayName:string} $args
     * @return \AWS\Result<array{gatewayRoute:array{gatewayRouteName:string, meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, spec:array{grpcRoute?:array{action:array{rewrite?:array{hostname?:array{defaultTargetHostname?:"ENABLED"|"DISABLED"}}, target:array{port?:int, virtualService:array{virtualServiceName:string}}}, match:array{hostname?:array{exact?:string, suffix?:string}, metadata?:array<array{invert?:bool, match?:mixed, name:string}>, port?:int, serviceName?:string}}, http2Route?:array{action:array{rewrite?:array{hostname?:array{defaultTargetHostname?:"ENABLED"|"DISABLED"}, path?:array{exact?:string}, prefix?:array{defaultPrefix?:"ENABLED"|"DISABLED", value?:string}}, target:array{port?:int, virtualService:array{virtualServiceName:string}}}, match:array{headers?:array<array{invert?:bool, match?:mixed, name:string}>, hostname?:array{exact?:string, suffix?:string}, method?:"GET"|"HEAD"|"POST"|"PUT"|"DELETE"|"CONNECT"|"OPTIONS"|"TRACE"|"PATCH", path?:array{exact?:string, regex?:string}, port?:int, prefix?:string, queryParameters?:array<array{match?:mixed, name:string}>}}, httpRoute?:array{action:array{rewrite?:array{hostname?:array{defaultTargetHostname?:"ENABLED"|"DISABLED"}, path?:array{exact?:string}, prefix?:array{defaultPrefix?:"ENABLED"|"DISABLED", value?:string}}, target:array{port?:int, virtualService:array{virtualServiceName:string}}}, match:array{headers?:array<array{invert?:bool, match?:mixed, name:string}>, hostname?:array{exact?:string, suffix?:string}, method?:"GET"|"HEAD"|"POST"|"PUT"|"DELETE"|"CONNECT"|"OPTIONS"|"TRACE"|"PATCH", path?:array{exact?:string, regex?:string}, port?:int, prefix?:string, queryParameters?:array<array{match?:mixed, name:string}>}}, priority?:int}, status:array{status:mixed}, virtualGatewayName:string}}>
     */
    public function createGatewayRoute(array $args): \AWS\Result { }

    /**
     * @param array{clientToken?:string, gatewayRouteName:string, meshName:string, meshOwner?:string, spec:array{grpcRoute?:array{action:array{rewrite?:array{hostname?:array{defaultTargetHostname?:"ENABLED"|"DISABLED"}}, target:array{port?:int, virtualService:array{virtualServiceName:string}}}, match:array{hostname?:array{exact?:string, suffix?:string}, metadata?:array<array{invert?:bool, match?:mixed, name:string}>, port?:int, serviceName?:string}}, http2Route?:array{action:array{rewrite?:array{hostname?:array{defaultTargetHostname?:"ENABLED"|"DISABLED"}, path?:array{exact?:string}, prefix?:array{defaultPrefix?:"ENABLED"|"DISABLED", value?:string}}, target:array{port?:int, virtualService:array{virtualServiceName:string}}}, match:array{headers?:array<array{invert?:bool, match?:mixed, name:string}>, hostname?:array{exact?:string, suffix?:string}, method?:"GET"|"HEAD"|"POST"|"PUT"|"DELETE"|"CONNECT"|"OPTIONS"|"TRACE"|"PATCH", path?:array{exact?:string, regex?:string}, port?:int, prefix?:string, queryParameters?:array<array{match?:mixed, name:string}>}}, httpRoute?:array{action:array{rewrite?:array{hostname?:array{defaultTargetHostname?:"ENABLED"|"DISABLED"}, path?:array{exact?:string}, prefix?:array{defaultPrefix?:"ENABLED"|"DISABLED", value?:string}}, target:array{port?:int, virtualService:array{virtualServiceName:string}}}, match:array{headers?:array<array{invert?:bool, match?:mixed, name:string}>, hostname?:array{exact?:string, suffix?:string}, method?:"GET"|"HEAD"|"POST"|"PUT"|"DELETE"|"CONNECT"|"OPTIONS"|"TRACE"|"PATCH", path?:array{exact?:string, regex?:string}, port?:int, prefix?:string, queryParameters?:array<array{match?:mixed, name:string}>}}, priority?:int}, tags?:array<array{key:string, value:string}>, virtualGatewayName:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{gatewayRoute:array{gatewayRouteName:string, meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, spec:array{grpcRoute?:array{action:array{rewrite?:array{hostname?:array{defaultTargetHostname?:"ENABLED"|"DISABLED"}}, target:array{port?:int, virtualService:array{virtualServiceName:string}}}, match:array{hostname?:array{exact?:string, suffix?:string}, metadata?:array<array{invert?:bool, match?:mixed, name:string}>, port?:int, serviceName?:string}}, http2Route?:array{action:array{rewrite?:array{hostname?:array{defaultTargetHostname?:"ENABLED"|"DISABLED"}, path?:array{exact?:string}, prefix?:array{defaultPrefix?:"ENABLED"|"DISABLED", value?:string}}, target:array{port?:int, virtualService:array{virtualServiceName:string}}}, match:array{headers?:array<array{invert?:bool, match?:mixed, name:string}>, hostname?:array{exact?:string, suffix?:string}, method?:"GET"|"HEAD"|"POST"|"PUT"|"DELETE"|"CONNECT"|"OPTIONS"|"TRACE"|"PATCH", path?:array{exact?:string, regex?:string}, port?:int, prefix?:string, queryParameters?:array<array{match?:mixed, name:string}>}}, httpRoute?:array{action:array{rewrite?:array{hostname?:array{defaultTargetHostname?:"ENABLED"|"DISABLED"}, path?:array{exact?:string}, prefix?:array{defaultPrefix?:"ENABLED"|"DISABLED", value?:string}}, target:array{port?:int, virtualService:array{virtualServiceName:string}}}, match:array{headers?:array<array{invert?:bool, match?:mixed, name:string}>, hostname?:array{exact?:string, suffix?:string}, method?:"GET"|"HEAD"|"POST"|"PUT"|"DELETE"|"CONNECT"|"OPTIONS"|"TRACE"|"PATCH", path?:array{exact?:string, regex?:string}, port?:int, prefix?:string, queryParameters?:array<array{match?:mixed, name:string}>}}, priority?:int}, status:array{status:mixed}, virtualGatewayName:string}}>
     */
    public function createGatewayRouteAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{clientToken?:string, meshName:string, spec?:array{egressFilter?:array{type:"ALLOW_ALL"|"DROP_ALL"}, serviceDiscovery?:array{ipPreference?:"IPv6_PREFERRED"|"IPv4_PREFERRED"|"IPv4_ONLY"|"IPv6_ONLY"}}, tags?:array<array{key:string, value:string}>} $args
     * @return \AWS\Result<array{mesh:array{meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, spec:array{egressFilter?:array{type:"ALLOW_ALL"|"DROP_ALL"}, serviceDiscovery?:array{ipPreference?:"IPv6_PREFERRED"|"IPv4_PREFERRED"|"IPv4_ONLY"|"IPv6_ONLY"}}, status:array{status?:mixed}}}>
     */
    public function createMesh(array $args): \AWS\Result { }

    /**
     * @param array{clientToken?:string, meshName:string, spec?:array{egressFilter?:array{type:"ALLOW_ALL"|"DROP_ALL"}, serviceDiscovery?:array{ipPreference?:"IPv6_PREFERRED"|"IPv4_PREFERRED"|"IPv4_ONLY"|"IPv6_ONLY"}}, tags?:array<array{key:string, value:string}>} $args
     * @return \GuzzleHttp\Promise\Promise<array{mesh:array{meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, spec:array{egressFilter?:array{type:"ALLOW_ALL"|"DROP_ALL"}, serviceDiscovery?:array{ipPreference?:"IPv6_PREFERRED"|"IPv4_PREFERRED"|"IPv4_ONLY"|"IPv6_ONLY"}}, status:array{status?:mixed}}}>
     */
    public function createMeshAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{clientToken?:string, meshName:string, meshOwner?:string, routeName:string, spec:array{grpcRoute?:array{action:array{weightedTargets:array<array{port?:int, virtualNode:string, weight:int}>}, match:array{metadata?:array<array{invert?:bool, match?:mixed, name:string}>, methodName?:string, port?:int, serviceName?:string}, retryPolicy?:array{grpcRetryEvents?:array<"cancelled"|"deadline-exceeded"|"internal"|"resource-exhausted"|"unavailable">, httpRetryEvents?:array<string>, maxRetries:int, perRetryTimeout:array{unit?:"s"|"ms", value?:int}, tcpRetryEvents?:array<"connection-error">}, timeout?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}}, http2Route?:array{action:array{weightedTargets:array<array{port?:int, virtualNode:string, weight:int}>}, match:array{headers?:array<array{invert?:bool, match?:mixed, name:string}>, method?:"GET"|"HEAD"|"POST"|"PUT"|"DELETE"|"CONNECT"|"OPTIONS"|"TRACE"|"PATCH", path?:array{exact?:string, regex?:string}, port?:int, prefix?:string, queryParameters?:array<array{match?:mixed, name:string}>, scheme?:"http"|"https"}, retryPolicy?:array{httpRetryEvents?:array<string>, maxRetries:int, perRetryTimeout:array{unit?:"s"|"ms", value?:int}, tcpRetryEvents?:array<"connection-error">}, timeout?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}}, httpRoute?:array{action:array{weightedTargets:array<array{port?:int, virtualNode:string, weight:int}>}, match:array{headers?:array<array{invert?:bool, match?:mixed, name:string}>, method?:"GET"|"HEAD"|"POST"|"PUT"|"DELETE"|"CONNECT"|"OPTIONS"|"TRACE"|"PATCH", path?:array{exact?:string, regex?:string}, port?:int, prefix?:string, queryParameters?:array<array{match?:mixed, name:string}>, scheme?:"http"|"https"}, retryPolicy?:array{httpRetryEvents?:array<string>, maxRetries:int, perRetryTimeout:array{unit?:"s"|"ms", value?:int}, tcpRetryEvents?:array<"connection-error">}, timeout?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}}, priority?:int, tcpRoute?:array{action:array{weightedTargets:array<array{port?:int, virtualNode:string, weight:int}>}, match?:array{port?:int}, timeout?:array{idle?:array{unit?:"s"|"ms", value?:int}}}}, tags?:array<array{key:string, value:string}>, virtualRouterName:string} $args
     * @return \AWS\Result<array{route:array{meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, routeName:string, spec:array{grpcRoute?:array{action:array{weightedTargets:array<array{port?:int, virtualNode:string, weight:int}>}, match:array{metadata?:array<array{invert?:bool, match?:mixed, name:string}>, methodName?:string, port?:int, serviceName?:string}, retryPolicy?:array{grpcRetryEvents?:array<"cancelled"|"deadline-exceeded"|"internal"|"resource-exhausted"|"unavailable">, httpRetryEvents?:array<string>, maxRetries:int, perRetryTimeout:array{unit?:"s"|"ms", value?:int}, tcpRetryEvents?:array<"connection-error">}, timeout?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}}, http2Route?:array{action:array{weightedTargets:array<array{port?:int, virtualNode:string, weight:int}>}, match:array{headers?:array<array{invert?:bool, match?:mixed, name:string}>, method?:"GET"|"HEAD"|"POST"|"PUT"|"DELETE"|"CONNECT"|"OPTIONS"|"TRACE"|"PATCH", path?:array{exact?:string, regex?:string}, port?:int, prefix?:string, queryParameters?:array<array{match?:mixed, name:string}>, scheme?:"http"|"https"}, retryPolicy?:array{httpRetryEvents?:array<string>, maxRetries:int, perRetryTimeout:array{unit?:"s"|"ms", value?:int}, tcpRetryEvents?:array<"connection-error">}, timeout?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}}, httpRoute?:array{action:array{weightedTargets:array<array{port?:int, virtualNode:string, weight:int}>}, match:array{headers?:array<array{invert?:bool, match?:mixed, name:string}>, method?:"GET"|"HEAD"|"POST"|"PUT"|"DELETE"|"CONNECT"|"OPTIONS"|"TRACE"|"PATCH", path?:array{exact?:string, regex?:string}, port?:int, prefix?:string, queryParameters?:array<array{match?:mixed, name:string}>, scheme?:"http"|"https"}, retryPolicy?:array{httpRetryEvents?:array<string>, maxRetries:int, perRetryTimeout:array{unit?:"s"|"ms", value?:int}, tcpRetryEvents?:array<"connection-error">}, timeout?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}}, priority?:int, tcpRoute?:array{action:array{weightedTargets:array<array{port?:int, virtualNode:string, weight:int}>}, match?:array{port?:int}, timeout?:array{idle?:array{unit?:"s"|"ms", value?:int}}}}, status:array{status:mixed}, virtualRouterName:string}}>
     */
    public function createRoute(array $args): \AWS\Result { }

    /**
     * @param array{clientToken?:string, meshName:string, meshOwner?:string, routeName:string, spec:array{grpcRoute?:array{action:array{weightedTargets:array<array{port?:int, virtualNode:string, weight:int}>}, match:array{metadata?:array<array{invert?:bool, match?:mixed, name:string}>, methodName?:string, port?:int, serviceName?:string}, retryPolicy?:array{grpcRetryEvents?:array<"cancelled"|"deadline-exceeded"|"internal"|"resource-exhausted"|"unavailable">, httpRetryEvents?:array<string>, maxRetries:int, perRetryTimeout:array{unit?:"s"|"ms", value?:int}, tcpRetryEvents?:array<"connection-error">}, timeout?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}}, http2Route?:array{action:array{weightedTargets:array<array{port?:int, virtualNode:string, weight:int}>}, match:array{headers?:array<array{invert?:bool, match?:mixed, name:string}>, method?:"GET"|"HEAD"|"POST"|"PUT"|"DELETE"|"CONNECT"|"OPTIONS"|"TRACE"|"PATCH", path?:array{exact?:string, regex?:string}, port?:int, prefix?:string, queryParameters?:array<array{match?:mixed, name:string}>, scheme?:"http"|"https"}, retryPolicy?:array{httpRetryEvents?:array<string>, maxRetries:int, perRetryTimeout:array{unit?:"s"|"ms", value?:int}, tcpRetryEvents?:array<"connection-error">}, timeout?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}}, httpRoute?:array{action:array{weightedTargets:array<array{port?:int, virtualNode:string, weight:int}>}, match:array{headers?:array<array{invert?:bool, match?:mixed, name:string}>, method?:"GET"|"HEAD"|"POST"|"PUT"|"DELETE"|"CONNECT"|"OPTIONS"|"TRACE"|"PATCH", path?:array{exact?:string, regex?:string}, port?:int, prefix?:string, queryParameters?:array<array{match?:mixed, name:string}>, scheme?:"http"|"https"}, retryPolicy?:array{httpRetryEvents?:array<string>, maxRetries:int, perRetryTimeout:array{unit?:"s"|"ms", value?:int}, tcpRetryEvents?:array<"connection-error">}, timeout?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}}, priority?:int, tcpRoute?:array{action:array{weightedTargets:array<array{port?:int, virtualNode:string, weight:int}>}, match?:array{port?:int}, timeout?:array{idle?:array{unit?:"s"|"ms", value?:int}}}}, tags?:array<array{key:string, value:string}>, virtualRouterName:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{route:array{meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, routeName:string, spec:array{grpcRoute?:array{action:array{weightedTargets:array<array{port?:int, virtualNode:string, weight:int}>}, match:array{metadata?:array<array{invert?:bool, match?:mixed, name:string}>, methodName?:string, port?:int, serviceName?:string}, retryPolicy?:array{grpcRetryEvents?:array<"cancelled"|"deadline-exceeded"|"internal"|"resource-exhausted"|"unavailable">, httpRetryEvents?:array<string>, maxRetries:int, perRetryTimeout:array{unit?:"s"|"ms", value?:int}, tcpRetryEvents?:array<"connection-error">}, timeout?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}}, http2Route?:array{action:array{weightedTargets:array<array{port?:int, virtualNode:string, weight:int}>}, match:array{headers?:array<array{invert?:bool, match?:mixed, name:string}>, method?:"GET"|"HEAD"|"POST"|"PUT"|"DELETE"|"CONNECT"|"OPTIONS"|"TRACE"|"PATCH", path?:array{exact?:string, regex?:string}, port?:int, prefix?:string, queryParameters?:array<array{match?:mixed, name:string}>, scheme?:"http"|"https"}, retryPolicy?:array{httpRetryEvents?:array<string>, maxRetries:int, perRetryTimeout:array{unit?:"s"|"ms", value?:int}, tcpRetryEvents?:array<"connection-error">}, timeout?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}}, httpRoute?:array{action:array{weightedTargets:array<array{port?:int, virtualNode:string, weight:int}>}, match:array{headers?:array<array{invert?:bool, match?:mixed, name:string}>, method?:"GET"|"HEAD"|"POST"|"PUT"|"DELETE"|"CONNECT"|"OPTIONS"|"TRACE"|"PATCH", path?:array{exact?:string, regex?:string}, port?:int, prefix?:string, queryParameters?:array<array{match?:mixed, name:string}>, scheme?:"http"|"https"}, retryPolicy?:array{httpRetryEvents?:array<string>, maxRetries:int, perRetryTimeout:array{unit?:"s"|"ms", value?:int}, tcpRetryEvents?:array<"connection-error">}, timeout?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}}, priority?:int, tcpRoute?:array{action:array{weightedTargets:array<array{port?:int, virtualNode:string, weight:int}>}, match?:array{port?:int}, timeout?:array{idle?:array{unit?:"s"|"ms", value?:int}}}}, status:array{status:mixed}, virtualRouterName:string}}>
     */
    public function createRouteAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{clientToken?:string, meshName:string, meshOwner?:string, spec:array{backendDefaults?:array{clientPolicy?:array{tls?:array{certificate?:array{file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, enforce?:bool, ports?:array<int>, validation:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{acm?:array{certificateAuthorityArns:array<string>}, file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}}, listeners:array<array{connectionPool?:array{grpc?:array{maxRequests:int}, http?:array{maxConnections:int, maxPendingRequests?:int}, http2?:array{maxRequests:int}}, healthCheck?:array{healthyThreshold:int, intervalMillis:int, path?:string, port?:int, protocol:"http"|"http2"|"grpc", timeoutMillis:int, unhealthyThreshold:int}, portMapping:array{port:int, protocol:"http"|"http2"|"grpc"}, tls?:array{certificate:array{acm?:array{certificateArn:string}, file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, mode:"STRICT"|"PERMISSIVE"|"DISABLED", validation?:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}>, logging?:array{accessLog?:array{file?:array{format?:array{json?:array<array{key:string, value:string}>, text?:string}, path:string}}}}, tags?:array<array{key:string, value:string}>, virtualGatewayName:string} $args
     * @return \AWS\Result<array{virtualGateway:array{meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, spec:array{backendDefaults?:array{clientPolicy?:array{tls?:array{certificate?:array{file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, enforce?:bool, ports?:array<int>, validation:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{acm?:array{certificateAuthorityArns:array<string>}, file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}}, listeners:array<array{connectionPool?:array{grpc?:array{maxRequests:int}, http?:array{maxConnections:int, maxPendingRequests?:int}, http2?:array{maxRequests:int}}, healthCheck?:array{healthyThreshold:int, intervalMillis:int, path?:string, port?:int, protocol:"http"|"http2"|"grpc", timeoutMillis:int, unhealthyThreshold:int}, portMapping:array{port:int, protocol:"http"|"http2"|"grpc"}, tls?:array{certificate:array{acm?:array{certificateArn:string}, file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, mode:"STRICT"|"PERMISSIVE"|"DISABLED", validation?:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}>, logging?:array{accessLog?:array{file?:array{format?:array{json?:array<array{key:string, value:string}>, text?:string}, path:string}}}}, status:array{status:mixed}, virtualGatewayName:string}}>
     */
    public function createVirtualGateway(array $args): \AWS\Result { }

    /**
     * @param array{clientToken?:string, meshName:string, meshOwner?:string, spec:array{backendDefaults?:array{clientPolicy?:array{tls?:array{certificate?:array{file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, enforce?:bool, ports?:array<int>, validation:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{acm?:array{certificateAuthorityArns:array<string>}, file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}}, listeners:array<array{connectionPool?:array{grpc?:array{maxRequests:int}, http?:array{maxConnections:int, maxPendingRequests?:int}, http2?:array{maxRequests:int}}, healthCheck?:array{healthyThreshold:int, intervalMillis:int, path?:string, port?:int, protocol:"http"|"http2"|"grpc", timeoutMillis:int, unhealthyThreshold:int}, portMapping:array{port:int, protocol:"http"|"http2"|"grpc"}, tls?:array{certificate:array{acm?:array{certificateArn:string}, file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, mode:"STRICT"|"PERMISSIVE"|"DISABLED", validation?:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}>, logging?:array{accessLog?:array{file?:array{format?:array{json?:array<array{key:string, value:string}>, text?:string}, path:string}}}}, tags?:array<array{key:string, value:string}>, virtualGatewayName:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{virtualGateway:array{meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, spec:array{backendDefaults?:array{clientPolicy?:array{tls?:array{certificate?:array{file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, enforce?:bool, ports?:array<int>, validation:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{acm?:array{certificateAuthorityArns:array<string>}, file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}}, listeners:array<array{connectionPool?:array{grpc?:array{maxRequests:int}, http?:array{maxConnections:int, maxPendingRequests?:int}, http2?:array{maxRequests:int}}, healthCheck?:array{healthyThreshold:int, intervalMillis:int, path?:string, port?:int, protocol:"http"|"http2"|"grpc", timeoutMillis:int, unhealthyThreshold:int}, portMapping:array{port:int, protocol:"http"|"http2"|"grpc"}, tls?:array{certificate:array{acm?:array{certificateArn:string}, file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, mode:"STRICT"|"PERMISSIVE"|"DISABLED", validation?:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}>, logging?:array{accessLog?:array{file?:array{format?:array{json?:array<array{key:string, value:string}>, text?:string}, path:string}}}}, status:array{status:mixed}, virtualGatewayName:string}}>
     */
    public function createVirtualGatewayAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{clientToken?:string, meshName:string, meshOwner?:string, spec:array{backendDefaults?:array{clientPolicy?:array{tls?:array{certificate?:array{file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, enforce?:bool, ports?:array<int>, validation:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{acm?:array{certificateAuthorityArns:array<string>}, file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}}, backends?:array<array{virtualService?:array{clientPolicy?:array{tls?:array{certificate?:array{file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, enforce?:bool, ports?:array<int>, validation:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{acm?:array{certificateAuthorityArns:array<string>}, file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}, virtualServiceName:string}}>, listeners?:array<array{connectionPool?:array{grpc?:array{maxRequests:int}, http?:array{maxConnections:int, maxPendingRequests?:int}, http2?:array{maxRequests:int}, tcp?:array{maxConnections:int}}, healthCheck?:array{healthyThreshold:int, intervalMillis:int, path?:string, port?:int, protocol:"http"|"tcp"|"http2"|"grpc", timeoutMillis:int, unhealthyThreshold:int}, outlierDetection?:array{baseEjectionDuration:array{unit?:"s"|"ms", value?:int}, interval:array{unit?:"s"|"ms", value?:int}, maxEjectionPercent:int, maxServerErrors:int}, portMapping:array{port:int, protocol:"http"|"tcp"|"http2"|"grpc"}, timeout?:array{grpc?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}, http?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}, http2?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}, tcp?:array{idle?:array{unit?:"s"|"ms", value?:int}}}, tls?:array{certificate:array{acm?:array{certificateArn:string}, file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, mode:"STRICT"|"PERMISSIVE"|"DISABLED", validation?:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}>, logging?:array{accessLog?:array{file?:array{format?:array{json?:array<array{key:string, value:string}>, text?:string}, path:string}}}, serviceDiscovery?:array{awsCloudMap?:array{attributes?:array<array{key:string, value:string}>, ipPreference?:"IPv6_PREFERRED"|"IPv4_PREFERRED"|"IPv4_ONLY"|"IPv6_ONLY", namespaceName:string, serviceName:string}, dns?:array{hostname:string, ipPreference?:"IPv6_PREFERRED"|"IPv4_PREFERRED"|"IPv4_ONLY"|"IPv6_ONLY", responseType?:"LOADBALANCER"|"ENDPOINTS"}}}, tags?:array<array{key:string, value:string}>, virtualNodeName:string} $args
     * @return \AWS\Result<array{virtualNode:array{meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, spec:array{backendDefaults?:array{clientPolicy?:array{tls?:array{certificate?:array{file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, enforce?:bool, ports?:array<int>, validation:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{acm?:array{certificateAuthorityArns:array<string>}, file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}}, backends?:array<array{virtualService?:array{clientPolicy?:array{tls?:array{certificate?:array{file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, enforce?:bool, ports?:array<int>, validation:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{acm?:array{certificateAuthorityArns:array<string>}, file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}, virtualServiceName:string}}>, listeners?:array<array{connectionPool?:array{grpc?:array{maxRequests:int}, http?:array{maxConnections:int, maxPendingRequests?:int}, http2?:array{maxRequests:int}, tcp?:array{maxConnections:int}}, healthCheck?:array{healthyThreshold:int, intervalMillis:int, path?:string, port?:int, protocol:"http"|"tcp"|"http2"|"grpc", timeoutMillis:int, unhealthyThreshold:int}, outlierDetection?:array{baseEjectionDuration:array{unit?:"s"|"ms", value?:int}, interval:array{unit?:"s"|"ms", value?:int}, maxEjectionPercent:int, maxServerErrors:int}, portMapping:array{port:int, protocol:"http"|"tcp"|"http2"|"grpc"}, timeout?:array{grpc?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}, http?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}, http2?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}, tcp?:array{idle?:array{unit?:"s"|"ms", value?:int}}}, tls?:array{certificate:array{acm?:array{certificateArn:string}, file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, mode:"STRICT"|"PERMISSIVE"|"DISABLED", validation?:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}>, logging?:array{accessLog?:array{file?:array{format?:array{json?:array<array{key:string, value:string}>, text?:string}, path:string}}}, serviceDiscovery?:array{awsCloudMap?:array{attributes?:array<array{key:string, value:string}>, ipPreference?:"IPv6_PREFERRED"|"IPv4_PREFERRED"|"IPv4_ONLY"|"IPv6_ONLY", namespaceName:string, serviceName:string}, dns?:array{hostname:string, ipPreference?:"IPv6_PREFERRED"|"IPv4_PREFERRED"|"IPv4_ONLY"|"IPv6_ONLY", responseType?:"LOADBALANCER"|"ENDPOINTS"}}}, status:array{status:mixed}, virtualNodeName:string}}>
     */
    public function createVirtualNode(array $args): \AWS\Result { }

    /**
     * @param array{clientToken?:string, meshName:string, meshOwner?:string, spec:array{backendDefaults?:array{clientPolicy?:array{tls?:array{certificate?:array{file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, enforce?:bool, ports?:array<int>, validation:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{acm?:array{certificateAuthorityArns:array<string>}, file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}}, backends?:array<array{virtualService?:array{clientPolicy?:array{tls?:array{certificate?:array{file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, enforce?:bool, ports?:array<int>, validation:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{acm?:array{certificateAuthorityArns:array<string>}, file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}, virtualServiceName:string}}>, listeners?:array<array{connectionPool?:array{grpc?:array{maxRequests:int}, http?:array{maxConnections:int, maxPendingRequests?:int}, http2?:array{maxRequests:int}, tcp?:array{maxConnections:int}}, healthCheck?:array{healthyThreshold:int, intervalMillis:int, path?:string, port?:int, protocol:"http"|"tcp"|"http2"|"grpc", timeoutMillis:int, unhealthyThreshold:int}, outlierDetection?:array{baseEjectionDuration:array{unit?:"s"|"ms", value?:int}, interval:array{unit?:"s"|"ms", value?:int}, maxEjectionPercent:int, maxServerErrors:int}, portMapping:array{port:int, protocol:"http"|"tcp"|"http2"|"grpc"}, timeout?:array{grpc?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}, http?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}, http2?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}, tcp?:array{idle?:array{unit?:"s"|"ms", value?:int}}}, tls?:array{certificate:array{acm?:array{certificateArn:string}, file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, mode:"STRICT"|"PERMISSIVE"|"DISABLED", validation?:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}>, logging?:array{accessLog?:array{file?:array{format?:array{json?:array<array{key:string, value:string}>, text?:string}, path:string}}}, serviceDiscovery?:array{awsCloudMap?:array{attributes?:array<array{key:string, value:string}>, ipPreference?:"IPv6_PREFERRED"|"IPv4_PREFERRED"|"IPv4_ONLY"|"IPv6_ONLY", namespaceName:string, serviceName:string}, dns?:array{hostname:string, ipPreference?:"IPv6_PREFERRED"|"IPv4_PREFERRED"|"IPv4_ONLY"|"IPv6_ONLY", responseType?:"LOADBALANCER"|"ENDPOINTS"}}}, tags?:array<array{key:string, value:string}>, virtualNodeName:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{virtualNode:array{meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, spec:array{backendDefaults?:array{clientPolicy?:array{tls?:array{certificate?:array{file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, enforce?:bool, ports?:array<int>, validation:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{acm?:array{certificateAuthorityArns:array<string>}, file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}}, backends?:array<array{virtualService?:array{clientPolicy?:array{tls?:array{certificate?:array{file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, enforce?:bool, ports?:array<int>, validation:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{acm?:array{certificateAuthorityArns:array<string>}, file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}, virtualServiceName:string}}>, listeners?:array<array{connectionPool?:array{grpc?:array{maxRequests:int}, http?:array{maxConnections:int, maxPendingRequests?:int}, http2?:array{maxRequests:int}, tcp?:array{maxConnections:int}}, healthCheck?:array{healthyThreshold:int, intervalMillis:int, path?:string, port?:int, protocol:"http"|"tcp"|"http2"|"grpc", timeoutMillis:int, unhealthyThreshold:int}, outlierDetection?:array{baseEjectionDuration:array{unit?:"s"|"ms", value?:int}, interval:array{unit?:"s"|"ms", value?:int}, maxEjectionPercent:int, maxServerErrors:int}, portMapping:array{port:int, protocol:"http"|"tcp"|"http2"|"grpc"}, timeout?:array{grpc?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}, http?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}, http2?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}, tcp?:array{idle?:array{unit?:"s"|"ms", value?:int}}}, tls?:array{certificate:array{acm?:array{certificateArn:string}, file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, mode:"STRICT"|"PERMISSIVE"|"DISABLED", validation?:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}>, logging?:array{accessLog?:array{file?:array{format?:array{json?:array<array{key:string, value:string}>, text?:string}, path:string}}}, serviceDiscovery?:array{awsCloudMap?:array{attributes?:array<array{key:string, value:string}>, ipPreference?:"IPv6_PREFERRED"|"IPv4_PREFERRED"|"IPv4_ONLY"|"IPv6_ONLY", namespaceName:string, serviceName:string}, dns?:array{hostname:string, ipPreference?:"IPv6_PREFERRED"|"IPv4_PREFERRED"|"IPv4_ONLY"|"IPv6_ONLY", responseType?:"LOADBALANCER"|"ENDPOINTS"}}}, status:array{status:mixed}, virtualNodeName:string}}>
     */
    public function createVirtualNodeAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{clientToken?:string, meshName:string, meshOwner?:string, spec:array{listeners?:array<array{portMapping:array{port:int, protocol:"http"|"tcp"|"http2"|"grpc"}}>}, tags?:array<array{key:string, value:string}>, virtualRouterName:string} $args
     * @return \AWS\Result<array{virtualRouter:array{meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, spec:array{listeners?:array<array{portMapping:array{port:int, protocol:"http"|"tcp"|"http2"|"grpc"}}>}, status:array{status:mixed}, virtualRouterName:string}}>
     */
    public function createVirtualRouter(array $args): \AWS\Result { }

    /**
     * @param array{clientToken?:string, meshName:string, meshOwner?:string, spec:array{listeners?:array<array{portMapping:array{port:int, protocol:"http"|"tcp"|"http2"|"grpc"}}>}, tags?:array<array{key:string, value:string}>, virtualRouterName:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{virtualRouter:array{meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, spec:array{listeners?:array<array{portMapping:array{port:int, protocol:"http"|"tcp"|"http2"|"grpc"}}>}, status:array{status:mixed}, virtualRouterName:string}}>
     */
    public function createVirtualRouterAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{clientToken?:string, meshName:string, meshOwner?:string, spec:array{provider?:array{virtualNode?:array{virtualNodeName:string}, virtualRouter?:array{virtualRouterName:string}}}, tags?:array<array{key:string, value:string}>, virtualServiceName:string} $args
     * @return \AWS\Result<array{virtualService:array{meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, spec:array{provider?:array{virtualNode?:array{virtualNodeName:string}, virtualRouter?:array{virtualRouterName:string}}}, status:array{status:mixed}, virtualServiceName:string}}>
     */
    public function createVirtualService(array $args): \AWS\Result { }

    /**
     * @param array{clientToken?:string, meshName:string, meshOwner?:string, spec:array{provider?:array{virtualNode?:array{virtualNodeName:string}, virtualRouter?:array{virtualRouterName:string}}}, tags?:array<array{key:string, value:string}>, virtualServiceName:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{virtualService:array{meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, spec:array{provider?:array{virtualNode?:array{virtualNodeName:string}, virtualRouter?:array{virtualRouterName:string}}}, status:array{status:mixed}, virtualServiceName:string}}>
     */
    public function createVirtualServiceAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{gatewayRouteName:string, meshName:string, meshOwner?:string, virtualGatewayName:string} $args
     * @return \AWS\Result<array{gatewayRoute:array{gatewayRouteName:string, meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, spec:array{grpcRoute?:array{action:array{rewrite?:array{hostname?:array{defaultTargetHostname?:"ENABLED"|"DISABLED"}}, target:array{port?:int, virtualService:array{virtualServiceName:string}}}, match:array{hostname?:array{exact?:string, suffix?:string}, metadata?:array<array{invert?:bool, match?:mixed, name:string}>, port?:int, serviceName?:string}}, http2Route?:array{action:array{rewrite?:array{hostname?:array{defaultTargetHostname?:"ENABLED"|"DISABLED"}, path?:array{exact?:string}, prefix?:array{defaultPrefix?:"ENABLED"|"DISABLED", value?:string}}, target:array{port?:int, virtualService:array{virtualServiceName:string}}}, match:array{headers?:array<array{invert?:bool, match?:mixed, name:string}>, hostname?:array{exact?:string, suffix?:string}, method?:"GET"|"HEAD"|"POST"|"PUT"|"DELETE"|"CONNECT"|"OPTIONS"|"TRACE"|"PATCH", path?:array{exact?:string, regex?:string}, port?:int, prefix?:string, queryParameters?:array<array{match?:mixed, name:string}>}}, httpRoute?:array{action:array{rewrite?:array{hostname?:array{defaultTargetHostname?:"ENABLED"|"DISABLED"}, path?:array{exact?:string}, prefix?:array{defaultPrefix?:"ENABLED"|"DISABLED", value?:string}}, target:array{port?:int, virtualService:array{virtualServiceName:string}}}, match:array{headers?:array<array{invert?:bool, match?:mixed, name:string}>, hostname?:array{exact?:string, suffix?:string}, method?:"GET"|"HEAD"|"POST"|"PUT"|"DELETE"|"CONNECT"|"OPTIONS"|"TRACE"|"PATCH", path?:array{exact?:string, regex?:string}, port?:int, prefix?:string, queryParameters?:array<array{match?:mixed, name:string}>}}, priority?:int}, status:array{status:mixed}, virtualGatewayName:string}}>
     */
    public function deleteGatewayRoute(array $args): \AWS\Result { }

    /**
     * @param array{gatewayRouteName:string, meshName:string, meshOwner?:string, virtualGatewayName:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{gatewayRoute:array{gatewayRouteName:string, meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, spec:array{grpcRoute?:array{action:array{rewrite?:array{hostname?:array{defaultTargetHostname?:"ENABLED"|"DISABLED"}}, target:array{port?:int, virtualService:array{virtualServiceName:string}}}, match:array{hostname?:array{exact?:string, suffix?:string}, metadata?:array<array{invert?:bool, match?:mixed, name:string}>, port?:int, serviceName?:string}}, http2Route?:array{action:array{rewrite?:array{hostname?:array{defaultTargetHostname?:"ENABLED"|"DISABLED"}, path?:array{exact?:string}, prefix?:array{defaultPrefix?:"ENABLED"|"DISABLED", value?:string}}, target:array{port?:int, virtualService:array{virtualServiceName:string}}}, match:array{headers?:array<array{invert?:bool, match?:mixed, name:string}>, hostname?:array{exact?:string, suffix?:string}, method?:"GET"|"HEAD"|"POST"|"PUT"|"DELETE"|"CONNECT"|"OPTIONS"|"TRACE"|"PATCH", path?:array{exact?:string, regex?:string}, port?:int, prefix?:string, queryParameters?:array<array{match?:mixed, name:string}>}}, httpRoute?:array{action:array{rewrite?:array{hostname?:array{defaultTargetHostname?:"ENABLED"|"DISABLED"}, path?:array{exact?:string}, prefix?:array{defaultPrefix?:"ENABLED"|"DISABLED", value?:string}}, target:array{port?:int, virtualService:array{virtualServiceName:string}}}, match:array{headers?:array<array{invert?:bool, match?:mixed, name:string}>, hostname?:array{exact?:string, suffix?:string}, method?:"GET"|"HEAD"|"POST"|"PUT"|"DELETE"|"CONNECT"|"OPTIONS"|"TRACE"|"PATCH", path?:array{exact?:string, regex?:string}, port?:int, prefix?:string, queryParameters?:array<array{match?:mixed, name:string}>}}, priority?:int}, status:array{status:mixed}, virtualGatewayName:string}}>
     */
    public function deleteGatewayRouteAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{meshName:string} $args
     * @return \AWS\Result<array{mesh:array{meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, spec:array{egressFilter?:array{type:"ALLOW_ALL"|"DROP_ALL"}, serviceDiscovery?:array{ipPreference?:"IPv6_PREFERRED"|"IPv4_PREFERRED"|"IPv4_ONLY"|"IPv6_ONLY"}}, status:array{status?:mixed}}}>
     */
    public function deleteMesh(array $args): \AWS\Result { }

    /**
     * @param array{meshName:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{mesh:array{meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, spec:array{egressFilter?:array{type:"ALLOW_ALL"|"DROP_ALL"}, serviceDiscovery?:array{ipPreference?:"IPv6_PREFERRED"|"IPv4_PREFERRED"|"IPv4_ONLY"|"IPv6_ONLY"}}, status:array{status?:mixed}}}>
     */
    public function deleteMeshAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{meshName:string, meshOwner?:string, routeName:string, virtualRouterName:string} $args
     * @return \AWS\Result<array{route:array{meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, routeName:string, spec:array{grpcRoute?:array{action:array{weightedTargets:array<array{port?:int, virtualNode:string, weight:int}>}, match:array{metadata?:array<array{invert?:bool, match?:mixed, name:string}>, methodName?:string, port?:int, serviceName?:string}, retryPolicy?:array{grpcRetryEvents?:array<"cancelled"|"deadline-exceeded"|"internal"|"resource-exhausted"|"unavailable">, httpRetryEvents?:array<string>, maxRetries:int, perRetryTimeout:array{unit?:"s"|"ms", value?:int}, tcpRetryEvents?:array<"connection-error">}, timeout?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}}, http2Route?:array{action:array{weightedTargets:array<array{port?:int, virtualNode:string, weight:int}>}, match:array{headers?:array<array{invert?:bool, match?:mixed, name:string}>, method?:"GET"|"HEAD"|"POST"|"PUT"|"DELETE"|"CONNECT"|"OPTIONS"|"TRACE"|"PATCH", path?:array{exact?:string, regex?:string}, port?:int, prefix?:string, queryParameters?:array<array{match?:mixed, name:string}>, scheme?:"http"|"https"}, retryPolicy?:array{httpRetryEvents?:array<string>, maxRetries:int, perRetryTimeout:array{unit?:"s"|"ms", value?:int}, tcpRetryEvents?:array<"connection-error">}, timeout?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}}, httpRoute?:array{action:array{weightedTargets:array<array{port?:int, virtualNode:string, weight:int}>}, match:array{headers?:array<array{invert?:bool, match?:mixed, name:string}>, method?:"GET"|"HEAD"|"POST"|"PUT"|"DELETE"|"CONNECT"|"OPTIONS"|"TRACE"|"PATCH", path?:array{exact?:string, regex?:string}, port?:int, prefix?:string, queryParameters?:array<array{match?:mixed, name:string}>, scheme?:"http"|"https"}, retryPolicy?:array{httpRetryEvents?:array<string>, maxRetries:int, perRetryTimeout:array{unit?:"s"|"ms", value?:int}, tcpRetryEvents?:array<"connection-error">}, timeout?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}}, priority?:int, tcpRoute?:array{action:array{weightedTargets:array<array{port?:int, virtualNode:string, weight:int}>}, match?:array{port?:int}, timeout?:array{idle?:array{unit?:"s"|"ms", value?:int}}}}, status:array{status:mixed}, virtualRouterName:string}}>
     */
    public function deleteRoute(array $args): \AWS\Result { }

    /**
     * @param array{meshName:string, meshOwner?:string, routeName:string, virtualRouterName:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{route:array{meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, routeName:string, spec:array{grpcRoute?:array{action:array{weightedTargets:array<array{port?:int, virtualNode:string, weight:int}>}, match:array{metadata?:array<array{invert?:bool, match?:mixed, name:string}>, methodName?:string, port?:int, serviceName?:string}, retryPolicy?:array{grpcRetryEvents?:array<"cancelled"|"deadline-exceeded"|"internal"|"resource-exhausted"|"unavailable">, httpRetryEvents?:array<string>, maxRetries:int, perRetryTimeout:array{unit?:"s"|"ms", value?:int}, tcpRetryEvents?:array<"connection-error">}, timeout?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}}, http2Route?:array{action:array{weightedTargets:array<array{port?:int, virtualNode:string, weight:int}>}, match:array{headers?:array<array{invert?:bool, match?:mixed, name:string}>, method?:"GET"|"HEAD"|"POST"|"PUT"|"DELETE"|"CONNECT"|"OPTIONS"|"TRACE"|"PATCH", path?:array{exact?:string, regex?:string}, port?:int, prefix?:string, queryParameters?:array<array{match?:mixed, name:string}>, scheme?:"http"|"https"}, retryPolicy?:array{httpRetryEvents?:array<string>, maxRetries:int, perRetryTimeout:array{unit?:"s"|"ms", value?:int}, tcpRetryEvents?:array<"connection-error">}, timeout?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}}, httpRoute?:array{action:array{weightedTargets:array<array{port?:int, virtualNode:string, weight:int}>}, match:array{headers?:array<array{invert?:bool, match?:mixed, name:string}>, method?:"GET"|"HEAD"|"POST"|"PUT"|"DELETE"|"CONNECT"|"OPTIONS"|"TRACE"|"PATCH", path?:array{exact?:string, regex?:string}, port?:int, prefix?:string, queryParameters?:array<array{match?:mixed, name:string}>, scheme?:"http"|"https"}, retryPolicy?:array{httpRetryEvents?:array<string>, maxRetries:int, perRetryTimeout:array{unit?:"s"|"ms", value?:int}, tcpRetryEvents?:array<"connection-error">}, timeout?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}}, priority?:int, tcpRoute?:array{action:array{weightedTargets:array<array{port?:int, virtualNode:string, weight:int}>}, match?:array{port?:int}, timeout?:array{idle?:array{unit?:"s"|"ms", value?:int}}}}, status:array{status:mixed}, virtualRouterName:string}}>
     */
    public function deleteRouteAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{meshName:string, meshOwner?:string, virtualGatewayName:string} $args
     * @return \AWS\Result<array{virtualGateway:array{meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, spec:array{backendDefaults?:array{clientPolicy?:array{tls?:array{certificate?:array{file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, enforce?:bool, ports?:array<int>, validation:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{acm?:array{certificateAuthorityArns:array<string>}, file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}}, listeners:array<array{connectionPool?:array{grpc?:array{maxRequests:int}, http?:array{maxConnections:int, maxPendingRequests?:int}, http2?:array{maxRequests:int}}, healthCheck?:array{healthyThreshold:int, intervalMillis:int, path?:string, port?:int, protocol:"http"|"http2"|"grpc", timeoutMillis:int, unhealthyThreshold:int}, portMapping:array{port:int, protocol:"http"|"http2"|"grpc"}, tls?:array{certificate:array{acm?:array{certificateArn:string}, file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, mode:"STRICT"|"PERMISSIVE"|"DISABLED", validation?:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}>, logging?:array{accessLog?:array{file?:array{format?:array{json?:array<array{key:string, value:string}>, text?:string}, path:string}}}}, status:array{status:mixed}, virtualGatewayName:string}}>
     */
    public function deleteVirtualGateway(array $args): \AWS\Result { }

    /**
     * @param array{meshName:string, meshOwner?:string, virtualGatewayName:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{virtualGateway:array{meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, spec:array{backendDefaults?:array{clientPolicy?:array{tls?:array{certificate?:array{file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, enforce?:bool, ports?:array<int>, validation:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{acm?:array{certificateAuthorityArns:array<string>}, file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}}, listeners:array<array{connectionPool?:array{grpc?:array{maxRequests:int}, http?:array{maxConnections:int, maxPendingRequests?:int}, http2?:array{maxRequests:int}}, healthCheck?:array{healthyThreshold:int, intervalMillis:int, path?:string, port?:int, protocol:"http"|"http2"|"grpc", timeoutMillis:int, unhealthyThreshold:int}, portMapping:array{port:int, protocol:"http"|"http2"|"grpc"}, tls?:array{certificate:array{acm?:array{certificateArn:string}, file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, mode:"STRICT"|"PERMISSIVE"|"DISABLED", validation?:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}>, logging?:array{accessLog?:array{file?:array{format?:array{json?:array<array{key:string, value:string}>, text?:string}, path:string}}}}, status:array{status:mixed}, virtualGatewayName:string}}>
     */
    public function deleteVirtualGatewayAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{meshName:string, meshOwner?:string, virtualNodeName:string} $args
     * @return \AWS\Result<array{virtualNode:array{meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, spec:array{backendDefaults?:array{clientPolicy?:array{tls?:array{certificate?:array{file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, enforce?:bool, ports?:array<int>, validation:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{acm?:array{certificateAuthorityArns:array<string>}, file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}}, backends?:array<array{virtualService?:array{clientPolicy?:array{tls?:array{certificate?:array{file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, enforce?:bool, ports?:array<int>, validation:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{acm?:array{certificateAuthorityArns:array<string>}, file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}, virtualServiceName:string}}>, listeners?:array<array{connectionPool?:array{grpc?:array{maxRequests:int}, http?:array{maxConnections:int, maxPendingRequests?:int}, http2?:array{maxRequests:int}, tcp?:array{maxConnections:int}}, healthCheck?:array{healthyThreshold:int, intervalMillis:int, path?:string, port?:int, protocol:"http"|"tcp"|"http2"|"grpc", timeoutMillis:int, unhealthyThreshold:int}, outlierDetection?:array{baseEjectionDuration:array{unit?:"s"|"ms", value?:int}, interval:array{unit?:"s"|"ms", value?:int}, maxEjectionPercent:int, maxServerErrors:int}, portMapping:array{port:int, protocol:"http"|"tcp"|"http2"|"grpc"}, timeout?:array{grpc?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}, http?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}, http2?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}, tcp?:array{idle?:array{unit?:"s"|"ms", value?:int}}}, tls?:array{certificate:array{acm?:array{certificateArn:string}, file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, mode:"STRICT"|"PERMISSIVE"|"DISABLED", validation?:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}>, logging?:array{accessLog?:array{file?:array{format?:array{json?:array<array{key:string, value:string}>, text?:string}, path:string}}}, serviceDiscovery?:array{awsCloudMap?:array{attributes?:array<array{key:string, value:string}>, ipPreference?:"IPv6_PREFERRED"|"IPv4_PREFERRED"|"IPv4_ONLY"|"IPv6_ONLY", namespaceName:string, serviceName:string}, dns?:array{hostname:string, ipPreference?:"IPv6_PREFERRED"|"IPv4_PREFERRED"|"IPv4_ONLY"|"IPv6_ONLY", responseType?:"LOADBALANCER"|"ENDPOINTS"}}}, status:array{status:mixed}, virtualNodeName:string}}>
     */
    public function deleteVirtualNode(array $args): \AWS\Result { }

    /**
     * @param array{meshName:string, meshOwner?:string, virtualNodeName:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{virtualNode:array{meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, spec:array{backendDefaults?:array{clientPolicy?:array{tls?:array{certificate?:array{file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, enforce?:bool, ports?:array<int>, validation:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{acm?:array{certificateAuthorityArns:array<string>}, file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}}, backends?:array<array{virtualService?:array{clientPolicy?:array{tls?:array{certificate?:array{file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, enforce?:bool, ports?:array<int>, validation:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{acm?:array{certificateAuthorityArns:array<string>}, file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}, virtualServiceName:string}}>, listeners?:array<array{connectionPool?:array{grpc?:array{maxRequests:int}, http?:array{maxConnections:int, maxPendingRequests?:int}, http2?:array{maxRequests:int}, tcp?:array{maxConnections:int}}, healthCheck?:array{healthyThreshold:int, intervalMillis:int, path?:string, port?:int, protocol:"http"|"tcp"|"http2"|"grpc", timeoutMillis:int, unhealthyThreshold:int}, outlierDetection?:array{baseEjectionDuration:array{unit?:"s"|"ms", value?:int}, interval:array{unit?:"s"|"ms", value?:int}, maxEjectionPercent:int, maxServerErrors:int}, portMapping:array{port:int, protocol:"http"|"tcp"|"http2"|"grpc"}, timeout?:array{grpc?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}, http?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}, http2?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}, tcp?:array{idle?:array{unit?:"s"|"ms", value?:int}}}, tls?:array{certificate:array{acm?:array{certificateArn:string}, file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, mode:"STRICT"|"PERMISSIVE"|"DISABLED", validation?:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}>, logging?:array{accessLog?:array{file?:array{format?:array{json?:array<array{key:string, value:string}>, text?:string}, path:string}}}, serviceDiscovery?:array{awsCloudMap?:array{attributes?:array<array{key:string, value:string}>, ipPreference?:"IPv6_PREFERRED"|"IPv4_PREFERRED"|"IPv4_ONLY"|"IPv6_ONLY", namespaceName:string, serviceName:string}, dns?:array{hostname:string, ipPreference?:"IPv6_PREFERRED"|"IPv4_PREFERRED"|"IPv4_ONLY"|"IPv6_ONLY", responseType?:"LOADBALANCER"|"ENDPOINTS"}}}, status:array{status:mixed}, virtualNodeName:string}}>
     */
    public function deleteVirtualNodeAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{meshName:string, meshOwner?:string, virtualRouterName:string} $args
     * @return \AWS\Result<array{virtualRouter:array{meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, spec:array{listeners?:array<array{portMapping:array{port:int, protocol:"http"|"tcp"|"http2"|"grpc"}}>}, status:array{status:mixed}, virtualRouterName:string}}>
     */
    public function deleteVirtualRouter(array $args): \AWS\Result { }

    /**
     * @param array{meshName:string, meshOwner?:string, virtualRouterName:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{virtualRouter:array{meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, spec:array{listeners?:array<array{portMapping:array{port:int, protocol:"http"|"tcp"|"http2"|"grpc"}}>}, status:array{status:mixed}, virtualRouterName:string}}>
     */
    public function deleteVirtualRouterAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{meshName:string, meshOwner?:string, virtualServiceName:string} $args
     * @return \AWS\Result<array{virtualService:array{meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, spec:array{provider?:array{virtualNode?:array{virtualNodeName:string}, virtualRouter?:array{virtualRouterName:string}}}, status:array{status:mixed}, virtualServiceName:string}}>
     */
    public function deleteVirtualService(array $args): \AWS\Result { }

    /**
     * @param array{meshName:string, meshOwner?:string, virtualServiceName:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{virtualService:array{meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, spec:array{provider?:array{virtualNode?:array{virtualNodeName:string}, virtualRouter?:array{virtualRouterName:string}}}, status:array{status:mixed}, virtualServiceName:string}}>
     */
    public function deleteVirtualServiceAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{gatewayRouteName:string, meshName:string, meshOwner?:string, virtualGatewayName:string} $args
     * @return \AWS\Result<array{gatewayRoute:array{gatewayRouteName:string, meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, spec:array{grpcRoute?:array{action:array{rewrite?:array{hostname?:array{defaultTargetHostname?:"ENABLED"|"DISABLED"}}, target:array{port?:int, virtualService:array{virtualServiceName:string}}}, match:array{hostname?:array{exact?:string, suffix?:string}, metadata?:array<array{invert?:bool, match?:mixed, name:string}>, port?:int, serviceName?:string}}, http2Route?:array{action:array{rewrite?:array{hostname?:array{defaultTargetHostname?:"ENABLED"|"DISABLED"}, path?:array{exact?:string}, prefix?:array{defaultPrefix?:"ENABLED"|"DISABLED", value?:string}}, target:array{port?:int, virtualService:array{virtualServiceName:string}}}, match:array{headers?:array<array{invert?:bool, match?:mixed, name:string}>, hostname?:array{exact?:string, suffix?:string}, method?:"GET"|"HEAD"|"POST"|"PUT"|"DELETE"|"CONNECT"|"OPTIONS"|"TRACE"|"PATCH", path?:array{exact?:string, regex?:string}, port?:int, prefix?:string, queryParameters?:array<array{match?:mixed, name:string}>}}, httpRoute?:array{action:array{rewrite?:array{hostname?:array{defaultTargetHostname?:"ENABLED"|"DISABLED"}, path?:array{exact?:string}, prefix?:array{defaultPrefix?:"ENABLED"|"DISABLED", value?:string}}, target:array{port?:int, virtualService:array{virtualServiceName:string}}}, match:array{headers?:array<array{invert?:bool, match?:mixed, name:string}>, hostname?:array{exact?:string, suffix?:string}, method?:"GET"|"HEAD"|"POST"|"PUT"|"DELETE"|"CONNECT"|"OPTIONS"|"TRACE"|"PATCH", path?:array{exact?:string, regex?:string}, port?:int, prefix?:string, queryParameters?:array<array{match?:mixed, name:string}>}}, priority?:int}, status:array{status:mixed}, virtualGatewayName:string}}>
     */
    public function describeGatewayRoute(array $args): \AWS\Result { }

    /**
     * @param array{gatewayRouteName:string, meshName:string, meshOwner?:string, virtualGatewayName:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{gatewayRoute:array{gatewayRouteName:string, meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, spec:array{grpcRoute?:array{action:array{rewrite?:array{hostname?:array{defaultTargetHostname?:"ENABLED"|"DISABLED"}}, target:array{port?:int, virtualService:array{virtualServiceName:string}}}, match:array{hostname?:array{exact?:string, suffix?:string}, metadata?:array<array{invert?:bool, match?:mixed, name:string}>, port?:int, serviceName?:string}}, http2Route?:array{action:array{rewrite?:array{hostname?:array{defaultTargetHostname?:"ENABLED"|"DISABLED"}, path?:array{exact?:string}, prefix?:array{defaultPrefix?:"ENABLED"|"DISABLED", value?:string}}, target:array{port?:int, virtualService:array{virtualServiceName:string}}}, match:array{headers?:array<array{invert?:bool, match?:mixed, name:string}>, hostname?:array{exact?:string, suffix?:string}, method?:"GET"|"HEAD"|"POST"|"PUT"|"DELETE"|"CONNECT"|"OPTIONS"|"TRACE"|"PATCH", path?:array{exact?:string, regex?:string}, port?:int, prefix?:string, queryParameters?:array<array{match?:mixed, name:string}>}}, httpRoute?:array{action:array{rewrite?:array{hostname?:array{defaultTargetHostname?:"ENABLED"|"DISABLED"}, path?:array{exact?:string}, prefix?:array{defaultPrefix?:"ENABLED"|"DISABLED", value?:string}}, target:array{port?:int, virtualService:array{virtualServiceName:string}}}, match:array{headers?:array<array{invert?:bool, match?:mixed, name:string}>, hostname?:array{exact?:string, suffix?:string}, method?:"GET"|"HEAD"|"POST"|"PUT"|"DELETE"|"CONNECT"|"OPTIONS"|"TRACE"|"PATCH", path?:array{exact?:string, regex?:string}, port?:int, prefix?:string, queryParameters?:array<array{match?:mixed, name:string}>}}, priority?:int}, status:array{status:mixed}, virtualGatewayName:string}}>
     */
    public function describeGatewayRouteAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{meshName:string, meshOwner?:string} $args
     * @return \AWS\Result<array{mesh:array{meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, spec:array{egressFilter?:array{type:"ALLOW_ALL"|"DROP_ALL"}, serviceDiscovery?:array{ipPreference?:"IPv6_PREFERRED"|"IPv4_PREFERRED"|"IPv4_ONLY"|"IPv6_ONLY"}}, status:array{status?:mixed}}}>
     */
    public function describeMesh(array $args): \AWS\Result { }

    /**
     * @param array{meshName:string, meshOwner?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{mesh:array{meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, spec:array{egressFilter?:array{type:"ALLOW_ALL"|"DROP_ALL"}, serviceDiscovery?:array{ipPreference?:"IPv6_PREFERRED"|"IPv4_PREFERRED"|"IPv4_ONLY"|"IPv6_ONLY"}}, status:array{status?:mixed}}}>
     */
    public function describeMeshAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{meshName:string, meshOwner?:string, routeName:string, virtualRouterName:string} $args
     * @return \AWS\Result<array{route:array{meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, routeName:string, spec:array{grpcRoute?:array{action:array{weightedTargets:array<array{port?:int, virtualNode:string, weight:int}>}, match:array{metadata?:array<array{invert?:bool, match?:mixed, name:string}>, methodName?:string, port?:int, serviceName?:string}, retryPolicy?:array{grpcRetryEvents?:array<"cancelled"|"deadline-exceeded"|"internal"|"resource-exhausted"|"unavailable">, httpRetryEvents?:array<string>, maxRetries:int, perRetryTimeout:array{unit?:"s"|"ms", value?:int}, tcpRetryEvents?:array<"connection-error">}, timeout?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}}, http2Route?:array{action:array{weightedTargets:array<array{port?:int, virtualNode:string, weight:int}>}, match:array{headers?:array<array{invert?:bool, match?:mixed, name:string}>, method?:"GET"|"HEAD"|"POST"|"PUT"|"DELETE"|"CONNECT"|"OPTIONS"|"TRACE"|"PATCH", path?:array{exact?:string, regex?:string}, port?:int, prefix?:string, queryParameters?:array<array{match?:mixed, name:string}>, scheme?:"http"|"https"}, retryPolicy?:array{httpRetryEvents?:array<string>, maxRetries:int, perRetryTimeout:array{unit?:"s"|"ms", value?:int}, tcpRetryEvents?:array<"connection-error">}, timeout?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}}, httpRoute?:array{action:array{weightedTargets:array<array{port?:int, virtualNode:string, weight:int}>}, match:array{headers?:array<array{invert?:bool, match?:mixed, name:string}>, method?:"GET"|"HEAD"|"POST"|"PUT"|"DELETE"|"CONNECT"|"OPTIONS"|"TRACE"|"PATCH", path?:array{exact?:string, regex?:string}, port?:int, prefix?:string, queryParameters?:array<array{match?:mixed, name:string}>, scheme?:"http"|"https"}, retryPolicy?:array{httpRetryEvents?:array<string>, maxRetries:int, perRetryTimeout:array{unit?:"s"|"ms", value?:int}, tcpRetryEvents?:array<"connection-error">}, timeout?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}}, priority?:int, tcpRoute?:array{action:array{weightedTargets:array<array{port?:int, virtualNode:string, weight:int}>}, match?:array{port?:int}, timeout?:array{idle?:array{unit?:"s"|"ms", value?:int}}}}, status:array{status:mixed}, virtualRouterName:string}}>
     */
    public function describeRoute(array $args): \AWS\Result { }

    /**
     * @param array{meshName:string, meshOwner?:string, routeName:string, virtualRouterName:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{route:array{meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, routeName:string, spec:array{grpcRoute?:array{action:array{weightedTargets:array<array{port?:int, virtualNode:string, weight:int}>}, match:array{metadata?:array<array{invert?:bool, match?:mixed, name:string}>, methodName?:string, port?:int, serviceName?:string}, retryPolicy?:array{grpcRetryEvents?:array<"cancelled"|"deadline-exceeded"|"internal"|"resource-exhausted"|"unavailable">, httpRetryEvents?:array<string>, maxRetries:int, perRetryTimeout:array{unit?:"s"|"ms", value?:int}, tcpRetryEvents?:array<"connection-error">}, timeout?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}}, http2Route?:array{action:array{weightedTargets:array<array{port?:int, virtualNode:string, weight:int}>}, match:array{headers?:array<array{invert?:bool, match?:mixed, name:string}>, method?:"GET"|"HEAD"|"POST"|"PUT"|"DELETE"|"CONNECT"|"OPTIONS"|"TRACE"|"PATCH", path?:array{exact?:string, regex?:string}, port?:int, prefix?:string, queryParameters?:array<array{match?:mixed, name:string}>, scheme?:"http"|"https"}, retryPolicy?:array{httpRetryEvents?:array<string>, maxRetries:int, perRetryTimeout:array{unit?:"s"|"ms", value?:int}, tcpRetryEvents?:array<"connection-error">}, timeout?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}}, httpRoute?:array{action:array{weightedTargets:array<array{port?:int, virtualNode:string, weight:int}>}, match:array{headers?:array<array{invert?:bool, match?:mixed, name:string}>, method?:"GET"|"HEAD"|"POST"|"PUT"|"DELETE"|"CONNECT"|"OPTIONS"|"TRACE"|"PATCH", path?:array{exact?:string, regex?:string}, port?:int, prefix?:string, queryParameters?:array<array{match?:mixed, name:string}>, scheme?:"http"|"https"}, retryPolicy?:array{httpRetryEvents?:array<string>, maxRetries:int, perRetryTimeout:array{unit?:"s"|"ms", value?:int}, tcpRetryEvents?:array<"connection-error">}, timeout?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}}, priority?:int, tcpRoute?:array{action:array{weightedTargets:array<array{port?:int, virtualNode:string, weight:int}>}, match?:array{port?:int}, timeout?:array{idle?:array{unit?:"s"|"ms", value?:int}}}}, status:array{status:mixed}, virtualRouterName:string}}>
     */
    public function describeRouteAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{meshName:string, meshOwner?:string, virtualGatewayName:string} $args
     * @return \AWS\Result<array{virtualGateway:array{meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, spec:array{backendDefaults?:array{clientPolicy?:array{tls?:array{certificate?:array{file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, enforce?:bool, ports?:array<int>, validation:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{acm?:array{certificateAuthorityArns:array<string>}, file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}}, listeners:array<array{connectionPool?:array{grpc?:array{maxRequests:int}, http?:array{maxConnections:int, maxPendingRequests?:int}, http2?:array{maxRequests:int}}, healthCheck?:array{healthyThreshold:int, intervalMillis:int, path?:string, port?:int, protocol:"http"|"http2"|"grpc", timeoutMillis:int, unhealthyThreshold:int}, portMapping:array{port:int, protocol:"http"|"http2"|"grpc"}, tls?:array{certificate:array{acm?:array{certificateArn:string}, file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, mode:"STRICT"|"PERMISSIVE"|"DISABLED", validation?:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}>, logging?:array{accessLog?:array{file?:array{format?:array{json?:array<array{key:string, value:string}>, text?:string}, path:string}}}}, status:array{status:mixed}, virtualGatewayName:string}}>
     */
    public function describeVirtualGateway(array $args): \AWS\Result { }

    /**
     * @param array{meshName:string, meshOwner?:string, virtualGatewayName:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{virtualGateway:array{meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, spec:array{backendDefaults?:array{clientPolicy?:array{tls?:array{certificate?:array{file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, enforce?:bool, ports?:array<int>, validation:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{acm?:array{certificateAuthorityArns:array<string>}, file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}}, listeners:array<array{connectionPool?:array{grpc?:array{maxRequests:int}, http?:array{maxConnections:int, maxPendingRequests?:int}, http2?:array{maxRequests:int}}, healthCheck?:array{healthyThreshold:int, intervalMillis:int, path?:string, port?:int, protocol:"http"|"http2"|"grpc", timeoutMillis:int, unhealthyThreshold:int}, portMapping:array{port:int, protocol:"http"|"http2"|"grpc"}, tls?:array{certificate:array{acm?:array{certificateArn:string}, file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, mode:"STRICT"|"PERMISSIVE"|"DISABLED", validation?:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}>, logging?:array{accessLog?:array{file?:array{format?:array{json?:array<array{key:string, value:string}>, text?:string}, path:string}}}}, status:array{status:mixed}, virtualGatewayName:string}}>
     */
    public function describeVirtualGatewayAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{meshName:string, meshOwner?:string, virtualNodeName:string} $args
     * @return \AWS\Result<array{virtualNode:array{meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, spec:array{backendDefaults?:array{clientPolicy?:array{tls?:array{certificate?:array{file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, enforce?:bool, ports?:array<int>, validation:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{acm?:array{certificateAuthorityArns:array<string>}, file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}}, backends?:array<array{virtualService?:array{clientPolicy?:array{tls?:array{certificate?:array{file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, enforce?:bool, ports?:array<int>, validation:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{acm?:array{certificateAuthorityArns:array<string>}, file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}, virtualServiceName:string}}>, listeners?:array<array{connectionPool?:array{grpc?:array{maxRequests:int}, http?:array{maxConnections:int, maxPendingRequests?:int}, http2?:array{maxRequests:int}, tcp?:array{maxConnections:int}}, healthCheck?:array{healthyThreshold:int, intervalMillis:int, path?:string, port?:int, protocol:"http"|"tcp"|"http2"|"grpc", timeoutMillis:int, unhealthyThreshold:int}, outlierDetection?:array{baseEjectionDuration:array{unit?:"s"|"ms", value?:int}, interval:array{unit?:"s"|"ms", value?:int}, maxEjectionPercent:int, maxServerErrors:int}, portMapping:array{port:int, protocol:"http"|"tcp"|"http2"|"grpc"}, timeout?:array{grpc?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}, http?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}, http2?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}, tcp?:array{idle?:array{unit?:"s"|"ms", value?:int}}}, tls?:array{certificate:array{acm?:array{certificateArn:string}, file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, mode:"STRICT"|"PERMISSIVE"|"DISABLED", validation?:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}>, logging?:array{accessLog?:array{file?:array{format?:array{json?:array<array{key:string, value:string}>, text?:string}, path:string}}}, serviceDiscovery?:array{awsCloudMap?:array{attributes?:array<array{key:string, value:string}>, ipPreference?:"IPv6_PREFERRED"|"IPv4_PREFERRED"|"IPv4_ONLY"|"IPv6_ONLY", namespaceName:string, serviceName:string}, dns?:array{hostname:string, ipPreference?:"IPv6_PREFERRED"|"IPv4_PREFERRED"|"IPv4_ONLY"|"IPv6_ONLY", responseType?:"LOADBALANCER"|"ENDPOINTS"}}}, status:array{status:mixed}, virtualNodeName:string}}>
     */
    public function describeVirtualNode(array $args): \AWS\Result { }

    /**
     * @param array{meshName:string, meshOwner?:string, virtualNodeName:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{virtualNode:array{meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, spec:array{backendDefaults?:array{clientPolicy?:array{tls?:array{certificate?:array{file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, enforce?:bool, ports?:array<int>, validation:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{acm?:array{certificateAuthorityArns:array<string>}, file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}}, backends?:array<array{virtualService?:array{clientPolicy?:array{tls?:array{certificate?:array{file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, enforce?:bool, ports?:array<int>, validation:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{acm?:array{certificateAuthorityArns:array<string>}, file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}, virtualServiceName:string}}>, listeners?:array<array{connectionPool?:array{grpc?:array{maxRequests:int}, http?:array{maxConnections:int, maxPendingRequests?:int}, http2?:array{maxRequests:int}, tcp?:array{maxConnections:int}}, healthCheck?:array{healthyThreshold:int, intervalMillis:int, path?:string, port?:int, protocol:"http"|"tcp"|"http2"|"grpc", timeoutMillis:int, unhealthyThreshold:int}, outlierDetection?:array{baseEjectionDuration:array{unit?:"s"|"ms", value?:int}, interval:array{unit?:"s"|"ms", value?:int}, maxEjectionPercent:int, maxServerErrors:int}, portMapping:array{port:int, protocol:"http"|"tcp"|"http2"|"grpc"}, timeout?:array{grpc?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}, http?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}, http2?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}, tcp?:array{idle?:array{unit?:"s"|"ms", value?:int}}}, tls?:array{certificate:array{acm?:array{certificateArn:string}, file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, mode:"STRICT"|"PERMISSIVE"|"DISABLED", validation?:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}>, logging?:array{accessLog?:array{file?:array{format?:array{json?:array<array{key:string, value:string}>, text?:string}, path:string}}}, serviceDiscovery?:array{awsCloudMap?:array{attributes?:array<array{key:string, value:string}>, ipPreference?:"IPv6_PREFERRED"|"IPv4_PREFERRED"|"IPv4_ONLY"|"IPv6_ONLY", namespaceName:string, serviceName:string}, dns?:array{hostname:string, ipPreference?:"IPv6_PREFERRED"|"IPv4_PREFERRED"|"IPv4_ONLY"|"IPv6_ONLY", responseType?:"LOADBALANCER"|"ENDPOINTS"}}}, status:array{status:mixed}, virtualNodeName:string}}>
     */
    public function describeVirtualNodeAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{meshName:string, meshOwner?:string, virtualRouterName:string} $args
     * @return \AWS\Result<array{virtualRouter:array{meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, spec:array{listeners?:array<array{portMapping:array{port:int, protocol:"http"|"tcp"|"http2"|"grpc"}}>}, status:array{status:mixed}, virtualRouterName:string}}>
     */
    public function describeVirtualRouter(array $args): \AWS\Result { }

    /**
     * @param array{meshName:string, meshOwner?:string, virtualRouterName:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{virtualRouter:array{meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, spec:array{listeners?:array<array{portMapping:array{port:int, protocol:"http"|"tcp"|"http2"|"grpc"}}>}, status:array{status:mixed}, virtualRouterName:string}}>
     */
    public function describeVirtualRouterAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{meshName:string, meshOwner?:string, virtualServiceName:string} $args
     * @return \AWS\Result<array{virtualService:array{meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, spec:array{provider?:array{virtualNode?:array{virtualNodeName:string}, virtualRouter?:array{virtualRouterName:string}}}, status:array{status:mixed}, virtualServiceName:string}}>
     */
    public function describeVirtualService(array $args): \AWS\Result { }

    /**
     * @param array{meshName:string, meshOwner?:string, virtualServiceName:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{virtualService:array{meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, spec:array{provider?:array{virtualNode?:array{virtualNodeName:string}, virtualRouter?:array{virtualRouterName:string}}}, status:array{status:mixed}, virtualServiceName:string}}>
     */
    public function describeVirtualServiceAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{limit?:int, meshName:string, meshOwner?:string, nextToken?:string, virtualGatewayName:string} $args
     * @return \AWS\Result<array{gatewayRoutes:array<array{arn:string, createdAt:int|string|\DateTimeInterface, gatewayRouteName:string, lastUpdatedAt:int|string|\DateTimeInterface, meshName:string, meshOwner:string, resourceOwner:string, version:int, virtualGatewayName:string}>, nextToken?:string}>
     */
    public function listGatewayRoutes(array $args): \AWS\Result { }

    /**
     * @param array{limit?:int, meshName:string, meshOwner?:string, nextToken?:string, virtualGatewayName:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{gatewayRoutes:array<array{arn:string, createdAt:int|string|\DateTimeInterface, gatewayRouteName:string, lastUpdatedAt:int|string|\DateTimeInterface, meshName:string, meshOwner:string, resourceOwner:string, version:int, virtualGatewayName:string}>, nextToken?:string}>
     */
    public function listGatewayRoutesAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{limit?:int, nextToken?:string} $args
     * @return \AWS\Result<array{meshes:array<array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshName:string, meshOwner:string, resourceOwner:string, version:int}>, nextToken?:string}>
     */
    public function listMeshes(array $args = []): \AWS\Result { }

    /**
     * @param array{limit?:int, nextToken?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{meshes:array<array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshName:string, meshOwner:string, resourceOwner:string, version:int}>, nextToken?:string}>
     */
    public function listMeshesAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{limit?:int, meshName:string, meshOwner?:string, nextToken?:string, virtualRouterName:string} $args
     * @return \AWS\Result<array{nextToken?:string, routes:array<array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshName:string, meshOwner:string, resourceOwner:string, routeName:string, version:int, virtualRouterName:string}>}>
     */
    public function listRoutes(array $args): \AWS\Result { }

    /**
     * @param array{limit?:int, meshName:string, meshOwner?:string, nextToken?:string, virtualRouterName:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{nextToken?:string, routes:array<array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshName:string, meshOwner:string, resourceOwner:string, routeName:string, version:int, virtualRouterName:string}>}>
     */
    public function listRoutesAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{limit?:int, nextToken?:string, resourceArn:string} $args
     * @return \AWS\Result<array{nextToken?:string, tags:array<array{key:string, value:string}>}>
     */
    public function listTagsForResource(array $args): \AWS\Result { }

    /**
     * @param array{limit?:int, nextToken?:string, resourceArn:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{nextToken?:string, tags:array<array{key:string, value:string}>}>
     */
    public function listTagsForResourceAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{limit?:int, meshName:string, meshOwner?:string, nextToken?:string} $args
     * @return \AWS\Result<array{nextToken?:string, virtualGateways:array<array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshName:string, meshOwner:string, resourceOwner:string, version:int, virtualGatewayName:string}>}>
     */
    public function listVirtualGateways(array $args): \AWS\Result { }

    /**
     * @param array{limit?:int, meshName:string, meshOwner?:string, nextToken?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{nextToken?:string, virtualGateways:array<array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshName:string, meshOwner:string, resourceOwner:string, version:int, virtualGatewayName:string}>}>
     */
    public function listVirtualGatewaysAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{limit?:int, meshName:string, meshOwner?:string, nextToken?:string} $args
     * @return \AWS\Result<array{nextToken?:string, virtualNodes:array<array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshName:string, meshOwner:string, resourceOwner:string, version:int, virtualNodeName:string}>}>
     */
    public function listVirtualNodes(array $args): \AWS\Result { }

    /**
     * @param array{limit?:int, meshName:string, meshOwner?:string, nextToken?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{nextToken?:string, virtualNodes:array<array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshName:string, meshOwner:string, resourceOwner:string, version:int, virtualNodeName:string}>}>
     */
    public function listVirtualNodesAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{limit?:int, meshName:string, meshOwner?:string, nextToken?:string} $args
     * @return \AWS\Result<array{nextToken?:string, virtualRouters:array<array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshName:string, meshOwner:string, resourceOwner:string, version:int, virtualRouterName:string}>}>
     */
    public function listVirtualRouters(array $args): \AWS\Result { }

    /**
     * @param array{limit?:int, meshName:string, meshOwner?:string, nextToken?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{nextToken?:string, virtualRouters:array<array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshName:string, meshOwner:string, resourceOwner:string, version:int, virtualRouterName:string}>}>
     */
    public function listVirtualRoutersAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{limit?:int, meshName:string, meshOwner?:string, nextToken?:string} $args
     * @return \AWS\Result<array{nextToken?:string, virtualServices:array<array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshName:string, meshOwner:string, resourceOwner:string, version:int, virtualServiceName:string}>}>
     */
    public function listVirtualServices(array $args): \AWS\Result { }

    /**
     * @param array{limit?:int, meshName:string, meshOwner?:string, nextToken?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{nextToken?:string, virtualServices:array<array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshName:string, meshOwner:string, resourceOwner:string, version:int, virtualServiceName:string}>}>
     */
    public function listVirtualServicesAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{resourceArn:string, tags:array<array{key:string, value:string}>} $args
     * @return \AWS\Result<array{}>
     */
    public function tagResource(array $args): \AWS\Result { }

    /**
     * @param array{resourceArn:string, tags:array<array{key:string, value:string}>} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function tagResourceAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{resourceArn:string, tagKeys:array<string>} $args
     * @return \AWS\Result<array{}>
     */
    public function untagResource(array $args): \AWS\Result { }

    /**
     * @param array{resourceArn:string, tagKeys:array<string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function untagResourceAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{clientToken?:string, gatewayRouteName:string, meshName:string, meshOwner?:string, spec:array{grpcRoute?:array{action:array{rewrite?:array{hostname?:array{defaultTargetHostname?:"ENABLED"|"DISABLED"}}, target:array{port?:int, virtualService:array{virtualServiceName:string}}}, match:array{hostname?:array{exact?:string, suffix?:string}, metadata?:array<array{invert?:bool, match?:mixed, name:string}>, port?:int, serviceName?:string}}, http2Route?:array{action:array{rewrite?:array{hostname?:array{defaultTargetHostname?:"ENABLED"|"DISABLED"}, path?:array{exact?:string}, prefix?:array{defaultPrefix?:"ENABLED"|"DISABLED", value?:string}}, target:array{port?:int, virtualService:array{virtualServiceName:string}}}, match:array{headers?:array<array{invert?:bool, match?:mixed, name:string}>, hostname?:array{exact?:string, suffix?:string}, method?:"GET"|"HEAD"|"POST"|"PUT"|"DELETE"|"CONNECT"|"OPTIONS"|"TRACE"|"PATCH", path?:array{exact?:string, regex?:string}, port?:int, prefix?:string, queryParameters?:array<array{match?:mixed, name:string}>}}, httpRoute?:array{action:array{rewrite?:array{hostname?:array{defaultTargetHostname?:"ENABLED"|"DISABLED"}, path?:array{exact?:string}, prefix?:array{defaultPrefix?:"ENABLED"|"DISABLED", value?:string}}, target:array{port?:int, virtualService:array{virtualServiceName:string}}}, match:array{headers?:array<array{invert?:bool, match?:mixed, name:string}>, hostname?:array{exact?:string, suffix?:string}, method?:"GET"|"HEAD"|"POST"|"PUT"|"DELETE"|"CONNECT"|"OPTIONS"|"TRACE"|"PATCH", path?:array{exact?:string, regex?:string}, port?:int, prefix?:string, queryParameters?:array<array{match?:mixed, name:string}>}}, priority?:int}, virtualGatewayName:string} $args
     * @return \AWS\Result<array{gatewayRoute:array{gatewayRouteName:string, meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, spec:array{grpcRoute?:array{action:array{rewrite?:array{hostname?:array{defaultTargetHostname?:"ENABLED"|"DISABLED"}}, target:array{port?:int, virtualService:array{virtualServiceName:string}}}, match:array{hostname?:array{exact?:string, suffix?:string}, metadata?:array<array{invert?:bool, match?:mixed, name:string}>, port?:int, serviceName?:string}}, http2Route?:array{action:array{rewrite?:array{hostname?:array{defaultTargetHostname?:"ENABLED"|"DISABLED"}, path?:array{exact?:string}, prefix?:array{defaultPrefix?:"ENABLED"|"DISABLED", value?:string}}, target:array{port?:int, virtualService:array{virtualServiceName:string}}}, match:array{headers?:array<array{invert?:bool, match?:mixed, name:string}>, hostname?:array{exact?:string, suffix?:string}, method?:"GET"|"HEAD"|"POST"|"PUT"|"DELETE"|"CONNECT"|"OPTIONS"|"TRACE"|"PATCH", path?:array{exact?:string, regex?:string}, port?:int, prefix?:string, queryParameters?:array<array{match?:mixed, name:string}>}}, httpRoute?:array{action:array{rewrite?:array{hostname?:array{defaultTargetHostname?:"ENABLED"|"DISABLED"}, path?:array{exact?:string}, prefix?:array{defaultPrefix?:"ENABLED"|"DISABLED", value?:string}}, target:array{port?:int, virtualService:array{virtualServiceName:string}}}, match:array{headers?:array<array{invert?:bool, match?:mixed, name:string}>, hostname?:array{exact?:string, suffix?:string}, method?:"GET"|"HEAD"|"POST"|"PUT"|"DELETE"|"CONNECT"|"OPTIONS"|"TRACE"|"PATCH", path?:array{exact?:string, regex?:string}, port?:int, prefix?:string, queryParameters?:array<array{match?:mixed, name:string}>}}, priority?:int}, status:array{status:mixed}, virtualGatewayName:string}}>
     */
    public function updateGatewayRoute(array $args): \AWS\Result { }

    /**
     * @param array{clientToken?:string, gatewayRouteName:string, meshName:string, meshOwner?:string, spec:array{grpcRoute?:array{action:array{rewrite?:array{hostname?:array{defaultTargetHostname?:"ENABLED"|"DISABLED"}}, target:array{port?:int, virtualService:array{virtualServiceName:string}}}, match:array{hostname?:array{exact?:string, suffix?:string}, metadata?:array<array{invert?:bool, match?:mixed, name:string}>, port?:int, serviceName?:string}}, http2Route?:array{action:array{rewrite?:array{hostname?:array{defaultTargetHostname?:"ENABLED"|"DISABLED"}, path?:array{exact?:string}, prefix?:array{defaultPrefix?:"ENABLED"|"DISABLED", value?:string}}, target:array{port?:int, virtualService:array{virtualServiceName:string}}}, match:array{headers?:array<array{invert?:bool, match?:mixed, name:string}>, hostname?:array{exact?:string, suffix?:string}, method?:"GET"|"HEAD"|"POST"|"PUT"|"DELETE"|"CONNECT"|"OPTIONS"|"TRACE"|"PATCH", path?:array{exact?:string, regex?:string}, port?:int, prefix?:string, queryParameters?:array<array{match?:mixed, name:string}>}}, httpRoute?:array{action:array{rewrite?:array{hostname?:array{defaultTargetHostname?:"ENABLED"|"DISABLED"}, path?:array{exact?:string}, prefix?:array{defaultPrefix?:"ENABLED"|"DISABLED", value?:string}}, target:array{port?:int, virtualService:array{virtualServiceName:string}}}, match:array{headers?:array<array{invert?:bool, match?:mixed, name:string}>, hostname?:array{exact?:string, suffix?:string}, method?:"GET"|"HEAD"|"POST"|"PUT"|"DELETE"|"CONNECT"|"OPTIONS"|"TRACE"|"PATCH", path?:array{exact?:string, regex?:string}, port?:int, prefix?:string, queryParameters?:array<array{match?:mixed, name:string}>}}, priority?:int}, virtualGatewayName:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{gatewayRoute:array{gatewayRouteName:string, meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, spec:array{grpcRoute?:array{action:array{rewrite?:array{hostname?:array{defaultTargetHostname?:"ENABLED"|"DISABLED"}}, target:array{port?:int, virtualService:array{virtualServiceName:string}}}, match:array{hostname?:array{exact?:string, suffix?:string}, metadata?:array<array{invert?:bool, match?:mixed, name:string}>, port?:int, serviceName?:string}}, http2Route?:array{action:array{rewrite?:array{hostname?:array{defaultTargetHostname?:"ENABLED"|"DISABLED"}, path?:array{exact?:string}, prefix?:array{defaultPrefix?:"ENABLED"|"DISABLED", value?:string}}, target:array{port?:int, virtualService:array{virtualServiceName:string}}}, match:array{headers?:array<array{invert?:bool, match?:mixed, name:string}>, hostname?:array{exact?:string, suffix?:string}, method?:"GET"|"HEAD"|"POST"|"PUT"|"DELETE"|"CONNECT"|"OPTIONS"|"TRACE"|"PATCH", path?:array{exact?:string, regex?:string}, port?:int, prefix?:string, queryParameters?:array<array{match?:mixed, name:string}>}}, httpRoute?:array{action:array{rewrite?:array{hostname?:array{defaultTargetHostname?:"ENABLED"|"DISABLED"}, path?:array{exact?:string}, prefix?:array{defaultPrefix?:"ENABLED"|"DISABLED", value?:string}}, target:array{port?:int, virtualService:array{virtualServiceName:string}}}, match:array{headers?:array<array{invert?:bool, match?:mixed, name:string}>, hostname?:array{exact?:string, suffix?:string}, method?:"GET"|"HEAD"|"POST"|"PUT"|"DELETE"|"CONNECT"|"OPTIONS"|"TRACE"|"PATCH", path?:array{exact?:string, regex?:string}, port?:int, prefix?:string, queryParameters?:array<array{match?:mixed, name:string}>}}, priority?:int}, status:array{status:mixed}, virtualGatewayName:string}}>
     */
    public function updateGatewayRouteAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{clientToken?:string, meshName:string, spec?:array{egressFilter?:array{type:"ALLOW_ALL"|"DROP_ALL"}, serviceDiscovery?:array{ipPreference?:"IPv6_PREFERRED"|"IPv4_PREFERRED"|"IPv4_ONLY"|"IPv6_ONLY"}}} $args
     * @return \AWS\Result<array{mesh:array{meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, spec:array{egressFilter?:array{type:"ALLOW_ALL"|"DROP_ALL"}, serviceDiscovery?:array{ipPreference?:"IPv6_PREFERRED"|"IPv4_PREFERRED"|"IPv4_ONLY"|"IPv6_ONLY"}}, status:array{status?:mixed}}}>
     */
    public function updateMesh(array $args): \AWS\Result { }

    /**
     * @param array{clientToken?:string, meshName:string, spec?:array{egressFilter?:array{type:"ALLOW_ALL"|"DROP_ALL"}, serviceDiscovery?:array{ipPreference?:"IPv6_PREFERRED"|"IPv4_PREFERRED"|"IPv4_ONLY"|"IPv6_ONLY"}}} $args
     * @return \GuzzleHttp\Promise\Promise<array{mesh:array{meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, spec:array{egressFilter?:array{type:"ALLOW_ALL"|"DROP_ALL"}, serviceDiscovery?:array{ipPreference?:"IPv6_PREFERRED"|"IPv4_PREFERRED"|"IPv4_ONLY"|"IPv6_ONLY"}}, status:array{status?:mixed}}}>
     */
    public function updateMeshAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{clientToken?:string, meshName:string, meshOwner?:string, routeName:string, spec:array{grpcRoute?:array{action:array{weightedTargets:array<array{port?:int, virtualNode:string, weight:int}>}, match:array{metadata?:array<array{invert?:bool, match?:mixed, name:string}>, methodName?:string, port?:int, serviceName?:string}, retryPolicy?:array{grpcRetryEvents?:array<"cancelled"|"deadline-exceeded"|"internal"|"resource-exhausted"|"unavailable">, httpRetryEvents?:array<string>, maxRetries:int, perRetryTimeout:array{unit?:"s"|"ms", value?:int}, tcpRetryEvents?:array<"connection-error">}, timeout?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}}, http2Route?:array{action:array{weightedTargets:array<array{port?:int, virtualNode:string, weight:int}>}, match:array{headers?:array<array{invert?:bool, match?:mixed, name:string}>, method?:"GET"|"HEAD"|"POST"|"PUT"|"DELETE"|"CONNECT"|"OPTIONS"|"TRACE"|"PATCH", path?:array{exact?:string, regex?:string}, port?:int, prefix?:string, queryParameters?:array<array{match?:mixed, name:string}>, scheme?:"http"|"https"}, retryPolicy?:array{httpRetryEvents?:array<string>, maxRetries:int, perRetryTimeout:array{unit?:"s"|"ms", value?:int}, tcpRetryEvents?:array<"connection-error">}, timeout?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}}, httpRoute?:array{action:array{weightedTargets:array<array{port?:int, virtualNode:string, weight:int}>}, match:array{headers?:array<array{invert?:bool, match?:mixed, name:string}>, method?:"GET"|"HEAD"|"POST"|"PUT"|"DELETE"|"CONNECT"|"OPTIONS"|"TRACE"|"PATCH", path?:array{exact?:string, regex?:string}, port?:int, prefix?:string, queryParameters?:array<array{match?:mixed, name:string}>, scheme?:"http"|"https"}, retryPolicy?:array{httpRetryEvents?:array<string>, maxRetries:int, perRetryTimeout:array{unit?:"s"|"ms", value?:int}, tcpRetryEvents?:array<"connection-error">}, timeout?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}}, priority?:int, tcpRoute?:array{action:array{weightedTargets:array<array{port?:int, virtualNode:string, weight:int}>}, match?:array{port?:int}, timeout?:array{idle?:array{unit?:"s"|"ms", value?:int}}}}, virtualRouterName:string} $args
     * @return \AWS\Result<array{route:array{meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, routeName:string, spec:array{grpcRoute?:array{action:array{weightedTargets:array<array{port?:int, virtualNode:string, weight:int}>}, match:array{metadata?:array<array{invert?:bool, match?:mixed, name:string}>, methodName?:string, port?:int, serviceName?:string}, retryPolicy?:array{grpcRetryEvents?:array<"cancelled"|"deadline-exceeded"|"internal"|"resource-exhausted"|"unavailable">, httpRetryEvents?:array<string>, maxRetries:int, perRetryTimeout:array{unit?:"s"|"ms", value?:int}, tcpRetryEvents?:array<"connection-error">}, timeout?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}}, http2Route?:array{action:array{weightedTargets:array<array{port?:int, virtualNode:string, weight:int}>}, match:array{headers?:array<array{invert?:bool, match?:mixed, name:string}>, method?:"GET"|"HEAD"|"POST"|"PUT"|"DELETE"|"CONNECT"|"OPTIONS"|"TRACE"|"PATCH", path?:array{exact?:string, regex?:string}, port?:int, prefix?:string, queryParameters?:array<array{match?:mixed, name:string}>, scheme?:"http"|"https"}, retryPolicy?:array{httpRetryEvents?:array<string>, maxRetries:int, perRetryTimeout:array{unit?:"s"|"ms", value?:int}, tcpRetryEvents?:array<"connection-error">}, timeout?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}}, httpRoute?:array{action:array{weightedTargets:array<array{port?:int, virtualNode:string, weight:int}>}, match:array{headers?:array<array{invert?:bool, match?:mixed, name:string}>, method?:"GET"|"HEAD"|"POST"|"PUT"|"DELETE"|"CONNECT"|"OPTIONS"|"TRACE"|"PATCH", path?:array{exact?:string, regex?:string}, port?:int, prefix?:string, queryParameters?:array<array{match?:mixed, name:string}>, scheme?:"http"|"https"}, retryPolicy?:array{httpRetryEvents?:array<string>, maxRetries:int, perRetryTimeout:array{unit?:"s"|"ms", value?:int}, tcpRetryEvents?:array<"connection-error">}, timeout?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}}, priority?:int, tcpRoute?:array{action:array{weightedTargets:array<array{port?:int, virtualNode:string, weight:int}>}, match?:array{port?:int}, timeout?:array{idle?:array{unit?:"s"|"ms", value?:int}}}}, status:array{status:mixed}, virtualRouterName:string}}>
     */
    public function updateRoute(array $args): \AWS\Result { }

    /**
     * @param array{clientToken?:string, meshName:string, meshOwner?:string, routeName:string, spec:array{grpcRoute?:array{action:array{weightedTargets:array<array{port?:int, virtualNode:string, weight:int}>}, match:array{metadata?:array<array{invert?:bool, match?:mixed, name:string}>, methodName?:string, port?:int, serviceName?:string}, retryPolicy?:array{grpcRetryEvents?:array<"cancelled"|"deadline-exceeded"|"internal"|"resource-exhausted"|"unavailable">, httpRetryEvents?:array<string>, maxRetries:int, perRetryTimeout:array{unit?:"s"|"ms", value?:int}, tcpRetryEvents?:array<"connection-error">}, timeout?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}}, http2Route?:array{action:array{weightedTargets:array<array{port?:int, virtualNode:string, weight:int}>}, match:array{headers?:array<array{invert?:bool, match?:mixed, name:string}>, method?:"GET"|"HEAD"|"POST"|"PUT"|"DELETE"|"CONNECT"|"OPTIONS"|"TRACE"|"PATCH", path?:array{exact?:string, regex?:string}, port?:int, prefix?:string, queryParameters?:array<array{match?:mixed, name:string}>, scheme?:"http"|"https"}, retryPolicy?:array{httpRetryEvents?:array<string>, maxRetries:int, perRetryTimeout:array{unit?:"s"|"ms", value?:int}, tcpRetryEvents?:array<"connection-error">}, timeout?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}}, httpRoute?:array{action:array{weightedTargets:array<array{port?:int, virtualNode:string, weight:int}>}, match:array{headers?:array<array{invert?:bool, match?:mixed, name:string}>, method?:"GET"|"HEAD"|"POST"|"PUT"|"DELETE"|"CONNECT"|"OPTIONS"|"TRACE"|"PATCH", path?:array{exact?:string, regex?:string}, port?:int, prefix?:string, queryParameters?:array<array{match?:mixed, name:string}>, scheme?:"http"|"https"}, retryPolicy?:array{httpRetryEvents?:array<string>, maxRetries:int, perRetryTimeout:array{unit?:"s"|"ms", value?:int}, tcpRetryEvents?:array<"connection-error">}, timeout?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}}, priority?:int, tcpRoute?:array{action:array{weightedTargets:array<array{port?:int, virtualNode:string, weight:int}>}, match?:array{port?:int}, timeout?:array{idle?:array{unit?:"s"|"ms", value?:int}}}}, virtualRouterName:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{route:array{meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, routeName:string, spec:array{grpcRoute?:array{action:array{weightedTargets:array<array{port?:int, virtualNode:string, weight:int}>}, match:array{metadata?:array<array{invert?:bool, match?:mixed, name:string}>, methodName?:string, port?:int, serviceName?:string}, retryPolicy?:array{grpcRetryEvents?:array<"cancelled"|"deadline-exceeded"|"internal"|"resource-exhausted"|"unavailable">, httpRetryEvents?:array<string>, maxRetries:int, perRetryTimeout:array{unit?:"s"|"ms", value?:int}, tcpRetryEvents?:array<"connection-error">}, timeout?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}}, http2Route?:array{action:array{weightedTargets:array<array{port?:int, virtualNode:string, weight:int}>}, match:array{headers?:array<array{invert?:bool, match?:mixed, name:string}>, method?:"GET"|"HEAD"|"POST"|"PUT"|"DELETE"|"CONNECT"|"OPTIONS"|"TRACE"|"PATCH", path?:array{exact?:string, regex?:string}, port?:int, prefix?:string, queryParameters?:array<array{match?:mixed, name:string}>, scheme?:"http"|"https"}, retryPolicy?:array{httpRetryEvents?:array<string>, maxRetries:int, perRetryTimeout:array{unit?:"s"|"ms", value?:int}, tcpRetryEvents?:array<"connection-error">}, timeout?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}}, httpRoute?:array{action:array{weightedTargets:array<array{port?:int, virtualNode:string, weight:int}>}, match:array{headers?:array<array{invert?:bool, match?:mixed, name:string}>, method?:"GET"|"HEAD"|"POST"|"PUT"|"DELETE"|"CONNECT"|"OPTIONS"|"TRACE"|"PATCH", path?:array{exact?:string, regex?:string}, port?:int, prefix?:string, queryParameters?:array<array{match?:mixed, name:string}>, scheme?:"http"|"https"}, retryPolicy?:array{httpRetryEvents?:array<string>, maxRetries:int, perRetryTimeout:array{unit?:"s"|"ms", value?:int}, tcpRetryEvents?:array<"connection-error">}, timeout?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}}, priority?:int, tcpRoute?:array{action:array{weightedTargets:array<array{port?:int, virtualNode:string, weight:int}>}, match?:array{port?:int}, timeout?:array{idle?:array{unit?:"s"|"ms", value?:int}}}}, status:array{status:mixed}, virtualRouterName:string}}>
     */
    public function updateRouteAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{clientToken?:string, meshName:string, meshOwner?:string, spec:array{backendDefaults?:array{clientPolicy?:array{tls?:array{certificate?:array{file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, enforce?:bool, ports?:array<int>, validation:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{acm?:array{certificateAuthorityArns:array<string>}, file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}}, listeners:array<array{connectionPool?:array{grpc?:array{maxRequests:int}, http?:array{maxConnections:int, maxPendingRequests?:int}, http2?:array{maxRequests:int}}, healthCheck?:array{healthyThreshold:int, intervalMillis:int, path?:string, port?:int, protocol:"http"|"http2"|"grpc", timeoutMillis:int, unhealthyThreshold:int}, portMapping:array{port:int, protocol:"http"|"http2"|"grpc"}, tls?:array{certificate:array{acm?:array{certificateArn:string}, file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, mode:"STRICT"|"PERMISSIVE"|"DISABLED", validation?:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}>, logging?:array{accessLog?:array{file?:array{format?:array{json?:array<array{key:string, value:string}>, text?:string}, path:string}}}}, virtualGatewayName:string} $args
     * @return \AWS\Result<array{virtualGateway:array{meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, spec:array{backendDefaults?:array{clientPolicy?:array{tls?:array{certificate?:array{file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, enforce?:bool, ports?:array<int>, validation:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{acm?:array{certificateAuthorityArns:array<string>}, file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}}, listeners:array<array{connectionPool?:array{grpc?:array{maxRequests:int}, http?:array{maxConnections:int, maxPendingRequests?:int}, http2?:array{maxRequests:int}}, healthCheck?:array{healthyThreshold:int, intervalMillis:int, path?:string, port?:int, protocol:"http"|"http2"|"grpc", timeoutMillis:int, unhealthyThreshold:int}, portMapping:array{port:int, protocol:"http"|"http2"|"grpc"}, tls?:array{certificate:array{acm?:array{certificateArn:string}, file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, mode:"STRICT"|"PERMISSIVE"|"DISABLED", validation?:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}>, logging?:array{accessLog?:array{file?:array{format?:array{json?:array<array{key:string, value:string}>, text?:string}, path:string}}}}, status:array{status:mixed}, virtualGatewayName:string}}>
     */
    public function updateVirtualGateway(array $args): \AWS\Result { }

    /**
     * @param array{clientToken?:string, meshName:string, meshOwner?:string, spec:array{backendDefaults?:array{clientPolicy?:array{tls?:array{certificate?:array{file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, enforce?:bool, ports?:array<int>, validation:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{acm?:array{certificateAuthorityArns:array<string>}, file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}}, listeners:array<array{connectionPool?:array{grpc?:array{maxRequests:int}, http?:array{maxConnections:int, maxPendingRequests?:int}, http2?:array{maxRequests:int}}, healthCheck?:array{healthyThreshold:int, intervalMillis:int, path?:string, port?:int, protocol:"http"|"http2"|"grpc", timeoutMillis:int, unhealthyThreshold:int}, portMapping:array{port:int, protocol:"http"|"http2"|"grpc"}, tls?:array{certificate:array{acm?:array{certificateArn:string}, file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, mode:"STRICT"|"PERMISSIVE"|"DISABLED", validation?:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}>, logging?:array{accessLog?:array{file?:array{format?:array{json?:array<array{key:string, value:string}>, text?:string}, path:string}}}}, virtualGatewayName:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{virtualGateway:array{meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, spec:array{backendDefaults?:array{clientPolicy?:array{tls?:array{certificate?:array{file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, enforce?:bool, ports?:array<int>, validation:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{acm?:array{certificateAuthorityArns:array<string>}, file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}}, listeners:array<array{connectionPool?:array{grpc?:array{maxRequests:int}, http?:array{maxConnections:int, maxPendingRequests?:int}, http2?:array{maxRequests:int}}, healthCheck?:array{healthyThreshold:int, intervalMillis:int, path?:string, port?:int, protocol:"http"|"http2"|"grpc", timeoutMillis:int, unhealthyThreshold:int}, portMapping:array{port:int, protocol:"http"|"http2"|"grpc"}, tls?:array{certificate:array{acm?:array{certificateArn:string}, file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, mode:"STRICT"|"PERMISSIVE"|"DISABLED", validation?:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}>, logging?:array{accessLog?:array{file?:array{format?:array{json?:array<array{key:string, value:string}>, text?:string}, path:string}}}}, status:array{status:mixed}, virtualGatewayName:string}}>
     */
    public function updateVirtualGatewayAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{clientToken?:string, meshName:string, meshOwner?:string, spec:array{backendDefaults?:array{clientPolicy?:array{tls?:array{certificate?:array{file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, enforce?:bool, ports?:array<int>, validation:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{acm?:array{certificateAuthorityArns:array<string>}, file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}}, backends?:array<array{virtualService?:array{clientPolicy?:array{tls?:array{certificate?:array{file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, enforce?:bool, ports?:array<int>, validation:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{acm?:array{certificateAuthorityArns:array<string>}, file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}, virtualServiceName:string}}>, listeners?:array<array{connectionPool?:array{grpc?:array{maxRequests:int}, http?:array{maxConnections:int, maxPendingRequests?:int}, http2?:array{maxRequests:int}, tcp?:array{maxConnections:int}}, healthCheck?:array{healthyThreshold:int, intervalMillis:int, path?:string, port?:int, protocol:"http"|"tcp"|"http2"|"grpc", timeoutMillis:int, unhealthyThreshold:int}, outlierDetection?:array{baseEjectionDuration:array{unit?:"s"|"ms", value?:int}, interval:array{unit?:"s"|"ms", value?:int}, maxEjectionPercent:int, maxServerErrors:int}, portMapping:array{port:int, protocol:"http"|"tcp"|"http2"|"grpc"}, timeout?:array{grpc?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}, http?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}, http2?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}, tcp?:array{idle?:array{unit?:"s"|"ms", value?:int}}}, tls?:array{certificate:array{acm?:array{certificateArn:string}, file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, mode:"STRICT"|"PERMISSIVE"|"DISABLED", validation?:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}>, logging?:array{accessLog?:array{file?:array{format?:array{json?:array<array{key:string, value:string}>, text?:string}, path:string}}}, serviceDiscovery?:array{awsCloudMap?:array{attributes?:array<array{key:string, value:string}>, ipPreference?:"IPv6_PREFERRED"|"IPv4_PREFERRED"|"IPv4_ONLY"|"IPv6_ONLY", namespaceName:string, serviceName:string}, dns?:array{hostname:string, ipPreference?:"IPv6_PREFERRED"|"IPv4_PREFERRED"|"IPv4_ONLY"|"IPv6_ONLY", responseType?:"LOADBALANCER"|"ENDPOINTS"}}}, virtualNodeName:string} $args
     * @return \AWS\Result<array{virtualNode:array{meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, spec:array{backendDefaults?:array{clientPolicy?:array{tls?:array{certificate?:array{file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, enforce?:bool, ports?:array<int>, validation:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{acm?:array{certificateAuthorityArns:array<string>}, file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}}, backends?:array<array{virtualService?:array{clientPolicy?:array{tls?:array{certificate?:array{file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, enforce?:bool, ports?:array<int>, validation:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{acm?:array{certificateAuthorityArns:array<string>}, file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}, virtualServiceName:string}}>, listeners?:array<array{connectionPool?:array{grpc?:array{maxRequests:int}, http?:array{maxConnections:int, maxPendingRequests?:int}, http2?:array{maxRequests:int}, tcp?:array{maxConnections:int}}, healthCheck?:array{healthyThreshold:int, intervalMillis:int, path?:string, port?:int, protocol:"http"|"tcp"|"http2"|"grpc", timeoutMillis:int, unhealthyThreshold:int}, outlierDetection?:array{baseEjectionDuration:array{unit?:"s"|"ms", value?:int}, interval:array{unit?:"s"|"ms", value?:int}, maxEjectionPercent:int, maxServerErrors:int}, portMapping:array{port:int, protocol:"http"|"tcp"|"http2"|"grpc"}, timeout?:array{grpc?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}, http?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}, http2?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}, tcp?:array{idle?:array{unit?:"s"|"ms", value?:int}}}, tls?:array{certificate:array{acm?:array{certificateArn:string}, file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, mode:"STRICT"|"PERMISSIVE"|"DISABLED", validation?:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}>, logging?:array{accessLog?:array{file?:array{format?:array{json?:array<array{key:string, value:string}>, text?:string}, path:string}}}, serviceDiscovery?:array{awsCloudMap?:array{attributes?:array<array{key:string, value:string}>, ipPreference?:"IPv6_PREFERRED"|"IPv4_PREFERRED"|"IPv4_ONLY"|"IPv6_ONLY", namespaceName:string, serviceName:string}, dns?:array{hostname:string, ipPreference?:"IPv6_PREFERRED"|"IPv4_PREFERRED"|"IPv4_ONLY"|"IPv6_ONLY", responseType?:"LOADBALANCER"|"ENDPOINTS"}}}, status:array{status:mixed}, virtualNodeName:string}}>
     */
    public function updateVirtualNode(array $args): \AWS\Result { }

    /**
     * @param array{clientToken?:string, meshName:string, meshOwner?:string, spec:array{backendDefaults?:array{clientPolicy?:array{tls?:array{certificate?:array{file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, enforce?:bool, ports?:array<int>, validation:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{acm?:array{certificateAuthorityArns:array<string>}, file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}}, backends?:array<array{virtualService?:array{clientPolicy?:array{tls?:array{certificate?:array{file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, enforce?:bool, ports?:array<int>, validation:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{acm?:array{certificateAuthorityArns:array<string>}, file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}, virtualServiceName:string}}>, listeners?:array<array{connectionPool?:array{grpc?:array{maxRequests:int}, http?:array{maxConnections:int, maxPendingRequests?:int}, http2?:array{maxRequests:int}, tcp?:array{maxConnections:int}}, healthCheck?:array{healthyThreshold:int, intervalMillis:int, path?:string, port?:int, protocol:"http"|"tcp"|"http2"|"grpc", timeoutMillis:int, unhealthyThreshold:int}, outlierDetection?:array{baseEjectionDuration:array{unit?:"s"|"ms", value?:int}, interval:array{unit?:"s"|"ms", value?:int}, maxEjectionPercent:int, maxServerErrors:int}, portMapping:array{port:int, protocol:"http"|"tcp"|"http2"|"grpc"}, timeout?:array{grpc?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}, http?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}, http2?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}, tcp?:array{idle?:array{unit?:"s"|"ms", value?:int}}}, tls?:array{certificate:array{acm?:array{certificateArn:string}, file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, mode:"STRICT"|"PERMISSIVE"|"DISABLED", validation?:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}>, logging?:array{accessLog?:array{file?:array{format?:array{json?:array<array{key:string, value:string}>, text?:string}, path:string}}}, serviceDiscovery?:array{awsCloudMap?:array{attributes?:array<array{key:string, value:string}>, ipPreference?:"IPv6_PREFERRED"|"IPv4_PREFERRED"|"IPv4_ONLY"|"IPv6_ONLY", namespaceName:string, serviceName:string}, dns?:array{hostname:string, ipPreference?:"IPv6_PREFERRED"|"IPv4_PREFERRED"|"IPv4_ONLY"|"IPv6_ONLY", responseType?:"LOADBALANCER"|"ENDPOINTS"}}}, virtualNodeName:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{virtualNode:array{meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, spec:array{backendDefaults?:array{clientPolicy?:array{tls?:array{certificate?:array{file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, enforce?:bool, ports?:array<int>, validation:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{acm?:array{certificateAuthorityArns:array<string>}, file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}}, backends?:array<array{virtualService?:array{clientPolicy?:array{tls?:array{certificate?:array{file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, enforce?:bool, ports?:array<int>, validation:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{acm?:array{certificateAuthorityArns:array<string>}, file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}, virtualServiceName:string}}>, listeners?:array<array{connectionPool?:array{grpc?:array{maxRequests:int}, http?:array{maxConnections:int, maxPendingRequests?:int}, http2?:array{maxRequests:int}, tcp?:array{maxConnections:int}}, healthCheck?:array{healthyThreshold:int, intervalMillis:int, path?:string, port?:int, protocol:"http"|"tcp"|"http2"|"grpc", timeoutMillis:int, unhealthyThreshold:int}, outlierDetection?:array{baseEjectionDuration:array{unit?:"s"|"ms", value?:int}, interval:array{unit?:"s"|"ms", value?:int}, maxEjectionPercent:int, maxServerErrors:int}, portMapping:array{port:int, protocol:"http"|"tcp"|"http2"|"grpc"}, timeout?:array{grpc?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}, http?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}, http2?:array{idle?:array{unit?:"s"|"ms", value?:int}, perRequest?:array{unit?:"s"|"ms", value?:int}}, tcp?:array{idle?:array{unit?:"s"|"ms", value?:int}}}, tls?:array{certificate:array{acm?:array{certificateArn:string}, file?:array{certificateChain:string, privateKey:string}, sds?:array{secretName:string}}, mode:"STRICT"|"PERMISSIVE"|"DISABLED", validation?:array{subjectAlternativeNames?:array{match:array{exact:array<string>}}, trust:array{file?:array{certificateChain:string}, sds?:array{secretName:string}}}}}>, logging?:array{accessLog?:array{file?:array{format?:array{json?:array<array{key:string, value:string}>, text?:string}, path:string}}}, serviceDiscovery?:array{awsCloudMap?:array{attributes?:array<array{key:string, value:string}>, ipPreference?:"IPv6_PREFERRED"|"IPv4_PREFERRED"|"IPv4_ONLY"|"IPv6_ONLY", namespaceName:string, serviceName:string}, dns?:array{hostname:string, ipPreference?:"IPv6_PREFERRED"|"IPv4_PREFERRED"|"IPv4_ONLY"|"IPv6_ONLY", responseType?:"LOADBALANCER"|"ENDPOINTS"}}}, status:array{status:mixed}, virtualNodeName:string}}>
     */
    public function updateVirtualNodeAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{clientToken?:string, meshName:string, meshOwner?:string, spec:array{listeners?:array<array{portMapping:array{port:int, protocol:"http"|"tcp"|"http2"|"grpc"}}>}, virtualRouterName:string} $args
     * @return \AWS\Result<array{virtualRouter:array{meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, spec:array{listeners?:array<array{portMapping:array{port:int, protocol:"http"|"tcp"|"http2"|"grpc"}}>}, status:array{status:mixed}, virtualRouterName:string}}>
     */
    public function updateVirtualRouter(array $args): \AWS\Result { }

    /**
     * @param array{clientToken?:string, meshName:string, meshOwner?:string, spec:array{listeners?:array<array{portMapping:array{port:int, protocol:"http"|"tcp"|"http2"|"grpc"}}>}, virtualRouterName:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{virtualRouter:array{meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, spec:array{listeners?:array<array{portMapping:array{port:int, protocol:"http"|"tcp"|"http2"|"grpc"}}>}, status:array{status:mixed}, virtualRouterName:string}}>
     */
    public function updateVirtualRouterAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{clientToken?:string, meshName:string, meshOwner?:string, spec:array{provider?:array{virtualNode?:array{virtualNodeName:string}, virtualRouter?:array{virtualRouterName:string}}}, virtualServiceName:string} $args
     * @return \AWS\Result<array{virtualService:array{meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, spec:array{provider?:array{virtualNode?:array{virtualNodeName:string}, virtualRouter?:array{virtualRouterName:string}}}, status:array{status:mixed}, virtualServiceName:string}}>
     */
    public function updateVirtualService(array $args): \AWS\Result { }

    /**
     * @param array{clientToken?:string, meshName:string, meshOwner?:string, spec:array{provider?:array{virtualNode?:array{virtualNodeName:string}, virtualRouter?:array{virtualRouterName:string}}}, virtualServiceName:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{virtualService:array{meshName:string, metadata:array{arn:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, meshOwner:string, resourceOwner:string, uid:string, version:int}, spec:array{provider?:array{virtualNode?:array{virtualNodeName:string}, virtualRouter?:array{virtualRouterName:string}}}, status:array{status:mixed}, virtualServiceName:string}}>
     */
    public function updateVirtualServiceAsync(array $args): \GuzzleHttp\Promise\Promise { }
}
