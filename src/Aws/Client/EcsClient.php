<?php
namespace AWS\Ecs;

class EcsClient
{
    /**
     * @param array{name:string, autoScalingGroupProvider:array{autoScalingGroupArn:string, managedScaling?:array{status?:"ENABLED"|"DISABLED", targetCapacity?:int, minimumScalingStepSize?:int, maximumScalingStepSize?:int, instanceWarmupPeriod?:int}, managedTerminationProtection?:"ENABLED"|"DISABLED", managedDraining?:"ENABLED"|"DISABLED"}, tags?:array<array{key?:string, value?:string}>} $args
     * @return \AWS\Result<array{capacityProvider?:array{capacityProviderArn?:string, name?:string, status?:"ACTIVE"|"INACTIVE", autoScalingGroupProvider?:array{autoScalingGroupArn:string, managedScaling?:array{status?:"ENABLED"|"DISABLED", targetCapacity?:int, minimumScalingStepSize?:int, maximumScalingStepSize?:int, instanceWarmupPeriod?:int}, managedTerminationProtection?:"ENABLED"|"DISABLED", managedDraining?:"ENABLED"|"DISABLED"}, updateStatus?:"DELETE_IN_PROGRESS"|"DELETE_COMPLETE"|"DELETE_FAILED"|"UPDATE_IN_PROGRESS"|"UPDATE_COMPLETE"|"UPDATE_FAILED", updateStatusReason?:string, tags?:array<array{key?:string, value?:string}>}}>
     */
    public function createCapacityProvider(array $args): \AWS\Result { }

    /**
     * @param array{name:string, autoScalingGroupProvider:array{autoScalingGroupArn:string, managedScaling?:array{status?:"ENABLED"|"DISABLED", targetCapacity?:int, minimumScalingStepSize?:int, maximumScalingStepSize?:int, instanceWarmupPeriod?:int}, managedTerminationProtection?:"ENABLED"|"DISABLED", managedDraining?:"ENABLED"|"DISABLED"}, tags?:array<array{key?:string, value?:string}>} $args
     * @return \GuzzleHttp\Promise\Promise<array{capacityProvider?:array{capacityProviderArn?:string, name?:string, status?:"ACTIVE"|"INACTIVE", autoScalingGroupProvider?:array{autoScalingGroupArn:string, managedScaling?:array{status?:"ENABLED"|"DISABLED", targetCapacity?:int, minimumScalingStepSize?:int, maximumScalingStepSize?:int, instanceWarmupPeriod?:int}, managedTerminationProtection?:"ENABLED"|"DISABLED", managedDraining?:"ENABLED"|"DISABLED"}, updateStatus?:"DELETE_IN_PROGRESS"|"DELETE_COMPLETE"|"DELETE_FAILED"|"UPDATE_IN_PROGRESS"|"UPDATE_COMPLETE"|"UPDATE_FAILED", updateStatusReason?:string, tags?:array<array{key?:string, value?:string}>}}>
     */
    public function createCapacityProviderAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{clusterName?:string, tags?:array<array{key?:string, value?:string}>, settings?:array<array{name?:"containerInsights", value?:string}>, configuration?:array{executeCommandConfiguration?:array{kmsKeyId?:string, logging?:"NONE"|"DEFAULT"|"OVERRIDE", logConfiguration?:array{cloudWatchLogGroupName?:string, cloudWatchEncryptionEnabled?:bool, s3BucketName?:string, s3EncryptionEnabled?:bool, s3KeyPrefix?:string}}, managedStorageConfiguration?:array{kmsKeyId?:string, fargateEphemeralStorageKmsKeyId?:string}}, capacityProviders?:array<string>, defaultCapacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, serviceConnectDefaults?:array{namespace:string}} $args
     * @return \AWS\Result<array{cluster?:array{clusterArn?:string, clusterName?:string, configuration?:array{executeCommandConfiguration?:array{kmsKeyId?:string, logging?:"NONE"|"DEFAULT"|"OVERRIDE", logConfiguration?:array{cloudWatchLogGroupName?:string, cloudWatchEncryptionEnabled?:bool, s3BucketName?:string, s3EncryptionEnabled?:bool, s3KeyPrefix?:string}}, managedStorageConfiguration?:array{kmsKeyId?:string, fargateEphemeralStorageKmsKeyId?:string}}, status?:string, registeredContainerInstancesCount?:int, runningTasksCount?:int, pendingTasksCount?:int, activeServicesCount?:int, statistics?:array<array{name?:string, value?:string}>, tags?:array<array{key?:string, value?:string}>, settings?:array<array{name?:"containerInsights", value?:string}>, capacityProviders?:array<string>, defaultCapacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, attachments?:array<array{id?:string, type?:string, status?:string, details?:array<array{name?:string, value?:string}>}>, attachmentsStatus?:string, serviceConnectDefaults?:array{namespace?:string}}}>
     */
    public function createCluster(array $args = []): \AWS\Result { }

    /**
     * @param array{clusterName?:string, tags?:array<array{key?:string, value?:string}>, settings?:array<array{name?:"containerInsights", value?:string}>, configuration?:array{executeCommandConfiguration?:array{kmsKeyId?:string, logging?:"NONE"|"DEFAULT"|"OVERRIDE", logConfiguration?:array{cloudWatchLogGroupName?:string, cloudWatchEncryptionEnabled?:bool, s3BucketName?:string, s3EncryptionEnabled?:bool, s3KeyPrefix?:string}}, managedStorageConfiguration?:array{kmsKeyId?:string, fargateEphemeralStorageKmsKeyId?:string}}, capacityProviders?:array<string>, defaultCapacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, serviceConnectDefaults?:array{namespace:string}} $args
     * @return \GuzzleHttp\Promise\Promise<array{cluster?:array{clusterArn?:string, clusterName?:string, configuration?:array{executeCommandConfiguration?:array{kmsKeyId?:string, logging?:"NONE"|"DEFAULT"|"OVERRIDE", logConfiguration?:array{cloudWatchLogGroupName?:string, cloudWatchEncryptionEnabled?:bool, s3BucketName?:string, s3EncryptionEnabled?:bool, s3KeyPrefix?:string}}, managedStorageConfiguration?:array{kmsKeyId?:string, fargateEphemeralStorageKmsKeyId?:string}}, status?:string, registeredContainerInstancesCount?:int, runningTasksCount?:int, pendingTasksCount?:int, activeServicesCount?:int, statistics?:array<array{name?:string, value?:string}>, tags?:array<array{key?:string, value?:string}>, settings?:array<array{name?:"containerInsights", value?:string}>, capacityProviders?:array<string>, defaultCapacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, attachments?:array<array{id?:string, type?:string, status?:string, details?:array<array{name?:string, value?:string}>}>, attachmentsStatus?:string, serviceConnectDefaults?:array{namespace?:string}}}>
     */
    public function createClusterAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{cluster?:string, serviceName:string, taskDefinition?:string, availabilityZoneRebalancing?:"ENABLED"|"DISABLED", loadBalancers?:array<array{targetGroupArn?:string, loadBalancerName?:string, containerName?:string, containerPort?:int}>, serviceRegistries?:array<array{registryArn?:string, port?:int, containerName?:string, containerPort?:int}>, desiredCount?:int, clientToken?:string, launchType?:"EC2"|"FARGATE"|"EXTERNAL", capacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, platformVersion?:string, role?:string, deploymentConfiguration?:array{deploymentCircuitBreaker?:array{enable:bool, rollback:bool}, maximumPercent?:int, minimumHealthyPercent?:int, alarms?:array{alarmNames:array<string>, rollback:bool, enable:bool}}, placementConstraints?:array<array{type?:"distinctInstance"|"memberOf", expression?:string}>, placementStrategy?:array<array{type?:"random"|"spread"|"binpack", field?:string}>, networkConfiguration?:array{awsvpcConfiguration?:array{subnets:array<string>, securityGroups?:array<string>, assignPublicIp?:"ENABLED"|"DISABLED"}}, healthCheckGracePeriodSeconds?:int, schedulingStrategy?:"REPLICA"|"DAEMON", deploymentController?:array{type:"ECS"|"CODE_DEPLOY"|"EXTERNAL"}, tags?:array<array{key?:string, value?:string}>, enableECSManagedTags?:bool, propagateTags?:"TASK_DEFINITION"|"SERVICE"|"NONE", enableExecuteCommand?:bool, serviceConnectConfiguration?:array{enabled:bool, namespace?:string, services?:array<array{portName:string, discoveryName?:string, clientAliases?:array<array{port:int, dnsName?:string}>, ingressPortOverride?:int, timeout?:array{idleTimeoutSeconds?:int, perRequestTimeoutSeconds?:int}, tls?:array{issuerCertificateAuthority:array{awsPcaAuthorityArn?:string}, kmsKey?:string, roleArn?:string}}>, logConfiguration?:array{logDriver:"json-file"|"syslog"|"journald"|"gelf"|"fluentd"|"awslogs"|"splunk"|"awsfirelens", options?:array<string, string>, secretOptions?:array<array{name:string, valueFrom:string}>}}, volumeConfigurations?:array<array{name:string, managedEBSVolume?:array{encrypted?:bool, kmsKeyId?:string, volumeType?:string, sizeInGiB?:int, snapshotId?:string, iops?:int, throughput?:int, tagSpecifications?:array<array{resourceType:"volume", tags?:array<array{key?:string, value?:string}>, propagateTags?:"TASK_DEFINITION"|"SERVICE"|"NONE"}>, roleArn:string, filesystemType?:"ext3"|"ext4"|"xfs"|"ntfs"}}>, vpcLatticeConfigurations?:array<array{roleArn:string, targetGroupArn:string, portName:string}>} $args
     * @return \AWS\Result<array{service?:array{serviceArn?:string, serviceName?:string, clusterArn?:string, loadBalancers?:array<array{targetGroupArn?:string, loadBalancerName?:string, containerName?:string, containerPort?:int}>, serviceRegistries?:array<array{registryArn?:string, port?:int, containerName?:string, containerPort?:int}>, status?:string, desiredCount?:int, runningCount?:int, pendingCount?:int, launchType?:"EC2"|"FARGATE"|"EXTERNAL", capacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, platformVersion?:string, platformFamily?:string, taskDefinition?:string, deploymentConfiguration?:array{deploymentCircuitBreaker?:array{enable:bool, rollback:bool}, maximumPercent?:int, minimumHealthyPercent?:int, alarms?:array{alarmNames:array<string>, rollback:bool, enable:bool}}, taskSets?:array<array{id?:string, taskSetArn?:string, serviceArn?:string, clusterArn?:string, startedBy?:string, externalId?:string, status?:string, taskDefinition?:string, computedDesiredCount?:int, pendingCount?:int, runningCount?:int, createdAt?:int|string|\DateTimeInterface, updatedAt?:int|string|\DateTimeInterface, launchType?:"EC2"|"FARGATE"|"EXTERNAL", capacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, platformVersion?:string, platformFamily?:string, networkConfiguration?:array{awsvpcConfiguration?:array{subnets:array<string>, securityGroups?:array<string>, assignPublicIp?:"ENABLED"|"DISABLED"}}, loadBalancers?:array<array{targetGroupArn?:string, loadBalancerName?:string, containerName?:string, containerPort?:int}>, serviceRegistries?:array<array{registryArn?:string, port?:int, containerName?:string, containerPort?:int}>, scale?:array{value?:float, unit?:"PERCENT"}, stabilityStatus?:"STEADY_STATE"|"STABILIZING", stabilityStatusAt?:int|string|\DateTimeInterface, tags?:array<array{key?:string, value?:string}>, fargateEphemeralStorage?:array{kmsKeyId?:string}}>, deployments?:array<array{id?:string, status?:string, taskDefinition?:string, desiredCount?:int, pendingCount?:int, runningCount?:int, failedTasks?:int, createdAt?:int|string|\DateTimeInterface, updatedAt?:int|string|\DateTimeInterface, capacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, launchType?:"EC2"|"FARGATE"|"EXTERNAL", platformVersion?:string, platformFamily?:string, networkConfiguration?:array{awsvpcConfiguration?:array{subnets:array<string>, securityGroups?:array<string>, assignPublicIp?:"ENABLED"|"DISABLED"}}, rolloutState?:"COMPLETED"|"FAILED"|"IN_PROGRESS", rolloutStateReason?:string, serviceConnectConfiguration?:array{enabled:bool, namespace?:string, services?:array<array{portName:string, discoveryName?:string, clientAliases?:array<array{port:int, dnsName?:string}>, ingressPortOverride?:int, timeout?:array{idleTimeoutSeconds?:int, perRequestTimeoutSeconds?:int}, tls?:array{issuerCertificateAuthority:array{awsPcaAuthorityArn?:string}, kmsKey?:string, roleArn?:string}}>, logConfiguration?:array{logDriver:"json-file"|"syslog"|"journald"|"gelf"|"fluentd"|"awslogs"|"splunk"|"awsfirelens", options?:array<string, string>, secretOptions?:array<array{name:string, valueFrom:string}>}}, serviceConnectResources?:array<array{discoveryName?:string, discoveryArn?:string}>, volumeConfigurations?:array<array{name:string, managedEBSVolume?:array{encrypted?:bool, kmsKeyId?:string, volumeType?:string, sizeInGiB?:int, snapshotId?:string, iops?:int, throughput?:int, tagSpecifications?:array<array{resourceType:"volume", tags?:array<array{key?:string, value?:string}>, propagateTags?:"TASK_DEFINITION"|"SERVICE"|"NONE"}>, roleArn:string, filesystemType?:"ext3"|"ext4"|"xfs"|"ntfs"}}>, fargateEphemeralStorage?:array{kmsKeyId?:string}, vpcLatticeConfigurations?:array<array{roleArn:string, targetGroupArn:string, portName:string}>}>, roleArn?:string, events?:array<array{id?:string, createdAt?:int|string|\DateTimeInterface, message?:string}>, createdAt?:int|string|\DateTimeInterface, placementConstraints?:array<array{type?:"distinctInstance"|"memberOf", expression?:string}>, placementStrategy?:array<array{type?:"random"|"spread"|"binpack", field?:string}>, networkConfiguration?:array{awsvpcConfiguration?:array{subnets:array<string>, securityGroups?:array<string>, assignPublicIp?:"ENABLED"|"DISABLED"}}, healthCheckGracePeriodSeconds?:int, schedulingStrategy?:"REPLICA"|"DAEMON", deploymentController?:array{type:"ECS"|"CODE_DEPLOY"|"EXTERNAL"}, tags?:array<array{key?:string, value?:string}>, createdBy?:string, enableECSManagedTags?:bool, propagateTags?:"TASK_DEFINITION"|"SERVICE"|"NONE", enableExecuteCommand?:bool, availabilityZoneRebalancing?:"ENABLED"|"DISABLED"}}>
     */
    public function createService(array $args): \AWS\Result { }

    /**
     * @param array{cluster?:string, serviceName:string, taskDefinition?:string, availabilityZoneRebalancing?:"ENABLED"|"DISABLED", loadBalancers?:array<array{targetGroupArn?:string, loadBalancerName?:string, containerName?:string, containerPort?:int}>, serviceRegistries?:array<array{registryArn?:string, port?:int, containerName?:string, containerPort?:int}>, desiredCount?:int, clientToken?:string, launchType?:"EC2"|"FARGATE"|"EXTERNAL", capacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, platformVersion?:string, role?:string, deploymentConfiguration?:array{deploymentCircuitBreaker?:array{enable:bool, rollback:bool}, maximumPercent?:int, minimumHealthyPercent?:int, alarms?:array{alarmNames:array<string>, rollback:bool, enable:bool}}, placementConstraints?:array<array{type?:"distinctInstance"|"memberOf", expression?:string}>, placementStrategy?:array<array{type?:"random"|"spread"|"binpack", field?:string}>, networkConfiguration?:array{awsvpcConfiguration?:array{subnets:array<string>, securityGroups?:array<string>, assignPublicIp?:"ENABLED"|"DISABLED"}}, healthCheckGracePeriodSeconds?:int, schedulingStrategy?:"REPLICA"|"DAEMON", deploymentController?:array{type:"ECS"|"CODE_DEPLOY"|"EXTERNAL"}, tags?:array<array{key?:string, value?:string}>, enableECSManagedTags?:bool, propagateTags?:"TASK_DEFINITION"|"SERVICE"|"NONE", enableExecuteCommand?:bool, serviceConnectConfiguration?:array{enabled:bool, namespace?:string, services?:array<array{portName:string, discoveryName?:string, clientAliases?:array<array{port:int, dnsName?:string}>, ingressPortOverride?:int, timeout?:array{idleTimeoutSeconds?:int, perRequestTimeoutSeconds?:int}, tls?:array{issuerCertificateAuthority:array{awsPcaAuthorityArn?:string}, kmsKey?:string, roleArn?:string}}>, logConfiguration?:array{logDriver:"json-file"|"syslog"|"journald"|"gelf"|"fluentd"|"awslogs"|"splunk"|"awsfirelens", options?:array<string, string>, secretOptions?:array<array{name:string, valueFrom:string}>}}, volumeConfigurations?:array<array{name:string, managedEBSVolume?:array{encrypted?:bool, kmsKeyId?:string, volumeType?:string, sizeInGiB?:int, snapshotId?:string, iops?:int, throughput?:int, tagSpecifications?:array<array{resourceType:"volume", tags?:array<array{key?:string, value?:string}>, propagateTags?:"TASK_DEFINITION"|"SERVICE"|"NONE"}>, roleArn:string, filesystemType?:"ext3"|"ext4"|"xfs"|"ntfs"}}>, vpcLatticeConfigurations?:array<array{roleArn:string, targetGroupArn:string, portName:string}>} $args
     * @return \GuzzleHttp\Promise\Promise<array{service?:array{serviceArn?:string, serviceName?:string, clusterArn?:string, loadBalancers?:array<array{targetGroupArn?:string, loadBalancerName?:string, containerName?:string, containerPort?:int}>, serviceRegistries?:array<array{registryArn?:string, port?:int, containerName?:string, containerPort?:int}>, status?:string, desiredCount?:int, runningCount?:int, pendingCount?:int, launchType?:"EC2"|"FARGATE"|"EXTERNAL", capacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, platformVersion?:string, platformFamily?:string, taskDefinition?:string, deploymentConfiguration?:array{deploymentCircuitBreaker?:array{enable:bool, rollback:bool}, maximumPercent?:int, minimumHealthyPercent?:int, alarms?:array{alarmNames:array<string>, rollback:bool, enable:bool}}, taskSets?:array<array{id?:string, taskSetArn?:string, serviceArn?:string, clusterArn?:string, startedBy?:string, externalId?:string, status?:string, taskDefinition?:string, computedDesiredCount?:int, pendingCount?:int, runningCount?:int, createdAt?:int|string|\DateTimeInterface, updatedAt?:int|string|\DateTimeInterface, launchType?:"EC2"|"FARGATE"|"EXTERNAL", capacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, platformVersion?:string, platformFamily?:string, networkConfiguration?:array{awsvpcConfiguration?:array{subnets:array<string>, securityGroups?:array<string>, assignPublicIp?:"ENABLED"|"DISABLED"}}, loadBalancers?:array<array{targetGroupArn?:string, loadBalancerName?:string, containerName?:string, containerPort?:int}>, serviceRegistries?:array<array{registryArn?:string, port?:int, containerName?:string, containerPort?:int}>, scale?:array{value?:float, unit?:"PERCENT"}, stabilityStatus?:"STEADY_STATE"|"STABILIZING", stabilityStatusAt?:int|string|\DateTimeInterface, tags?:array<array{key?:string, value?:string}>, fargateEphemeralStorage?:array{kmsKeyId?:string}}>, deployments?:array<array{id?:string, status?:string, taskDefinition?:string, desiredCount?:int, pendingCount?:int, runningCount?:int, failedTasks?:int, createdAt?:int|string|\DateTimeInterface, updatedAt?:int|string|\DateTimeInterface, capacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, launchType?:"EC2"|"FARGATE"|"EXTERNAL", platformVersion?:string, platformFamily?:string, networkConfiguration?:array{awsvpcConfiguration?:array{subnets:array<string>, securityGroups?:array<string>, assignPublicIp?:"ENABLED"|"DISABLED"}}, rolloutState?:"COMPLETED"|"FAILED"|"IN_PROGRESS", rolloutStateReason?:string, serviceConnectConfiguration?:array{enabled:bool, namespace?:string, services?:array<array{portName:string, discoveryName?:string, clientAliases?:array<array{port:int, dnsName?:string}>, ingressPortOverride?:int, timeout?:array{idleTimeoutSeconds?:int, perRequestTimeoutSeconds?:int}, tls?:array{issuerCertificateAuthority:array{awsPcaAuthorityArn?:string}, kmsKey?:string, roleArn?:string}}>, logConfiguration?:array{logDriver:"json-file"|"syslog"|"journald"|"gelf"|"fluentd"|"awslogs"|"splunk"|"awsfirelens", options?:array<string, string>, secretOptions?:array<array{name:string, valueFrom:string}>}}, serviceConnectResources?:array<array{discoveryName?:string, discoveryArn?:string}>, volumeConfigurations?:array<array{name:string, managedEBSVolume?:array{encrypted?:bool, kmsKeyId?:string, volumeType?:string, sizeInGiB?:int, snapshotId?:string, iops?:int, throughput?:int, tagSpecifications?:array<array{resourceType:"volume", tags?:array<array{key?:string, value?:string}>, propagateTags?:"TASK_DEFINITION"|"SERVICE"|"NONE"}>, roleArn:string, filesystemType?:"ext3"|"ext4"|"xfs"|"ntfs"}}>, fargateEphemeralStorage?:array{kmsKeyId?:string}, vpcLatticeConfigurations?:array<array{roleArn:string, targetGroupArn:string, portName:string}>}>, roleArn?:string, events?:array<array{id?:string, createdAt?:int|string|\DateTimeInterface, message?:string}>, createdAt?:int|string|\DateTimeInterface, placementConstraints?:array<array{type?:"distinctInstance"|"memberOf", expression?:string}>, placementStrategy?:array<array{type?:"random"|"spread"|"binpack", field?:string}>, networkConfiguration?:array{awsvpcConfiguration?:array{subnets:array<string>, securityGroups?:array<string>, assignPublicIp?:"ENABLED"|"DISABLED"}}, healthCheckGracePeriodSeconds?:int, schedulingStrategy?:"REPLICA"|"DAEMON", deploymentController?:array{type:"ECS"|"CODE_DEPLOY"|"EXTERNAL"}, tags?:array<array{key?:string, value?:string}>, createdBy?:string, enableECSManagedTags?:bool, propagateTags?:"TASK_DEFINITION"|"SERVICE"|"NONE", enableExecuteCommand?:bool, availabilityZoneRebalancing?:"ENABLED"|"DISABLED"}}>
     */
    public function createServiceAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{service:string, cluster:string, externalId?:string, taskDefinition:string, networkConfiguration?:array{awsvpcConfiguration?:array{subnets:array<string>, securityGroups?:array<string>, assignPublicIp?:"ENABLED"|"DISABLED"}}, loadBalancers?:array<array{targetGroupArn?:string, loadBalancerName?:string, containerName?:string, containerPort?:int}>, serviceRegistries?:array<array{registryArn?:string, port?:int, containerName?:string, containerPort?:int}>, launchType?:"EC2"|"FARGATE"|"EXTERNAL", capacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, platformVersion?:string, scale?:array{value?:float, unit?:"PERCENT"}, clientToken?:string, tags?:array<array{key?:string, value?:string}>} $args
     * @return \AWS\Result<array{taskSet?:array{id?:string, taskSetArn?:string, serviceArn?:string, clusterArn?:string, startedBy?:string, externalId?:string, status?:string, taskDefinition?:string, computedDesiredCount?:int, pendingCount?:int, runningCount?:int, createdAt?:int|string|\DateTimeInterface, updatedAt?:int|string|\DateTimeInterface, launchType?:"EC2"|"FARGATE"|"EXTERNAL", capacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, platformVersion?:string, platformFamily?:string, networkConfiguration?:array{awsvpcConfiguration?:array{subnets:array<string>, securityGroups?:array<string>, assignPublicIp?:"ENABLED"|"DISABLED"}}, loadBalancers?:array<array{targetGroupArn?:string, loadBalancerName?:string, containerName?:string, containerPort?:int}>, serviceRegistries?:array<array{registryArn?:string, port?:int, containerName?:string, containerPort?:int}>, scale?:array{value?:float, unit?:"PERCENT"}, stabilityStatus?:"STEADY_STATE"|"STABILIZING", stabilityStatusAt?:int|string|\DateTimeInterface, tags?:array<array{key?:string, value?:string}>, fargateEphemeralStorage?:array{kmsKeyId?:string}}}>
     */
    public function createTaskSet(array $args): \AWS\Result { }

    /**
     * @param array{service:string, cluster:string, externalId?:string, taskDefinition:string, networkConfiguration?:array{awsvpcConfiguration?:array{subnets:array<string>, securityGroups?:array<string>, assignPublicIp?:"ENABLED"|"DISABLED"}}, loadBalancers?:array<array{targetGroupArn?:string, loadBalancerName?:string, containerName?:string, containerPort?:int}>, serviceRegistries?:array<array{registryArn?:string, port?:int, containerName?:string, containerPort?:int}>, launchType?:"EC2"|"FARGATE"|"EXTERNAL", capacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, platformVersion?:string, scale?:array{value?:float, unit?:"PERCENT"}, clientToken?:string, tags?:array<array{key?:string, value?:string}>} $args
     * @return \GuzzleHttp\Promise\Promise<array{taskSet?:array{id?:string, taskSetArn?:string, serviceArn?:string, clusterArn?:string, startedBy?:string, externalId?:string, status?:string, taskDefinition?:string, computedDesiredCount?:int, pendingCount?:int, runningCount?:int, createdAt?:int|string|\DateTimeInterface, updatedAt?:int|string|\DateTimeInterface, launchType?:"EC2"|"FARGATE"|"EXTERNAL", capacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, platformVersion?:string, platformFamily?:string, networkConfiguration?:array{awsvpcConfiguration?:array{subnets:array<string>, securityGroups?:array<string>, assignPublicIp?:"ENABLED"|"DISABLED"}}, loadBalancers?:array<array{targetGroupArn?:string, loadBalancerName?:string, containerName?:string, containerPort?:int}>, serviceRegistries?:array<array{registryArn?:string, port?:int, containerName?:string, containerPort?:int}>, scale?:array{value?:float, unit?:"PERCENT"}, stabilityStatus?:"STEADY_STATE"|"STABILIZING", stabilityStatusAt?:int|string|\DateTimeInterface, tags?:array<array{key?:string, value?:string}>, fargateEphemeralStorage?:array{kmsKeyId?:string}}}>
     */
    public function createTaskSetAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{name:"serviceLongArnFormat"|"taskLongArnFormat"|"containerInstanceLongArnFormat"|"awsvpcTrunking"|"containerInsights"|"fargateFIPSMode"|"tagResourceAuthorization"|"fargateTaskRetirementWaitPeriod"|"guardDutyActivate", principalArn?:string} $args
     * @return \AWS\Result<array{setting?:array{name?:"serviceLongArnFormat"|"taskLongArnFormat"|"containerInstanceLongArnFormat"|"awsvpcTrunking"|"containerInsights"|"fargateFIPSMode"|"tagResourceAuthorization"|"fargateTaskRetirementWaitPeriod"|"guardDutyActivate", value?:string, principalArn?:string, type?:"user"|"aws_managed"}}>
     */
    public function deleteAccountSetting(array $args): \AWS\Result { }

    /**
     * @param array{name:"serviceLongArnFormat"|"taskLongArnFormat"|"containerInstanceLongArnFormat"|"awsvpcTrunking"|"containerInsights"|"fargateFIPSMode"|"tagResourceAuthorization"|"fargateTaskRetirementWaitPeriod"|"guardDutyActivate", principalArn?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{setting?:array{name?:"serviceLongArnFormat"|"taskLongArnFormat"|"containerInstanceLongArnFormat"|"awsvpcTrunking"|"containerInsights"|"fargateFIPSMode"|"tagResourceAuthorization"|"fargateTaskRetirementWaitPeriod"|"guardDutyActivate", value?:string, principalArn?:string, type?:"user"|"aws_managed"}}>
     */
    public function deleteAccountSettingAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{cluster?:string, attributes:array<array{name:string, value?:string, targetType?:"container-instance", targetId?:string}>} $args
     * @return \AWS\Result<array{attributes?:array<array{name:string, value?:string, targetType?:"container-instance", targetId?:string}>}>
     */
    public function deleteAttributes(array $args): \AWS\Result { }

    /**
     * @param array{cluster?:string, attributes:array<array{name:string, value?:string, targetType?:"container-instance", targetId?:string}>} $args
     * @return \GuzzleHttp\Promise\Promise<array{attributes?:array<array{name:string, value?:string, targetType?:"container-instance", targetId?:string}>}>
     */
    public function deleteAttributesAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{capacityProvider:string} $args
     * @return \AWS\Result<array{capacityProvider?:array{capacityProviderArn?:string, name?:string, status?:"ACTIVE"|"INACTIVE", autoScalingGroupProvider?:array{autoScalingGroupArn:string, managedScaling?:array{status?:"ENABLED"|"DISABLED", targetCapacity?:int, minimumScalingStepSize?:int, maximumScalingStepSize?:int, instanceWarmupPeriod?:int}, managedTerminationProtection?:"ENABLED"|"DISABLED", managedDraining?:"ENABLED"|"DISABLED"}, updateStatus?:"DELETE_IN_PROGRESS"|"DELETE_COMPLETE"|"DELETE_FAILED"|"UPDATE_IN_PROGRESS"|"UPDATE_COMPLETE"|"UPDATE_FAILED", updateStatusReason?:string, tags?:array<array{key?:string, value?:string}>}}>
     */
    public function deleteCapacityProvider(array $args): \AWS\Result { }

    /**
     * @param array{capacityProvider:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{capacityProvider?:array{capacityProviderArn?:string, name?:string, status?:"ACTIVE"|"INACTIVE", autoScalingGroupProvider?:array{autoScalingGroupArn:string, managedScaling?:array{status?:"ENABLED"|"DISABLED", targetCapacity?:int, minimumScalingStepSize?:int, maximumScalingStepSize?:int, instanceWarmupPeriod?:int}, managedTerminationProtection?:"ENABLED"|"DISABLED", managedDraining?:"ENABLED"|"DISABLED"}, updateStatus?:"DELETE_IN_PROGRESS"|"DELETE_COMPLETE"|"DELETE_FAILED"|"UPDATE_IN_PROGRESS"|"UPDATE_COMPLETE"|"UPDATE_FAILED", updateStatusReason?:string, tags?:array<array{key?:string, value?:string}>}}>
     */
    public function deleteCapacityProviderAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{cluster:string} $args
     * @return \AWS\Result<array{cluster?:array{clusterArn?:string, clusterName?:string, configuration?:array{executeCommandConfiguration?:array{kmsKeyId?:string, logging?:"NONE"|"DEFAULT"|"OVERRIDE", logConfiguration?:array{cloudWatchLogGroupName?:string, cloudWatchEncryptionEnabled?:bool, s3BucketName?:string, s3EncryptionEnabled?:bool, s3KeyPrefix?:string}}, managedStorageConfiguration?:array{kmsKeyId?:string, fargateEphemeralStorageKmsKeyId?:string}}, status?:string, registeredContainerInstancesCount?:int, runningTasksCount?:int, pendingTasksCount?:int, activeServicesCount?:int, statistics?:array<array{name?:string, value?:string}>, tags?:array<array{key?:string, value?:string}>, settings?:array<array{name?:"containerInsights", value?:string}>, capacityProviders?:array<string>, defaultCapacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, attachments?:array<array{id?:string, type?:string, status?:string, details?:array<array{name?:string, value?:string}>}>, attachmentsStatus?:string, serviceConnectDefaults?:array{namespace?:string}}}>
     */
    public function deleteCluster(array $args): \AWS\Result { }

    /**
     * @param array{cluster:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{cluster?:array{clusterArn?:string, clusterName?:string, configuration?:array{executeCommandConfiguration?:array{kmsKeyId?:string, logging?:"NONE"|"DEFAULT"|"OVERRIDE", logConfiguration?:array{cloudWatchLogGroupName?:string, cloudWatchEncryptionEnabled?:bool, s3BucketName?:string, s3EncryptionEnabled?:bool, s3KeyPrefix?:string}}, managedStorageConfiguration?:array{kmsKeyId?:string, fargateEphemeralStorageKmsKeyId?:string}}, status?:string, registeredContainerInstancesCount?:int, runningTasksCount?:int, pendingTasksCount?:int, activeServicesCount?:int, statistics?:array<array{name?:string, value?:string}>, tags?:array<array{key?:string, value?:string}>, settings?:array<array{name?:"containerInsights", value?:string}>, capacityProviders?:array<string>, defaultCapacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, attachments?:array<array{id?:string, type?:string, status?:string, details?:array<array{name?:string, value?:string}>}>, attachmentsStatus?:string, serviceConnectDefaults?:array{namespace?:string}}}>
     */
    public function deleteClusterAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{cluster?:string, service:string, force?:bool} $args
     * @return \AWS\Result<array{service?:array{serviceArn?:string, serviceName?:string, clusterArn?:string, loadBalancers?:array<array{targetGroupArn?:string, loadBalancerName?:string, containerName?:string, containerPort?:int}>, serviceRegistries?:array<array{registryArn?:string, port?:int, containerName?:string, containerPort?:int}>, status?:string, desiredCount?:int, runningCount?:int, pendingCount?:int, launchType?:"EC2"|"FARGATE"|"EXTERNAL", capacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, platformVersion?:string, platformFamily?:string, taskDefinition?:string, deploymentConfiguration?:array{deploymentCircuitBreaker?:array{enable:bool, rollback:bool}, maximumPercent?:int, minimumHealthyPercent?:int, alarms?:array{alarmNames:array<string>, rollback:bool, enable:bool}}, taskSets?:array<array{id?:string, taskSetArn?:string, serviceArn?:string, clusterArn?:string, startedBy?:string, externalId?:string, status?:string, taskDefinition?:string, computedDesiredCount?:int, pendingCount?:int, runningCount?:int, createdAt?:int|string|\DateTimeInterface, updatedAt?:int|string|\DateTimeInterface, launchType?:"EC2"|"FARGATE"|"EXTERNAL", capacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, platformVersion?:string, platformFamily?:string, networkConfiguration?:array{awsvpcConfiguration?:array{subnets:array<string>, securityGroups?:array<string>, assignPublicIp?:"ENABLED"|"DISABLED"}}, loadBalancers?:array<array{targetGroupArn?:string, loadBalancerName?:string, containerName?:string, containerPort?:int}>, serviceRegistries?:array<array{registryArn?:string, port?:int, containerName?:string, containerPort?:int}>, scale?:array{value?:float, unit?:"PERCENT"}, stabilityStatus?:"STEADY_STATE"|"STABILIZING", stabilityStatusAt?:int|string|\DateTimeInterface, tags?:array<array{key?:string, value?:string}>, fargateEphemeralStorage?:array{kmsKeyId?:string}}>, deployments?:array<array{id?:string, status?:string, taskDefinition?:string, desiredCount?:int, pendingCount?:int, runningCount?:int, failedTasks?:int, createdAt?:int|string|\DateTimeInterface, updatedAt?:int|string|\DateTimeInterface, capacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, launchType?:"EC2"|"FARGATE"|"EXTERNAL", platformVersion?:string, platformFamily?:string, networkConfiguration?:array{awsvpcConfiguration?:array{subnets:array<string>, securityGroups?:array<string>, assignPublicIp?:"ENABLED"|"DISABLED"}}, rolloutState?:"COMPLETED"|"FAILED"|"IN_PROGRESS", rolloutStateReason?:string, serviceConnectConfiguration?:array{enabled:bool, namespace?:string, services?:array<array{portName:string, discoveryName?:string, clientAliases?:array<array{port:int, dnsName?:string}>, ingressPortOverride?:int, timeout?:array{idleTimeoutSeconds?:int, perRequestTimeoutSeconds?:int}, tls?:array{issuerCertificateAuthority:array{awsPcaAuthorityArn?:string}, kmsKey?:string, roleArn?:string}}>, logConfiguration?:array{logDriver:"json-file"|"syslog"|"journald"|"gelf"|"fluentd"|"awslogs"|"splunk"|"awsfirelens", options?:array<string, string>, secretOptions?:array<array{name:string, valueFrom:string}>}}, serviceConnectResources?:array<array{discoveryName?:string, discoveryArn?:string}>, volumeConfigurations?:array<array{name:string, managedEBSVolume?:array{encrypted?:bool, kmsKeyId?:string, volumeType?:string, sizeInGiB?:int, snapshotId?:string, iops?:int, throughput?:int, tagSpecifications?:array<array{resourceType:"volume", tags?:array<array{key?:string, value?:string}>, propagateTags?:"TASK_DEFINITION"|"SERVICE"|"NONE"}>, roleArn:string, filesystemType?:"ext3"|"ext4"|"xfs"|"ntfs"}}>, fargateEphemeralStorage?:array{kmsKeyId?:string}, vpcLatticeConfigurations?:array<array{roleArn:string, targetGroupArn:string, portName:string}>}>, roleArn?:string, events?:array<array{id?:string, createdAt?:int|string|\DateTimeInterface, message?:string}>, createdAt?:int|string|\DateTimeInterface, placementConstraints?:array<array{type?:"distinctInstance"|"memberOf", expression?:string}>, placementStrategy?:array<array{type?:"random"|"spread"|"binpack", field?:string}>, networkConfiguration?:array{awsvpcConfiguration?:array{subnets:array<string>, securityGroups?:array<string>, assignPublicIp?:"ENABLED"|"DISABLED"}}, healthCheckGracePeriodSeconds?:int, schedulingStrategy?:"REPLICA"|"DAEMON", deploymentController?:array{type:"ECS"|"CODE_DEPLOY"|"EXTERNAL"}, tags?:array<array{key?:string, value?:string}>, createdBy?:string, enableECSManagedTags?:bool, propagateTags?:"TASK_DEFINITION"|"SERVICE"|"NONE", enableExecuteCommand?:bool, availabilityZoneRebalancing?:"ENABLED"|"DISABLED"}}>
     */
    public function deleteService(array $args): \AWS\Result { }

    /**
     * @param array{cluster?:string, service:string, force?:bool} $args
     * @return \GuzzleHttp\Promise\Promise<array{service?:array{serviceArn?:string, serviceName?:string, clusterArn?:string, loadBalancers?:array<array{targetGroupArn?:string, loadBalancerName?:string, containerName?:string, containerPort?:int}>, serviceRegistries?:array<array{registryArn?:string, port?:int, containerName?:string, containerPort?:int}>, status?:string, desiredCount?:int, runningCount?:int, pendingCount?:int, launchType?:"EC2"|"FARGATE"|"EXTERNAL", capacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, platformVersion?:string, platformFamily?:string, taskDefinition?:string, deploymentConfiguration?:array{deploymentCircuitBreaker?:array{enable:bool, rollback:bool}, maximumPercent?:int, minimumHealthyPercent?:int, alarms?:array{alarmNames:array<string>, rollback:bool, enable:bool}}, taskSets?:array<array{id?:string, taskSetArn?:string, serviceArn?:string, clusterArn?:string, startedBy?:string, externalId?:string, status?:string, taskDefinition?:string, computedDesiredCount?:int, pendingCount?:int, runningCount?:int, createdAt?:int|string|\DateTimeInterface, updatedAt?:int|string|\DateTimeInterface, launchType?:"EC2"|"FARGATE"|"EXTERNAL", capacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, platformVersion?:string, platformFamily?:string, networkConfiguration?:array{awsvpcConfiguration?:array{subnets:array<string>, securityGroups?:array<string>, assignPublicIp?:"ENABLED"|"DISABLED"}}, loadBalancers?:array<array{targetGroupArn?:string, loadBalancerName?:string, containerName?:string, containerPort?:int}>, serviceRegistries?:array<array{registryArn?:string, port?:int, containerName?:string, containerPort?:int}>, scale?:array{value?:float, unit?:"PERCENT"}, stabilityStatus?:"STEADY_STATE"|"STABILIZING", stabilityStatusAt?:int|string|\DateTimeInterface, tags?:array<array{key?:string, value?:string}>, fargateEphemeralStorage?:array{kmsKeyId?:string}}>, deployments?:array<array{id?:string, status?:string, taskDefinition?:string, desiredCount?:int, pendingCount?:int, runningCount?:int, failedTasks?:int, createdAt?:int|string|\DateTimeInterface, updatedAt?:int|string|\DateTimeInterface, capacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, launchType?:"EC2"|"FARGATE"|"EXTERNAL", platformVersion?:string, platformFamily?:string, networkConfiguration?:array{awsvpcConfiguration?:array{subnets:array<string>, securityGroups?:array<string>, assignPublicIp?:"ENABLED"|"DISABLED"}}, rolloutState?:"COMPLETED"|"FAILED"|"IN_PROGRESS", rolloutStateReason?:string, serviceConnectConfiguration?:array{enabled:bool, namespace?:string, services?:array<array{portName:string, discoveryName?:string, clientAliases?:array<array{port:int, dnsName?:string}>, ingressPortOverride?:int, timeout?:array{idleTimeoutSeconds?:int, perRequestTimeoutSeconds?:int}, tls?:array{issuerCertificateAuthority:array{awsPcaAuthorityArn?:string}, kmsKey?:string, roleArn?:string}}>, logConfiguration?:array{logDriver:"json-file"|"syslog"|"journald"|"gelf"|"fluentd"|"awslogs"|"splunk"|"awsfirelens", options?:array<string, string>, secretOptions?:array<array{name:string, valueFrom:string}>}}, serviceConnectResources?:array<array{discoveryName?:string, discoveryArn?:string}>, volumeConfigurations?:array<array{name:string, managedEBSVolume?:array{encrypted?:bool, kmsKeyId?:string, volumeType?:string, sizeInGiB?:int, snapshotId?:string, iops?:int, throughput?:int, tagSpecifications?:array<array{resourceType:"volume", tags?:array<array{key?:string, value?:string}>, propagateTags?:"TASK_DEFINITION"|"SERVICE"|"NONE"}>, roleArn:string, filesystemType?:"ext3"|"ext4"|"xfs"|"ntfs"}}>, fargateEphemeralStorage?:array{kmsKeyId?:string}, vpcLatticeConfigurations?:array<array{roleArn:string, targetGroupArn:string, portName:string}>}>, roleArn?:string, events?:array<array{id?:string, createdAt?:int|string|\DateTimeInterface, message?:string}>, createdAt?:int|string|\DateTimeInterface, placementConstraints?:array<array{type?:"distinctInstance"|"memberOf", expression?:string}>, placementStrategy?:array<array{type?:"random"|"spread"|"binpack", field?:string}>, networkConfiguration?:array{awsvpcConfiguration?:array{subnets:array<string>, securityGroups?:array<string>, assignPublicIp?:"ENABLED"|"DISABLED"}}, healthCheckGracePeriodSeconds?:int, schedulingStrategy?:"REPLICA"|"DAEMON", deploymentController?:array{type:"ECS"|"CODE_DEPLOY"|"EXTERNAL"}, tags?:array<array{key?:string, value?:string}>, createdBy?:string, enableECSManagedTags?:bool, propagateTags?:"TASK_DEFINITION"|"SERVICE"|"NONE", enableExecuteCommand?:bool, availabilityZoneRebalancing?:"ENABLED"|"DISABLED"}}>
     */
    public function deleteServiceAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{taskDefinitions:array<string>} $args
     * @return \AWS\Result<array{taskDefinitions?:array<array{taskDefinitionArn?:string, containerDefinitions?:array<array{name?:string, image?:string, repositoryCredentials?:array{credentialsParameter:string}, cpu?:int, memory?:int, memoryReservation?:int, links?:array<string>, portMappings?:array<array{containerPort?:int, hostPort?:int, protocol?:"tcp"|"udp", name?:string, appProtocol?:"http"|"http2"|"grpc", containerPortRange?:string}>, essential?:bool, restartPolicy?:array{enabled:bool, ignoredExitCodes?:array<int>, restartAttemptPeriod?:int}, entryPoint?:array<string>, command?:array<string>, environment?:array<array{name?:string, value?:string}>, environmentFiles?:array<array{value:string, type:"s3"}>, mountPoints?:array<array{sourceVolume?:string, containerPath?:string, readOnly?:bool}>, volumesFrom?:array<array{sourceContainer?:string, readOnly?:bool}>, linuxParameters?:array{capabilities?:array{add?:array<string>, drop?:array<string>}, devices?:array<array{hostPath:string, containerPath?:string, permissions?:array<"read"|"write"|"mknod">}>, initProcessEnabled?:bool, sharedMemorySize?:int, tmpfs?:array<array{containerPath:string, size:int, mountOptions?:array<string>}>, maxSwap?:int, swappiness?:int}, secrets?:array<array{name:string, valueFrom:string}>, dependsOn?:array<array{containerName:string, condition:"START"|"COMPLETE"|"SUCCESS"|"HEALTHY"}>, startTimeout?:int, stopTimeout?:int, versionConsistency?:"enabled"|"disabled", hostname?:string, user?:string, workingDirectory?:string, disableNetworking?:bool, privileged?:bool, readonlyRootFilesystem?:bool, dnsServers?:array<string>, dnsSearchDomains?:array<string>, extraHosts?:array<array{hostname:string, ipAddress:string}>, dockerSecurityOptions?:array<string>, interactive?:bool, pseudoTerminal?:bool, dockerLabels?:array<string, string>, ulimits?:array<array{name:"core"|"cpu"|"data"|"fsize"|"locks"|"memlock"|"msgqueue"|"nice"|"nofile"|"nproc"|"rss"|"rtprio"|"rttime"|"sigpending"|"stack", softLimit:int, hardLimit:int}>, logConfiguration?:array{logDriver:"json-file"|"syslog"|"journald"|"gelf"|"fluentd"|"awslogs"|"splunk"|"awsfirelens", options?:array<string, string>, secretOptions?:array<array{name:string, valueFrom:string}>}, healthCheck?:array{command:array<string>, interval?:int, timeout?:int, retries?:int, startPeriod?:int}, systemControls?:array<array{namespace?:string, value?:string}>, resourceRequirements?:array<array{value:string, type:"GPU"|"InferenceAccelerator"}>, firelensConfiguration?:array{type:"fluentd"|"fluentbit", options?:array<string, string>}, credentialSpecs?:array<string>}>, family?:string, taskRoleArn?:string, executionRoleArn?:string, networkMode?:"bridge"|"host"|"awsvpc"|"none", revision?:int, volumes?:array<array{name?:string, host?:array{sourcePath?:string}, dockerVolumeConfiguration?:array{scope?:"task"|"shared", autoprovision?:bool, driver?:string, driverOpts?:array<string, string>, labels?:array<string, string>}, efsVolumeConfiguration?:array{fileSystemId:string, rootDirectory?:string, transitEncryption?:"ENABLED"|"DISABLED", transitEncryptionPort?:int, authorizationConfig?:array{accessPointId?:string, iam?:"ENABLED"|"DISABLED"}}, fsxWindowsFileServerVolumeConfiguration?:array{fileSystemId:string, rootDirectory:string, authorizationConfig:array{credentialsParameter:string, domain:string}}, configuredAtLaunch?:bool}>, status?:"ACTIVE"|"INACTIVE"|"DELETE_IN_PROGRESS", requiresAttributes?:array<array{name:string, value?:string, targetType?:"container-instance", targetId?:string}>, placementConstraints?:array<array{type?:"memberOf", expression?:string}>, compatibilities?:array<"EC2"|"FARGATE"|"EXTERNAL">, runtimePlatform?:array{cpuArchitecture?:"X86_64"|"ARM64", operatingSystemFamily?:"WINDOWS_SERVER_2019_FULL"|"WINDOWS_SERVER_2019_CORE"|"WINDOWS_SERVER_2016_FULL"|"WINDOWS_SERVER_2004_CORE"|"WINDOWS_SERVER_2022_CORE"|"WINDOWS_SERVER_2022_FULL"|"WINDOWS_SERVER_20H2_CORE"|"LINUX"}, requiresCompatibilities?:array<"EC2"|"FARGATE"|"EXTERNAL">, cpu?:string, memory?:string, inferenceAccelerators?:array<array{deviceName:string, deviceType:string}>, pidMode?:"host"|"task", ipcMode?:"host"|"task"|"none", proxyConfiguration?:array{type?:"APPMESH", containerName:string, properties?:array<array{name?:string, value?:string}>}, registeredAt?:int|string|\DateTimeInterface, deregisteredAt?:int|string|\DateTimeInterface, registeredBy?:string, ephemeralStorage?:array{sizeInGiB:int}, enableFaultInjection?:bool}>, failures?:array<array{arn?:string, reason?:string, detail?:string}>}>
     */
    public function deleteTaskDefinitions(array $args): \AWS\Result { }

    /**
     * @param array{taskDefinitions:array<string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{taskDefinitions?:array<array{taskDefinitionArn?:string, containerDefinitions?:array<array{name?:string, image?:string, repositoryCredentials?:array{credentialsParameter:string}, cpu?:int, memory?:int, memoryReservation?:int, links?:array<string>, portMappings?:array<array{containerPort?:int, hostPort?:int, protocol?:"tcp"|"udp", name?:string, appProtocol?:"http"|"http2"|"grpc", containerPortRange?:string}>, essential?:bool, restartPolicy?:array{enabled:bool, ignoredExitCodes?:array<int>, restartAttemptPeriod?:int}, entryPoint?:array<string>, command?:array<string>, environment?:array<array{name?:string, value?:string}>, environmentFiles?:array<array{value:string, type:"s3"}>, mountPoints?:array<array{sourceVolume?:string, containerPath?:string, readOnly?:bool}>, volumesFrom?:array<array{sourceContainer?:string, readOnly?:bool}>, linuxParameters?:array{capabilities?:array{add?:array<string>, drop?:array<string>}, devices?:array<array{hostPath:string, containerPath?:string, permissions?:array<"read"|"write"|"mknod">}>, initProcessEnabled?:bool, sharedMemorySize?:int, tmpfs?:array<array{containerPath:string, size:int, mountOptions?:array<string>}>, maxSwap?:int, swappiness?:int}, secrets?:array<array{name:string, valueFrom:string}>, dependsOn?:array<array{containerName:string, condition:"START"|"COMPLETE"|"SUCCESS"|"HEALTHY"}>, startTimeout?:int, stopTimeout?:int, versionConsistency?:"enabled"|"disabled", hostname?:string, user?:string, workingDirectory?:string, disableNetworking?:bool, privileged?:bool, readonlyRootFilesystem?:bool, dnsServers?:array<string>, dnsSearchDomains?:array<string>, extraHosts?:array<array{hostname:string, ipAddress:string}>, dockerSecurityOptions?:array<string>, interactive?:bool, pseudoTerminal?:bool, dockerLabels?:array<string, string>, ulimits?:array<array{name:"core"|"cpu"|"data"|"fsize"|"locks"|"memlock"|"msgqueue"|"nice"|"nofile"|"nproc"|"rss"|"rtprio"|"rttime"|"sigpending"|"stack", softLimit:int, hardLimit:int}>, logConfiguration?:array{logDriver:"json-file"|"syslog"|"journald"|"gelf"|"fluentd"|"awslogs"|"splunk"|"awsfirelens", options?:array<string, string>, secretOptions?:array<array{name:string, valueFrom:string}>}, healthCheck?:array{command:array<string>, interval?:int, timeout?:int, retries?:int, startPeriod?:int}, systemControls?:array<array{namespace?:string, value?:string}>, resourceRequirements?:array<array{value:string, type:"GPU"|"InferenceAccelerator"}>, firelensConfiguration?:array{type:"fluentd"|"fluentbit", options?:array<string, string>}, credentialSpecs?:array<string>}>, family?:string, taskRoleArn?:string, executionRoleArn?:string, networkMode?:"bridge"|"host"|"awsvpc"|"none", revision?:int, volumes?:array<array{name?:string, host?:array{sourcePath?:string}, dockerVolumeConfiguration?:array{scope?:"task"|"shared", autoprovision?:bool, driver?:string, driverOpts?:array<string, string>, labels?:array<string, string>}, efsVolumeConfiguration?:array{fileSystemId:string, rootDirectory?:string, transitEncryption?:"ENABLED"|"DISABLED", transitEncryptionPort?:int, authorizationConfig?:array{accessPointId?:string, iam?:"ENABLED"|"DISABLED"}}, fsxWindowsFileServerVolumeConfiguration?:array{fileSystemId:string, rootDirectory:string, authorizationConfig:array{credentialsParameter:string, domain:string}}, configuredAtLaunch?:bool}>, status?:"ACTIVE"|"INACTIVE"|"DELETE_IN_PROGRESS", requiresAttributes?:array<array{name:string, value?:string, targetType?:"container-instance", targetId?:string}>, placementConstraints?:array<array{type?:"memberOf", expression?:string}>, compatibilities?:array<"EC2"|"FARGATE"|"EXTERNAL">, runtimePlatform?:array{cpuArchitecture?:"X86_64"|"ARM64", operatingSystemFamily?:"WINDOWS_SERVER_2019_FULL"|"WINDOWS_SERVER_2019_CORE"|"WINDOWS_SERVER_2016_FULL"|"WINDOWS_SERVER_2004_CORE"|"WINDOWS_SERVER_2022_CORE"|"WINDOWS_SERVER_2022_FULL"|"WINDOWS_SERVER_20H2_CORE"|"LINUX"}, requiresCompatibilities?:array<"EC2"|"FARGATE"|"EXTERNAL">, cpu?:string, memory?:string, inferenceAccelerators?:array<array{deviceName:string, deviceType:string}>, pidMode?:"host"|"task", ipcMode?:"host"|"task"|"none", proxyConfiguration?:array{type?:"APPMESH", containerName:string, properties?:array<array{name?:string, value?:string}>}, registeredAt?:int|string|\DateTimeInterface, deregisteredAt?:int|string|\DateTimeInterface, registeredBy?:string, ephemeralStorage?:array{sizeInGiB:int}, enableFaultInjection?:bool}>, failures?:array<array{arn?:string, reason?:string, detail?:string}>}>
     */
    public function deleteTaskDefinitionsAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{cluster:string, service:string, taskSet:string, force?:bool} $args
     * @return \AWS\Result<array{taskSet?:array{id?:string, taskSetArn?:string, serviceArn?:string, clusterArn?:string, startedBy?:string, externalId?:string, status?:string, taskDefinition?:string, computedDesiredCount?:int, pendingCount?:int, runningCount?:int, createdAt?:int|string|\DateTimeInterface, updatedAt?:int|string|\DateTimeInterface, launchType?:"EC2"|"FARGATE"|"EXTERNAL", capacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, platformVersion?:string, platformFamily?:string, networkConfiguration?:array{awsvpcConfiguration?:array{subnets:array<string>, securityGroups?:array<string>, assignPublicIp?:"ENABLED"|"DISABLED"}}, loadBalancers?:array<array{targetGroupArn?:string, loadBalancerName?:string, containerName?:string, containerPort?:int}>, serviceRegistries?:array<array{registryArn?:string, port?:int, containerName?:string, containerPort?:int}>, scale?:array{value?:float, unit?:"PERCENT"}, stabilityStatus?:"STEADY_STATE"|"STABILIZING", stabilityStatusAt?:int|string|\DateTimeInterface, tags?:array<array{key?:string, value?:string}>, fargateEphemeralStorage?:array{kmsKeyId?:string}}}>
     */
    public function deleteTaskSet(array $args): \AWS\Result { }

    /**
     * @param array{cluster:string, service:string, taskSet:string, force?:bool} $args
     * @return \GuzzleHttp\Promise\Promise<array{taskSet?:array{id?:string, taskSetArn?:string, serviceArn?:string, clusterArn?:string, startedBy?:string, externalId?:string, status?:string, taskDefinition?:string, computedDesiredCount?:int, pendingCount?:int, runningCount?:int, createdAt?:int|string|\DateTimeInterface, updatedAt?:int|string|\DateTimeInterface, launchType?:"EC2"|"FARGATE"|"EXTERNAL", capacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, platformVersion?:string, platformFamily?:string, networkConfiguration?:array{awsvpcConfiguration?:array{subnets:array<string>, securityGroups?:array<string>, assignPublicIp?:"ENABLED"|"DISABLED"}}, loadBalancers?:array<array{targetGroupArn?:string, loadBalancerName?:string, containerName?:string, containerPort?:int}>, serviceRegistries?:array<array{registryArn?:string, port?:int, containerName?:string, containerPort?:int}>, scale?:array{value?:float, unit?:"PERCENT"}, stabilityStatus?:"STEADY_STATE"|"STABILIZING", stabilityStatusAt?:int|string|\DateTimeInterface, tags?:array<array{key?:string, value?:string}>, fargateEphemeralStorage?:array{kmsKeyId?:string}}}>
     */
    public function deleteTaskSetAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{cluster?:string, containerInstance:string, force?:bool} $args
     * @return \AWS\Result<array{containerInstance?:array{containerInstanceArn?:string, ec2InstanceId?:string, capacityProviderName?:string, version?:int, versionInfo?:array{agentVersion?:string, agentHash?:string, dockerVersion?:string}, remainingResources?:array<array{name?:string, type?:string, doubleValue?:float, longValue?:int, integerValue?:int, stringSetValue?:array<string>}>, registeredResources?:array<array{name?:string, type?:string, doubleValue?:float, longValue?:int, integerValue?:int, stringSetValue?:array<string>}>, status?:string, statusReason?:string, agentConnected?:bool, runningTasksCount?:int, pendingTasksCount?:int, agentUpdateStatus?:"PENDING"|"STAGING"|"STAGED"|"UPDATING"|"UPDATED"|"FAILED", attributes?:array<array{name:string, value?:string, targetType?:"container-instance", targetId?:string}>, registeredAt?:int|string|\DateTimeInterface, attachments?:array<array{id?:string, type?:string, status?:string, details?:array<array{name?:string, value?:string}>}>, tags?:array<array{key?:string, value?:string}>, healthStatus?:array{overallStatus?:"OK"|"IMPAIRED"|"INSUFFICIENT_DATA"|"INITIALIZING", details?:array<array{type?:"CONTAINER_RUNTIME", status?:"OK"|"IMPAIRED"|"INSUFFICIENT_DATA"|"INITIALIZING", lastUpdated?:int|string|\DateTimeInterface, lastStatusChange?:int|string|\DateTimeInterface}>}}}>
     */
    public function deregisterContainerInstance(array $args): \AWS\Result { }

    /**
     * @param array{cluster?:string, containerInstance:string, force?:bool} $args
     * @return \GuzzleHttp\Promise\Promise<array{containerInstance?:array{containerInstanceArn?:string, ec2InstanceId?:string, capacityProviderName?:string, version?:int, versionInfo?:array{agentVersion?:string, agentHash?:string, dockerVersion?:string}, remainingResources?:array<array{name?:string, type?:string, doubleValue?:float, longValue?:int, integerValue?:int, stringSetValue?:array<string>}>, registeredResources?:array<array{name?:string, type?:string, doubleValue?:float, longValue?:int, integerValue?:int, stringSetValue?:array<string>}>, status?:string, statusReason?:string, agentConnected?:bool, runningTasksCount?:int, pendingTasksCount?:int, agentUpdateStatus?:"PENDING"|"STAGING"|"STAGED"|"UPDATING"|"UPDATED"|"FAILED", attributes?:array<array{name:string, value?:string, targetType?:"container-instance", targetId?:string}>, registeredAt?:int|string|\DateTimeInterface, attachments?:array<array{id?:string, type?:string, status?:string, details?:array<array{name?:string, value?:string}>}>, tags?:array<array{key?:string, value?:string}>, healthStatus?:array{overallStatus?:"OK"|"IMPAIRED"|"INSUFFICIENT_DATA"|"INITIALIZING", details?:array<array{type?:"CONTAINER_RUNTIME", status?:"OK"|"IMPAIRED"|"INSUFFICIENT_DATA"|"INITIALIZING", lastUpdated?:int|string|\DateTimeInterface, lastStatusChange?:int|string|\DateTimeInterface}>}}}>
     */
    public function deregisterContainerInstanceAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{taskDefinition:string} $args
     * @return \AWS\Result<array{taskDefinition?:array{taskDefinitionArn?:string, containerDefinitions?:array<array{name?:string, image?:string, repositoryCredentials?:array{credentialsParameter:string}, cpu?:int, memory?:int, memoryReservation?:int, links?:array<string>, portMappings?:array<array{containerPort?:int, hostPort?:int, protocol?:"tcp"|"udp", name?:string, appProtocol?:"http"|"http2"|"grpc", containerPortRange?:string}>, essential?:bool, restartPolicy?:array{enabled:bool, ignoredExitCodes?:array<int>, restartAttemptPeriod?:int}, entryPoint?:array<string>, command?:array<string>, environment?:array<array{name?:string, value?:string}>, environmentFiles?:array<array{value:string, type:"s3"}>, mountPoints?:array<array{sourceVolume?:string, containerPath?:string, readOnly?:bool}>, volumesFrom?:array<array{sourceContainer?:string, readOnly?:bool}>, linuxParameters?:array{capabilities?:array{add?:array<string>, drop?:array<string>}, devices?:array<array{hostPath:string, containerPath?:string, permissions?:array<"read"|"write"|"mknod">}>, initProcessEnabled?:bool, sharedMemorySize?:int, tmpfs?:array<array{containerPath:string, size:int, mountOptions?:array<string>}>, maxSwap?:int, swappiness?:int}, secrets?:array<array{name:string, valueFrom:string}>, dependsOn?:array<array{containerName:string, condition:"START"|"COMPLETE"|"SUCCESS"|"HEALTHY"}>, startTimeout?:int, stopTimeout?:int, versionConsistency?:"enabled"|"disabled", hostname?:string, user?:string, workingDirectory?:string, disableNetworking?:bool, privileged?:bool, readonlyRootFilesystem?:bool, dnsServers?:array<string>, dnsSearchDomains?:array<string>, extraHosts?:array<array{hostname:string, ipAddress:string}>, dockerSecurityOptions?:array<string>, interactive?:bool, pseudoTerminal?:bool, dockerLabels?:array<string, string>, ulimits?:array<array{name:"core"|"cpu"|"data"|"fsize"|"locks"|"memlock"|"msgqueue"|"nice"|"nofile"|"nproc"|"rss"|"rtprio"|"rttime"|"sigpending"|"stack", softLimit:int, hardLimit:int}>, logConfiguration?:array{logDriver:"json-file"|"syslog"|"journald"|"gelf"|"fluentd"|"awslogs"|"splunk"|"awsfirelens", options?:array<string, string>, secretOptions?:array<array{name:string, valueFrom:string}>}, healthCheck?:array{command:array<string>, interval?:int, timeout?:int, retries?:int, startPeriod?:int}, systemControls?:array<array{namespace?:string, value?:string}>, resourceRequirements?:array<array{value:string, type:"GPU"|"InferenceAccelerator"}>, firelensConfiguration?:array{type:"fluentd"|"fluentbit", options?:array<string, string>}, credentialSpecs?:array<string>}>, family?:string, taskRoleArn?:string, executionRoleArn?:string, networkMode?:"bridge"|"host"|"awsvpc"|"none", revision?:int, volumes?:array<array{name?:string, host?:array{sourcePath?:string}, dockerVolumeConfiguration?:array{scope?:"task"|"shared", autoprovision?:bool, driver?:string, driverOpts?:array<string, string>, labels?:array<string, string>}, efsVolumeConfiguration?:array{fileSystemId:string, rootDirectory?:string, transitEncryption?:"ENABLED"|"DISABLED", transitEncryptionPort?:int, authorizationConfig?:array{accessPointId?:string, iam?:"ENABLED"|"DISABLED"}}, fsxWindowsFileServerVolumeConfiguration?:array{fileSystemId:string, rootDirectory:string, authorizationConfig:array{credentialsParameter:string, domain:string}}, configuredAtLaunch?:bool}>, status?:"ACTIVE"|"INACTIVE"|"DELETE_IN_PROGRESS", requiresAttributes?:array<array{name:string, value?:string, targetType?:"container-instance", targetId?:string}>, placementConstraints?:array<array{type?:"memberOf", expression?:string}>, compatibilities?:array<"EC2"|"FARGATE"|"EXTERNAL">, runtimePlatform?:array{cpuArchitecture?:"X86_64"|"ARM64", operatingSystemFamily?:"WINDOWS_SERVER_2019_FULL"|"WINDOWS_SERVER_2019_CORE"|"WINDOWS_SERVER_2016_FULL"|"WINDOWS_SERVER_2004_CORE"|"WINDOWS_SERVER_2022_CORE"|"WINDOWS_SERVER_2022_FULL"|"WINDOWS_SERVER_20H2_CORE"|"LINUX"}, requiresCompatibilities?:array<"EC2"|"FARGATE"|"EXTERNAL">, cpu?:string, memory?:string, inferenceAccelerators?:array<array{deviceName:string, deviceType:string}>, pidMode?:"host"|"task", ipcMode?:"host"|"task"|"none", proxyConfiguration?:array{type?:"APPMESH", containerName:string, properties?:array<array{name?:string, value?:string}>}, registeredAt?:int|string|\DateTimeInterface, deregisteredAt?:int|string|\DateTimeInterface, registeredBy?:string, ephemeralStorage?:array{sizeInGiB:int}, enableFaultInjection?:bool}}>
     */
    public function deregisterTaskDefinition(array $args): \AWS\Result { }

    /**
     * @param array{taskDefinition:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{taskDefinition?:array{taskDefinitionArn?:string, containerDefinitions?:array<array{name?:string, image?:string, repositoryCredentials?:array{credentialsParameter:string}, cpu?:int, memory?:int, memoryReservation?:int, links?:array<string>, portMappings?:array<array{containerPort?:int, hostPort?:int, protocol?:"tcp"|"udp", name?:string, appProtocol?:"http"|"http2"|"grpc", containerPortRange?:string}>, essential?:bool, restartPolicy?:array{enabled:bool, ignoredExitCodes?:array<int>, restartAttemptPeriod?:int}, entryPoint?:array<string>, command?:array<string>, environment?:array<array{name?:string, value?:string}>, environmentFiles?:array<array{value:string, type:"s3"}>, mountPoints?:array<array{sourceVolume?:string, containerPath?:string, readOnly?:bool}>, volumesFrom?:array<array{sourceContainer?:string, readOnly?:bool}>, linuxParameters?:array{capabilities?:array{add?:array<string>, drop?:array<string>}, devices?:array<array{hostPath:string, containerPath?:string, permissions?:array<"read"|"write"|"mknod">}>, initProcessEnabled?:bool, sharedMemorySize?:int, tmpfs?:array<array{containerPath:string, size:int, mountOptions?:array<string>}>, maxSwap?:int, swappiness?:int}, secrets?:array<array{name:string, valueFrom:string}>, dependsOn?:array<array{containerName:string, condition:"START"|"COMPLETE"|"SUCCESS"|"HEALTHY"}>, startTimeout?:int, stopTimeout?:int, versionConsistency?:"enabled"|"disabled", hostname?:string, user?:string, workingDirectory?:string, disableNetworking?:bool, privileged?:bool, readonlyRootFilesystem?:bool, dnsServers?:array<string>, dnsSearchDomains?:array<string>, extraHosts?:array<array{hostname:string, ipAddress:string}>, dockerSecurityOptions?:array<string>, interactive?:bool, pseudoTerminal?:bool, dockerLabels?:array<string, string>, ulimits?:array<array{name:"core"|"cpu"|"data"|"fsize"|"locks"|"memlock"|"msgqueue"|"nice"|"nofile"|"nproc"|"rss"|"rtprio"|"rttime"|"sigpending"|"stack", softLimit:int, hardLimit:int}>, logConfiguration?:array{logDriver:"json-file"|"syslog"|"journald"|"gelf"|"fluentd"|"awslogs"|"splunk"|"awsfirelens", options?:array<string, string>, secretOptions?:array<array{name:string, valueFrom:string}>}, healthCheck?:array{command:array<string>, interval?:int, timeout?:int, retries?:int, startPeriod?:int}, systemControls?:array<array{namespace?:string, value?:string}>, resourceRequirements?:array<array{value:string, type:"GPU"|"InferenceAccelerator"}>, firelensConfiguration?:array{type:"fluentd"|"fluentbit", options?:array<string, string>}, credentialSpecs?:array<string>}>, family?:string, taskRoleArn?:string, executionRoleArn?:string, networkMode?:"bridge"|"host"|"awsvpc"|"none", revision?:int, volumes?:array<array{name?:string, host?:array{sourcePath?:string}, dockerVolumeConfiguration?:array{scope?:"task"|"shared", autoprovision?:bool, driver?:string, driverOpts?:array<string, string>, labels?:array<string, string>}, efsVolumeConfiguration?:array{fileSystemId:string, rootDirectory?:string, transitEncryption?:"ENABLED"|"DISABLED", transitEncryptionPort?:int, authorizationConfig?:array{accessPointId?:string, iam?:"ENABLED"|"DISABLED"}}, fsxWindowsFileServerVolumeConfiguration?:array{fileSystemId:string, rootDirectory:string, authorizationConfig:array{credentialsParameter:string, domain:string}}, configuredAtLaunch?:bool}>, status?:"ACTIVE"|"INACTIVE"|"DELETE_IN_PROGRESS", requiresAttributes?:array<array{name:string, value?:string, targetType?:"container-instance", targetId?:string}>, placementConstraints?:array<array{type?:"memberOf", expression?:string}>, compatibilities?:array<"EC2"|"FARGATE"|"EXTERNAL">, runtimePlatform?:array{cpuArchitecture?:"X86_64"|"ARM64", operatingSystemFamily?:"WINDOWS_SERVER_2019_FULL"|"WINDOWS_SERVER_2019_CORE"|"WINDOWS_SERVER_2016_FULL"|"WINDOWS_SERVER_2004_CORE"|"WINDOWS_SERVER_2022_CORE"|"WINDOWS_SERVER_2022_FULL"|"WINDOWS_SERVER_20H2_CORE"|"LINUX"}, requiresCompatibilities?:array<"EC2"|"FARGATE"|"EXTERNAL">, cpu?:string, memory?:string, inferenceAccelerators?:array<array{deviceName:string, deviceType:string}>, pidMode?:"host"|"task", ipcMode?:"host"|"task"|"none", proxyConfiguration?:array{type?:"APPMESH", containerName:string, properties?:array<array{name?:string, value?:string}>}, registeredAt?:int|string|\DateTimeInterface, deregisteredAt?:int|string|\DateTimeInterface, registeredBy?:string, ephemeralStorage?:array{sizeInGiB:int}, enableFaultInjection?:bool}}>
     */
    public function deregisterTaskDefinitionAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{capacityProviders?:array<string>, include?:array<"TAGS">, maxResults?:int, nextToken?:string} $args
     * @return \AWS\Result<array{capacityProviders?:array<array{capacityProviderArn?:string, name?:string, status?:"ACTIVE"|"INACTIVE", autoScalingGroupProvider?:array{autoScalingGroupArn:string, managedScaling?:array{status?:"ENABLED"|"DISABLED", targetCapacity?:int, minimumScalingStepSize?:int, maximumScalingStepSize?:int, instanceWarmupPeriod?:int}, managedTerminationProtection?:"ENABLED"|"DISABLED", managedDraining?:"ENABLED"|"DISABLED"}, updateStatus?:"DELETE_IN_PROGRESS"|"DELETE_COMPLETE"|"DELETE_FAILED"|"UPDATE_IN_PROGRESS"|"UPDATE_COMPLETE"|"UPDATE_FAILED", updateStatusReason?:string, tags?:array<array{key?:string, value?:string}>}>, failures?:array<array{arn?:string, reason?:string, detail?:string}>, nextToken?:string}>
     */
    public function describeCapacityProviders(array $args = []): \AWS\Result { }

    /**
     * @param array{capacityProviders?:array<string>, include?:array<"TAGS">, maxResults?:int, nextToken?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{capacityProviders?:array<array{capacityProviderArn?:string, name?:string, status?:"ACTIVE"|"INACTIVE", autoScalingGroupProvider?:array{autoScalingGroupArn:string, managedScaling?:array{status?:"ENABLED"|"DISABLED", targetCapacity?:int, minimumScalingStepSize?:int, maximumScalingStepSize?:int, instanceWarmupPeriod?:int}, managedTerminationProtection?:"ENABLED"|"DISABLED", managedDraining?:"ENABLED"|"DISABLED"}, updateStatus?:"DELETE_IN_PROGRESS"|"DELETE_COMPLETE"|"DELETE_FAILED"|"UPDATE_IN_PROGRESS"|"UPDATE_COMPLETE"|"UPDATE_FAILED", updateStatusReason?:string, tags?:array<array{key?:string, value?:string}>}>, failures?:array<array{arn?:string, reason?:string, detail?:string}>, nextToken?:string}>
     */
    public function describeCapacityProvidersAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{clusters?:array<string>, include?:array<"ATTACHMENTS"|"CONFIGURATIONS"|"SETTINGS"|"STATISTICS"|"TAGS">} $args
     * @return \AWS\Result<array{clusters?:array<array{clusterArn?:string, clusterName?:string, configuration?:array{executeCommandConfiguration?:array{kmsKeyId?:string, logging?:"NONE"|"DEFAULT"|"OVERRIDE", logConfiguration?:array{cloudWatchLogGroupName?:string, cloudWatchEncryptionEnabled?:bool, s3BucketName?:string, s3EncryptionEnabled?:bool, s3KeyPrefix?:string}}, managedStorageConfiguration?:array{kmsKeyId?:string, fargateEphemeralStorageKmsKeyId?:string}}, status?:string, registeredContainerInstancesCount?:int, runningTasksCount?:int, pendingTasksCount?:int, activeServicesCount?:int, statistics?:array<array{name?:string, value?:string}>, tags?:array<array{key?:string, value?:string}>, settings?:array<array{name?:"containerInsights", value?:string}>, capacityProviders?:array<string>, defaultCapacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, attachments?:array<array{id?:string, type?:string, status?:string, details?:array<array{name?:string, value?:string}>}>, attachmentsStatus?:string, serviceConnectDefaults?:array{namespace?:string}}>, failures?:array<array{arn?:string, reason?:string, detail?:string}>}>
     */
    public function describeClusters(array $args = []): \AWS\Result { }

    /**
     * @param array{clusters?:array<string>, include?:array<"ATTACHMENTS"|"CONFIGURATIONS"|"SETTINGS"|"STATISTICS"|"TAGS">} $args
     * @return \GuzzleHttp\Promise\Promise<array{clusters?:array<array{clusterArn?:string, clusterName?:string, configuration?:array{executeCommandConfiguration?:array{kmsKeyId?:string, logging?:"NONE"|"DEFAULT"|"OVERRIDE", logConfiguration?:array{cloudWatchLogGroupName?:string, cloudWatchEncryptionEnabled?:bool, s3BucketName?:string, s3EncryptionEnabled?:bool, s3KeyPrefix?:string}}, managedStorageConfiguration?:array{kmsKeyId?:string, fargateEphemeralStorageKmsKeyId?:string}}, status?:string, registeredContainerInstancesCount?:int, runningTasksCount?:int, pendingTasksCount?:int, activeServicesCount?:int, statistics?:array<array{name?:string, value?:string}>, tags?:array<array{key?:string, value?:string}>, settings?:array<array{name?:"containerInsights", value?:string}>, capacityProviders?:array<string>, defaultCapacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, attachments?:array<array{id?:string, type?:string, status?:string, details?:array<array{name?:string, value?:string}>}>, attachmentsStatus?:string, serviceConnectDefaults?:array{namespace?:string}}>, failures?:array<array{arn?:string, reason?:string, detail?:string}>}>
     */
    public function describeClustersAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{cluster?:string, containerInstances:array<string>, include?:array<"TAGS"|"CONTAINER_INSTANCE_HEALTH">} $args
     * @return \AWS\Result<array{containerInstances?:array<array{containerInstanceArn?:string, ec2InstanceId?:string, capacityProviderName?:string, version?:int, versionInfo?:array{agentVersion?:string, agentHash?:string, dockerVersion?:string}, remainingResources?:array<array{name?:string, type?:string, doubleValue?:float, longValue?:int, integerValue?:int, stringSetValue?:array<string>}>, registeredResources?:array<array{name?:string, type?:string, doubleValue?:float, longValue?:int, integerValue?:int, stringSetValue?:array<string>}>, status?:string, statusReason?:string, agentConnected?:bool, runningTasksCount?:int, pendingTasksCount?:int, agentUpdateStatus?:"PENDING"|"STAGING"|"STAGED"|"UPDATING"|"UPDATED"|"FAILED", attributes?:array<array{name:string, value?:string, targetType?:"container-instance", targetId?:string}>, registeredAt?:int|string|\DateTimeInterface, attachments?:array<array{id?:string, type?:string, status?:string, details?:array<array{name?:string, value?:string}>}>, tags?:array<array{key?:string, value?:string}>, healthStatus?:array{overallStatus?:"OK"|"IMPAIRED"|"INSUFFICIENT_DATA"|"INITIALIZING", details?:array<array{type?:"CONTAINER_RUNTIME", status?:"OK"|"IMPAIRED"|"INSUFFICIENT_DATA"|"INITIALIZING", lastUpdated?:int|string|\DateTimeInterface, lastStatusChange?:int|string|\DateTimeInterface}>}}>, failures?:array<array{arn?:string, reason?:string, detail?:string}>}>
     */
    public function describeContainerInstances(array $args): \AWS\Result { }

    /**
     * @param array{cluster?:string, containerInstances:array<string>, include?:array<"TAGS"|"CONTAINER_INSTANCE_HEALTH">} $args
     * @return \GuzzleHttp\Promise\Promise<array{containerInstances?:array<array{containerInstanceArn?:string, ec2InstanceId?:string, capacityProviderName?:string, version?:int, versionInfo?:array{agentVersion?:string, agentHash?:string, dockerVersion?:string}, remainingResources?:array<array{name?:string, type?:string, doubleValue?:float, longValue?:int, integerValue?:int, stringSetValue?:array<string>}>, registeredResources?:array<array{name?:string, type?:string, doubleValue?:float, longValue?:int, integerValue?:int, stringSetValue?:array<string>}>, status?:string, statusReason?:string, agentConnected?:bool, runningTasksCount?:int, pendingTasksCount?:int, agentUpdateStatus?:"PENDING"|"STAGING"|"STAGED"|"UPDATING"|"UPDATED"|"FAILED", attributes?:array<array{name:string, value?:string, targetType?:"container-instance", targetId?:string}>, registeredAt?:int|string|\DateTimeInterface, attachments?:array<array{id?:string, type?:string, status?:string, details?:array<array{name?:string, value?:string}>}>, tags?:array<array{key?:string, value?:string}>, healthStatus?:array{overallStatus?:"OK"|"IMPAIRED"|"INSUFFICIENT_DATA"|"INITIALIZING", details?:array<array{type?:"CONTAINER_RUNTIME", status?:"OK"|"IMPAIRED"|"INSUFFICIENT_DATA"|"INITIALIZING", lastUpdated?:int|string|\DateTimeInterface, lastStatusChange?:int|string|\DateTimeInterface}>}}>, failures?:array<array{arn?:string, reason?:string, detail?:string}>}>
     */
    public function describeContainerInstancesAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{serviceDeploymentArns:array<string>} $args
     * @return \AWS\Result<array{serviceDeployments?:array<array{serviceDeploymentArn?:string, serviceArn?:string, clusterArn?:string, createdAt?:int|string|\DateTimeInterface, startedAt?:int|string|\DateTimeInterface, finishedAt?:int|string|\DateTimeInterface, stoppedAt?:int|string|\DateTimeInterface, updatedAt?:int|string|\DateTimeInterface, sourceServiceRevisions?:array<array{arn?:string, requestedTaskCount?:int, runningTaskCount?:int, pendingTaskCount?:int}>, targetServiceRevision?:array{arn?:string, requestedTaskCount?:int, runningTaskCount?:int, pendingTaskCount?:int}, status?:"PENDING"|"SUCCESSFUL"|"STOPPED"|"STOP_REQUESTED"|"IN_PROGRESS"|"ROLLBACK_IN_PROGRESS"|"ROLLBACK_SUCCESSFUL"|"ROLLBACK_FAILED", statusReason?:string, deploymentConfiguration?:array{deploymentCircuitBreaker?:array{enable:bool, rollback:bool}, maximumPercent?:int, minimumHealthyPercent?:int, alarms?:array{alarmNames:array<string>, rollback:bool, enable:bool}}, rollback?:array{reason?:string, startedAt?:int|string|\DateTimeInterface, serviceRevisionArn?:string}, deploymentCircuitBreaker?:array{status?:"TRIGGERED"|"MONITORING"|"MONITORING_COMPLETE"|"DISABLED", failureCount?:int, threshold?:int}, alarms?:array{status?:"TRIGGERED"|"MONITORING"|"MONITORING_COMPLETE"|"DISABLED", alarmNames?:array<string>, triggeredAlarmNames?:array<string>}}>, failures?:array<array{arn?:string, reason?:string, detail?:string}>}>
     */
    public function describeServiceDeployments(array $args): \AWS\Result { }

    /**
     * @param array{serviceDeploymentArns:array<string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{serviceDeployments?:array<array{serviceDeploymentArn?:string, serviceArn?:string, clusterArn?:string, createdAt?:int|string|\DateTimeInterface, startedAt?:int|string|\DateTimeInterface, finishedAt?:int|string|\DateTimeInterface, stoppedAt?:int|string|\DateTimeInterface, updatedAt?:int|string|\DateTimeInterface, sourceServiceRevisions?:array<array{arn?:string, requestedTaskCount?:int, runningTaskCount?:int, pendingTaskCount?:int}>, targetServiceRevision?:array{arn?:string, requestedTaskCount?:int, runningTaskCount?:int, pendingTaskCount?:int}, status?:"PENDING"|"SUCCESSFUL"|"STOPPED"|"STOP_REQUESTED"|"IN_PROGRESS"|"ROLLBACK_IN_PROGRESS"|"ROLLBACK_SUCCESSFUL"|"ROLLBACK_FAILED", statusReason?:string, deploymentConfiguration?:array{deploymentCircuitBreaker?:array{enable:bool, rollback:bool}, maximumPercent?:int, minimumHealthyPercent?:int, alarms?:array{alarmNames:array<string>, rollback:bool, enable:bool}}, rollback?:array{reason?:string, startedAt?:int|string|\DateTimeInterface, serviceRevisionArn?:string}, deploymentCircuitBreaker?:array{status?:"TRIGGERED"|"MONITORING"|"MONITORING_COMPLETE"|"DISABLED", failureCount?:int, threshold?:int}, alarms?:array{status?:"TRIGGERED"|"MONITORING"|"MONITORING_COMPLETE"|"DISABLED", alarmNames?:array<string>, triggeredAlarmNames?:array<string>}}>, failures?:array<array{arn?:string, reason?:string, detail?:string}>}>
     */
    public function describeServiceDeploymentsAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{serviceRevisionArns:array<string>} $args
     * @return \AWS\Result<array{serviceRevisions?:array<array{serviceRevisionArn?:string, serviceArn?:string, clusterArn?:string, taskDefinition?:string, capacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, launchType?:"EC2"|"FARGATE"|"EXTERNAL", platformVersion?:string, platformFamily?:string, loadBalancers?:array<array{targetGroupArn?:string, loadBalancerName?:string, containerName?:string, containerPort?:int}>, serviceRegistries?:array<array{registryArn?:string, port?:int, containerName?:string, containerPort?:int}>, networkConfiguration?:array{awsvpcConfiguration?:array{subnets:array<string>, securityGroups?:array<string>, assignPublicIp?:"ENABLED"|"DISABLED"}}, containerImages?:array<array{containerName?:string, imageDigest?:string, image?:string}>, guardDutyEnabled?:bool, serviceConnectConfiguration?:array{enabled:bool, namespace?:string, services?:array<array{portName:string, discoveryName?:string, clientAliases?:array<array{port:int, dnsName?:string}>, ingressPortOverride?:int, timeout?:array{idleTimeoutSeconds?:int, perRequestTimeoutSeconds?:int}, tls?:array{issuerCertificateAuthority:array{awsPcaAuthorityArn?:string}, kmsKey?:string, roleArn?:string}}>, logConfiguration?:array{logDriver:"json-file"|"syslog"|"journald"|"gelf"|"fluentd"|"awslogs"|"splunk"|"awsfirelens", options?:array<string, string>, secretOptions?:array<array{name:string, valueFrom:string}>}}, volumeConfigurations?:array<array{name:string, managedEBSVolume?:array{encrypted?:bool, kmsKeyId?:string, volumeType?:string, sizeInGiB?:int, snapshotId?:string, iops?:int, throughput?:int, tagSpecifications?:array<array{resourceType:"volume", tags?:array<array{key?:string, value?:string}>, propagateTags?:"TASK_DEFINITION"|"SERVICE"|"NONE"}>, roleArn:string, filesystemType?:"ext3"|"ext4"|"xfs"|"ntfs"}}>, fargateEphemeralStorage?:array{kmsKeyId?:string}, createdAt?:int|string|\DateTimeInterface, vpcLatticeConfigurations?:array<array{roleArn:string, targetGroupArn:string, portName:string}>}>, failures?:array<array{arn?:string, reason?:string, detail?:string}>}>
     */
    public function describeServiceRevisions(array $args): \AWS\Result { }

    /**
     * @param array{serviceRevisionArns:array<string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{serviceRevisions?:array<array{serviceRevisionArn?:string, serviceArn?:string, clusterArn?:string, taskDefinition?:string, capacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, launchType?:"EC2"|"FARGATE"|"EXTERNAL", platformVersion?:string, platformFamily?:string, loadBalancers?:array<array{targetGroupArn?:string, loadBalancerName?:string, containerName?:string, containerPort?:int}>, serviceRegistries?:array<array{registryArn?:string, port?:int, containerName?:string, containerPort?:int}>, networkConfiguration?:array{awsvpcConfiguration?:array{subnets:array<string>, securityGroups?:array<string>, assignPublicIp?:"ENABLED"|"DISABLED"}}, containerImages?:array<array{containerName?:string, imageDigest?:string, image?:string}>, guardDutyEnabled?:bool, serviceConnectConfiguration?:array{enabled:bool, namespace?:string, services?:array<array{portName:string, discoveryName?:string, clientAliases?:array<array{port:int, dnsName?:string}>, ingressPortOverride?:int, timeout?:array{idleTimeoutSeconds?:int, perRequestTimeoutSeconds?:int}, tls?:array{issuerCertificateAuthority:array{awsPcaAuthorityArn?:string}, kmsKey?:string, roleArn?:string}}>, logConfiguration?:array{logDriver:"json-file"|"syslog"|"journald"|"gelf"|"fluentd"|"awslogs"|"splunk"|"awsfirelens", options?:array<string, string>, secretOptions?:array<array{name:string, valueFrom:string}>}}, volumeConfigurations?:array<array{name:string, managedEBSVolume?:array{encrypted?:bool, kmsKeyId?:string, volumeType?:string, sizeInGiB?:int, snapshotId?:string, iops?:int, throughput?:int, tagSpecifications?:array<array{resourceType:"volume", tags?:array<array{key?:string, value?:string}>, propagateTags?:"TASK_DEFINITION"|"SERVICE"|"NONE"}>, roleArn:string, filesystemType?:"ext3"|"ext4"|"xfs"|"ntfs"}}>, fargateEphemeralStorage?:array{kmsKeyId?:string}, createdAt?:int|string|\DateTimeInterface, vpcLatticeConfigurations?:array<array{roleArn:string, targetGroupArn:string, portName:string}>}>, failures?:array<array{arn?:string, reason?:string, detail?:string}>}>
     */
    public function describeServiceRevisionsAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{cluster?:string, services:array<string>, include?:array<"TAGS">} $args
     * @return \AWS\Result<array{services?:array<array{serviceArn?:string, serviceName?:string, clusterArn?:string, loadBalancers?:array<array{targetGroupArn?:string, loadBalancerName?:string, containerName?:string, containerPort?:int}>, serviceRegistries?:array<array{registryArn?:string, port?:int, containerName?:string, containerPort?:int}>, status?:string, desiredCount?:int, runningCount?:int, pendingCount?:int, launchType?:"EC2"|"FARGATE"|"EXTERNAL", capacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, platformVersion?:string, platformFamily?:string, taskDefinition?:string, deploymentConfiguration?:array{deploymentCircuitBreaker?:array{enable:bool, rollback:bool}, maximumPercent?:int, minimumHealthyPercent?:int, alarms?:array{alarmNames:array<string>, rollback:bool, enable:bool}}, taskSets?:array<array{id?:string, taskSetArn?:string, serviceArn?:string, clusterArn?:string, startedBy?:string, externalId?:string, status?:string, taskDefinition?:string, computedDesiredCount?:int, pendingCount?:int, runningCount?:int, createdAt?:int|string|\DateTimeInterface, updatedAt?:int|string|\DateTimeInterface, launchType?:"EC2"|"FARGATE"|"EXTERNAL", capacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, platformVersion?:string, platformFamily?:string, networkConfiguration?:array{awsvpcConfiguration?:array{subnets:array<string>, securityGroups?:array<string>, assignPublicIp?:"ENABLED"|"DISABLED"}}, loadBalancers?:array<array{targetGroupArn?:string, loadBalancerName?:string, containerName?:string, containerPort?:int}>, serviceRegistries?:array<array{registryArn?:string, port?:int, containerName?:string, containerPort?:int}>, scale?:array{value?:float, unit?:"PERCENT"}, stabilityStatus?:"STEADY_STATE"|"STABILIZING", stabilityStatusAt?:int|string|\DateTimeInterface, tags?:array<array{key?:string, value?:string}>, fargateEphemeralStorage?:array{kmsKeyId?:string}}>, deployments?:array<array{id?:string, status?:string, taskDefinition?:string, desiredCount?:int, pendingCount?:int, runningCount?:int, failedTasks?:int, createdAt?:int|string|\DateTimeInterface, updatedAt?:int|string|\DateTimeInterface, capacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, launchType?:"EC2"|"FARGATE"|"EXTERNAL", platformVersion?:string, platformFamily?:string, networkConfiguration?:array{awsvpcConfiguration?:array{subnets:array<string>, securityGroups?:array<string>, assignPublicIp?:"ENABLED"|"DISABLED"}}, rolloutState?:"COMPLETED"|"FAILED"|"IN_PROGRESS", rolloutStateReason?:string, serviceConnectConfiguration?:array{enabled:bool, namespace?:string, services?:mixed, logConfiguration?:array{logDriver:"json-file"|"syslog"|"journald"|"gelf"|"fluentd"|"awslogs"|"splunk"|"awsfirelens", options?:array<string, string>, secretOptions?:array<array{name:string, valueFrom:string}>}}, serviceConnectResources?:array<array{discoveryName?:string, discoveryArn?:string}>, volumeConfigurations?:array<array{name:string, managedEBSVolume?:array{encrypted?:bool, kmsKeyId?:string, volumeType?:string, sizeInGiB?:int, snapshotId?:string, iops?:int, throughput?:int, tagSpecifications?:array<array{resourceType:"volume", tags?:array<array{key?:string, value?:string}>, propagateTags?:"TASK_DEFINITION"|"SERVICE"|"NONE"}>, roleArn:string, filesystemType?:"ext3"|"ext4"|"xfs"|"ntfs"}}>, fargateEphemeralStorage?:array{kmsKeyId?:string}, vpcLatticeConfigurations?:array<array{roleArn:string, targetGroupArn:string, portName:string}>}>, roleArn?:string, events?:array<array{id?:string, createdAt?:int|string|\DateTimeInterface, message?:string}>, createdAt?:int|string|\DateTimeInterface, placementConstraints?:array<array{type?:"distinctInstance"|"memberOf", expression?:string}>, placementStrategy?:array<array{type?:"random"|"spread"|"binpack", field?:string}>, networkConfiguration?:array{awsvpcConfiguration?:array{subnets:array<string>, securityGroups?:array<string>, assignPublicIp?:"ENABLED"|"DISABLED"}}, healthCheckGracePeriodSeconds?:int, schedulingStrategy?:"REPLICA"|"DAEMON", deploymentController?:array{type:"ECS"|"CODE_DEPLOY"|"EXTERNAL"}, tags?:array<array{key?:string, value?:string}>, createdBy?:string, enableECSManagedTags?:bool, propagateTags?:"TASK_DEFINITION"|"SERVICE"|"NONE", enableExecuteCommand?:bool, availabilityZoneRebalancing?:"ENABLED"|"DISABLED"}>, failures?:array<array{arn?:string, reason?:string, detail?:string}>}>
     */
    public function describeServices(array $args): \AWS\Result { }

    /**
     * @param array{cluster?:string, services:array<string>, include?:array<"TAGS">} $args
     * @return \GuzzleHttp\Promise\Promise<array{services?:array<array{serviceArn?:string, serviceName?:string, clusterArn?:string, loadBalancers?:array<array{targetGroupArn?:string, loadBalancerName?:string, containerName?:string, containerPort?:int}>, serviceRegistries?:array<array{registryArn?:string, port?:int, containerName?:string, containerPort?:int}>, status?:string, desiredCount?:int, runningCount?:int, pendingCount?:int, launchType?:"EC2"|"FARGATE"|"EXTERNAL", capacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, platformVersion?:string, platformFamily?:string, taskDefinition?:string, deploymentConfiguration?:array{deploymentCircuitBreaker?:array{enable:bool, rollback:bool}, maximumPercent?:int, minimumHealthyPercent?:int, alarms?:array{alarmNames:array<string>, rollback:bool, enable:bool}}, taskSets?:array<array{id?:string, taskSetArn?:string, serviceArn?:string, clusterArn?:string, startedBy?:string, externalId?:string, status?:string, taskDefinition?:string, computedDesiredCount?:int, pendingCount?:int, runningCount?:int, createdAt?:int|string|\DateTimeInterface, updatedAt?:int|string|\DateTimeInterface, launchType?:"EC2"|"FARGATE"|"EXTERNAL", capacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, platformVersion?:string, platformFamily?:string, networkConfiguration?:array{awsvpcConfiguration?:array{subnets:array<string>, securityGroups?:array<string>, assignPublicIp?:"ENABLED"|"DISABLED"}}, loadBalancers?:array<array{targetGroupArn?:string, loadBalancerName?:string, containerName?:string, containerPort?:int}>, serviceRegistries?:array<array{registryArn?:string, port?:int, containerName?:string, containerPort?:int}>, scale?:array{value?:float, unit?:"PERCENT"}, stabilityStatus?:"STEADY_STATE"|"STABILIZING", stabilityStatusAt?:int|string|\DateTimeInterface, tags?:array<array{key?:string, value?:string}>, fargateEphemeralStorage?:array{kmsKeyId?:string}}>, deployments?:array<array{id?:string, status?:string, taskDefinition?:string, desiredCount?:int, pendingCount?:int, runningCount?:int, failedTasks?:int, createdAt?:int|string|\DateTimeInterface, updatedAt?:int|string|\DateTimeInterface, capacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, launchType?:"EC2"|"FARGATE"|"EXTERNAL", platformVersion?:string, platformFamily?:string, networkConfiguration?:array{awsvpcConfiguration?:array{subnets:array<string>, securityGroups?:array<string>, assignPublicIp?:"ENABLED"|"DISABLED"}}, rolloutState?:"COMPLETED"|"FAILED"|"IN_PROGRESS", rolloutStateReason?:string, serviceConnectConfiguration?:array{enabled:bool, namespace?:string, services?:mixed, logConfiguration?:array{logDriver:"json-file"|"syslog"|"journald"|"gelf"|"fluentd"|"awslogs"|"splunk"|"awsfirelens", options?:array<string, string>, secretOptions?:array<array{name:string, valueFrom:string}>}}, serviceConnectResources?:array<array{discoveryName?:string, discoveryArn?:string}>, volumeConfigurations?:array<array{name:string, managedEBSVolume?:array{encrypted?:bool, kmsKeyId?:string, volumeType?:string, sizeInGiB?:int, snapshotId?:string, iops?:int, throughput?:int, tagSpecifications?:array<array{resourceType:"volume", tags?:array<array{key?:string, value?:string}>, propagateTags?:"TASK_DEFINITION"|"SERVICE"|"NONE"}>, roleArn:string, filesystemType?:"ext3"|"ext4"|"xfs"|"ntfs"}}>, fargateEphemeralStorage?:array{kmsKeyId?:string}, vpcLatticeConfigurations?:array<array{roleArn:string, targetGroupArn:string, portName:string}>}>, roleArn?:string, events?:array<array{id?:string, createdAt?:int|string|\DateTimeInterface, message?:string}>, createdAt?:int|string|\DateTimeInterface, placementConstraints?:array<array{type?:"distinctInstance"|"memberOf", expression?:string}>, placementStrategy?:array<array{type?:"random"|"spread"|"binpack", field?:string}>, networkConfiguration?:array{awsvpcConfiguration?:array{subnets:array<string>, securityGroups?:array<string>, assignPublicIp?:"ENABLED"|"DISABLED"}}, healthCheckGracePeriodSeconds?:int, schedulingStrategy?:"REPLICA"|"DAEMON", deploymentController?:array{type:"ECS"|"CODE_DEPLOY"|"EXTERNAL"}, tags?:array<array{key?:string, value?:string}>, createdBy?:string, enableECSManagedTags?:bool, propagateTags?:"TASK_DEFINITION"|"SERVICE"|"NONE", enableExecuteCommand?:bool, availabilityZoneRebalancing?:"ENABLED"|"DISABLED"}>, failures?:array<array{arn?:string, reason?:string, detail?:string}>}>
     */
    public function describeServicesAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{taskDefinition:string, include?:array<"TAGS">} $args
     * @return \AWS\Result<array{taskDefinition?:array{taskDefinitionArn?:string, containerDefinitions?:array<array{name?:string, image?:string, repositoryCredentials?:array{credentialsParameter:string}, cpu?:int, memory?:int, memoryReservation?:int, links?:array<string>, portMappings?:array<array{containerPort?:int, hostPort?:int, protocol?:"tcp"|"udp", name?:string, appProtocol?:"http"|"http2"|"grpc", containerPortRange?:string}>, essential?:bool, restartPolicy?:array{enabled:bool, ignoredExitCodes?:array<int>, restartAttemptPeriod?:int}, entryPoint?:array<string>, command?:array<string>, environment?:array<array{name?:string, value?:string}>, environmentFiles?:array<array{value:string, type:"s3"}>, mountPoints?:array<array{sourceVolume?:string, containerPath?:string, readOnly?:bool}>, volumesFrom?:array<array{sourceContainer?:string, readOnly?:bool}>, linuxParameters?:array{capabilities?:array{add?:array<string>, drop?:array<string>}, devices?:array<array{hostPath:string, containerPath?:string, permissions?:array<"read"|"write"|"mknod">}>, initProcessEnabled?:bool, sharedMemorySize?:int, tmpfs?:array<array{containerPath:string, size:int, mountOptions?:array<string>}>, maxSwap?:int, swappiness?:int}, secrets?:array<array{name:string, valueFrom:string}>, dependsOn?:array<array{containerName:string, condition:"START"|"COMPLETE"|"SUCCESS"|"HEALTHY"}>, startTimeout?:int, stopTimeout?:int, versionConsistency?:"enabled"|"disabled", hostname?:string, user?:string, workingDirectory?:string, disableNetworking?:bool, privileged?:bool, readonlyRootFilesystem?:bool, dnsServers?:array<string>, dnsSearchDomains?:array<string>, extraHosts?:array<array{hostname:string, ipAddress:string}>, dockerSecurityOptions?:array<string>, interactive?:bool, pseudoTerminal?:bool, dockerLabels?:array<string, string>, ulimits?:array<array{name:"core"|"cpu"|"data"|"fsize"|"locks"|"memlock"|"msgqueue"|"nice"|"nofile"|"nproc"|"rss"|"rtprio"|"rttime"|"sigpending"|"stack", softLimit:int, hardLimit:int}>, logConfiguration?:array{logDriver:"json-file"|"syslog"|"journald"|"gelf"|"fluentd"|"awslogs"|"splunk"|"awsfirelens", options?:array<string, string>, secretOptions?:array<array{name:string, valueFrom:string}>}, healthCheck?:array{command:array<string>, interval?:int, timeout?:int, retries?:int, startPeriod?:int}, systemControls?:array<array{namespace?:string, value?:string}>, resourceRequirements?:array<array{value:string, type:"GPU"|"InferenceAccelerator"}>, firelensConfiguration?:array{type:"fluentd"|"fluentbit", options?:array<string, string>}, credentialSpecs?:array<string>}>, family?:string, taskRoleArn?:string, executionRoleArn?:string, networkMode?:"bridge"|"host"|"awsvpc"|"none", revision?:int, volumes?:array<array{name?:string, host?:array{sourcePath?:string}, dockerVolumeConfiguration?:array{scope?:"task"|"shared", autoprovision?:bool, driver?:string, driverOpts?:array<string, string>, labels?:array<string, string>}, efsVolumeConfiguration?:array{fileSystemId:string, rootDirectory?:string, transitEncryption?:"ENABLED"|"DISABLED", transitEncryptionPort?:int, authorizationConfig?:array{accessPointId?:string, iam?:"ENABLED"|"DISABLED"}}, fsxWindowsFileServerVolumeConfiguration?:array{fileSystemId:string, rootDirectory:string, authorizationConfig:array{credentialsParameter:string, domain:string}}, configuredAtLaunch?:bool}>, status?:"ACTIVE"|"INACTIVE"|"DELETE_IN_PROGRESS", requiresAttributes?:array<array{name:string, value?:string, targetType?:"container-instance", targetId?:string}>, placementConstraints?:array<array{type?:"memberOf", expression?:string}>, compatibilities?:array<"EC2"|"FARGATE"|"EXTERNAL">, runtimePlatform?:array{cpuArchitecture?:"X86_64"|"ARM64", operatingSystemFamily?:"WINDOWS_SERVER_2019_FULL"|"WINDOWS_SERVER_2019_CORE"|"WINDOWS_SERVER_2016_FULL"|"WINDOWS_SERVER_2004_CORE"|"WINDOWS_SERVER_2022_CORE"|"WINDOWS_SERVER_2022_FULL"|"WINDOWS_SERVER_20H2_CORE"|"LINUX"}, requiresCompatibilities?:array<"EC2"|"FARGATE"|"EXTERNAL">, cpu?:string, memory?:string, inferenceAccelerators?:array<array{deviceName:string, deviceType:string}>, pidMode?:"host"|"task", ipcMode?:"host"|"task"|"none", proxyConfiguration?:array{type?:"APPMESH", containerName:string, properties?:array<array{name?:string, value?:string}>}, registeredAt?:int|string|\DateTimeInterface, deregisteredAt?:int|string|\DateTimeInterface, registeredBy?:string, ephemeralStorage?:array{sizeInGiB:int}, enableFaultInjection?:bool}, tags?:array<array{key?:string, value?:string}>}>
     */
    public function describeTaskDefinition(array $args): \AWS\Result { }

    /**
     * @param array{taskDefinition:string, include?:array<"TAGS">} $args
     * @return \GuzzleHttp\Promise\Promise<array{taskDefinition?:array{taskDefinitionArn?:string, containerDefinitions?:array<array{name?:string, image?:string, repositoryCredentials?:array{credentialsParameter:string}, cpu?:int, memory?:int, memoryReservation?:int, links?:array<string>, portMappings?:array<array{containerPort?:int, hostPort?:int, protocol?:"tcp"|"udp", name?:string, appProtocol?:"http"|"http2"|"grpc", containerPortRange?:string}>, essential?:bool, restartPolicy?:array{enabled:bool, ignoredExitCodes?:array<int>, restartAttemptPeriod?:int}, entryPoint?:array<string>, command?:array<string>, environment?:array<array{name?:string, value?:string}>, environmentFiles?:array<array{value:string, type:"s3"}>, mountPoints?:array<array{sourceVolume?:string, containerPath?:string, readOnly?:bool}>, volumesFrom?:array<array{sourceContainer?:string, readOnly?:bool}>, linuxParameters?:array{capabilities?:array{add?:array<string>, drop?:array<string>}, devices?:array<array{hostPath:string, containerPath?:string, permissions?:array<"read"|"write"|"mknod">}>, initProcessEnabled?:bool, sharedMemorySize?:int, tmpfs?:array<array{containerPath:string, size:int, mountOptions?:array<string>}>, maxSwap?:int, swappiness?:int}, secrets?:array<array{name:string, valueFrom:string}>, dependsOn?:array<array{containerName:string, condition:"START"|"COMPLETE"|"SUCCESS"|"HEALTHY"}>, startTimeout?:int, stopTimeout?:int, versionConsistency?:"enabled"|"disabled", hostname?:string, user?:string, workingDirectory?:string, disableNetworking?:bool, privileged?:bool, readonlyRootFilesystem?:bool, dnsServers?:array<string>, dnsSearchDomains?:array<string>, extraHosts?:array<array{hostname:string, ipAddress:string}>, dockerSecurityOptions?:array<string>, interactive?:bool, pseudoTerminal?:bool, dockerLabels?:array<string, string>, ulimits?:array<array{name:"core"|"cpu"|"data"|"fsize"|"locks"|"memlock"|"msgqueue"|"nice"|"nofile"|"nproc"|"rss"|"rtprio"|"rttime"|"sigpending"|"stack", softLimit:int, hardLimit:int}>, logConfiguration?:array{logDriver:"json-file"|"syslog"|"journald"|"gelf"|"fluentd"|"awslogs"|"splunk"|"awsfirelens", options?:array<string, string>, secretOptions?:array<array{name:string, valueFrom:string}>}, healthCheck?:array{command:array<string>, interval?:int, timeout?:int, retries?:int, startPeriod?:int}, systemControls?:array<array{namespace?:string, value?:string}>, resourceRequirements?:array<array{value:string, type:"GPU"|"InferenceAccelerator"}>, firelensConfiguration?:array{type:"fluentd"|"fluentbit", options?:array<string, string>}, credentialSpecs?:array<string>}>, family?:string, taskRoleArn?:string, executionRoleArn?:string, networkMode?:"bridge"|"host"|"awsvpc"|"none", revision?:int, volumes?:array<array{name?:string, host?:array{sourcePath?:string}, dockerVolumeConfiguration?:array{scope?:"task"|"shared", autoprovision?:bool, driver?:string, driverOpts?:array<string, string>, labels?:array<string, string>}, efsVolumeConfiguration?:array{fileSystemId:string, rootDirectory?:string, transitEncryption?:"ENABLED"|"DISABLED", transitEncryptionPort?:int, authorizationConfig?:array{accessPointId?:string, iam?:"ENABLED"|"DISABLED"}}, fsxWindowsFileServerVolumeConfiguration?:array{fileSystemId:string, rootDirectory:string, authorizationConfig:array{credentialsParameter:string, domain:string}}, configuredAtLaunch?:bool}>, status?:"ACTIVE"|"INACTIVE"|"DELETE_IN_PROGRESS", requiresAttributes?:array<array{name:string, value?:string, targetType?:"container-instance", targetId?:string}>, placementConstraints?:array<array{type?:"memberOf", expression?:string}>, compatibilities?:array<"EC2"|"FARGATE"|"EXTERNAL">, runtimePlatform?:array{cpuArchitecture?:"X86_64"|"ARM64", operatingSystemFamily?:"WINDOWS_SERVER_2019_FULL"|"WINDOWS_SERVER_2019_CORE"|"WINDOWS_SERVER_2016_FULL"|"WINDOWS_SERVER_2004_CORE"|"WINDOWS_SERVER_2022_CORE"|"WINDOWS_SERVER_2022_FULL"|"WINDOWS_SERVER_20H2_CORE"|"LINUX"}, requiresCompatibilities?:array<"EC2"|"FARGATE"|"EXTERNAL">, cpu?:string, memory?:string, inferenceAccelerators?:array<array{deviceName:string, deviceType:string}>, pidMode?:"host"|"task", ipcMode?:"host"|"task"|"none", proxyConfiguration?:array{type?:"APPMESH", containerName:string, properties?:array<array{name?:string, value?:string}>}, registeredAt?:int|string|\DateTimeInterface, deregisteredAt?:int|string|\DateTimeInterface, registeredBy?:string, ephemeralStorage?:array{sizeInGiB:int}, enableFaultInjection?:bool}, tags?:array<array{key?:string, value?:string}>}>
     */
    public function describeTaskDefinitionAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{cluster:string, service:string, taskSets?:array<string>, include?:array<"TAGS">} $args
     * @return \AWS\Result<array{taskSets?:array<array{id?:string, taskSetArn?:string, serviceArn?:string, clusterArn?:string, startedBy?:string, externalId?:string, status?:string, taskDefinition?:string, computedDesiredCount?:int, pendingCount?:int, runningCount?:int, createdAt?:int|string|\DateTimeInterface, updatedAt?:int|string|\DateTimeInterface, launchType?:"EC2"|"FARGATE"|"EXTERNAL", capacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, platformVersion?:string, platformFamily?:string, networkConfiguration?:array{awsvpcConfiguration?:array{subnets:array<string>, securityGroups?:array<string>, assignPublicIp?:"ENABLED"|"DISABLED"}}, loadBalancers?:array<array{targetGroupArn?:string, loadBalancerName?:string, containerName?:string, containerPort?:int}>, serviceRegistries?:array<array{registryArn?:string, port?:int, containerName?:string, containerPort?:int}>, scale?:array{value?:float, unit?:"PERCENT"}, stabilityStatus?:"STEADY_STATE"|"STABILIZING", stabilityStatusAt?:int|string|\DateTimeInterface, tags?:array<array{key?:string, value?:string}>, fargateEphemeralStorage?:array{kmsKeyId?:string}}>, failures?:array<array{arn?:string, reason?:string, detail?:string}>}>
     */
    public function describeTaskSets(array $args): \AWS\Result { }

    /**
     * @param array{cluster:string, service:string, taskSets?:array<string>, include?:array<"TAGS">} $args
     * @return \GuzzleHttp\Promise\Promise<array{taskSets?:array<array{id?:string, taskSetArn?:string, serviceArn?:string, clusterArn?:string, startedBy?:string, externalId?:string, status?:string, taskDefinition?:string, computedDesiredCount?:int, pendingCount?:int, runningCount?:int, createdAt?:int|string|\DateTimeInterface, updatedAt?:int|string|\DateTimeInterface, launchType?:"EC2"|"FARGATE"|"EXTERNAL", capacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, platformVersion?:string, platformFamily?:string, networkConfiguration?:array{awsvpcConfiguration?:array{subnets:array<string>, securityGroups?:array<string>, assignPublicIp?:"ENABLED"|"DISABLED"}}, loadBalancers?:array<array{targetGroupArn?:string, loadBalancerName?:string, containerName?:string, containerPort?:int}>, serviceRegistries?:array<array{registryArn?:string, port?:int, containerName?:string, containerPort?:int}>, scale?:array{value?:float, unit?:"PERCENT"}, stabilityStatus?:"STEADY_STATE"|"STABILIZING", stabilityStatusAt?:int|string|\DateTimeInterface, tags?:array<array{key?:string, value?:string}>, fargateEphemeralStorage?:array{kmsKeyId?:string}}>, failures?:array<array{arn?:string, reason?:string, detail?:string}>}>
     */
    public function describeTaskSetsAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{cluster?:string, tasks:array<string>, include?:array<"TAGS">} $args
     * @return \AWS\Result<array{tasks?:array<array{attachments?:array<array{id?:string, type?:string, status?:string, details?:array<array{name?:string, value?:string}>}>, attributes?:array<array{name:string, value?:string, targetType?:"container-instance", targetId?:string}>, availabilityZone?:string, capacityProviderName?:string, clusterArn?:string, connectivity?:"CONNECTED"|"DISCONNECTED", connectivityAt?:int|string|\DateTimeInterface, containerInstanceArn?:string, containers?:array<array{containerArn?:string, taskArn?:string, name?:string, image?:string, imageDigest?:string, runtimeId?:string, lastStatus?:string, exitCode?:int, reason?:string, networkBindings?:array<array{bindIP?:string, containerPort?:int, hostPort?:int, protocol?:"tcp"|"udp", containerPortRange?:string, hostPortRange?:string}>, networkInterfaces?:array<array{attachmentId?:string, privateIpv4Address?:string, ipv6Address?:string}>, healthStatus?:"HEALTHY"|"UNHEALTHY"|"UNKNOWN", managedAgents?:array<array{lastStartedAt?:int|string|\DateTimeInterface, name?:"ExecuteCommandAgent", reason?:string, lastStatus?:string}>, cpu?:string, memory?:string, memoryReservation?:string, gpuIds?:array<string>}>, cpu?:string, createdAt?:int|string|\DateTimeInterface, desiredStatus?:string, enableExecuteCommand?:bool, executionStoppedAt?:int|string|\DateTimeInterface, group?:string, healthStatus?:"HEALTHY"|"UNHEALTHY"|"UNKNOWN", inferenceAccelerators?:array<array{deviceName:string, deviceType:string}>, lastStatus?:string, launchType?:"EC2"|"FARGATE"|"EXTERNAL", memory?:string, overrides?:array{containerOverrides?:array<array{name?:string, command?:array<string>, environment?:array<array{name?:string, value?:string}>, environmentFiles?:array<array{value:string, type:"s3"}>, cpu?:int, memory?:int, memoryReservation?:int, resourceRequirements?:array<array{value:string, type:"GPU"|"InferenceAccelerator"}>}>, cpu?:string, inferenceAcceleratorOverrides?:array<array{deviceName?:string, deviceType?:string}>, executionRoleArn?:string, memory?:string, taskRoleArn?:string, ephemeralStorage?:array{sizeInGiB:int}}, platformVersion?:string, platformFamily?:string, pullStartedAt?:int|string|\DateTimeInterface, pullStoppedAt?:int|string|\DateTimeInterface, startedAt?:int|string|\DateTimeInterface, startedBy?:string, stopCode?:"TaskFailedToStart"|"EssentialContainerExited"|"UserInitiated"|"ServiceSchedulerInitiated"|"SpotInterruption"|"TerminationNotice", stoppedAt?:int|string|\DateTimeInterface, stoppedReason?:string, stoppingAt?:int|string|\DateTimeInterface, tags?:array<array{key?:string, value?:string}>, taskArn?:string, taskDefinitionArn?:string, version?:int, ephemeralStorage?:array{sizeInGiB:int}, fargateEphemeralStorage?:array{sizeInGiB?:int, kmsKeyId?:string}}>, failures?:array<array{arn?:string, reason?:string, detail?:string}>}>
     */
    public function describeTasks(array $args): \AWS\Result { }

    /**
     * @param array{cluster?:string, tasks:array<string>, include?:array<"TAGS">} $args
     * @return \GuzzleHttp\Promise\Promise<array{tasks?:array<array{attachments?:array<array{id?:string, type?:string, status?:string, details?:array<array{name?:string, value?:string}>}>, attributes?:array<array{name:string, value?:string, targetType?:"container-instance", targetId?:string}>, availabilityZone?:string, capacityProviderName?:string, clusterArn?:string, connectivity?:"CONNECTED"|"DISCONNECTED", connectivityAt?:int|string|\DateTimeInterface, containerInstanceArn?:string, containers?:array<array{containerArn?:string, taskArn?:string, name?:string, image?:string, imageDigest?:string, runtimeId?:string, lastStatus?:string, exitCode?:int, reason?:string, networkBindings?:array<array{bindIP?:string, containerPort?:int, hostPort?:int, protocol?:"tcp"|"udp", containerPortRange?:string, hostPortRange?:string}>, networkInterfaces?:array<array{attachmentId?:string, privateIpv4Address?:string, ipv6Address?:string}>, healthStatus?:"HEALTHY"|"UNHEALTHY"|"UNKNOWN", managedAgents?:array<array{lastStartedAt?:int|string|\DateTimeInterface, name?:"ExecuteCommandAgent", reason?:string, lastStatus?:string}>, cpu?:string, memory?:string, memoryReservation?:string, gpuIds?:array<string>}>, cpu?:string, createdAt?:int|string|\DateTimeInterface, desiredStatus?:string, enableExecuteCommand?:bool, executionStoppedAt?:int|string|\DateTimeInterface, group?:string, healthStatus?:"HEALTHY"|"UNHEALTHY"|"UNKNOWN", inferenceAccelerators?:array<array{deviceName:string, deviceType:string}>, lastStatus?:string, launchType?:"EC2"|"FARGATE"|"EXTERNAL", memory?:string, overrides?:array{containerOverrides?:array<array{name?:string, command?:array<string>, environment?:array<array{name?:string, value?:string}>, environmentFiles?:array<array{value:string, type:"s3"}>, cpu?:int, memory?:int, memoryReservation?:int, resourceRequirements?:array<array{value:string, type:"GPU"|"InferenceAccelerator"}>}>, cpu?:string, inferenceAcceleratorOverrides?:array<array{deviceName?:string, deviceType?:string}>, executionRoleArn?:string, memory?:string, taskRoleArn?:string, ephemeralStorage?:array{sizeInGiB:int}}, platformVersion?:string, platformFamily?:string, pullStartedAt?:int|string|\DateTimeInterface, pullStoppedAt?:int|string|\DateTimeInterface, startedAt?:int|string|\DateTimeInterface, startedBy?:string, stopCode?:"TaskFailedToStart"|"EssentialContainerExited"|"UserInitiated"|"ServiceSchedulerInitiated"|"SpotInterruption"|"TerminationNotice", stoppedAt?:int|string|\DateTimeInterface, stoppedReason?:string, stoppingAt?:int|string|\DateTimeInterface, tags?:array<array{key?:string, value?:string}>, taskArn?:string, taskDefinitionArn?:string, version?:int, ephemeralStorage?:array{sizeInGiB:int}, fargateEphemeralStorage?:array{sizeInGiB?:int, kmsKeyId?:string}}>, failures?:array<array{arn?:string, reason?:string, detail?:string}>}>
     */
    public function describeTasksAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{containerInstance?:string, cluster?:string} $args
     * @return \AWS\Result<array{endpoint?:string, telemetryEndpoint?:string, serviceConnectEndpoint?:string}>
     */
    public function discoverPollEndpoint(array $args = []): \AWS\Result { }

    /**
     * @param array{containerInstance?:string, cluster?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{endpoint?:string, telemetryEndpoint?:string, serviceConnectEndpoint?:string}>
     */
    public function discoverPollEndpointAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{cluster?:string, container?:string, command:string, interactive:bool, task:string} $args
     * @return \AWS\Result<array{clusterArn?:string, containerArn?:string, containerName?:string, interactive?:bool, session?:array{sessionId?:string, streamUrl?:string, tokenValue?:string}, taskArn?:string}>
     */
    public function executeCommand(array $args): \AWS\Result { }

    /**
     * @param array{cluster?:string, container?:string, command:string, interactive:bool, task:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{clusterArn?:string, containerArn?:string, containerName?:string, interactive?:bool, session?:array{sessionId?:string, streamUrl?:string, tokenValue?:string}, taskArn?:string}>
     */
    public function executeCommandAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{cluster:string, tasks?:array<string>} $args
     * @return \AWS\Result<array{protectedTasks?:array<array{taskArn?:string, protectionEnabled?:bool, expirationDate?:int|string|\DateTimeInterface}>, failures?:array<array{arn?:string, reason?:string, detail?:string}>}>
     */
    public function getTaskProtection(array $args): \AWS\Result { }

    /**
     * @param array{cluster:string, tasks?:array<string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{protectedTasks?:array<array{taskArn?:string, protectionEnabled?:bool, expirationDate?:int|string|\DateTimeInterface}>, failures?:array<array{arn?:string, reason?:string, detail?:string}>}>
     */
    public function getTaskProtectionAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{name?:"serviceLongArnFormat"|"taskLongArnFormat"|"containerInstanceLongArnFormat"|"awsvpcTrunking"|"containerInsights"|"fargateFIPSMode"|"tagResourceAuthorization"|"fargateTaskRetirementWaitPeriod"|"guardDutyActivate", value?:string, principalArn?:string, effectiveSettings?:bool, nextToken?:string, maxResults?:int} $args
     * @return \AWS\Result<array{settings?:array<array{name?:"serviceLongArnFormat"|"taskLongArnFormat"|"containerInstanceLongArnFormat"|"awsvpcTrunking"|"containerInsights"|"fargateFIPSMode"|"tagResourceAuthorization"|"fargateTaskRetirementWaitPeriod"|"guardDutyActivate", value?:string, principalArn?:string, type?:"user"|"aws_managed"}>, nextToken?:string}>
     */
    public function listAccountSettings(array $args = []): \AWS\Result { }

    /**
     * @param array{name?:"serviceLongArnFormat"|"taskLongArnFormat"|"containerInstanceLongArnFormat"|"awsvpcTrunking"|"containerInsights"|"fargateFIPSMode"|"tagResourceAuthorization"|"fargateTaskRetirementWaitPeriod"|"guardDutyActivate", value?:string, principalArn?:string, effectiveSettings?:bool, nextToken?:string, maxResults?:int} $args
     * @return \GuzzleHttp\Promise\Promise<array{settings?:array<array{name?:"serviceLongArnFormat"|"taskLongArnFormat"|"containerInstanceLongArnFormat"|"awsvpcTrunking"|"containerInsights"|"fargateFIPSMode"|"tagResourceAuthorization"|"fargateTaskRetirementWaitPeriod"|"guardDutyActivate", value?:string, principalArn?:string, type?:"user"|"aws_managed"}>, nextToken?:string}>
     */
    public function listAccountSettingsAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{cluster?:string, targetType:"container-instance", attributeName?:string, attributeValue?:string, nextToken?:string, maxResults?:int} $args
     * @return \AWS\Result<array{attributes?:array<array{name:string, value?:string, targetType?:"container-instance", targetId?:string}>, nextToken?:string}>
     */
    public function listAttributes(array $args): \AWS\Result { }

    /**
     * @param array{cluster?:string, targetType:"container-instance", attributeName?:string, attributeValue?:string, nextToken?:string, maxResults?:int} $args
     * @return \GuzzleHttp\Promise\Promise<array{attributes?:array<array{name:string, value?:string, targetType?:"container-instance", targetId?:string}>, nextToken?:string}>
     */
    public function listAttributesAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{nextToken?:string, maxResults?:int} $args
     * @return \AWS\Result<array{clusterArns?:array<string>, nextToken?:string}>
     */
    public function listClusters(array $args = []): \AWS\Result { }

    /**
     * @param array{nextToken?:string, maxResults?:int} $args
     * @return \GuzzleHttp\Promise\Promise<array{clusterArns?:array<string>, nextToken?:string}>
     */
    public function listClustersAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{cluster?:string, filter?:string, nextToken?:string, maxResults?:int, status?:"ACTIVE"|"DRAINING"|"REGISTERING"|"DEREGISTERING"|"REGISTRATION_FAILED"} $args
     * @return \AWS\Result<array{containerInstanceArns?:array<string>, nextToken?:string}>
     */
    public function listContainerInstances(array $args = []): \AWS\Result { }

    /**
     * @param array{cluster?:string, filter?:string, nextToken?:string, maxResults?:int, status?:"ACTIVE"|"DRAINING"|"REGISTERING"|"DEREGISTERING"|"REGISTRATION_FAILED"} $args
     * @return \GuzzleHttp\Promise\Promise<array{containerInstanceArns?:array<string>, nextToken?:string}>
     */
    public function listContainerInstancesAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{service:string, cluster?:string, status?:array<"PENDING"|"SUCCESSFUL"|"STOPPED"|"STOP_REQUESTED"|"IN_PROGRESS"|"ROLLBACK_IN_PROGRESS"|"ROLLBACK_SUCCESSFUL"|"ROLLBACK_FAILED">, createdAt?:array{before?:int|string|\DateTimeInterface, after?:int|string|\DateTimeInterface}, nextToken?:string, maxResults?:int} $args
     * @return \AWS\Result<array{serviceDeployments?:array<array{serviceDeploymentArn?:string, serviceArn?:string, clusterArn?:string, startedAt?:int|string|\DateTimeInterface, createdAt?:int|string|\DateTimeInterface, finishedAt?:int|string|\DateTimeInterface, targetServiceRevisionArn?:string, status?:"PENDING"|"SUCCESSFUL"|"STOPPED"|"STOP_REQUESTED"|"IN_PROGRESS"|"ROLLBACK_IN_PROGRESS"|"ROLLBACK_SUCCESSFUL"|"ROLLBACK_FAILED", statusReason?:string}>, nextToken?:string}>
     */
    public function listServiceDeployments(array $args): \AWS\Result { }

    /**
     * @param array{service:string, cluster?:string, status?:array<"PENDING"|"SUCCESSFUL"|"STOPPED"|"STOP_REQUESTED"|"IN_PROGRESS"|"ROLLBACK_IN_PROGRESS"|"ROLLBACK_SUCCESSFUL"|"ROLLBACK_FAILED">, createdAt?:array{before?:int|string|\DateTimeInterface, after?:int|string|\DateTimeInterface}, nextToken?:string, maxResults?:int} $args
     * @return \GuzzleHttp\Promise\Promise<array{serviceDeployments?:array<array{serviceDeploymentArn?:string, serviceArn?:string, clusterArn?:string, startedAt?:int|string|\DateTimeInterface, createdAt?:int|string|\DateTimeInterface, finishedAt?:int|string|\DateTimeInterface, targetServiceRevisionArn?:string, status?:"PENDING"|"SUCCESSFUL"|"STOPPED"|"STOP_REQUESTED"|"IN_PROGRESS"|"ROLLBACK_IN_PROGRESS"|"ROLLBACK_SUCCESSFUL"|"ROLLBACK_FAILED", statusReason?:string}>, nextToken?:string}>
     */
    public function listServiceDeploymentsAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{cluster?:string, nextToken?:string, maxResults?:int, launchType?:"EC2"|"FARGATE"|"EXTERNAL", schedulingStrategy?:"REPLICA"|"DAEMON"} $args
     * @return \AWS\Result<array{serviceArns?:array<string>, nextToken?:string}>
     */
    public function listServices(array $args = []): \AWS\Result { }

    /**
     * @param array{cluster?:string, nextToken?:string, maxResults?:int, launchType?:"EC2"|"FARGATE"|"EXTERNAL", schedulingStrategy?:"REPLICA"|"DAEMON"} $args
     * @return \GuzzleHttp\Promise\Promise<array{serviceArns?:array<string>, nextToken?:string}>
     */
    public function listServicesAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{namespace:string, nextToken?:string, maxResults?:int} $args
     * @return \AWS\Result<array{serviceArns?:array<string>, nextToken?:string}>
     */
    public function listServicesByNamespace(array $args): \AWS\Result { }

    /**
     * @param array{namespace:string, nextToken?:string, maxResults?:int} $args
     * @return \GuzzleHttp\Promise\Promise<array{serviceArns?:array<string>, nextToken?:string}>
     */
    public function listServicesByNamespaceAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{resourceArn:string} $args
     * @return \AWS\Result<array{tags?:array<array{key?:string, value?:string}>}>
     */
    public function listTagsForResource(array $args): \AWS\Result { }

    /**
     * @param array{resourceArn:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{tags?:array<array{key?:string, value?:string}>}>
     */
    public function listTagsForResourceAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{familyPrefix?:string, status?:"ACTIVE"|"INACTIVE"|"ALL", nextToken?:string, maxResults?:int} $args
     * @return \AWS\Result<array{families?:array<string>, nextToken?:string}>
     */
    public function listTaskDefinitionFamilies(array $args = []): \AWS\Result { }

    /**
     * @param array{familyPrefix?:string, status?:"ACTIVE"|"INACTIVE"|"ALL", nextToken?:string, maxResults?:int} $args
     * @return \GuzzleHttp\Promise\Promise<array{families?:array<string>, nextToken?:string}>
     */
    public function listTaskDefinitionFamiliesAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{familyPrefix?:string, status?:"ACTIVE"|"INACTIVE"|"DELETE_IN_PROGRESS", sort?:"ASC"|"DESC", nextToken?:string, maxResults?:int} $args
     * @return \AWS\Result<array{taskDefinitionArns?:array<string>, nextToken?:string}>
     */
    public function listTaskDefinitions(array $args = []): \AWS\Result { }

    /**
     * @param array{familyPrefix?:string, status?:"ACTIVE"|"INACTIVE"|"DELETE_IN_PROGRESS", sort?:"ASC"|"DESC", nextToken?:string, maxResults?:int} $args
     * @return \GuzzleHttp\Promise\Promise<array{taskDefinitionArns?:array<string>, nextToken?:string}>
     */
    public function listTaskDefinitionsAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{cluster?:string, containerInstance?:string, family?:string, nextToken?:string, maxResults?:int, startedBy?:string, serviceName?:string, desiredStatus?:"RUNNING"|"PENDING"|"STOPPED", launchType?:"EC2"|"FARGATE"|"EXTERNAL"} $args
     * @return \AWS\Result<array{taskArns?:array<string>, nextToken?:string}>
     */
    public function listTasks(array $args = []): \AWS\Result { }

    /**
     * @param array{cluster?:string, containerInstance?:string, family?:string, nextToken?:string, maxResults?:int, startedBy?:string, serviceName?:string, desiredStatus?:"RUNNING"|"PENDING"|"STOPPED", launchType?:"EC2"|"FARGATE"|"EXTERNAL"} $args
     * @return \GuzzleHttp\Promise\Promise<array{taskArns?:array<string>, nextToken?:string}>
     */
    public function listTasksAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{name:"serviceLongArnFormat"|"taskLongArnFormat"|"containerInstanceLongArnFormat"|"awsvpcTrunking"|"containerInsights"|"fargateFIPSMode"|"tagResourceAuthorization"|"fargateTaskRetirementWaitPeriod"|"guardDutyActivate", value:string, principalArn?:string} $args
     * @return \AWS\Result<array{setting?:array{name?:"serviceLongArnFormat"|"taskLongArnFormat"|"containerInstanceLongArnFormat"|"awsvpcTrunking"|"containerInsights"|"fargateFIPSMode"|"tagResourceAuthorization"|"fargateTaskRetirementWaitPeriod"|"guardDutyActivate", value?:string, principalArn?:string, type?:"user"|"aws_managed"}}>
     */
    public function putAccountSetting(array $args): \AWS\Result { }

    /**
     * @param array{name:"serviceLongArnFormat"|"taskLongArnFormat"|"containerInstanceLongArnFormat"|"awsvpcTrunking"|"containerInsights"|"fargateFIPSMode"|"tagResourceAuthorization"|"fargateTaskRetirementWaitPeriod"|"guardDutyActivate", value:string, principalArn?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{setting?:array{name?:"serviceLongArnFormat"|"taskLongArnFormat"|"containerInstanceLongArnFormat"|"awsvpcTrunking"|"containerInsights"|"fargateFIPSMode"|"tagResourceAuthorization"|"fargateTaskRetirementWaitPeriod"|"guardDutyActivate", value?:string, principalArn?:string, type?:"user"|"aws_managed"}}>
     */
    public function putAccountSettingAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{name:"serviceLongArnFormat"|"taskLongArnFormat"|"containerInstanceLongArnFormat"|"awsvpcTrunking"|"containerInsights"|"fargateFIPSMode"|"tagResourceAuthorization"|"fargateTaskRetirementWaitPeriod"|"guardDutyActivate", value:string} $args
     * @return \AWS\Result<array{setting?:array{name?:"serviceLongArnFormat"|"taskLongArnFormat"|"containerInstanceLongArnFormat"|"awsvpcTrunking"|"containerInsights"|"fargateFIPSMode"|"tagResourceAuthorization"|"fargateTaskRetirementWaitPeriod"|"guardDutyActivate", value?:string, principalArn?:string, type?:"user"|"aws_managed"}}>
     */
    public function putAccountSettingDefault(array $args): \AWS\Result { }

    /**
     * @param array{name:"serviceLongArnFormat"|"taskLongArnFormat"|"containerInstanceLongArnFormat"|"awsvpcTrunking"|"containerInsights"|"fargateFIPSMode"|"tagResourceAuthorization"|"fargateTaskRetirementWaitPeriod"|"guardDutyActivate", value:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{setting?:array{name?:"serviceLongArnFormat"|"taskLongArnFormat"|"containerInstanceLongArnFormat"|"awsvpcTrunking"|"containerInsights"|"fargateFIPSMode"|"tagResourceAuthorization"|"fargateTaskRetirementWaitPeriod"|"guardDutyActivate", value?:string, principalArn?:string, type?:"user"|"aws_managed"}}>
     */
    public function putAccountSettingDefaultAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{cluster?:string, attributes:array<array{name:string, value?:string, targetType?:"container-instance", targetId?:string}>} $args
     * @return \AWS\Result<array{attributes?:array<array{name:string, value?:string, targetType?:"container-instance", targetId?:string}>}>
     */
    public function putAttributes(array $args): \AWS\Result { }

    /**
     * @param array{cluster?:string, attributes:array<array{name:string, value?:string, targetType?:"container-instance", targetId?:string}>} $args
     * @return \GuzzleHttp\Promise\Promise<array{attributes?:array<array{name:string, value?:string, targetType?:"container-instance", targetId?:string}>}>
     */
    public function putAttributesAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{cluster:string, capacityProviders:array<string>, defaultCapacityProviderStrategy:array<array{capacityProvider:string, weight?:int, base?:int}>} $args
     * @return \AWS\Result<array{cluster?:array{clusterArn?:string, clusterName?:string, configuration?:array{executeCommandConfiguration?:array{kmsKeyId?:string, logging?:"NONE"|"DEFAULT"|"OVERRIDE", logConfiguration?:array{cloudWatchLogGroupName?:string, cloudWatchEncryptionEnabled?:bool, s3BucketName?:string, s3EncryptionEnabled?:bool, s3KeyPrefix?:string}}, managedStorageConfiguration?:array{kmsKeyId?:string, fargateEphemeralStorageKmsKeyId?:string}}, status?:string, registeredContainerInstancesCount?:int, runningTasksCount?:int, pendingTasksCount?:int, activeServicesCount?:int, statistics?:array<array{name?:string, value?:string}>, tags?:array<array{key?:string, value?:string}>, settings?:array<array{name?:"containerInsights", value?:string}>, capacityProviders?:array<string>, defaultCapacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, attachments?:array<array{id?:string, type?:string, status?:string, details?:array<array{name?:string, value?:string}>}>, attachmentsStatus?:string, serviceConnectDefaults?:array{namespace?:string}}}>
     */
    public function putClusterCapacityProviders(array $args): \AWS\Result { }

    /**
     * @param array{cluster:string, capacityProviders:array<string>, defaultCapacityProviderStrategy:array<array{capacityProvider:string, weight?:int, base?:int}>} $args
     * @return \GuzzleHttp\Promise\Promise<array{cluster?:array{clusterArn?:string, clusterName?:string, configuration?:array{executeCommandConfiguration?:array{kmsKeyId?:string, logging?:"NONE"|"DEFAULT"|"OVERRIDE", logConfiguration?:array{cloudWatchLogGroupName?:string, cloudWatchEncryptionEnabled?:bool, s3BucketName?:string, s3EncryptionEnabled?:bool, s3KeyPrefix?:string}}, managedStorageConfiguration?:array{kmsKeyId?:string, fargateEphemeralStorageKmsKeyId?:string}}, status?:string, registeredContainerInstancesCount?:int, runningTasksCount?:int, pendingTasksCount?:int, activeServicesCount?:int, statistics?:array<array{name?:string, value?:string}>, tags?:array<array{key?:string, value?:string}>, settings?:array<array{name?:"containerInsights", value?:string}>, capacityProviders?:array<string>, defaultCapacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, attachments?:array<array{id?:string, type?:string, status?:string, details?:array<array{name?:string, value?:string}>}>, attachmentsStatus?:string, serviceConnectDefaults?:array{namespace?:string}}}>
     */
    public function putClusterCapacityProvidersAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{cluster?:string, instanceIdentityDocument?:string, instanceIdentityDocumentSignature?:string, totalResources?:array<array{name?:string, type?:string, doubleValue?:float, longValue?:int, integerValue?:int, stringSetValue?:array<string>}>, versionInfo?:array{agentVersion?:string, agentHash?:string, dockerVersion?:string}, containerInstanceArn?:string, attributes?:array<array{name:string, value?:string, targetType?:"container-instance", targetId?:string}>, platformDevices?:array<array{id:string, type:"GPU"}>, tags?:array<array{key?:string, value?:string}>} $args
     * @return \AWS\Result<array{containerInstance?:array{containerInstanceArn?:string, ec2InstanceId?:string, capacityProviderName?:string, version?:int, versionInfo?:array{agentVersion?:string, agentHash?:string, dockerVersion?:string}, remainingResources?:array<array{name?:string, type?:string, doubleValue?:float, longValue?:int, integerValue?:int, stringSetValue?:array<string>}>, registeredResources?:array<array{name?:string, type?:string, doubleValue?:float, longValue?:int, integerValue?:int, stringSetValue?:array<string>}>, status?:string, statusReason?:string, agentConnected?:bool, runningTasksCount?:int, pendingTasksCount?:int, agentUpdateStatus?:"PENDING"|"STAGING"|"STAGED"|"UPDATING"|"UPDATED"|"FAILED", attributes?:array<array{name:string, value?:string, targetType?:"container-instance", targetId?:string}>, registeredAt?:int|string|\DateTimeInterface, attachments?:array<array{id?:string, type?:string, status?:string, details?:array<array{name?:string, value?:string}>}>, tags?:array<array{key?:string, value?:string}>, healthStatus?:array{overallStatus?:"OK"|"IMPAIRED"|"INSUFFICIENT_DATA"|"INITIALIZING", details?:array<array{type?:"CONTAINER_RUNTIME", status?:"OK"|"IMPAIRED"|"INSUFFICIENT_DATA"|"INITIALIZING", lastUpdated?:int|string|\DateTimeInterface, lastStatusChange?:int|string|\DateTimeInterface}>}}}>
     */
    public function registerContainerInstance(array $args = []): \AWS\Result { }

    /**
     * @param array{cluster?:string, instanceIdentityDocument?:string, instanceIdentityDocumentSignature?:string, totalResources?:array<array{name?:string, type?:string, doubleValue?:float, longValue?:int, integerValue?:int, stringSetValue?:array<string>}>, versionInfo?:array{agentVersion?:string, agentHash?:string, dockerVersion?:string}, containerInstanceArn?:string, attributes?:array<array{name:string, value?:string, targetType?:"container-instance", targetId?:string}>, platformDevices?:array<array{id:string, type:"GPU"}>, tags?:array<array{key?:string, value?:string}>} $args
     * @return \GuzzleHttp\Promise\Promise<array{containerInstance?:array{containerInstanceArn?:string, ec2InstanceId?:string, capacityProviderName?:string, version?:int, versionInfo?:array{agentVersion?:string, agentHash?:string, dockerVersion?:string}, remainingResources?:array<array{name?:string, type?:string, doubleValue?:float, longValue?:int, integerValue?:int, stringSetValue?:array<string>}>, registeredResources?:array<array{name?:string, type?:string, doubleValue?:float, longValue?:int, integerValue?:int, stringSetValue?:array<string>}>, status?:string, statusReason?:string, agentConnected?:bool, runningTasksCount?:int, pendingTasksCount?:int, agentUpdateStatus?:"PENDING"|"STAGING"|"STAGED"|"UPDATING"|"UPDATED"|"FAILED", attributes?:array<array{name:string, value?:string, targetType?:"container-instance", targetId?:string}>, registeredAt?:int|string|\DateTimeInterface, attachments?:array<array{id?:string, type?:string, status?:string, details?:array<array{name?:string, value?:string}>}>, tags?:array<array{key?:string, value?:string}>, healthStatus?:array{overallStatus?:"OK"|"IMPAIRED"|"INSUFFICIENT_DATA"|"INITIALIZING", details?:array<array{type?:"CONTAINER_RUNTIME", status?:"OK"|"IMPAIRED"|"INSUFFICIENT_DATA"|"INITIALIZING", lastUpdated?:int|string|\DateTimeInterface, lastStatusChange?:int|string|\DateTimeInterface}>}}}>
     */
    public function registerContainerInstanceAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{family:string, taskRoleArn?:string, executionRoleArn?:string, networkMode?:"bridge"|"host"|"awsvpc"|"none", containerDefinitions:array<array{name?:string, image?:string, repositoryCredentials?:array{credentialsParameter:string}, cpu?:int, memory?:int, memoryReservation?:int, links?:array<string>, portMappings?:array<array{containerPort?:int, hostPort?:int, protocol?:"tcp"|"udp", name?:string, appProtocol?:"http"|"http2"|"grpc", containerPortRange?:string}>, essential?:bool, restartPolicy?:array{enabled:bool, ignoredExitCodes?:array<int>, restartAttemptPeriod?:int}, entryPoint?:array<string>, command?:array<string>, environment?:array<array{name?:string, value?:string}>, environmentFiles?:array<array{value:string, type:"s3"}>, mountPoints?:array<array{sourceVolume?:string, containerPath?:string, readOnly?:bool}>, volumesFrom?:array<array{sourceContainer?:string, readOnly?:bool}>, linuxParameters?:array{capabilities?:array{add?:array<string>, drop?:array<string>}, devices?:array<array{hostPath:string, containerPath?:string, permissions?:array<"read"|"write"|"mknod">}>, initProcessEnabled?:bool, sharedMemorySize?:int, tmpfs?:array<array{containerPath:string, size:int, mountOptions?:array<string>}>, maxSwap?:int, swappiness?:int}, secrets?:array<array{name:string, valueFrom:string}>, dependsOn?:array<array{containerName:string, condition:"START"|"COMPLETE"|"SUCCESS"|"HEALTHY"}>, startTimeout?:int, stopTimeout?:int, versionConsistency?:"enabled"|"disabled", hostname?:string, user?:string, workingDirectory?:string, disableNetworking?:bool, privileged?:bool, readonlyRootFilesystem?:bool, dnsServers?:array<string>, dnsSearchDomains?:array<string>, extraHosts?:array<array{hostname:string, ipAddress:string}>, dockerSecurityOptions?:array<string>, interactive?:bool, pseudoTerminal?:bool, dockerLabels?:array<string, string>, ulimits?:array<array{name:"core"|"cpu"|"data"|"fsize"|"locks"|"memlock"|"msgqueue"|"nice"|"nofile"|"nproc"|"rss"|"rtprio"|"rttime"|"sigpending"|"stack", softLimit:int, hardLimit:int}>, logConfiguration?:array{logDriver:"json-file"|"syslog"|"journald"|"gelf"|"fluentd"|"awslogs"|"splunk"|"awsfirelens", options?:array<string, string>, secretOptions?:array<array{name:string, valueFrom:string}>}, healthCheck?:array{command:array<string>, interval?:int, timeout?:int, retries?:int, startPeriod?:int}, systemControls?:array<array{namespace?:string, value?:string}>, resourceRequirements?:array<array{value:string, type:"GPU"|"InferenceAccelerator"}>, firelensConfiguration?:array{type:"fluentd"|"fluentbit", options?:array<string, string>}, credentialSpecs?:array<string>}>, volumes?:array<array{name?:string, host?:array{sourcePath?:string}, dockerVolumeConfiguration?:array{scope?:"task"|"shared", autoprovision?:bool, driver?:string, driverOpts?:array<string, string>, labels?:array<string, string>}, efsVolumeConfiguration?:array{fileSystemId:string, rootDirectory?:string, transitEncryption?:"ENABLED"|"DISABLED", transitEncryptionPort?:int, authorizationConfig?:array{accessPointId?:string, iam?:"ENABLED"|"DISABLED"}}, fsxWindowsFileServerVolumeConfiguration?:array{fileSystemId:string, rootDirectory:string, authorizationConfig:array{credentialsParameter:string, domain:string}}, configuredAtLaunch?:bool}>, placementConstraints?:array<array{type?:"memberOf", expression?:string}>, requiresCompatibilities?:array<"EC2"|"FARGATE"|"EXTERNAL">, cpu?:string, memory?:string, tags?:array<array{key?:string, value?:string}>, pidMode?:"host"|"task", ipcMode?:"host"|"task"|"none", proxyConfiguration?:array{type?:"APPMESH", containerName:string, properties?:array<array{name?:string, value?:string}>}, inferenceAccelerators?:array<array{deviceName:string, deviceType:string}>, ephemeralStorage?:array{sizeInGiB:int}, runtimePlatform?:array{cpuArchitecture?:"X86_64"|"ARM64", operatingSystemFamily?:"WINDOWS_SERVER_2019_FULL"|"WINDOWS_SERVER_2019_CORE"|"WINDOWS_SERVER_2016_FULL"|"WINDOWS_SERVER_2004_CORE"|"WINDOWS_SERVER_2022_CORE"|"WINDOWS_SERVER_2022_FULL"|"WINDOWS_SERVER_20H2_CORE"|"LINUX"}, enableFaultInjection?:bool} $args
     * @return \AWS\Result<array{taskDefinition?:array{taskDefinitionArn?:string, containerDefinitions?:array<array{name?:string, image?:string, repositoryCredentials?:array{credentialsParameter:string}, cpu?:int, memory?:int, memoryReservation?:int, links?:array<string>, portMappings?:array<array{containerPort?:int, hostPort?:int, protocol?:"tcp"|"udp", name?:string, appProtocol?:"http"|"http2"|"grpc", containerPortRange?:string}>, essential?:bool, restartPolicy?:array{enabled:bool, ignoredExitCodes?:array<int>, restartAttemptPeriod?:int}, entryPoint?:array<string>, command?:array<string>, environment?:array<array{name?:string, value?:string}>, environmentFiles?:array<array{value:string, type:"s3"}>, mountPoints?:array<array{sourceVolume?:string, containerPath?:string, readOnly?:bool}>, volumesFrom?:array<array{sourceContainer?:string, readOnly?:bool}>, linuxParameters?:array{capabilities?:array{add?:array<string>, drop?:array<string>}, devices?:array<array{hostPath:string, containerPath?:string, permissions?:array<"read"|"write"|"mknod">}>, initProcessEnabled?:bool, sharedMemorySize?:int, tmpfs?:array<array{containerPath:string, size:int, mountOptions?:array<string>}>, maxSwap?:int, swappiness?:int}, secrets?:array<array{name:string, valueFrom:string}>, dependsOn?:array<array{containerName:string, condition:"START"|"COMPLETE"|"SUCCESS"|"HEALTHY"}>, startTimeout?:int, stopTimeout?:int, versionConsistency?:"enabled"|"disabled", hostname?:string, user?:string, workingDirectory?:string, disableNetworking?:bool, privileged?:bool, readonlyRootFilesystem?:bool, dnsServers?:array<string>, dnsSearchDomains?:array<string>, extraHosts?:array<array{hostname:string, ipAddress:string}>, dockerSecurityOptions?:array<string>, interactive?:bool, pseudoTerminal?:bool, dockerLabels?:array<string, string>, ulimits?:array<array{name:"core"|"cpu"|"data"|"fsize"|"locks"|"memlock"|"msgqueue"|"nice"|"nofile"|"nproc"|"rss"|"rtprio"|"rttime"|"sigpending"|"stack", softLimit:int, hardLimit:int}>, logConfiguration?:array{logDriver:"json-file"|"syslog"|"journald"|"gelf"|"fluentd"|"awslogs"|"splunk"|"awsfirelens", options?:array<string, string>, secretOptions?:array<array{name:string, valueFrom:string}>}, healthCheck?:array{command:array<string>, interval?:int, timeout?:int, retries?:int, startPeriod?:int}, systemControls?:array<array{namespace?:string, value?:string}>, resourceRequirements?:array<array{value:string, type:"GPU"|"InferenceAccelerator"}>, firelensConfiguration?:array{type:"fluentd"|"fluentbit", options?:array<string, string>}, credentialSpecs?:array<string>}>, family?:string, taskRoleArn?:string, executionRoleArn?:string, networkMode?:"bridge"|"host"|"awsvpc"|"none", revision?:int, volumes?:array<array{name?:string, host?:array{sourcePath?:string}, dockerVolumeConfiguration?:array{scope?:"task"|"shared", autoprovision?:bool, driver?:string, driverOpts?:array<string, string>, labels?:array<string, string>}, efsVolumeConfiguration?:array{fileSystemId:string, rootDirectory?:string, transitEncryption?:"ENABLED"|"DISABLED", transitEncryptionPort?:int, authorizationConfig?:array{accessPointId?:string, iam?:"ENABLED"|"DISABLED"}}, fsxWindowsFileServerVolumeConfiguration?:array{fileSystemId:string, rootDirectory:string, authorizationConfig:array{credentialsParameter:string, domain:string}}, configuredAtLaunch?:bool}>, status?:"ACTIVE"|"INACTIVE"|"DELETE_IN_PROGRESS", requiresAttributes?:array<array{name:string, value?:string, targetType?:"container-instance", targetId?:string}>, placementConstraints?:array<array{type?:"memberOf", expression?:string}>, compatibilities?:array<"EC2"|"FARGATE"|"EXTERNAL">, runtimePlatform?:array{cpuArchitecture?:"X86_64"|"ARM64", operatingSystemFamily?:"WINDOWS_SERVER_2019_FULL"|"WINDOWS_SERVER_2019_CORE"|"WINDOWS_SERVER_2016_FULL"|"WINDOWS_SERVER_2004_CORE"|"WINDOWS_SERVER_2022_CORE"|"WINDOWS_SERVER_2022_FULL"|"WINDOWS_SERVER_20H2_CORE"|"LINUX"}, requiresCompatibilities?:array<"EC2"|"FARGATE"|"EXTERNAL">, cpu?:string, memory?:string, inferenceAccelerators?:array<array{deviceName:string, deviceType:string}>, pidMode?:"host"|"task", ipcMode?:"host"|"task"|"none", proxyConfiguration?:array{type?:"APPMESH", containerName:string, properties?:array<array{name?:string, value?:string}>}, registeredAt?:int|string|\DateTimeInterface, deregisteredAt?:int|string|\DateTimeInterface, registeredBy?:string, ephemeralStorage?:array{sizeInGiB:int}, enableFaultInjection?:bool}, tags?:array<array{key?:string, value?:string}>}>
     */
    public function registerTaskDefinition(array $args): \AWS\Result { }

    /**
     * @param array{family:string, taskRoleArn?:string, executionRoleArn?:string, networkMode?:"bridge"|"host"|"awsvpc"|"none", containerDefinitions:array<array{name?:string, image?:string, repositoryCredentials?:array{credentialsParameter:string}, cpu?:int, memory?:int, memoryReservation?:int, links?:array<string>, portMappings?:array<array{containerPort?:int, hostPort?:int, protocol?:"tcp"|"udp", name?:string, appProtocol?:"http"|"http2"|"grpc", containerPortRange?:string}>, essential?:bool, restartPolicy?:array{enabled:bool, ignoredExitCodes?:array<int>, restartAttemptPeriod?:int}, entryPoint?:array<string>, command?:array<string>, environment?:array<array{name?:string, value?:string}>, environmentFiles?:array<array{value:string, type:"s3"}>, mountPoints?:array<array{sourceVolume?:string, containerPath?:string, readOnly?:bool}>, volumesFrom?:array<array{sourceContainer?:string, readOnly?:bool}>, linuxParameters?:array{capabilities?:array{add?:array<string>, drop?:array<string>}, devices?:array<array{hostPath:string, containerPath?:string, permissions?:array<"read"|"write"|"mknod">}>, initProcessEnabled?:bool, sharedMemorySize?:int, tmpfs?:array<array{containerPath:string, size:int, mountOptions?:array<string>}>, maxSwap?:int, swappiness?:int}, secrets?:array<array{name:string, valueFrom:string}>, dependsOn?:array<array{containerName:string, condition:"START"|"COMPLETE"|"SUCCESS"|"HEALTHY"}>, startTimeout?:int, stopTimeout?:int, versionConsistency?:"enabled"|"disabled", hostname?:string, user?:string, workingDirectory?:string, disableNetworking?:bool, privileged?:bool, readonlyRootFilesystem?:bool, dnsServers?:array<string>, dnsSearchDomains?:array<string>, extraHosts?:array<array{hostname:string, ipAddress:string}>, dockerSecurityOptions?:array<string>, interactive?:bool, pseudoTerminal?:bool, dockerLabels?:array<string, string>, ulimits?:array<array{name:"core"|"cpu"|"data"|"fsize"|"locks"|"memlock"|"msgqueue"|"nice"|"nofile"|"nproc"|"rss"|"rtprio"|"rttime"|"sigpending"|"stack", softLimit:int, hardLimit:int}>, logConfiguration?:array{logDriver:"json-file"|"syslog"|"journald"|"gelf"|"fluentd"|"awslogs"|"splunk"|"awsfirelens", options?:array<string, string>, secretOptions?:array<array{name:string, valueFrom:string}>}, healthCheck?:array{command:array<string>, interval?:int, timeout?:int, retries?:int, startPeriod?:int}, systemControls?:array<array{namespace?:string, value?:string}>, resourceRequirements?:array<array{value:string, type:"GPU"|"InferenceAccelerator"}>, firelensConfiguration?:array{type:"fluentd"|"fluentbit", options?:array<string, string>}, credentialSpecs?:array<string>}>, volumes?:array<array{name?:string, host?:array{sourcePath?:string}, dockerVolumeConfiguration?:array{scope?:"task"|"shared", autoprovision?:bool, driver?:string, driverOpts?:array<string, string>, labels?:array<string, string>}, efsVolumeConfiguration?:array{fileSystemId:string, rootDirectory?:string, transitEncryption?:"ENABLED"|"DISABLED", transitEncryptionPort?:int, authorizationConfig?:array{accessPointId?:string, iam?:"ENABLED"|"DISABLED"}}, fsxWindowsFileServerVolumeConfiguration?:array{fileSystemId:string, rootDirectory:string, authorizationConfig:array{credentialsParameter:string, domain:string}}, configuredAtLaunch?:bool}>, placementConstraints?:array<array{type?:"memberOf", expression?:string}>, requiresCompatibilities?:array<"EC2"|"FARGATE"|"EXTERNAL">, cpu?:string, memory?:string, tags?:array<array{key?:string, value?:string}>, pidMode?:"host"|"task", ipcMode?:"host"|"task"|"none", proxyConfiguration?:array{type?:"APPMESH", containerName:string, properties?:array<array{name?:string, value?:string}>}, inferenceAccelerators?:array<array{deviceName:string, deviceType:string}>, ephemeralStorage?:array{sizeInGiB:int}, runtimePlatform?:array{cpuArchitecture?:"X86_64"|"ARM64", operatingSystemFamily?:"WINDOWS_SERVER_2019_FULL"|"WINDOWS_SERVER_2019_CORE"|"WINDOWS_SERVER_2016_FULL"|"WINDOWS_SERVER_2004_CORE"|"WINDOWS_SERVER_2022_CORE"|"WINDOWS_SERVER_2022_FULL"|"WINDOWS_SERVER_20H2_CORE"|"LINUX"}, enableFaultInjection?:bool} $args
     * @return \GuzzleHttp\Promise\Promise<array{taskDefinition?:array{taskDefinitionArn?:string, containerDefinitions?:array<array{name?:string, image?:string, repositoryCredentials?:array{credentialsParameter:string}, cpu?:int, memory?:int, memoryReservation?:int, links?:array<string>, portMappings?:array<array{containerPort?:int, hostPort?:int, protocol?:"tcp"|"udp", name?:string, appProtocol?:"http"|"http2"|"grpc", containerPortRange?:string}>, essential?:bool, restartPolicy?:array{enabled:bool, ignoredExitCodes?:array<int>, restartAttemptPeriod?:int}, entryPoint?:array<string>, command?:array<string>, environment?:array<array{name?:string, value?:string}>, environmentFiles?:array<array{value:string, type:"s3"}>, mountPoints?:array<array{sourceVolume?:string, containerPath?:string, readOnly?:bool}>, volumesFrom?:array<array{sourceContainer?:string, readOnly?:bool}>, linuxParameters?:array{capabilities?:array{add?:array<string>, drop?:array<string>}, devices?:array<array{hostPath:string, containerPath?:string, permissions?:array<"read"|"write"|"mknod">}>, initProcessEnabled?:bool, sharedMemorySize?:int, tmpfs?:array<array{containerPath:string, size:int, mountOptions?:array<string>}>, maxSwap?:int, swappiness?:int}, secrets?:array<array{name:string, valueFrom:string}>, dependsOn?:array<array{containerName:string, condition:"START"|"COMPLETE"|"SUCCESS"|"HEALTHY"}>, startTimeout?:int, stopTimeout?:int, versionConsistency?:"enabled"|"disabled", hostname?:string, user?:string, workingDirectory?:string, disableNetworking?:bool, privileged?:bool, readonlyRootFilesystem?:bool, dnsServers?:array<string>, dnsSearchDomains?:array<string>, extraHosts?:array<array{hostname:string, ipAddress:string}>, dockerSecurityOptions?:array<string>, interactive?:bool, pseudoTerminal?:bool, dockerLabels?:array<string, string>, ulimits?:array<array{name:"core"|"cpu"|"data"|"fsize"|"locks"|"memlock"|"msgqueue"|"nice"|"nofile"|"nproc"|"rss"|"rtprio"|"rttime"|"sigpending"|"stack", softLimit:int, hardLimit:int}>, logConfiguration?:array{logDriver:"json-file"|"syslog"|"journald"|"gelf"|"fluentd"|"awslogs"|"splunk"|"awsfirelens", options?:array<string, string>, secretOptions?:array<array{name:string, valueFrom:string}>}, healthCheck?:array{command:array<string>, interval?:int, timeout?:int, retries?:int, startPeriod?:int}, systemControls?:array<array{namespace?:string, value?:string}>, resourceRequirements?:array<array{value:string, type:"GPU"|"InferenceAccelerator"}>, firelensConfiguration?:array{type:"fluentd"|"fluentbit", options?:array<string, string>}, credentialSpecs?:array<string>}>, family?:string, taskRoleArn?:string, executionRoleArn?:string, networkMode?:"bridge"|"host"|"awsvpc"|"none", revision?:int, volumes?:array<array{name?:string, host?:array{sourcePath?:string}, dockerVolumeConfiguration?:array{scope?:"task"|"shared", autoprovision?:bool, driver?:string, driverOpts?:array<string, string>, labels?:array<string, string>}, efsVolumeConfiguration?:array{fileSystemId:string, rootDirectory?:string, transitEncryption?:"ENABLED"|"DISABLED", transitEncryptionPort?:int, authorizationConfig?:array{accessPointId?:string, iam?:"ENABLED"|"DISABLED"}}, fsxWindowsFileServerVolumeConfiguration?:array{fileSystemId:string, rootDirectory:string, authorizationConfig:array{credentialsParameter:string, domain:string}}, configuredAtLaunch?:bool}>, status?:"ACTIVE"|"INACTIVE"|"DELETE_IN_PROGRESS", requiresAttributes?:array<array{name:string, value?:string, targetType?:"container-instance", targetId?:string}>, placementConstraints?:array<array{type?:"memberOf", expression?:string}>, compatibilities?:array<"EC2"|"FARGATE"|"EXTERNAL">, runtimePlatform?:array{cpuArchitecture?:"X86_64"|"ARM64", operatingSystemFamily?:"WINDOWS_SERVER_2019_FULL"|"WINDOWS_SERVER_2019_CORE"|"WINDOWS_SERVER_2016_FULL"|"WINDOWS_SERVER_2004_CORE"|"WINDOWS_SERVER_2022_CORE"|"WINDOWS_SERVER_2022_FULL"|"WINDOWS_SERVER_20H2_CORE"|"LINUX"}, requiresCompatibilities?:array<"EC2"|"FARGATE"|"EXTERNAL">, cpu?:string, memory?:string, inferenceAccelerators?:array<array{deviceName:string, deviceType:string}>, pidMode?:"host"|"task", ipcMode?:"host"|"task"|"none", proxyConfiguration?:array{type?:"APPMESH", containerName:string, properties?:array<array{name?:string, value?:string}>}, registeredAt?:int|string|\DateTimeInterface, deregisteredAt?:int|string|\DateTimeInterface, registeredBy?:string, ephemeralStorage?:array{sizeInGiB:int}, enableFaultInjection?:bool}, tags?:array<array{key?:string, value?:string}>}>
     */
    public function registerTaskDefinitionAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{capacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, cluster?:string, count?:int, enableECSManagedTags?:bool, enableExecuteCommand?:bool, group?:string, launchType?:"EC2"|"FARGATE"|"EXTERNAL", networkConfiguration?:array{awsvpcConfiguration?:array{subnets:array<string>, securityGroups?:array<string>, assignPublicIp?:"ENABLED"|"DISABLED"}}, overrides?:array{containerOverrides?:array<array{name?:string, command?:array<string>, environment?:array<array{name?:string, value?:string}>, environmentFiles?:array<array{value:string, type:"s3"}>, cpu?:int, memory?:int, memoryReservation?:int, resourceRequirements?:array<array{value:string, type:"GPU"|"InferenceAccelerator"}>}>, cpu?:string, inferenceAcceleratorOverrides?:array<array{deviceName?:string, deviceType?:string}>, executionRoleArn?:string, memory?:string, taskRoleArn?:string, ephemeralStorage?:array{sizeInGiB:int}}, placementConstraints?:array<array{type?:"distinctInstance"|"memberOf", expression?:string}>, placementStrategy?:array<array{type?:"random"|"spread"|"binpack", field?:string}>, platformVersion?:string, propagateTags?:"TASK_DEFINITION"|"SERVICE"|"NONE", referenceId?:string, startedBy?:string, tags?:array<array{key?:string, value?:string}>, taskDefinition:string, clientToken?:string, volumeConfigurations?:array<array{name:string, managedEBSVolume?:array{encrypted?:bool, kmsKeyId?:string, volumeType?:string, sizeInGiB?:int, snapshotId?:string, iops?:int, throughput?:int, tagSpecifications?:array<array{resourceType:"volume", tags?:array<array{key?:string, value?:string}>, propagateTags?:"TASK_DEFINITION"|"SERVICE"|"NONE"}>, roleArn:string, terminationPolicy?:array{deleteOnTermination:bool}, filesystemType?:"ext3"|"ext4"|"xfs"|"ntfs"}}>} $args
     * @return \AWS\Result<array{tasks?:array<array{attachments?:array<array{id?:string, type?:string, status?:string, details?:array<array{name?:string, value?:string}>}>, attributes?:array<array{name:string, value?:string, targetType?:"container-instance", targetId?:string}>, availabilityZone?:string, capacityProviderName?:string, clusterArn?:string, connectivity?:"CONNECTED"|"DISCONNECTED", connectivityAt?:int|string|\DateTimeInterface, containerInstanceArn?:string, containers?:array<array{containerArn?:string, taskArn?:string, name?:string, image?:string, imageDigest?:string, runtimeId?:string, lastStatus?:string, exitCode?:int, reason?:string, networkBindings?:array<array{bindIP?:string, containerPort?:int, hostPort?:int, protocol?:"tcp"|"udp", containerPortRange?:string, hostPortRange?:string}>, networkInterfaces?:array<array{attachmentId?:string, privateIpv4Address?:string, ipv6Address?:string}>, healthStatus?:"HEALTHY"|"UNHEALTHY"|"UNKNOWN", managedAgents?:array<array{lastStartedAt?:int|string|\DateTimeInterface, name?:"ExecuteCommandAgent", reason?:string, lastStatus?:string}>, cpu?:string, memory?:string, memoryReservation?:string, gpuIds?:array<string>}>, cpu?:string, createdAt?:int|string|\DateTimeInterface, desiredStatus?:string, enableExecuteCommand?:bool, executionStoppedAt?:int|string|\DateTimeInterface, group?:string, healthStatus?:"HEALTHY"|"UNHEALTHY"|"UNKNOWN", inferenceAccelerators?:array<array{deviceName:string, deviceType:string}>, lastStatus?:string, launchType?:"EC2"|"FARGATE"|"EXTERNAL", memory?:string, overrides?:array{containerOverrides?:array<array{name?:string, command?:array<string>, environment?:array<array{name?:string, value?:string}>, environmentFiles?:array<array{value:string, type:"s3"}>, cpu?:int, memory?:int, memoryReservation?:int, resourceRequirements?:array<array{value:string, type:"GPU"|"InferenceAccelerator"}>}>, cpu?:string, inferenceAcceleratorOverrides?:array<array{deviceName?:string, deviceType?:string}>, executionRoleArn?:string, memory?:string, taskRoleArn?:string, ephemeralStorage?:array{sizeInGiB:int}}, platformVersion?:string, platformFamily?:string, pullStartedAt?:int|string|\DateTimeInterface, pullStoppedAt?:int|string|\DateTimeInterface, startedAt?:int|string|\DateTimeInterface, startedBy?:string, stopCode?:"TaskFailedToStart"|"EssentialContainerExited"|"UserInitiated"|"ServiceSchedulerInitiated"|"SpotInterruption"|"TerminationNotice", stoppedAt?:int|string|\DateTimeInterface, stoppedReason?:string, stoppingAt?:int|string|\DateTimeInterface, tags?:array<array{key?:string, value?:string}>, taskArn?:string, taskDefinitionArn?:string, version?:int, ephemeralStorage?:array{sizeInGiB:int}, fargateEphemeralStorage?:array{sizeInGiB?:int, kmsKeyId?:string}}>, failures?:array<array{arn?:string, reason?:string, detail?:string}>}>
     */
    public function runTask(array $args): \AWS\Result { }

    /**
     * @param array{capacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, cluster?:string, count?:int, enableECSManagedTags?:bool, enableExecuteCommand?:bool, group?:string, launchType?:"EC2"|"FARGATE"|"EXTERNAL", networkConfiguration?:array{awsvpcConfiguration?:array{subnets:array<string>, securityGroups?:array<string>, assignPublicIp?:"ENABLED"|"DISABLED"}}, overrides?:array{containerOverrides?:array<array{name?:string, command?:array<string>, environment?:array<array{name?:string, value?:string}>, environmentFiles?:array<array{value:string, type:"s3"}>, cpu?:int, memory?:int, memoryReservation?:int, resourceRequirements?:array<array{value:string, type:"GPU"|"InferenceAccelerator"}>}>, cpu?:string, inferenceAcceleratorOverrides?:array<array{deviceName?:string, deviceType?:string}>, executionRoleArn?:string, memory?:string, taskRoleArn?:string, ephemeralStorage?:array{sizeInGiB:int}}, placementConstraints?:array<array{type?:"distinctInstance"|"memberOf", expression?:string}>, placementStrategy?:array<array{type?:"random"|"spread"|"binpack", field?:string}>, platformVersion?:string, propagateTags?:"TASK_DEFINITION"|"SERVICE"|"NONE", referenceId?:string, startedBy?:string, tags?:array<array{key?:string, value?:string}>, taskDefinition:string, clientToken?:string, volumeConfigurations?:array<array{name:string, managedEBSVolume?:array{encrypted?:bool, kmsKeyId?:string, volumeType?:string, sizeInGiB?:int, snapshotId?:string, iops?:int, throughput?:int, tagSpecifications?:array<array{resourceType:"volume", tags?:array<array{key?:string, value?:string}>, propagateTags?:"TASK_DEFINITION"|"SERVICE"|"NONE"}>, roleArn:string, terminationPolicy?:array{deleteOnTermination:bool}, filesystemType?:"ext3"|"ext4"|"xfs"|"ntfs"}}>} $args
     * @return \GuzzleHttp\Promise\Promise<array{tasks?:array<array{attachments?:array<array{id?:string, type?:string, status?:string, details?:array<array{name?:string, value?:string}>}>, attributes?:array<array{name:string, value?:string, targetType?:"container-instance", targetId?:string}>, availabilityZone?:string, capacityProviderName?:string, clusterArn?:string, connectivity?:"CONNECTED"|"DISCONNECTED", connectivityAt?:int|string|\DateTimeInterface, containerInstanceArn?:string, containers?:array<array{containerArn?:string, taskArn?:string, name?:string, image?:string, imageDigest?:string, runtimeId?:string, lastStatus?:string, exitCode?:int, reason?:string, networkBindings?:array<array{bindIP?:string, containerPort?:int, hostPort?:int, protocol?:"tcp"|"udp", containerPortRange?:string, hostPortRange?:string}>, networkInterfaces?:array<array{attachmentId?:string, privateIpv4Address?:string, ipv6Address?:string}>, healthStatus?:"HEALTHY"|"UNHEALTHY"|"UNKNOWN", managedAgents?:array<array{lastStartedAt?:int|string|\DateTimeInterface, name?:"ExecuteCommandAgent", reason?:string, lastStatus?:string}>, cpu?:string, memory?:string, memoryReservation?:string, gpuIds?:array<string>}>, cpu?:string, createdAt?:int|string|\DateTimeInterface, desiredStatus?:string, enableExecuteCommand?:bool, executionStoppedAt?:int|string|\DateTimeInterface, group?:string, healthStatus?:"HEALTHY"|"UNHEALTHY"|"UNKNOWN", inferenceAccelerators?:array<array{deviceName:string, deviceType:string}>, lastStatus?:string, launchType?:"EC2"|"FARGATE"|"EXTERNAL", memory?:string, overrides?:array{containerOverrides?:array<array{name?:string, command?:array<string>, environment?:array<array{name?:string, value?:string}>, environmentFiles?:array<array{value:string, type:"s3"}>, cpu?:int, memory?:int, memoryReservation?:int, resourceRequirements?:array<array{value:string, type:"GPU"|"InferenceAccelerator"}>}>, cpu?:string, inferenceAcceleratorOverrides?:array<array{deviceName?:string, deviceType?:string}>, executionRoleArn?:string, memory?:string, taskRoleArn?:string, ephemeralStorage?:array{sizeInGiB:int}}, platformVersion?:string, platformFamily?:string, pullStartedAt?:int|string|\DateTimeInterface, pullStoppedAt?:int|string|\DateTimeInterface, startedAt?:int|string|\DateTimeInterface, startedBy?:string, stopCode?:"TaskFailedToStart"|"EssentialContainerExited"|"UserInitiated"|"ServiceSchedulerInitiated"|"SpotInterruption"|"TerminationNotice", stoppedAt?:int|string|\DateTimeInterface, stoppedReason?:string, stoppingAt?:int|string|\DateTimeInterface, tags?:array<array{key?:string, value?:string}>, taskArn?:string, taskDefinitionArn?:string, version?:int, ephemeralStorage?:array{sizeInGiB:int}, fargateEphemeralStorage?:array{sizeInGiB?:int, kmsKeyId?:string}}>, failures?:array<array{arn?:string, reason?:string, detail?:string}>}>
     */
    public function runTaskAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{cluster?:string, containerInstances:array<string>, enableECSManagedTags?:bool, enableExecuteCommand?:bool, group?:string, networkConfiguration?:array{awsvpcConfiguration?:array{subnets:array<string>, securityGroups?:array<string>, assignPublicIp?:"ENABLED"|"DISABLED"}}, overrides?:array{containerOverrides?:array<array{name?:string, command?:array<string>, environment?:array<array{name?:string, value?:string}>, environmentFiles?:array<array{value:string, type:"s3"}>, cpu?:int, memory?:int, memoryReservation?:int, resourceRequirements?:array<array{value:string, type:"GPU"|"InferenceAccelerator"}>}>, cpu?:string, inferenceAcceleratorOverrides?:array<array{deviceName?:string, deviceType?:string}>, executionRoleArn?:string, memory?:string, taskRoleArn?:string, ephemeralStorage?:array{sizeInGiB:int}}, propagateTags?:"TASK_DEFINITION"|"SERVICE"|"NONE", referenceId?:string, startedBy?:string, tags?:array<array{key?:string, value?:string}>, taskDefinition:string, volumeConfigurations?:array<array{name:string, managedEBSVolume?:array{encrypted?:bool, kmsKeyId?:string, volumeType?:string, sizeInGiB?:int, snapshotId?:string, iops?:int, throughput?:int, tagSpecifications?:array<array{resourceType:"volume", tags?:array<array{key?:string, value?:string}>, propagateTags?:"TASK_DEFINITION"|"SERVICE"|"NONE"}>, roleArn:string, terminationPolicy?:array{deleteOnTermination:bool}, filesystemType?:"ext3"|"ext4"|"xfs"|"ntfs"}}>} $args
     * @return \AWS\Result<array{tasks?:array<array{attachments?:array<array{id?:string, type?:string, status?:string, details?:array<array{name?:string, value?:string}>}>, attributes?:array<array{name:string, value?:string, targetType?:"container-instance", targetId?:string}>, availabilityZone?:string, capacityProviderName?:string, clusterArn?:string, connectivity?:"CONNECTED"|"DISCONNECTED", connectivityAt?:int|string|\DateTimeInterface, containerInstanceArn?:string, containers?:array<array{containerArn?:string, taskArn?:string, name?:string, image?:string, imageDigest?:string, runtimeId?:string, lastStatus?:string, exitCode?:int, reason?:string, networkBindings?:array<array{bindIP?:string, containerPort?:int, hostPort?:int, protocol?:"tcp"|"udp", containerPortRange?:string, hostPortRange?:string}>, networkInterfaces?:array<array{attachmentId?:string, privateIpv4Address?:string, ipv6Address?:string}>, healthStatus?:"HEALTHY"|"UNHEALTHY"|"UNKNOWN", managedAgents?:array<array{lastStartedAt?:int|string|\DateTimeInterface, name?:"ExecuteCommandAgent", reason?:string, lastStatus?:string}>, cpu?:string, memory?:string, memoryReservation?:string, gpuIds?:array<string>}>, cpu?:string, createdAt?:int|string|\DateTimeInterface, desiredStatus?:string, enableExecuteCommand?:bool, executionStoppedAt?:int|string|\DateTimeInterface, group?:string, healthStatus?:"HEALTHY"|"UNHEALTHY"|"UNKNOWN", inferenceAccelerators?:array<array{deviceName:string, deviceType:string}>, lastStatus?:string, launchType?:"EC2"|"FARGATE"|"EXTERNAL", memory?:string, overrides?:array{containerOverrides?:array<array{name?:string, command?:array<string>, environment?:array<array{name?:string, value?:string}>, environmentFiles?:array<array{value:string, type:"s3"}>, cpu?:int, memory?:int, memoryReservation?:int, resourceRequirements?:array<array{value:string, type:"GPU"|"InferenceAccelerator"}>}>, cpu?:string, inferenceAcceleratorOverrides?:array<array{deviceName?:string, deviceType?:string}>, executionRoleArn?:string, memory?:string, taskRoleArn?:string, ephemeralStorage?:array{sizeInGiB:int}}, platformVersion?:string, platformFamily?:string, pullStartedAt?:int|string|\DateTimeInterface, pullStoppedAt?:int|string|\DateTimeInterface, startedAt?:int|string|\DateTimeInterface, startedBy?:string, stopCode?:"TaskFailedToStart"|"EssentialContainerExited"|"UserInitiated"|"ServiceSchedulerInitiated"|"SpotInterruption"|"TerminationNotice", stoppedAt?:int|string|\DateTimeInterface, stoppedReason?:string, stoppingAt?:int|string|\DateTimeInterface, tags?:array<array{key?:string, value?:string}>, taskArn?:string, taskDefinitionArn?:string, version?:int, ephemeralStorage?:array{sizeInGiB:int}, fargateEphemeralStorage?:array{sizeInGiB?:int, kmsKeyId?:string}}>, failures?:array<array{arn?:string, reason?:string, detail?:string}>}>
     */
    public function startTask(array $args): \AWS\Result { }

    /**
     * @param array{cluster?:string, containerInstances:array<string>, enableECSManagedTags?:bool, enableExecuteCommand?:bool, group?:string, networkConfiguration?:array{awsvpcConfiguration?:array{subnets:array<string>, securityGroups?:array<string>, assignPublicIp?:"ENABLED"|"DISABLED"}}, overrides?:array{containerOverrides?:array<array{name?:string, command?:array<string>, environment?:array<array{name?:string, value?:string}>, environmentFiles?:array<array{value:string, type:"s3"}>, cpu?:int, memory?:int, memoryReservation?:int, resourceRequirements?:array<array{value:string, type:"GPU"|"InferenceAccelerator"}>}>, cpu?:string, inferenceAcceleratorOverrides?:array<array{deviceName?:string, deviceType?:string}>, executionRoleArn?:string, memory?:string, taskRoleArn?:string, ephemeralStorage?:array{sizeInGiB:int}}, propagateTags?:"TASK_DEFINITION"|"SERVICE"|"NONE", referenceId?:string, startedBy?:string, tags?:array<array{key?:string, value?:string}>, taskDefinition:string, volumeConfigurations?:array<array{name:string, managedEBSVolume?:array{encrypted?:bool, kmsKeyId?:string, volumeType?:string, sizeInGiB?:int, snapshotId?:string, iops?:int, throughput?:int, tagSpecifications?:array<array{resourceType:"volume", tags?:array<array{key?:string, value?:string}>, propagateTags?:"TASK_DEFINITION"|"SERVICE"|"NONE"}>, roleArn:string, terminationPolicy?:array{deleteOnTermination:bool}, filesystemType?:"ext3"|"ext4"|"xfs"|"ntfs"}}>} $args
     * @return \GuzzleHttp\Promise\Promise<array{tasks?:array<array{attachments?:array<array{id?:string, type?:string, status?:string, details?:array<array{name?:string, value?:string}>}>, attributes?:array<array{name:string, value?:string, targetType?:"container-instance", targetId?:string}>, availabilityZone?:string, capacityProviderName?:string, clusterArn?:string, connectivity?:"CONNECTED"|"DISCONNECTED", connectivityAt?:int|string|\DateTimeInterface, containerInstanceArn?:string, containers?:array<array{containerArn?:string, taskArn?:string, name?:string, image?:string, imageDigest?:string, runtimeId?:string, lastStatus?:string, exitCode?:int, reason?:string, networkBindings?:array<array{bindIP?:string, containerPort?:int, hostPort?:int, protocol?:"tcp"|"udp", containerPortRange?:string, hostPortRange?:string}>, networkInterfaces?:array<array{attachmentId?:string, privateIpv4Address?:string, ipv6Address?:string}>, healthStatus?:"HEALTHY"|"UNHEALTHY"|"UNKNOWN", managedAgents?:array<array{lastStartedAt?:int|string|\DateTimeInterface, name?:"ExecuteCommandAgent", reason?:string, lastStatus?:string}>, cpu?:string, memory?:string, memoryReservation?:string, gpuIds?:array<string>}>, cpu?:string, createdAt?:int|string|\DateTimeInterface, desiredStatus?:string, enableExecuteCommand?:bool, executionStoppedAt?:int|string|\DateTimeInterface, group?:string, healthStatus?:"HEALTHY"|"UNHEALTHY"|"UNKNOWN", inferenceAccelerators?:array<array{deviceName:string, deviceType:string}>, lastStatus?:string, launchType?:"EC2"|"FARGATE"|"EXTERNAL", memory?:string, overrides?:array{containerOverrides?:array<array{name?:string, command?:array<string>, environment?:array<array{name?:string, value?:string}>, environmentFiles?:array<array{value:string, type:"s3"}>, cpu?:int, memory?:int, memoryReservation?:int, resourceRequirements?:array<array{value:string, type:"GPU"|"InferenceAccelerator"}>}>, cpu?:string, inferenceAcceleratorOverrides?:array<array{deviceName?:string, deviceType?:string}>, executionRoleArn?:string, memory?:string, taskRoleArn?:string, ephemeralStorage?:array{sizeInGiB:int}}, platformVersion?:string, platformFamily?:string, pullStartedAt?:int|string|\DateTimeInterface, pullStoppedAt?:int|string|\DateTimeInterface, startedAt?:int|string|\DateTimeInterface, startedBy?:string, stopCode?:"TaskFailedToStart"|"EssentialContainerExited"|"UserInitiated"|"ServiceSchedulerInitiated"|"SpotInterruption"|"TerminationNotice", stoppedAt?:int|string|\DateTimeInterface, stoppedReason?:string, stoppingAt?:int|string|\DateTimeInterface, tags?:array<array{key?:string, value?:string}>, taskArn?:string, taskDefinitionArn?:string, version?:int, ephemeralStorage?:array{sizeInGiB:int}, fargateEphemeralStorage?:array{sizeInGiB?:int, kmsKeyId?:string}}>, failures?:array<array{arn?:string, reason?:string, detail?:string}>}>
     */
    public function startTaskAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{cluster?:string, task:string, reason?:string} $args
     * @return \AWS\Result<array{task?:array{attachments?:array<array{id?:string, type?:string, status?:string, details?:array<array{name?:string, value?:string}>}>, attributes?:array<array{name:string, value?:string, targetType?:"container-instance", targetId?:string}>, availabilityZone?:string, capacityProviderName?:string, clusterArn?:string, connectivity?:"CONNECTED"|"DISCONNECTED", connectivityAt?:int|string|\DateTimeInterface, containerInstanceArn?:string, containers?:array<array{containerArn?:string, taskArn?:string, name?:string, image?:string, imageDigest?:string, runtimeId?:string, lastStatus?:string, exitCode?:int, reason?:string, networkBindings?:array<array{bindIP?:string, containerPort?:int, hostPort?:int, protocol?:"tcp"|"udp", containerPortRange?:string, hostPortRange?:string}>, networkInterfaces?:array<array{attachmentId?:string, privateIpv4Address?:string, ipv6Address?:string}>, healthStatus?:"HEALTHY"|"UNHEALTHY"|"UNKNOWN", managedAgents?:array<array{lastStartedAt?:int|string|\DateTimeInterface, name?:"ExecuteCommandAgent", reason?:string, lastStatus?:string}>, cpu?:string, memory?:string, memoryReservation?:string, gpuIds?:array<string>}>, cpu?:string, createdAt?:int|string|\DateTimeInterface, desiredStatus?:string, enableExecuteCommand?:bool, executionStoppedAt?:int|string|\DateTimeInterface, group?:string, healthStatus?:"HEALTHY"|"UNHEALTHY"|"UNKNOWN", inferenceAccelerators?:array<array{deviceName:string, deviceType:string}>, lastStatus?:string, launchType?:"EC2"|"FARGATE"|"EXTERNAL", memory?:string, overrides?:array{containerOverrides?:array<array{name?:string, command?:array<string>, environment?:array<array{name?:string, value?:string}>, environmentFiles?:array<array{value:string, type:"s3"}>, cpu?:int, memory?:int, memoryReservation?:int, resourceRequirements?:array<array{value:string, type:"GPU"|"InferenceAccelerator"}>}>, cpu?:string, inferenceAcceleratorOverrides?:array<array{deviceName?:string, deviceType?:string}>, executionRoleArn?:string, memory?:string, taskRoleArn?:string, ephemeralStorage?:array{sizeInGiB:int}}, platformVersion?:string, platformFamily?:string, pullStartedAt?:int|string|\DateTimeInterface, pullStoppedAt?:int|string|\DateTimeInterface, startedAt?:int|string|\DateTimeInterface, startedBy?:string, stopCode?:"TaskFailedToStart"|"EssentialContainerExited"|"UserInitiated"|"ServiceSchedulerInitiated"|"SpotInterruption"|"TerminationNotice", stoppedAt?:int|string|\DateTimeInterface, stoppedReason?:string, stoppingAt?:int|string|\DateTimeInterface, tags?:array<array{key?:string, value?:string}>, taskArn?:string, taskDefinitionArn?:string, version?:int, ephemeralStorage?:array{sizeInGiB:int}, fargateEphemeralStorage?:array{sizeInGiB?:int, kmsKeyId?:string}}}>
     */
    public function stopTask(array $args): \AWS\Result { }

    /**
     * @param array{cluster?:string, task:string, reason?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{task?:array{attachments?:array<array{id?:string, type?:string, status?:string, details?:array<array{name?:string, value?:string}>}>, attributes?:array<array{name:string, value?:string, targetType?:"container-instance", targetId?:string}>, availabilityZone?:string, capacityProviderName?:string, clusterArn?:string, connectivity?:"CONNECTED"|"DISCONNECTED", connectivityAt?:int|string|\DateTimeInterface, containerInstanceArn?:string, containers?:array<array{containerArn?:string, taskArn?:string, name?:string, image?:string, imageDigest?:string, runtimeId?:string, lastStatus?:string, exitCode?:int, reason?:string, networkBindings?:array<array{bindIP?:string, containerPort?:int, hostPort?:int, protocol?:"tcp"|"udp", containerPortRange?:string, hostPortRange?:string}>, networkInterfaces?:array<array{attachmentId?:string, privateIpv4Address?:string, ipv6Address?:string}>, healthStatus?:"HEALTHY"|"UNHEALTHY"|"UNKNOWN", managedAgents?:array<array{lastStartedAt?:int|string|\DateTimeInterface, name?:"ExecuteCommandAgent", reason?:string, lastStatus?:string}>, cpu?:string, memory?:string, memoryReservation?:string, gpuIds?:array<string>}>, cpu?:string, createdAt?:int|string|\DateTimeInterface, desiredStatus?:string, enableExecuteCommand?:bool, executionStoppedAt?:int|string|\DateTimeInterface, group?:string, healthStatus?:"HEALTHY"|"UNHEALTHY"|"UNKNOWN", inferenceAccelerators?:array<array{deviceName:string, deviceType:string}>, lastStatus?:string, launchType?:"EC2"|"FARGATE"|"EXTERNAL", memory?:string, overrides?:array{containerOverrides?:array<array{name?:string, command?:array<string>, environment?:array<array{name?:string, value?:string}>, environmentFiles?:array<array{value:string, type:"s3"}>, cpu?:int, memory?:int, memoryReservation?:int, resourceRequirements?:array<array{value:string, type:"GPU"|"InferenceAccelerator"}>}>, cpu?:string, inferenceAcceleratorOverrides?:array<array{deviceName?:string, deviceType?:string}>, executionRoleArn?:string, memory?:string, taskRoleArn?:string, ephemeralStorage?:array{sizeInGiB:int}}, platformVersion?:string, platformFamily?:string, pullStartedAt?:int|string|\DateTimeInterface, pullStoppedAt?:int|string|\DateTimeInterface, startedAt?:int|string|\DateTimeInterface, startedBy?:string, stopCode?:"TaskFailedToStart"|"EssentialContainerExited"|"UserInitiated"|"ServiceSchedulerInitiated"|"SpotInterruption"|"TerminationNotice", stoppedAt?:int|string|\DateTimeInterface, stoppedReason?:string, stoppingAt?:int|string|\DateTimeInterface, tags?:array<array{key?:string, value?:string}>, taskArn?:string, taskDefinitionArn?:string, version?:int, ephemeralStorage?:array{sizeInGiB:int}, fargateEphemeralStorage?:array{sizeInGiB?:int, kmsKeyId?:string}}}>
     */
    public function stopTaskAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{cluster?:string, attachments:array<array{attachmentArn:string, status:string}>} $args
     * @return \AWS\Result<array{acknowledgment?:string}>
     */
    public function submitAttachmentStateChanges(array $args): \AWS\Result { }

    /**
     * @param array{cluster?:string, attachments:array<array{attachmentArn:string, status:string}>} $args
     * @return \GuzzleHttp\Promise\Promise<array{acknowledgment?:string}>
     */
    public function submitAttachmentStateChangesAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{cluster?:string, task?:string, containerName?:string, runtimeId?:string, status?:string, exitCode?:int, reason?:string, networkBindings?:array<array{bindIP?:string, containerPort?:int, hostPort?:int, protocol?:"tcp"|"udp", containerPortRange?:string, hostPortRange?:string}>} $args
     * @return \AWS\Result<array{acknowledgment?:string}>
     */
    public function submitContainerStateChange(array $args = []): \AWS\Result { }

    /**
     * @param array{cluster?:string, task?:string, containerName?:string, runtimeId?:string, status?:string, exitCode?:int, reason?:string, networkBindings?:array<array{bindIP?:string, containerPort?:int, hostPort?:int, protocol?:"tcp"|"udp", containerPortRange?:string, hostPortRange?:string}>} $args
     * @return \GuzzleHttp\Promise\Promise<array{acknowledgment?:string}>
     */
    public function submitContainerStateChangeAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{cluster?:string, task?:string, status?:string, reason?:string, containers?:array<array{containerName?:string, imageDigest?:string, runtimeId?:string, exitCode?:int, networkBindings?:array<array{bindIP?:string, containerPort?:int, hostPort?:int, protocol?:"tcp"|"udp", containerPortRange?:string, hostPortRange?:string}>, reason?:string, status?:string}>, attachments?:array<array{attachmentArn:string, status:string}>, managedAgents?:array<array{containerName:string, managedAgentName:"ExecuteCommandAgent", status:string, reason?:string}>, pullStartedAt?:int|string|\DateTimeInterface, pullStoppedAt?:int|string|\DateTimeInterface, executionStoppedAt?:int|string|\DateTimeInterface} $args
     * @return \AWS\Result<array{acknowledgment?:string}>
     */
    public function submitTaskStateChange(array $args = []): \AWS\Result { }

    /**
     * @param array{cluster?:string, task?:string, status?:string, reason?:string, containers?:array<array{containerName?:string, imageDigest?:string, runtimeId?:string, exitCode?:int, networkBindings?:array<array{bindIP?:string, containerPort?:int, hostPort?:int, protocol?:"tcp"|"udp", containerPortRange?:string, hostPortRange?:string}>, reason?:string, status?:string}>, attachments?:array<array{attachmentArn:string, status:string}>, managedAgents?:array<array{containerName:string, managedAgentName:"ExecuteCommandAgent", status:string, reason?:string}>, pullStartedAt?:int|string|\DateTimeInterface, pullStoppedAt?:int|string|\DateTimeInterface, executionStoppedAt?:int|string|\DateTimeInterface} $args
     * @return \GuzzleHttp\Promise\Promise<array{acknowledgment?:string}>
     */
    public function submitTaskStateChangeAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{resourceArn:string, tags:array<array{key?:string, value?:string}>} $args
     * @return \AWS\Result<array{}>
     */
    public function tagResource(array $args): \AWS\Result { }

    /**
     * @param array{resourceArn:string, tags:array<array{key?:string, value?:string}>} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function tagResourceAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{resourceArn:string, tagKeys:array<string>} $args
     * @return \AWS\Result<array{}>
     */
    public function untagResource(array $args): \AWS\Result { }

    /**
     * @param array{resourceArn:string, tagKeys:array<string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function untagResourceAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{name:string, autoScalingGroupProvider:array{managedScaling?:array{status?:"ENABLED"|"DISABLED", targetCapacity?:int, minimumScalingStepSize?:int, maximumScalingStepSize?:int, instanceWarmupPeriod?:int}, managedTerminationProtection?:"ENABLED"|"DISABLED", managedDraining?:"ENABLED"|"DISABLED"}} $args
     * @return \AWS\Result<array{capacityProvider?:array{capacityProviderArn?:string, name?:string, status?:"ACTIVE"|"INACTIVE", autoScalingGroupProvider?:array{autoScalingGroupArn:string, managedScaling?:array{status?:"ENABLED"|"DISABLED", targetCapacity?:int, minimumScalingStepSize?:int, maximumScalingStepSize?:int, instanceWarmupPeriod?:int}, managedTerminationProtection?:"ENABLED"|"DISABLED", managedDraining?:"ENABLED"|"DISABLED"}, updateStatus?:"DELETE_IN_PROGRESS"|"DELETE_COMPLETE"|"DELETE_FAILED"|"UPDATE_IN_PROGRESS"|"UPDATE_COMPLETE"|"UPDATE_FAILED", updateStatusReason?:string, tags?:array<array{key?:string, value?:string}>}}>
     */
    public function updateCapacityProvider(array $args): \AWS\Result { }

    /**
     * @param array{name:string, autoScalingGroupProvider:array{managedScaling?:array{status?:"ENABLED"|"DISABLED", targetCapacity?:int, minimumScalingStepSize?:int, maximumScalingStepSize?:int, instanceWarmupPeriod?:int}, managedTerminationProtection?:"ENABLED"|"DISABLED", managedDraining?:"ENABLED"|"DISABLED"}} $args
     * @return \GuzzleHttp\Promise\Promise<array{capacityProvider?:array{capacityProviderArn?:string, name?:string, status?:"ACTIVE"|"INACTIVE", autoScalingGroupProvider?:array{autoScalingGroupArn:string, managedScaling?:array{status?:"ENABLED"|"DISABLED", targetCapacity?:int, minimumScalingStepSize?:int, maximumScalingStepSize?:int, instanceWarmupPeriod?:int}, managedTerminationProtection?:"ENABLED"|"DISABLED", managedDraining?:"ENABLED"|"DISABLED"}, updateStatus?:"DELETE_IN_PROGRESS"|"DELETE_COMPLETE"|"DELETE_FAILED"|"UPDATE_IN_PROGRESS"|"UPDATE_COMPLETE"|"UPDATE_FAILED", updateStatusReason?:string, tags?:array<array{key?:string, value?:string}>}}>
     */
    public function updateCapacityProviderAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{cluster:string, settings?:array<array{name?:"containerInsights", value?:string}>, configuration?:array{executeCommandConfiguration?:array{kmsKeyId?:string, logging?:"NONE"|"DEFAULT"|"OVERRIDE", logConfiguration?:array{cloudWatchLogGroupName?:string, cloudWatchEncryptionEnabled?:bool, s3BucketName?:string, s3EncryptionEnabled?:bool, s3KeyPrefix?:string}}, managedStorageConfiguration?:array{kmsKeyId?:string, fargateEphemeralStorageKmsKeyId?:string}}, serviceConnectDefaults?:array{namespace:string}} $args
     * @return \AWS\Result<array{cluster?:array{clusterArn?:string, clusterName?:string, configuration?:array{executeCommandConfiguration?:array{kmsKeyId?:string, logging?:"NONE"|"DEFAULT"|"OVERRIDE", logConfiguration?:array{cloudWatchLogGroupName?:string, cloudWatchEncryptionEnabled?:bool, s3BucketName?:string, s3EncryptionEnabled?:bool, s3KeyPrefix?:string}}, managedStorageConfiguration?:array{kmsKeyId?:string, fargateEphemeralStorageKmsKeyId?:string}}, status?:string, registeredContainerInstancesCount?:int, runningTasksCount?:int, pendingTasksCount?:int, activeServicesCount?:int, statistics?:array<array{name?:string, value?:string}>, tags?:array<array{key?:string, value?:string}>, settings?:array<array{name?:"containerInsights", value?:string}>, capacityProviders?:array<string>, defaultCapacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, attachments?:array<array{id?:string, type?:string, status?:string, details?:array<array{name?:string, value?:string}>}>, attachmentsStatus?:string, serviceConnectDefaults?:array{namespace?:string}}}>
     */
    public function updateCluster(array $args): \AWS\Result { }

    /**
     * @param array{cluster:string, settings?:array<array{name?:"containerInsights", value?:string}>, configuration?:array{executeCommandConfiguration?:array{kmsKeyId?:string, logging?:"NONE"|"DEFAULT"|"OVERRIDE", logConfiguration?:array{cloudWatchLogGroupName?:string, cloudWatchEncryptionEnabled?:bool, s3BucketName?:string, s3EncryptionEnabled?:bool, s3KeyPrefix?:string}}, managedStorageConfiguration?:array{kmsKeyId?:string, fargateEphemeralStorageKmsKeyId?:string}}, serviceConnectDefaults?:array{namespace:string}} $args
     * @return \GuzzleHttp\Promise\Promise<array{cluster?:array{clusterArn?:string, clusterName?:string, configuration?:array{executeCommandConfiguration?:array{kmsKeyId?:string, logging?:"NONE"|"DEFAULT"|"OVERRIDE", logConfiguration?:array{cloudWatchLogGroupName?:string, cloudWatchEncryptionEnabled?:bool, s3BucketName?:string, s3EncryptionEnabled?:bool, s3KeyPrefix?:string}}, managedStorageConfiguration?:array{kmsKeyId?:string, fargateEphemeralStorageKmsKeyId?:string}}, status?:string, registeredContainerInstancesCount?:int, runningTasksCount?:int, pendingTasksCount?:int, activeServicesCount?:int, statistics?:array<array{name?:string, value?:string}>, tags?:array<array{key?:string, value?:string}>, settings?:array<array{name?:"containerInsights", value?:string}>, capacityProviders?:array<string>, defaultCapacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, attachments?:array<array{id?:string, type?:string, status?:string, details?:array<array{name?:string, value?:string}>}>, attachmentsStatus?:string, serviceConnectDefaults?:array{namespace?:string}}}>
     */
    public function updateClusterAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{cluster:string, settings:array<array{name?:"containerInsights", value?:string}>} $args
     * @return \AWS\Result<array{cluster?:array{clusterArn?:string, clusterName?:string, configuration?:array{executeCommandConfiguration?:array{kmsKeyId?:string, logging?:"NONE"|"DEFAULT"|"OVERRIDE", logConfiguration?:array{cloudWatchLogGroupName?:string, cloudWatchEncryptionEnabled?:bool, s3BucketName?:string, s3EncryptionEnabled?:bool, s3KeyPrefix?:string}}, managedStorageConfiguration?:array{kmsKeyId?:string, fargateEphemeralStorageKmsKeyId?:string}}, status?:string, registeredContainerInstancesCount?:int, runningTasksCount?:int, pendingTasksCount?:int, activeServicesCount?:int, statistics?:array<array{name?:string, value?:string}>, tags?:array<array{key?:string, value?:string}>, settings?:array<array{name?:"containerInsights", value?:string}>, capacityProviders?:array<string>, defaultCapacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, attachments?:array<array{id?:string, type?:string, status?:string, details?:array<array{name?:string, value?:string}>}>, attachmentsStatus?:string, serviceConnectDefaults?:array{namespace?:string}}}>
     */
    public function updateClusterSettings(array $args): \AWS\Result { }

    /**
     * @param array{cluster:string, settings:array<array{name?:"containerInsights", value?:string}>} $args
     * @return \GuzzleHttp\Promise\Promise<array{cluster?:array{clusterArn?:string, clusterName?:string, configuration?:array{executeCommandConfiguration?:array{kmsKeyId?:string, logging?:"NONE"|"DEFAULT"|"OVERRIDE", logConfiguration?:array{cloudWatchLogGroupName?:string, cloudWatchEncryptionEnabled?:bool, s3BucketName?:string, s3EncryptionEnabled?:bool, s3KeyPrefix?:string}}, managedStorageConfiguration?:array{kmsKeyId?:string, fargateEphemeralStorageKmsKeyId?:string}}, status?:string, registeredContainerInstancesCount?:int, runningTasksCount?:int, pendingTasksCount?:int, activeServicesCount?:int, statistics?:array<array{name?:string, value?:string}>, tags?:array<array{key?:string, value?:string}>, settings?:array<array{name?:"containerInsights", value?:string}>, capacityProviders?:array<string>, defaultCapacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, attachments?:array<array{id?:string, type?:string, status?:string, details?:array<array{name?:string, value?:string}>}>, attachmentsStatus?:string, serviceConnectDefaults?:array{namespace?:string}}}>
     */
    public function updateClusterSettingsAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{cluster?:string, containerInstance:string} $args
     * @return \AWS\Result<array{containerInstance?:array{containerInstanceArn?:string, ec2InstanceId?:string, capacityProviderName?:string, version?:int, versionInfo?:array{agentVersion?:string, agentHash?:string, dockerVersion?:string}, remainingResources?:array<array{name?:string, type?:string, doubleValue?:float, longValue?:int, integerValue?:int, stringSetValue?:array<string>}>, registeredResources?:array<array{name?:string, type?:string, doubleValue?:float, longValue?:int, integerValue?:int, stringSetValue?:array<string>}>, status?:string, statusReason?:string, agentConnected?:bool, runningTasksCount?:int, pendingTasksCount?:int, agentUpdateStatus?:"PENDING"|"STAGING"|"STAGED"|"UPDATING"|"UPDATED"|"FAILED", attributes?:array<array{name:string, value?:string, targetType?:"container-instance", targetId?:string}>, registeredAt?:int|string|\DateTimeInterface, attachments?:array<array{id?:string, type?:string, status?:string, details?:array<array{name?:string, value?:string}>}>, tags?:array<array{key?:string, value?:string}>, healthStatus?:array{overallStatus?:"OK"|"IMPAIRED"|"INSUFFICIENT_DATA"|"INITIALIZING", details?:array<array{type?:"CONTAINER_RUNTIME", status?:"OK"|"IMPAIRED"|"INSUFFICIENT_DATA"|"INITIALIZING", lastUpdated?:int|string|\DateTimeInterface, lastStatusChange?:int|string|\DateTimeInterface}>}}}>
     */
    public function updateContainerAgent(array $args): \AWS\Result { }

    /**
     * @param array{cluster?:string, containerInstance:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{containerInstance?:array{containerInstanceArn?:string, ec2InstanceId?:string, capacityProviderName?:string, version?:int, versionInfo?:array{agentVersion?:string, agentHash?:string, dockerVersion?:string}, remainingResources?:array<array{name?:string, type?:string, doubleValue?:float, longValue?:int, integerValue?:int, stringSetValue?:array<string>}>, registeredResources?:array<array{name?:string, type?:string, doubleValue?:float, longValue?:int, integerValue?:int, stringSetValue?:array<string>}>, status?:string, statusReason?:string, agentConnected?:bool, runningTasksCount?:int, pendingTasksCount?:int, agentUpdateStatus?:"PENDING"|"STAGING"|"STAGED"|"UPDATING"|"UPDATED"|"FAILED", attributes?:array<array{name:string, value?:string, targetType?:"container-instance", targetId?:string}>, registeredAt?:int|string|\DateTimeInterface, attachments?:array<array{id?:string, type?:string, status?:string, details?:array<array{name?:string, value?:string}>}>, tags?:array<array{key?:string, value?:string}>, healthStatus?:array{overallStatus?:"OK"|"IMPAIRED"|"INSUFFICIENT_DATA"|"INITIALIZING", details?:array<array{type?:"CONTAINER_RUNTIME", status?:"OK"|"IMPAIRED"|"INSUFFICIENT_DATA"|"INITIALIZING", lastUpdated?:int|string|\DateTimeInterface, lastStatusChange?:int|string|\DateTimeInterface}>}}}>
     */
    public function updateContainerAgentAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{cluster?:string, containerInstances:array<string>, status:"ACTIVE"|"DRAINING"|"REGISTERING"|"DEREGISTERING"|"REGISTRATION_FAILED"} $args
     * @return \AWS\Result<array{containerInstances?:array<array{containerInstanceArn?:string, ec2InstanceId?:string, capacityProviderName?:string, version?:int, versionInfo?:array{agentVersion?:string, agentHash?:string, dockerVersion?:string}, remainingResources?:array<array{name?:string, type?:string, doubleValue?:float, longValue?:int, integerValue?:int, stringSetValue?:array<string>}>, registeredResources?:array<array{name?:string, type?:string, doubleValue?:float, longValue?:int, integerValue?:int, stringSetValue?:array<string>}>, status?:string, statusReason?:string, agentConnected?:bool, runningTasksCount?:int, pendingTasksCount?:int, agentUpdateStatus?:"PENDING"|"STAGING"|"STAGED"|"UPDATING"|"UPDATED"|"FAILED", attributes?:array<array{name:string, value?:string, targetType?:"container-instance", targetId?:string}>, registeredAt?:int|string|\DateTimeInterface, attachments?:array<array{id?:string, type?:string, status?:string, details?:array<array{name?:string, value?:string}>}>, tags?:array<array{key?:string, value?:string}>, healthStatus?:array{overallStatus?:"OK"|"IMPAIRED"|"INSUFFICIENT_DATA"|"INITIALIZING", details?:array<array{type?:"CONTAINER_RUNTIME", status?:"OK"|"IMPAIRED"|"INSUFFICIENT_DATA"|"INITIALIZING", lastUpdated?:int|string|\DateTimeInterface, lastStatusChange?:int|string|\DateTimeInterface}>}}>, failures?:array<array{arn?:string, reason?:string, detail?:string}>}>
     */
    public function updateContainerInstancesState(array $args): \AWS\Result { }

    /**
     * @param array{cluster?:string, containerInstances:array<string>, status:"ACTIVE"|"DRAINING"|"REGISTERING"|"DEREGISTERING"|"REGISTRATION_FAILED"} $args
     * @return \GuzzleHttp\Promise\Promise<array{containerInstances?:array<array{containerInstanceArn?:string, ec2InstanceId?:string, capacityProviderName?:string, version?:int, versionInfo?:array{agentVersion?:string, agentHash?:string, dockerVersion?:string}, remainingResources?:array<array{name?:string, type?:string, doubleValue?:float, longValue?:int, integerValue?:int, stringSetValue?:array<string>}>, registeredResources?:array<array{name?:string, type?:string, doubleValue?:float, longValue?:int, integerValue?:int, stringSetValue?:array<string>}>, status?:string, statusReason?:string, agentConnected?:bool, runningTasksCount?:int, pendingTasksCount?:int, agentUpdateStatus?:"PENDING"|"STAGING"|"STAGED"|"UPDATING"|"UPDATED"|"FAILED", attributes?:array<array{name:string, value?:string, targetType?:"container-instance", targetId?:string}>, registeredAt?:int|string|\DateTimeInterface, attachments?:array<array{id?:string, type?:string, status?:string, details?:array<array{name?:string, value?:string}>}>, tags?:array<array{key?:string, value?:string}>, healthStatus?:array{overallStatus?:"OK"|"IMPAIRED"|"INSUFFICIENT_DATA"|"INITIALIZING", details?:array<array{type?:"CONTAINER_RUNTIME", status?:"OK"|"IMPAIRED"|"INSUFFICIENT_DATA"|"INITIALIZING", lastUpdated?:int|string|\DateTimeInterface, lastStatusChange?:int|string|\DateTimeInterface}>}}>, failures?:array<array{arn?:string, reason?:string, detail?:string}>}>
     */
    public function updateContainerInstancesStateAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{cluster?:string, service:string, desiredCount?:int, taskDefinition?:string, capacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, deploymentConfiguration?:array{deploymentCircuitBreaker?:array{enable:bool, rollback:bool}, maximumPercent?:int, minimumHealthyPercent?:int, alarms?:array{alarmNames:array<string>, rollback:bool, enable:bool}}, availabilityZoneRebalancing?:"ENABLED"|"DISABLED", networkConfiguration?:array{awsvpcConfiguration?:array{subnets:array<string>, securityGroups?:array<string>, assignPublicIp?:"ENABLED"|"DISABLED"}}, placementConstraints?:array<array{type?:"distinctInstance"|"memberOf", expression?:string}>, placementStrategy?:array<array{type?:"random"|"spread"|"binpack", field?:string}>, platformVersion?:string, forceNewDeployment?:bool, healthCheckGracePeriodSeconds?:int, enableExecuteCommand?:bool, enableECSManagedTags?:bool, loadBalancers?:array<array{targetGroupArn?:string, loadBalancerName?:string, containerName?:string, containerPort?:int}>, propagateTags?:"TASK_DEFINITION"|"SERVICE"|"NONE", serviceRegistries?:array<array{registryArn?:string, port?:int, containerName?:string, containerPort?:int}>, serviceConnectConfiguration?:array{enabled:bool, namespace?:string, services?:array<array{portName:string, discoveryName?:string, clientAliases?:array<array{port:int, dnsName?:string}>, ingressPortOverride?:int, timeout?:array{idleTimeoutSeconds?:int, perRequestTimeoutSeconds?:int}, tls?:array{issuerCertificateAuthority:array{awsPcaAuthorityArn?:string}, kmsKey?:string, roleArn?:string}}>, logConfiguration?:array{logDriver:"json-file"|"syslog"|"journald"|"gelf"|"fluentd"|"awslogs"|"splunk"|"awsfirelens", options?:array<string, string>, secretOptions?:array<array{name:string, valueFrom:string}>}}, volumeConfigurations?:array<array{name:string, managedEBSVolume?:array{encrypted?:bool, kmsKeyId?:string, volumeType?:string, sizeInGiB?:int, snapshotId?:string, iops?:int, throughput?:int, tagSpecifications?:array<array{resourceType:"volume", tags?:array<array{key?:string, value?:string}>, propagateTags?:"TASK_DEFINITION"|"SERVICE"|"NONE"}>, roleArn:string, filesystemType?:"ext3"|"ext4"|"xfs"|"ntfs"}}>, vpcLatticeConfigurations?:array<array{roleArn:string, targetGroupArn:string, portName:string}>} $args
     * @return \AWS\Result<array{service?:array{serviceArn?:string, serviceName?:string, clusterArn?:string, loadBalancers?:array<array{targetGroupArn?:string, loadBalancerName?:string, containerName?:string, containerPort?:int}>, serviceRegistries?:array<array{registryArn?:string, port?:int, containerName?:string, containerPort?:int}>, status?:string, desiredCount?:int, runningCount?:int, pendingCount?:int, launchType?:"EC2"|"FARGATE"|"EXTERNAL", capacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, platformVersion?:string, platformFamily?:string, taskDefinition?:string, deploymentConfiguration?:array{deploymentCircuitBreaker?:array{enable:bool, rollback:bool}, maximumPercent?:int, minimumHealthyPercent?:int, alarms?:array{alarmNames:array<string>, rollback:bool, enable:bool}}, taskSets?:array<array{id?:string, taskSetArn?:string, serviceArn?:string, clusterArn?:string, startedBy?:string, externalId?:string, status?:string, taskDefinition?:string, computedDesiredCount?:int, pendingCount?:int, runningCount?:int, createdAt?:int|string|\DateTimeInterface, updatedAt?:int|string|\DateTimeInterface, launchType?:"EC2"|"FARGATE"|"EXTERNAL", capacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, platformVersion?:string, platformFamily?:string, networkConfiguration?:array{awsvpcConfiguration?:array{subnets:array<string>, securityGroups?:array<string>, assignPublicIp?:"ENABLED"|"DISABLED"}}, loadBalancers?:array<array{targetGroupArn?:string, loadBalancerName?:string, containerName?:string, containerPort?:int}>, serviceRegistries?:array<array{registryArn?:string, port?:int, containerName?:string, containerPort?:int}>, scale?:array{value?:float, unit?:"PERCENT"}, stabilityStatus?:"STEADY_STATE"|"STABILIZING", stabilityStatusAt?:int|string|\DateTimeInterface, tags?:array<array{key?:string, value?:string}>, fargateEphemeralStorage?:array{kmsKeyId?:string}}>, deployments?:array<array{id?:string, status?:string, taskDefinition?:string, desiredCount?:int, pendingCount?:int, runningCount?:int, failedTasks?:int, createdAt?:int|string|\DateTimeInterface, updatedAt?:int|string|\DateTimeInterface, capacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, launchType?:"EC2"|"FARGATE"|"EXTERNAL", platformVersion?:string, platformFamily?:string, networkConfiguration?:array{awsvpcConfiguration?:array{subnets:array<string>, securityGroups?:array<string>, assignPublicIp?:"ENABLED"|"DISABLED"}}, rolloutState?:"COMPLETED"|"FAILED"|"IN_PROGRESS", rolloutStateReason?:string, serviceConnectConfiguration?:array{enabled:bool, namespace?:string, services?:array<array{portName:string, discoveryName?:string, clientAliases?:array<array{port:int, dnsName?:string}>, ingressPortOverride?:int, timeout?:array{idleTimeoutSeconds?:int, perRequestTimeoutSeconds?:int}, tls?:array{issuerCertificateAuthority:array{awsPcaAuthorityArn?:string}, kmsKey?:string, roleArn?:string}}>, logConfiguration?:array{logDriver:"json-file"|"syslog"|"journald"|"gelf"|"fluentd"|"awslogs"|"splunk"|"awsfirelens", options?:array<string, string>, secretOptions?:array<array{name:string, valueFrom:string}>}}, serviceConnectResources?:array<array{discoveryName?:string, discoveryArn?:string}>, volumeConfigurations?:array<array{name:string, managedEBSVolume?:array{encrypted?:bool, kmsKeyId?:string, volumeType?:string, sizeInGiB?:int, snapshotId?:string, iops?:int, throughput?:int, tagSpecifications?:array<array{resourceType:"volume", tags?:array<array{key?:string, value?:string}>, propagateTags?:"TASK_DEFINITION"|"SERVICE"|"NONE"}>, roleArn:string, filesystemType?:"ext3"|"ext4"|"xfs"|"ntfs"}}>, fargateEphemeralStorage?:array{kmsKeyId?:string}, vpcLatticeConfigurations?:array<array{roleArn:string, targetGroupArn:string, portName:string}>}>, roleArn?:string, events?:array<array{id?:string, createdAt?:int|string|\DateTimeInterface, message?:string}>, createdAt?:int|string|\DateTimeInterface, placementConstraints?:array<array{type?:"distinctInstance"|"memberOf", expression?:string}>, placementStrategy?:array<array{type?:"random"|"spread"|"binpack", field?:string}>, networkConfiguration?:array{awsvpcConfiguration?:array{subnets:array<string>, securityGroups?:array<string>, assignPublicIp?:"ENABLED"|"DISABLED"}}, healthCheckGracePeriodSeconds?:int, schedulingStrategy?:"REPLICA"|"DAEMON", deploymentController?:array{type:"ECS"|"CODE_DEPLOY"|"EXTERNAL"}, tags?:array<array{key?:string, value?:string}>, createdBy?:string, enableECSManagedTags?:bool, propagateTags?:"TASK_DEFINITION"|"SERVICE"|"NONE", enableExecuteCommand?:bool, availabilityZoneRebalancing?:"ENABLED"|"DISABLED"}}>
     */
    public function updateService(array $args): \AWS\Result { }

    /**
     * @param array{cluster?:string, service:string, desiredCount?:int, taskDefinition?:string, capacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, deploymentConfiguration?:array{deploymentCircuitBreaker?:array{enable:bool, rollback:bool}, maximumPercent?:int, minimumHealthyPercent?:int, alarms?:array{alarmNames:array<string>, rollback:bool, enable:bool}}, availabilityZoneRebalancing?:"ENABLED"|"DISABLED", networkConfiguration?:array{awsvpcConfiguration?:array{subnets:array<string>, securityGroups?:array<string>, assignPublicIp?:"ENABLED"|"DISABLED"}}, placementConstraints?:array<array{type?:"distinctInstance"|"memberOf", expression?:string}>, placementStrategy?:array<array{type?:"random"|"spread"|"binpack", field?:string}>, platformVersion?:string, forceNewDeployment?:bool, healthCheckGracePeriodSeconds?:int, enableExecuteCommand?:bool, enableECSManagedTags?:bool, loadBalancers?:array<array{targetGroupArn?:string, loadBalancerName?:string, containerName?:string, containerPort?:int}>, propagateTags?:"TASK_DEFINITION"|"SERVICE"|"NONE", serviceRegistries?:array<array{registryArn?:string, port?:int, containerName?:string, containerPort?:int}>, serviceConnectConfiguration?:array{enabled:bool, namespace?:string, services?:array<array{portName:string, discoveryName?:string, clientAliases?:array<array{port:int, dnsName?:string}>, ingressPortOverride?:int, timeout?:array{idleTimeoutSeconds?:int, perRequestTimeoutSeconds?:int}, tls?:array{issuerCertificateAuthority:array{awsPcaAuthorityArn?:string}, kmsKey?:string, roleArn?:string}}>, logConfiguration?:array{logDriver:"json-file"|"syslog"|"journald"|"gelf"|"fluentd"|"awslogs"|"splunk"|"awsfirelens", options?:array<string, string>, secretOptions?:array<array{name:string, valueFrom:string}>}}, volumeConfigurations?:array<array{name:string, managedEBSVolume?:array{encrypted?:bool, kmsKeyId?:string, volumeType?:string, sizeInGiB?:int, snapshotId?:string, iops?:int, throughput?:int, tagSpecifications?:array<array{resourceType:"volume", tags?:array<array{key?:string, value?:string}>, propagateTags?:"TASK_DEFINITION"|"SERVICE"|"NONE"}>, roleArn:string, filesystemType?:"ext3"|"ext4"|"xfs"|"ntfs"}}>, vpcLatticeConfigurations?:array<array{roleArn:string, targetGroupArn:string, portName:string}>} $args
     * @return \GuzzleHttp\Promise\Promise<array{service?:array{serviceArn?:string, serviceName?:string, clusterArn?:string, loadBalancers?:array<array{targetGroupArn?:string, loadBalancerName?:string, containerName?:string, containerPort?:int}>, serviceRegistries?:array<array{registryArn?:string, port?:int, containerName?:string, containerPort?:int}>, status?:string, desiredCount?:int, runningCount?:int, pendingCount?:int, launchType?:"EC2"|"FARGATE"|"EXTERNAL", capacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, platformVersion?:string, platformFamily?:string, taskDefinition?:string, deploymentConfiguration?:array{deploymentCircuitBreaker?:array{enable:bool, rollback:bool}, maximumPercent?:int, minimumHealthyPercent?:int, alarms?:array{alarmNames:array<string>, rollback:bool, enable:bool}}, taskSets?:array<array{id?:string, taskSetArn?:string, serviceArn?:string, clusterArn?:string, startedBy?:string, externalId?:string, status?:string, taskDefinition?:string, computedDesiredCount?:int, pendingCount?:int, runningCount?:int, createdAt?:int|string|\DateTimeInterface, updatedAt?:int|string|\DateTimeInterface, launchType?:"EC2"|"FARGATE"|"EXTERNAL", capacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, platformVersion?:string, platformFamily?:string, networkConfiguration?:array{awsvpcConfiguration?:array{subnets:array<string>, securityGroups?:array<string>, assignPublicIp?:"ENABLED"|"DISABLED"}}, loadBalancers?:array<array{targetGroupArn?:string, loadBalancerName?:string, containerName?:string, containerPort?:int}>, serviceRegistries?:array<array{registryArn?:string, port?:int, containerName?:string, containerPort?:int}>, scale?:array{value?:float, unit?:"PERCENT"}, stabilityStatus?:"STEADY_STATE"|"STABILIZING", stabilityStatusAt?:int|string|\DateTimeInterface, tags?:array<array{key?:string, value?:string}>, fargateEphemeralStorage?:array{kmsKeyId?:string}}>, deployments?:array<array{id?:string, status?:string, taskDefinition?:string, desiredCount?:int, pendingCount?:int, runningCount?:int, failedTasks?:int, createdAt?:int|string|\DateTimeInterface, updatedAt?:int|string|\DateTimeInterface, capacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, launchType?:"EC2"|"FARGATE"|"EXTERNAL", platformVersion?:string, platformFamily?:string, networkConfiguration?:array{awsvpcConfiguration?:array{subnets:array<string>, securityGroups?:array<string>, assignPublicIp?:"ENABLED"|"DISABLED"}}, rolloutState?:"COMPLETED"|"FAILED"|"IN_PROGRESS", rolloutStateReason?:string, serviceConnectConfiguration?:array{enabled:bool, namespace?:string, services?:array<array{portName:string, discoveryName?:string, clientAliases?:array<array{port:int, dnsName?:string}>, ingressPortOverride?:int, timeout?:array{idleTimeoutSeconds?:int, perRequestTimeoutSeconds?:int}, tls?:array{issuerCertificateAuthority:array{awsPcaAuthorityArn?:string}, kmsKey?:string, roleArn?:string}}>, logConfiguration?:array{logDriver:"json-file"|"syslog"|"journald"|"gelf"|"fluentd"|"awslogs"|"splunk"|"awsfirelens", options?:array<string, string>, secretOptions?:array<array{name:string, valueFrom:string}>}}, serviceConnectResources?:array<array{discoveryName?:string, discoveryArn?:string}>, volumeConfigurations?:array<array{name:string, managedEBSVolume?:array{encrypted?:bool, kmsKeyId?:string, volumeType?:string, sizeInGiB?:int, snapshotId?:string, iops?:int, throughput?:int, tagSpecifications?:array<array{resourceType:"volume", tags?:array<array{key?:string, value?:string}>, propagateTags?:"TASK_DEFINITION"|"SERVICE"|"NONE"}>, roleArn:string, filesystemType?:"ext3"|"ext4"|"xfs"|"ntfs"}}>, fargateEphemeralStorage?:array{kmsKeyId?:string}, vpcLatticeConfigurations?:array<array{roleArn:string, targetGroupArn:string, portName:string}>}>, roleArn?:string, events?:array<array{id?:string, createdAt?:int|string|\DateTimeInterface, message?:string}>, createdAt?:int|string|\DateTimeInterface, placementConstraints?:array<array{type?:"distinctInstance"|"memberOf", expression?:string}>, placementStrategy?:array<array{type?:"random"|"spread"|"binpack", field?:string}>, networkConfiguration?:array{awsvpcConfiguration?:array{subnets:array<string>, securityGroups?:array<string>, assignPublicIp?:"ENABLED"|"DISABLED"}}, healthCheckGracePeriodSeconds?:int, schedulingStrategy?:"REPLICA"|"DAEMON", deploymentController?:array{type:"ECS"|"CODE_DEPLOY"|"EXTERNAL"}, tags?:array<array{key?:string, value?:string}>, createdBy?:string, enableECSManagedTags?:bool, propagateTags?:"TASK_DEFINITION"|"SERVICE"|"NONE", enableExecuteCommand?:bool, availabilityZoneRebalancing?:"ENABLED"|"DISABLED"}}>
     */
    public function updateServiceAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{cluster:string, service:string, primaryTaskSet:string} $args
     * @return \AWS\Result<array{taskSet?:array{id?:string, taskSetArn?:string, serviceArn?:string, clusterArn?:string, startedBy?:string, externalId?:string, status?:string, taskDefinition?:string, computedDesiredCount?:int, pendingCount?:int, runningCount?:int, createdAt?:int|string|\DateTimeInterface, updatedAt?:int|string|\DateTimeInterface, launchType?:"EC2"|"FARGATE"|"EXTERNAL", capacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, platformVersion?:string, platformFamily?:string, networkConfiguration?:array{awsvpcConfiguration?:array{subnets:array<string>, securityGroups?:array<string>, assignPublicIp?:"ENABLED"|"DISABLED"}}, loadBalancers?:array<array{targetGroupArn?:string, loadBalancerName?:string, containerName?:string, containerPort?:int}>, serviceRegistries?:array<array{registryArn?:string, port?:int, containerName?:string, containerPort?:int}>, scale?:array{value?:float, unit?:"PERCENT"}, stabilityStatus?:"STEADY_STATE"|"STABILIZING", stabilityStatusAt?:int|string|\DateTimeInterface, tags?:array<array{key?:string, value?:string}>, fargateEphemeralStorage?:array{kmsKeyId?:string}}}>
     */
    public function updateServicePrimaryTaskSet(array $args): \AWS\Result { }

    /**
     * @param array{cluster:string, service:string, primaryTaskSet:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{taskSet?:array{id?:string, taskSetArn?:string, serviceArn?:string, clusterArn?:string, startedBy?:string, externalId?:string, status?:string, taskDefinition?:string, computedDesiredCount?:int, pendingCount?:int, runningCount?:int, createdAt?:int|string|\DateTimeInterface, updatedAt?:int|string|\DateTimeInterface, launchType?:"EC2"|"FARGATE"|"EXTERNAL", capacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, platformVersion?:string, platformFamily?:string, networkConfiguration?:array{awsvpcConfiguration?:array{subnets:array<string>, securityGroups?:array<string>, assignPublicIp?:"ENABLED"|"DISABLED"}}, loadBalancers?:array<array{targetGroupArn?:string, loadBalancerName?:string, containerName?:string, containerPort?:int}>, serviceRegistries?:array<array{registryArn?:string, port?:int, containerName?:string, containerPort?:int}>, scale?:array{value?:float, unit?:"PERCENT"}, stabilityStatus?:"STEADY_STATE"|"STABILIZING", stabilityStatusAt?:int|string|\DateTimeInterface, tags?:array<array{key?:string, value?:string}>, fargateEphemeralStorage?:array{kmsKeyId?:string}}}>
     */
    public function updateServicePrimaryTaskSetAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{cluster:string, tasks:array<string>, protectionEnabled:bool, expiresInMinutes?:int} $args
     * @return \AWS\Result<array{protectedTasks?:array<array{taskArn?:string, protectionEnabled?:bool, expirationDate?:int|string|\DateTimeInterface}>, failures?:array<array{arn?:string, reason?:string, detail?:string}>}>
     */
    public function updateTaskProtection(array $args): \AWS\Result { }

    /**
     * @param array{cluster:string, tasks:array<string>, protectionEnabled:bool, expiresInMinutes?:int} $args
     * @return \GuzzleHttp\Promise\Promise<array{protectedTasks?:array<array{taskArn?:string, protectionEnabled?:bool, expirationDate?:int|string|\DateTimeInterface}>, failures?:array<array{arn?:string, reason?:string, detail?:string}>}>
     */
    public function updateTaskProtectionAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{cluster:string, service:string, taskSet:string, scale:array{value?:float, unit?:"PERCENT"}} $args
     * @return \AWS\Result<array{taskSet?:array{id?:string, taskSetArn?:string, serviceArn?:string, clusterArn?:string, startedBy?:string, externalId?:string, status?:string, taskDefinition?:string, computedDesiredCount?:int, pendingCount?:int, runningCount?:int, createdAt?:int|string|\DateTimeInterface, updatedAt?:int|string|\DateTimeInterface, launchType?:"EC2"|"FARGATE"|"EXTERNAL", capacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, platformVersion?:string, platformFamily?:string, networkConfiguration?:array{awsvpcConfiguration?:array{subnets:array<string>, securityGroups?:array<string>, assignPublicIp?:"ENABLED"|"DISABLED"}}, loadBalancers?:array<array{targetGroupArn?:string, loadBalancerName?:string, containerName?:string, containerPort?:int}>, serviceRegistries?:array<array{registryArn?:string, port?:int, containerName?:string, containerPort?:int}>, scale?:array{value?:float, unit?:"PERCENT"}, stabilityStatus?:"STEADY_STATE"|"STABILIZING", stabilityStatusAt?:int|string|\DateTimeInterface, tags?:array<array{key?:string, value?:string}>, fargateEphemeralStorage?:array{kmsKeyId?:string}}}>
     */
    public function updateTaskSet(array $args): \AWS\Result { }

    /**
     * @param array{cluster:string, service:string, taskSet:string, scale:array{value?:float, unit?:"PERCENT"}} $args
     * @return \GuzzleHttp\Promise\Promise<array{taskSet?:array{id?:string, taskSetArn?:string, serviceArn?:string, clusterArn?:string, startedBy?:string, externalId?:string, status?:string, taskDefinition?:string, computedDesiredCount?:int, pendingCount?:int, runningCount?:int, createdAt?:int|string|\DateTimeInterface, updatedAt?:int|string|\DateTimeInterface, launchType?:"EC2"|"FARGATE"|"EXTERNAL", capacityProviderStrategy?:array<array{capacityProvider:string, weight?:int, base?:int}>, platformVersion?:string, platformFamily?:string, networkConfiguration?:array{awsvpcConfiguration?:array{subnets:array<string>, securityGroups?:array<string>, assignPublicIp?:"ENABLED"|"DISABLED"}}, loadBalancers?:array<array{targetGroupArn?:string, loadBalancerName?:string, containerName?:string, containerPort?:int}>, serviceRegistries?:array<array{registryArn?:string, port?:int, containerName?:string, containerPort?:int}>, scale?:array{value?:float, unit?:"PERCENT"}, stabilityStatus?:"STEADY_STATE"|"STABILIZING", stabilityStatusAt?:int|string|\DateTimeInterface, tags?:array<array{key?:string, value?:string}>, fargateEphemeralStorage?:array{kmsKeyId?:string}}}>
     */
    public function updateTaskSetAsync(array $args): \GuzzleHttp\Promise\Promise { }
}
