<?php
namespace AWS\Glue;

class GlueClient
{
    /**
     * @param array{CatalogId?:string, DatabaseName:string, TableName:string, PartitionInputList:array<array{Values?:array<string>, LastAccessTime?:int|string|\DateTimeInterface, StorageDescriptor?:array{Columns?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, Location?:string, AdditionalLocations?:array<string>, InputFormat?:string, OutputFormat?:string, Compressed?:bool, NumberOfBuckets?:int, SerdeInfo?:array{Name?:string, SerializationLibrary?:string, Parameters?:array<string, string>}, BucketColumns?:array<string>, SortColumns?:array<array{Column:string, SortOrder:int}>, Parameters?:array<string, string>, SkewedInfo?:array{SkewedColumnNames?:array<string>, SkewedColumnValues?:array<string>, SkewedColumnValueLocationMaps?:array<string, string>}, StoredAsSubDirectories?:bool, SchemaReference?:array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionId?:string, SchemaVersionNumber?:int}}, Parameters?:array<string, string>, LastAnalyzedTime?:int|string|\DateTimeInterface}>} $args
     * @return \AWS\Result<array{Errors?:array<array{PartitionValues?:array<string>, ErrorDetail?:array{ErrorCode?:string, ErrorMessage?:string}}>}>
     */
    public function batchCreatePartition(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, TableName:string, PartitionInputList:array<array{Values?:array<string>, LastAccessTime?:int|string|\DateTimeInterface, StorageDescriptor?:array{Columns?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, Location?:string, AdditionalLocations?:array<string>, InputFormat?:string, OutputFormat?:string, Compressed?:bool, NumberOfBuckets?:int, SerdeInfo?:array{Name?:string, SerializationLibrary?:string, Parameters?:array<string, string>}, BucketColumns?:array<string>, SortColumns?:array<array{Column:string, SortOrder:int}>, Parameters?:array<string, string>, SkewedInfo?:array{SkewedColumnNames?:array<string>, SkewedColumnValues?:array<string>, SkewedColumnValueLocationMaps?:array<string, string>}, StoredAsSubDirectories?:bool, SchemaReference?:array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionId?:string, SchemaVersionNumber?:int}}, Parameters?:array<string, string>, LastAnalyzedTime?:int|string|\DateTimeInterface}>} $args
     * @return \GuzzleHttp\Promise\Promise<array{Errors?:array<array{PartitionValues?:array<string>, ErrorDetail?:array{ErrorCode?:string, ErrorMessage?:string}}>}>
     */
    public function batchCreatePartitionAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId?:string, ConnectionNameList:array<string>} $args
     * @return \AWS\Result<array{Succeeded?:array<string>, Errors?:array<string, array{ErrorCode?:string, ErrorMessage?:string}>}>
     */
    public function batchDeleteConnection(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId?:string, ConnectionNameList:array<string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{Succeeded?:array<string>, Errors?:array<string, array{ErrorCode?:string, ErrorMessage?:string}>}>
     */
    public function batchDeleteConnectionAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, TableName:string, PartitionsToDelete:array<array{Values:array<string>}>} $args
     * @return \AWS\Result<array{Errors?:array<array{PartitionValues?:array<string>, ErrorDetail?:array{ErrorCode?:string, ErrorMessage?:string}}>}>
     */
    public function batchDeletePartition(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, TableName:string, PartitionsToDelete:array<array{Values:array<string>}>} $args
     * @return \GuzzleHttp\Promise\Promise<array{Errors?:array<array{PartitionValues?:array<string>, ErrorDetail?:array{ErrorCode?:string, ErrorMessage?:string}}>}>
     */
    public function batchDeletePartitionAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, TablesToDelete:array<string>, TransactionId?:string} $args
     * @return \AWS\Result<array{Errors?:array<array{TableName?:string, ErrorDetail?:array{ErrorCode?:string, ErrorMessage?:string}}>}>
     */
    public function batchDeleteTable(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, TablesToDelete:array<string>, TransactionId?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Errors?:array<array{TableName?:string, ErrorDetail?:array{ErrorCode?:string, ErrorMessage?:string}}>}>
     */
    public function batchDeleteTableAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, TableName:string, VersionIds:array<string>} $args
     * @return \AWS\Result<array{Errors?:array<array{TableName?:string, VersionId?:string, ErrorDetail?:array{ErrorCode?:string, ErrorMessage?:string}}>}>
     */
    public function batchDeleteTableVersion(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, TableName:string, VersionIds:array<string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{Errors?:array<array{TableName?:string, VersionId?:string, ErrorDetail?:array{ErrorCode?:string, ErrorMessage?:string}}>}>
     */
    public function batchDeleteTableVersionAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Names:array<string>, IncludeBlueprint?:bool, IncludeParameterSpec?:bool} $args
     * @return \AWS\Result<array{Blueprints?:array<array{Name?:string, Description?:string, CreatedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface, ParameterSpec?:string, BlueprintLocation?:string, BlueprintServiceLocation?:string, Status?:"CREATING"|"ACTIVE"|"UPDATING"|"FAILED", ErrorMessage?:string, LastActiveDefinition?:array{Description?:string, LastModifiedOn?:int|string|\DateTimeInterface, ParameterSpec?:string, BlueprintLocation?:string, BlueprintServiceLocation?:string}}>, MissingBlueprints?:array<string>}>
     */
    public function batchGetBlueprints(array $args): \AWS\Result { }

    /**
     * @param array{Names:array<string>, IncludeBlueprint?:bool, IncludeParameterSpec?:bool} $args
     * @return \GuzzleHttp\Promise\Promise<array{Blueprints?:array<array{Name?:string, Description?:string, CreatedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface, ParameterSpec?:string, BlueprintLocation?:string, BlueprintServiceLocation?:string, Status?:"CREATING"|"ACTIVE"|"UPDATING"|"FAILED", ErrorMessage?:string, LastActiveDefinition?:array{Description?:string, LastModifiedOn?:int|string|\DateTimeInterface, ParameterSpec?:string, BlueprintLocation?:string, BlueprintServiceLocation?:string}}>, MissingBlueprints?:array<string>}>
     */
    public function batchGetBlueprintsAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CrawlerNames:array<string>} $args
     * @return \AWS\Result<array{Crawlers?:array<array{Name?:string, Role?:string, Targets?:array{S3Targets?:array<array{Path?:string, Exclusions?:array<string>, ConnectionName?:string, SampleSize?:int, EventQueueArn?:string, DlqEventQueueArn?:string}>, JdbcTargets?:array<array{ConnectionName?:string, Path?:string, Exclusions?:array<string>, EnableAdditionalMetadata?:array<"COMMENTS"|"RAWTYPES">}>, MongoDBTargets?:array<array{ConnectionName?:string, Path?:string, ScanAll?:bool}>, DynamoDBTargets?:array<array{Path?:string, scanAll?:bool, scanRate?:float}>, CatalogTargets?:array<array{DatabaseName:string, Tables:array<string>, ConnectionName?:string, EventQueueArn?:string, DlqEventQueueArn?:string}>, DeltaTargets?:array<array{DeltaTables?:array<string>, ConnectionName?:string, WriteManifest?:bool, CreateNativeDeltaTable?:bool}>, IcebergTargets?:array<array{Paths?:array<string>, ConnectionName?:string, Exclusions?:array<string>, MaximumTraversalDepth?:int}>, HudiTargets?:array<array{Paths?:array<string>, ConnectionName?:string, Exclusions?:array<string>, MaximumTraversalDepth?:int}>}, DatabaseName?:string, Description?:string, Classifiers?:array<string>, RecrawlPolicy?:array{RecrawlBehavior?:"CRAWL_EVERYTHING"|"CRAWL_NEW_FOLDERS_ONLY"|"CRAWL_EVENT_MODE"}, SchemaChangePolicy?:array{UpdateBehavior?:"LOG"|"UPDATE_IN_DATABASE", DeleteBehavior?:"LOG"|"DELETE_FROM_DATABASE"|"DEPRECATE_IN_DATABASE"}, LineageConfiguration?:array{CrawlerLineageSettings?:"ENABLE"|"DISABLE"}, State?:"READY"|"RUNNING"|"STOPPING", TablePrefix?:string, Schedule?:array{ScheduleExpression?:string, State?:"SCHEDULED"|"NOT_SCHEDULED"|"TRANSITIONING"}, CrawlElapsedTime?:int, CreationTime?:int|string|\DateTimeInterface, LastUpdated?:int|string|\DateTimeInterface, LastCrawl?:array{Status?:"SUCCEEDED"|"CANCELLED"|"FAILED", ErrorMessage?:string, LogGroup?:string, LogStream?:string, MessagePrefix?:string, StartTime?:int|string|\DateTimeInterface}, Version?:int, Configuration?:string, CrawlerSecurityConfiguration?:string, LakeFormationConfiguration?:array{UseLakeFormationCredentials?:bool, AccountId?:string}}>, CrawlersNotFound?:array<string>}>
     */
    public function batchGetCrawlers(array $args): \AWS\Result { }

    /**
     * @param array{CrawlerNames:array<string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{Crawlers?:array<array{Name?:string, Role?:string, Targets?:array{S3Targets?:array<array{Path?:string, Exclusions?:array<string>, ConnectionName?:string, SampleSize?:int, EventQueueArn?:string, DlqEventQueueArn?:string}>, JdbcTargets?:array<array{ConnectionName?:string, Path?:string, Exclusions?:array<string>, EnableAdditionalMetadata?:array<"COMMENTS"|"RAWTYPES">}>, MongoDBTargets?:array<array{ConnectionName?:string, Path?:string, ScanAll?:bool}>, DynamoDBTargets?:array<array{Path?:string, scanAll?:bool, scanRate?:float}>, CatalogTargets?:array<array{DatabaseName:string, Tables:array<string>, ConnectionName?:string, EventQueueArn?:string, DlqEventQueueArn?:string}>, DeltaTargets?:array<array{DeltaTables?:array<string>, ConnectionName?:string, WriteManifest?:bool, CreateNativeDeltaTable?:bool}>, IcebergTargets?:array<array{Paths?:array<string>, ConnectionName?:string, Exclusions?:array<string>, MaximumTraversalDepth?:int}>, HudiTargets?:array<array{Paths?:array<string>, ConnectionName?:string, Exclusions?:array<string>, MaximumTraversalDepth?:int}>}, DatabaseName?:string, Description?:string, Classifiers?:array<string>, RecrawlPolicy?:array{RecrawlBehavior?:"CRAWL_EVERYTHING"|"CRAWL_NEW_FOLDERS_ONLY"|"CRAWL_EVENT_MODE"}, SchemaChangePolicy?:array{UpdateBehavior?:"LOG"|"UPDATE_IN_DATABASE", DeleteBehavior?:"LOG"|"DELETE_FROM_DATABASE"|"DEPRECATE_IN_DATABASE"}, LineageConfiguration?:array{CrawlerLineageSettings?:"ENABLE"|"DISABLE"}, State?:"READY"|"RUNNING"|"STOPPING", TablePrefix?:string, Schedule?:array{ScheduleExpression?:string, State?:"SCHEDULED"|"NOT_SCHEDULED"|"TRANSITIONING"}, CrawlElapsedTime?:int, CreationTime?:int|string|\DateTimeInterface, LastUpdated?:int|string|\DateTimeInterface, LastCrawl?:array{Status?:"SUCCEEDED"|"CANCELLED"|"FAILED", ErrorMessage?:string, LogGroup?:string, LogStream?:string, MessagePrefix?:string, StartTime?:int|string|\DateTimeInterface}, Version?:int, Configuration?:string, CrawlerSecurityConfiguration?:string, LakeFormationConfiguration?:array{UseLakeFormationCredentials?:bool, AccountId?:string}}>, CrawlersNotFound?:array<string>}>
     */
    public function batchGetCrawlersAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Names:array<string>} $args
     * @return \AWS\Result<array{CustomEntityTypes?:array<array{Name:string, RegexString:string, ContextWords?:array<string>}>, CustomEntityTypesNotFound?:array<string>}>
     */
    public function batchGetCustomEntityTypes(array $args): \AWS\Result { }

    /**
     * @param array{Names:array<string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{CustomEntityTypes?:array<array{Name:string, RegexString:string, ContextWords?:array<string>}>, CustomEntityTypesNotFound?:array<string>}>
     */
    public function batchGetCustomEntityTypesAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ResultIds:array<string>} $args
     * @return \AWS\Result<array{Results:array<array{ResultId?:string, ProfileId?:string, Score?:float, DataSource?:array{GlueTable:array{DatabaseName:string, TableName:string, CatalogId?:string, ConnectionName?:string, AdditionalOptions?:array<string, string>}}, RulesetName?:string, EvaluationContext?:string, StartedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, JobName?:string, JobRunId?:string, RulesetEvaluationRunId?:string, RuleResults?:array<array{Name?:string, Description?:string, EvaluationMessage?:string, Result?:"PASS"|"FAIL"|"ERROR", EvaluatedMetrics?:array<string, float>, EvaluatedRule?:string}>, AnalyzerResults?:array<array{Name?:string, Description?:string, EvaluationMessage?:string, EvaluatedMetrics?:array<string, float>}>, Observations?:array<array{Description?:string, MetricBasedObservation?:array{MetricName?:string, StatisticId?:string, MetricValues?:array{ActualValue?:float, ExpectedValue?:float, LowerLimit?:float, UpperLimit?:float}, NewRules?:array<string>}}>}>, ResultsNotFound?:array<string>}>
     */
    public function batchGetDataQualityResult(array $args): \AWS\Result { }

    /**
     * @param array{ResultIds:array<string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{Results:array<array{ResultId?:string, ProfileId?:string, Score?:float, DataSource?:array{GlueTable:array{DatabaseName:string, TableName:string, CatalogId?:string, ConnectionName?:string, AdditionalOptions?:array<string, string>}}, RulesetName?:string, EvaluationContext?:string, StartedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, JobName?:string, JobRunId?:string, RulesetEvaluationRunId?:string, RuleResults?:array<array{Name?:string, Description?:string, EvaluationMessage?:string, Result?:"PASS"|"FAIL"|"ERROR", EvaluatedMetrics?:array<string, float>, EvaluatedRule?:string}>, AnalyzerResults?:array<array{Name?:string, Description?:string, EvaluationMessage?:string, EvaluatedMetrics?:array<string, float>}>, Observations?:array<array{Description?:string, MetricBasedObservation?:array{MetricName?:string, StatisticId?:string, MetricValues?:array{ActualValue?:float, ExpectedValue?:float, LowerLimit?:float, UpperLimit?:float}, NewRules?:array<string>}}>}>, ResultsNotFound?:array<string>}>
     */
    public function batchGetDataQualityResultAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{DevEndpointNames:array<string>} $args
     * @return \AWS\Result<array{DevEndpoints?:array<array{EndpointName?:string, RoleArn?:string, SecurityGroupIds?:array<string>, SubnetId?:string, YarnEndpointAddress?:string, PrivateAddress?:string, ZeppelinRemoteSparkInterpreterPort?:int, PublicAddress?:string, Status?:string, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", GlueVersion?:string, NumberOfWorkers?:int, NumberOfNodes?:int, AvailabilityZone?:string, VpcId?:string, ExtraPythonLibsS3Path?:string, ExtraJarsS3Path?:string, FailureReason?:string, LastUpdateStatus?:string, CreatedTimestamp?:int|string|\DateTimeInterface, LastModifiedTimestamp?:int|string|\DateTimeInterface, PublicKey?:string, PublicKeys?:array<string>, SecurityConfiguration?:string, Arguments?:array<string, string>}>, DevEndpointsNotFound?:array<string>}>
     */
    public function batchGetDevEndpoints(array $args): \AWS\Result { }

    /**
     * @param array{DevEndpointNames:array<string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{DevEndpoints?:array<array{EndpointName?:string, RoleArn?:string, SecurityGroupIds?:array<string>, SubnetId?:string, YarnEndpointAddress?:string, PrivateAddress?:string, ZeppelinRemoteSparkInterpreterPort?:int, PublicAddress?:string, Status?:string, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", GlueVersion?:string, NumberOfWorkers?:int, NumberOfNodes?:int, AvailabilityZone?:string, VpcId?:string, ExtraPythonLibsS3Path?:string, ExtraJarsS3Path?:string, FailureReason?:string, LastUpdateStatus?:string, CreatedTimestamp?:int|string|\DateTimeInterface, LastModifiedTimestamp?:int|string|\DateTimeInterface, PublicKey?:string, PublicKeys?:array<string>, SecurityConfiguration?:string, Arguments?:array<string, string>}>, DevEndpointsNotFound?:array<string>}>
     */
    public function batchGetDevEndpointsAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{JobNames:array<string>} $args
     * @return \AWS\Result<array{Jobs?:array<array{Name?:string, JobMode?:"SCRIPT"|"VISUAL"|"NOTEBOOK", JobRunQueuingEnabled?:bool, Description?:string, LogUri?:string, Role?:string, CreatedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface, ExecutionProperty?:array{MaxConcurrentRuns?:int}, Command?:array{Name?:string, ScriptLocation?:string, PythonVersion?:string, Runtime?:string}, DefaultArguments?:array<string, string>, NonOverridableArguments?:array<string, string>, Connections?:array{Connections?:mixed}, MaxRetries?:int, AllocatedCapacity?:int, Timeout?:int, MaxCapacity?:float, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", NumberOfWorkers?:int, SecurityConfiguration?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, GlueVersion?:string, CodeGenConfigurationNodes?:array<string, array{AthenaConnectorSource?:array{Name:string, ConnectionName:string, ConnectorName:string, ConnectionType:string, ConnectionTable?:string, SchemaName:string, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, JDBCConnectorSource?:array{Name:string, ConnectionName:string, ConnectorName:string, ConnectionType:string, AdditionalOptions?:array{FilterPredicate?:string, PartitionColumn?:string, LowerBound?:int, UpperBound?:int, NumPartitions?:int, JobBookmarkKeys?:array<string>, JobBookmarkKeysSortOrder?:string, DataTypeMapping?:array<"ARRAY"|"BIGINT"|"BINARY"|"BIT"|"BLOB"|"BOOLEAN"|"CHAR"|"CLOB"|"DATALINK"|"DATE"|"DECIMAL"|"DISTINCT"|"DOUBLE"|"FLOAT"|"INTEGER"|"JAVA_OBJECT"|"LONGNVARCHAR"|"LONGVARBINARY"|"LONGVARCHAR"|"NCHAR"|"NCLOB"|"NULL"|"NUMERIC"|"NVARCHAR"|"OTHER"|"REAL"|"REF"|"REF_CURSOR"|"ROWID"|"SMALLINT"|"SQLXML"|"STRUCT"|"TIME"|"TIME_WITH_TIMEZONE"|"TIMESTAMP"|"TIMESTAMP_WITH_TIMEZONE"|"TINYINT"|"VARBINARY"|"VARCHAR", "DATE"|"STRING"|"TIMESTAMP"|"INT"|"FLOAT"|"LONG"|"BIGDECIMAL"|"BYTE"|"SHORT"|"DOUBLE">}, ConnectionTable?:string, Query?:string, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, SparkConnectorSource?:array{Name:string, ConnectionName:string, ConnectorName:string, ConnectionType:string, AdditionalOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, CatalogSource?:array{Name:string, Database:string, Table:string}, RedshiftSource?:array{Name:string, Database:string, Table:string, RedshiftTmpDir?:string, TmpDirIAMRole?:string}, S3CatalogSource?:array{Name:string, Database:string, Table:string, PartitionPredicate?:string, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int}}, S3CsvSource?:array{Name:string, Paths:array<string>, CompressionType?:"gzip"|"bzip2", Exclusions?:array<string>, GroupSize?:string, GroupFiles?:string, Recurse?:bool, MaxBand?:int, MaxFilesInBand?:int, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, Separator:"comma"|"ctrla"|"pipe"|"semicolon"|"tab", Escaper?:string, QuoteChar:"quote"|"quillemet"|"single_quote"|"disabled", Multiline?:bool, WithHeader?:bool, WriteHeader?:bool, SkipFirst?:bool, OptimizePerformance?:bool, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3JsonSource?:array{Name:string, Paths:array<string>, CompressionType?:"gzip"|"bzip2", Exclusions?:array<string>, GroupSize?:string, GroupFiles?:string, Recurse?:bool, MaxBand?:int, MaxFilesInBand?:int, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, JsonPath?:string, Multiline?:bool, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3ParquetSource?:array{Name:string, Paths:array<string>, CompressionType?:"snappy"|"lzo"|"gzip"|"uncompressed"|"none", Exclusions?:array<string>, GroupSize?:string, GroupFiles?:string, Recurse?:bool, MaxBand?:int, MaxFilesInBand?:int, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, RelationalCatalogSource?:array{Name:string, Database:string, Table:string}, DynamoDBCatalogSource?:array{Name:string, Database:string, Table:string}, JDBCConnectorTarget?:array{Name:string, Inputs:array<string>, ConnectionName:string, ConnectionTable:string, ConnectorName:string, ConnectionType:string, AdditionalOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, SparkConnectorTarget?:array{Name:string, Inputs:array<string>, ConnectionName:string, ConnectorName:string, ConnectionType:string, AdditionalOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, CatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Database:string, Table:string}, RedshiftTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string, RedshiftTmpDir?:string, TmpDirIAMRole?:string, UpsertRedshiftOptions?:array{TableLocation?:string, ConnectionName?:string, UpsertKeys?:array<string>}}, S3CatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Table:string, Database:string, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG"}}, S3GlueParquetTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Path:string, Compression?:"snappy"|"lzo"|"gzip"|"uncompressed"|"none", SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG", Table?:string, Database?:string}}, S3DirectTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Path:string, Compression?:string, Format:"json"|"csv"|"avro"|"orc"|"parquet"|"hudi"|"delta", SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG", Table?:string, Database?:string}}, ApplyMapping?:array{Name:string, Inputs:array<string>, Mapping:array<array{ToKey?:string, FromPath?:array<string>, FromType?:string, ToType?:string, Dropped?:bool, Children?:array<array{ToKey?:string, FromPath?:array<string>, FromType?:string, ToType?:string, Dropped?:bool, Children?:mixed}>}>}, SelectFields?:array{Name:string, Inputs:array<string>, Paths:array<array<string>>}, DropFields?:array{Name:string, Inputs:array<string>, Paths:array<array<string>>}, RenameField?:array{Name:string, Inputs:array<string>, SourcePath:array<string>, TargetPath:array<string>}, Spigot?:array{Name:string, Inputs:array<string>, Path:string, Topk?:int, Prob?:float}, Join?:array{Name:string, Inputs:array<string>, JoinType:"equijoin"|"left"|"right"|"outer"|"leftsemi"|"leftanti", Columns:array<array{From:string, Keys:array<array<string>>}>}, SplitFields?:array{Name:string, Inputs:array<string>, Paths:array<array<string>>}, SelectFromCollection?:array{Name:string, Inputs:array<string>, Index:int}, FillMissingValues?:array{Name:string, Inputs:array<string>, ImputedPath:string, FilledPath?:string}, Filter?:array{Name:string, Inputs:array<string>, LogicalOperator:"AND"|"OR", Filters:array<array{Operation:"EQ"|"LT"|"GT"|"LTE"|"GTE"|"REGEX"|"ISNULL", Negated?:bool, Values:array<array{Type:"COLUMNEXTRACTED"|"CONSTANT", Value:array<string>}>}>}, CustomCode?:array{Name:string, Inputs:array<string>, Code:string, ClassName:string, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, SparkSQL?:array{Name:string, Inputs:array<string>, SqlQuery:string, SqlAliases:array<array{From:string, Alias:string}>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, DirectKinesisSource?:array{Name:string, WindowSize?:int, DetectSchema?:bool, StreamingOptions?:array{EndpointUrl?:string, StreamName?:string, Classification?:string, Delimiter?:string, StartingPosition?:"latest"|"trim_horizon"|"earliest"|"timestamp", MaxFetchTimeInMs?:int, MaxFetchRecordsPerShard?:int, MaxRecordPerRead?:int, AddIdleTimeBetweenReads?:bool, IdleTimeBetweenReadsInMs?:int, DescribeShardInterval?:int, NumRetries?:int, RetryIntervalMs?:int, MaxRetryIntervalMs?:int, AvoidEmptyBatches?:bool, StreamArn?:string, RoleArn?:string, RoleSessionName?:string, AddRecordTimestamp?:string, EmitConsumerLagMetrics?:string, StartingTimestamp?:int|string|\DateTimeInterface}, DataPreviewOptions?:array{PollingTime?:int, RecordPollingLimit?:int}}, DirectKafkaSource?:array{Name:string, StreamingOptions?:array{BootstrapServers?:string, SecurityProtocol?:string, ConnectionName?:string, TopicName?:string, Assign?:string, SubscribePattern?:string, Classification?:string, Delimiter?:string, StartingOffsets?:string, EndingOffsets?:string, PollTimeoutMs?:int, NumRetries?:int, RetryIntervalMs?:int, MaxOffsetsPerTrigger?:int, MinPartitions?:int, IncludeHeaders?:bool, AddRecordTimestamp?:string, EmitConsumerLagMetrics?:string, StartingTimestamp?:int|string|\DateTimeInterface}, WindowSize?:int, DetectSchema?:bool, DataPreviewOptions?:array{PollingTime?:int, RecordPollingLimit?:int}}, CatalogKinesisSource?:array{Name:string, WindowSize?:int, DetectSchema?:bool, Table:string, Database:string, StreamingOptions?:array{EndpointUrl?:string, StreamName?:string, Classification?:string, Delimiter?:string, StartingPosition?:"latest"|"trim_horizon"|"earliest"|"timestamp", MaxFetchTimeInMs?:int, MaxFetchRecordsPerShard?:int, MaxRecordPerRead?:int, AddIdleTimeBetweenReads?:bool, IdleTimeBetweenReadsInMs?:int, DescribeShardInterval?:int, NumRetries?:int, RetryIntervalMs?:int, MaxRetryIntervalMs?:int, AvoidEmptyBatches?:bool, StreamArn?:string, RoleArn?:string, RoleSessionName?:string, AddRecordTimestamp?:string, EmitConsumerLagMetrics?:string, StartingTimestamp?:int|string|\DateTimeInterface}, DataPreviewOptions?:array{PollingTime?:int, RecordPollingLimit?:int}}, CatalogKafkaSource?:array{Name:string, WindowSize?:int, DetectSchema?:bool, Table:string, Database:string, StreamingOptions?:array{BootstrapServers?:string, SecurityProtocol?:string, ConnectionName?:string, TopicName?:string, Assign?:string, SubscribePattern?:string, Classification?:string, Delimiter?:string, StartingOffsets?:string, EndingOffsets?:string, PollTimeoutMs?:int, NumRetries?:int, RetryIntervalMs?:int, MaxOffsetsPerTrigger?:int, MinPartitions?:int, IncludeHeaders?:bool, AddRecordTimestamp?:string, EmitConsumerLagMetrics?:string, StartingTimestamp?:int|string|\DateTimeInterface}, DataPreviewOptions?:array{PollingTime?:int, RecordPollingLimit?:int}}, DropNullFields?:array{Name:string, Inputs:array<string>, NullCheckBoxList?:array{IsEmpty?:bool, IsNullString?:bool, IsNegOne?:bool}, NullTextList?:array<array{Value:string, Datatype:array{Id:string, Label:string}}>}, Merge?:array{Name:string, Inputs:array<string>, Source:string, PrimaryKeys:array<array<string>>}, Union?:array{Name:string, Inputs:array<string>, UnionType:"ALL"|"DISTINCT"}, PIIDetection?:array{Name:string, Inputs:array<string>, PiiType:"RowAudit"|"RowMasking"|"ColumnAudit"|"ColumnMasking", EntityTypesToDetect:array<string>, OutputColumnName?:string, SampleFraction?:float, ThresholdFraction?:float, MaskValue?:string}, Aggregate?:array{Name:string, Inputs:array<string>, Groups:array<array<string>>, Aggs:array<array{Column:array<string>, AggFunc:"avg"|"countDistinct"|"count"|"first"|"last"|"kurtosis"|"max"|"min"|"skewness"|"stddev_samp"|"stddev_pop"|"sum"|"sumDistinct"|"var_samp"|"var_pop"}>}, DropDuplicates?:array{Name:string, Inputs:array<string>, Columns?:array<array<string>>}, GovernedCatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Table:string, Database:string, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG"}}, GovernedCatalogSource?:array{Name:string, Database:string, Table:string, PartitionPredicate?:string, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int}}, MicrosoftSQLServerCatalogSource?:array{Name:string, Database:string, Table:string}, MySQLCatalogSource?:array{Name:string, Database:string, Table:string}, OracleSQLCatalogSource?:array{Name:string, Database:string, Table:string}, PostgreSQLCatalogSource?:array{Name:string, Database:string, Table:string}, MicrosoftSQLServerCatalogTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string}, MySQLCatalogTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string}, OracleSQLCatalogTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string}, PostgreSQLCatalogTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string}, DynamicTransform?:array{Name:string, TransformName:string, Inputs:array<string>, Parameters?:array<array{Name:string, Type:"str"|"int"|"float"|"complex"|"bool"|"list"|"null", ValidationRule?:string, ValidationMessage?:string, Value?:array<string>, ListType?:"str"|"int"|"float"|"complex"|"bool"|"list"|"null", IsOptional?:bool}>, FunctionName:string, Path:string, Version?:string, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, EvaluateDataQuality?:array{Name:string, Inputs:array<string>, Ruleset:string, Output?:"PrimaryInput"|"EvaluationResults", PublishingOptions?:array{EvaluationContext?:string, ResultsS3Prefix?:string, CloudWatchMetricsEnabled?:bool, ResultsPublishingEnabled?:bool}, StopJobOnFailureOptions?:array{StopJobOnFailureTiming?:"Immediate"|"AfterDataLoad"}}, S3CatalogHudiSource?:array{Name:string, Database:string, Table:string, AdditionalHudiOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, CatalogHudiSource?:array{Name:string, Database:string, Table:string, AdditionalHudiOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3HudiSource?:array{Name:string, Paths:array<string>, AdditionalHudiOptions?:array<string, string>, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3HudiCatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Table:string, Database:string, AdditionalOptions:array<string, string>, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG"}}, S3HudiDirectTarget?:array{Name:string, Inputs:array<string>, Path:string, Compression:"gzip"|"lzo"|"uncompressed"|"snappy", PartitionKeys?:array<array<string>>, Format:"json"|"csv"|"avro"|"orc"|"parquet"|"hudi"|"delta", AdditionalOptions:array<string, string>, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG", Table?:string, Database?:string}}, DirectJDBCSource?:array{Name:string, Database:string, Table:string, ConnectionName:string, ConnectionType:"sqlserver"|"mysql"|"oracle"|"postgresql"|"redshift", RedshiftTmpDir?:string}, S3CatalogDeltaSource?:array{Name:string, Database:string, Table:string, AdditionalDeltaOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, CatalogDeltaSource?:array{Name:string, Database:string, Table:string, AdditionalDeltaOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3DeltaSource?:array{Name:string, Paths:array<string>, AdditionalDeltaOptions?:array<string, string>, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3DeltaCatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Table:string, Database:string, AdditionalOptions?:array<string, string>, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG"}}, S3DeltaDirectTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Path:string, Compression:"uncompressed"|"snappy", Format:"json"|"csv"|"avro"|"orc"|"parquet"|"hudi"|"delta", AdditionalOptions?:array<string, string>, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG", Table?:string, Database?:string}}, AmazonRedshiftSource?:array{Name?:string, Data?:array{AccessType?:string, SourceType?:string, Connection?:array{Value?:string, Label?:string, Description?:string}, Schema?:array{Value?:string, Label?:string, Description?:string}, Table?:array{Value?:string, Label?:string, Description?:string}, CatalogDatabase?:array{Value?:string, Label?:string, Description?:string}, CatalogTable?:array{Value?:string, Label?:string, Description?:string}, CatalogRedshiftSchema?:string, CatalogRedshiftTable?:string, TempDir?:string, IamRole?:array{Value?:string, Label?:string, Description?:string}, AdvancedOptions?:array<array{Key?:string, Value?:string}>, SampleQuery?:string, PreAction?:string, PostAction?:string, Action?:string, TablePrefix?:string, Upsert?:bool, MergeAction?:string, MergeWhenMatched?:string, MergeWhenNotMatched?:string, MergeClause?:string, CrawlerConnection?:string, TableSchema?:array<array{Value?:string, Label?:string, Description?:string}>, StagingTable?:string, SelectedColumns?:array<array{Value?:string, Label?:string, Description?:string}>}}, AmazonRedshiftTarget?:array{Name?:string, Data?:array{AccessType?:string, SourceType?:string, Connection?:array{Value?:string, Label?:string, Description?:string}, Schema?:array{Value?:string, Label?:string, Description?:string}, Table?:array{Value?:string, Label?:string, Description?:string}, CatalogDatabase?:array{Value?:string, Label?:string, Description?:string}, CatalogTable?:array{Value?:string, Label?:string, Description?:string}, CatalogRedshiftSchema?:string, CatalogRedshiftTable?:string, TempDir?:string, IamRole?:array{Value?:string, Label?:string, Description?:string}, AdvancedOptions?:array<array{Key?:string, Value?:string}>, SampleQuery?:string, PreAction?:string, PostAction?:string, Action?:string, TablePrefix?:string, Upsert?:bool, MergeAction?:string, MergeWhenMatched?:string, MergeWhenNotMatched?:string, MergeClause?:string, CrawlerConnection?:string, TableSchema?:array<array{Value?:string, Label?:string, Description?:string}>, StagingTable?:string, SelectedColumns?:array<array{Value?:string, Label?:string, Description?:string}>}, Inputs?:array<string>}, EvaluateDataQualityMultiFrame?:array{Name:string, Inputs:array<string>, AdditionalDataSources?:array<string, string>, Ruleset:string, PublishingOptions?:array{EvaluationContext?:string, ResultsS3Prefix?:string, CloudWatchMetricsEnabled?:bool, ResultsPublishingEnabled?:bool}, AdditionalOptions?:array<"performanceTuning.caching"|"observations.scope", string>, StopJobOnFailureOptions?:array{StopJobOnFailureTiming?:"Immediate"|"AfterDataLoad"}}, Recipe?:array{Name:string, Inputs:array<string>, RecipeReference?:array{RecipeArn:string, RecipeVersion:string}, RecipeSteps?:array<array{Action:array{Operation:string, Parameters?:array<string, string>}, ConditionExpressions?:array<array{Condition:string, Value?:string, TargetColumn:string}>}>}, SnowflakeSource?:array{Name:string, Data:array{SourceType?:string, Connection?:array{Value?:string, Label?:string, Description?:string}, Schema?:string, Table?:string, Database?:string, TempDir?:string, IamRole?:array{Value?:string, Label?:string, Description?:string}, AdditionalOptions?:array<string, string>, SampleQuery?:string, PreAction?:string, PostAction?:string, Action?:string, Upsert?:bool, MergeAction?:string, MergeWhenMatched?:string, MergeWhenNotMatched?:string, MergeClause?:string, StagingTable?:string, SelectedColumns?:array<array{Value?:string, Label?:string, Description?:string}>, AutoPushdown?:bool, TableSchema?:array<array{Value?:string, Label?:string, Description?:string}>}, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, SnowflakeTarget?:array{Name:string, Data:array{SourceType?:string, Connection?:array{Value?:string, Label?:string, Description?:string}, Schema?:string, Table?:string, Database?:string, TempDir?:string, IamRole?:array{Value?:string, Label?:string, Description?:string}, AdditionalOptions?:array<string, string>, SampleQuery?:string, PreAction?:string, PostAction?:string, Action?:string, Upsert?:bool, MergeAction?:string, MergeWhenMatched?:string, MergeWhenNotMatched?:string, MergeClause?:string, StagingTable?:string, SelectedColumns?:array<array{Value?:string, Label?:string, Description?:string}>, AutoPushdown?:bool, TableSchema?:array<array{Value?:string, Label?:string, Description?:string}>}, Inputs?:array<string>}, ConnectorDataSource?:array{Name:string, ConnectionType:string, Data:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, ConnectorDataTarget?:array{Name:string, ConnectionType:string, Data:array<string, string>, Inputs?:array<string>}}>, ExecutionClass?:"FLEX"|"STANDARD", SourceControlDetails?:array{Provider?:"GITHUB"|"GITLAB"|"BITBUCKET"|"AWS_CODE_COMMIT", Repository?:string, Owner?:string, Branch?:string, Folder?:string, LastCommitId?:string, AuthStrategy?:"PERSONAL_ACCESS_TOKEN"|"AWS_SECRETS_MANAGER", AuthToken?:string}, MaintenanceWindow?:string, ProfileName?:string}>, JobsNotFound?:array<string>}>
     */
    public function batchGetJobs(array $args): \AWS\Result { }

    /**
     * @param array{JobNames:array<string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{Jobs?:array<array{Name?:string, JobMode?:"SCRIPT"|"VISUAL"|"NOTEBOOK", JobRunQueuingEnabled?:bool, Description?:string, LogUri?:string, Role?:string, CreatedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface, ExecutionProperty?:array{MaxConcurrentRuns?:int}, Command?:array{Name?:string, ScriptLocation?:string, PythonVersion?:string, Runtime?:string}, DefaultArguments?:array<string, string>, NonOverridableArguments?:array<string, string>, Connections?:array{Connections?:mixed}, MaxRetries?:int, AllocatedCapacity?:int, Timeout?:int, MaxCapacity?:float, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", NumberOfWorkers?:int, SecurityConfiguration?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, GlueVersion?:string, CodeGenConfigurationNodes?:array<string, array{AthenaConnectorSource?:array{Name:string, ConnectionName:string, ConnectorName:string, ConnectionType:string, ConnectionTable?:string, SchemaName:string, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, JDBCConnectorSource?:array{Name:string, ConnectionName:string, ConnectorName:string, ConnectionType:string, AdditionalOptions?:array{FilterPredicate?:string, PartitionColumn?:string, LowerBound?:int, UpperBound?:int, NumPartitions?:int, JobBookmarkKeys?:array<string>, JobBookmarkKeysSortOrder?:string, DataTypeMapping?:array<"ARRAY"|"BIGINT"|"BINARY"|"BIT"|"BLOB"|"BOOLEAN"|"CHAR"|"CLOB"|"DATALINK"|"DATE"|"DECIMAL"|"DISTINCT"|"DOUBLE"|"FLOAT"|"INTEGER"|"JAVA_OBJECT"|"LONGNVARCHAR"|"LONGVARBINARY"|"LONGVARCHAR"|"NCHAR"|"NCLOB"|"NULL"|"NUMERIC"|"NVARCHAR"|"OTHER"|"REAL"|"REF"|"REF_CURSOR"|"ROWID"|"SMALLINT"|"SQLXML"|"STRUCT"|"TIME"|"TIME_WITH_TIMEZONE"|"TIMESTAMP"|"TIMESTAMP_WITH_TIMEZONE"|"TINYINT"|"VARBINARY"|"VARCHAR", "DATE"|"STRING"|"TIMESTAMP"|"INT"|"FLOAT"|"LONG"|"BIGDECIMAL"|"BYTE"|"SHORT"|"DOUBLE">}, ConnectionTable?:string, Query?:string, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, SparkConnectorSource?:array{Name:string, ConnectionName:string, ConnectorName:string, ConnectionType:string, AdditionalOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, CatalogSource?:array{Name:string, Database:string, Table:string}, RedshiftSource?:array{Name:string, Database:string, Table:string, RedshiftTmpDir?:string, TmpDirIAMRole?:string}, S3CatalogSource?:array{Name:string, Database:string, Table:string, PartitionPredicate?:string, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int}}, S3CsvSource?:array{Name:string, Paths:array<string>, CompressionType?:"gzip"|"bzip2", Exclusions?:array<string>, GroupSize?:string, GroupFiles?:string, Recurse?:bool, MaxBand?:int, MaxFilesInBand?:int, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, Separator:"comma"|"ctrla"|"pipe"|"semicolon"|"tab", Escaper?:string, QuoteChar:"quote"|"quillemet"|"single_quote"|"disabled", Multiline?:bool, WithHeader?:bool, WriteHeader?:bool, SkipFirst?:bool, OptimizePerformance?:bool, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3JsonSource?:array{Name:string, Paths:array<string>, CompressionType?:"gzip"|"bzip2", Exclusions?:array<string>, GroupSize?:string, GroupFiles?:string, Recurse?:bool, MaxBand?:int, MaxFilesInBand?:int, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, JsonPath?:string, Multiline?:bool, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3ParquetSource?:array{Name:string, Paths:array<string>, CompressionType?:"snappy"|"lzo"|"gzip"|"uncompressed"|"none", Exclusions?:array<string>, GroupSize?:string, GroupFiles?:string, Recurse?:bool, MaxBand?:int, MaxFilesInBand?:int, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, RelationalCatalogSource?:array{Name:string, Database:string, Table:string}, DynamoDBCatalogSource?:array{Name:string, Database:string, Table:string}, JDBCConnectorTarget?:array{Name:string, Inputs:array<string>, ConnectionName:string, ConnectionTable:string, ConnectorName:string, ConnectionType:string, AdditionalOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, SparkConnectorTarget?:array{Name:string, Inputs:array<string>, ConnectionName:string, ConnectorName:string, ConnectionType:string, AdditionalOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, CatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Database:string, Table:string}, RedshiftTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string, RedshiftTmpDir?:string, TmpDirIAMRole?:string, UpsertRedshiftOptions?:array{TableLocation?:string, ConnectionName?:string, UpsertKeys?:array<string>}}, S3CatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Table:string, Database:string, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG"}}, S3GlueParquetTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Path:string, Compression?:"snappy"|"lzo"|"gzip"|"uncompressed"|"none", SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG", Table?:string, Database?:string}}, S3DirectTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Path:string, Compression?:string, Format:"json"|"csv"|"avro"|"orc"|"parquet"|"hudi"|"delta", SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG", Table?:string, Database?:string}}, ApplyMapping?:array{Name:string, Inputs:array<string>, Mapping:array<array{ToKey?:string, FromPath?:array<string>, FromType?:string, ToType?:string, Dropped?:bool, Children?:array<array{ToKey?:string, FromPath?:array<string>, FromType?:string, ToType?:string, Dropped?:bool, Children?:mixed}>}>}, SelectFields?:array{Name:string, Inputs:array<string>, Paths:array<array<string>>}, DropFields?:array{Name:string, Inputs:array<string>, Paths:array<array<string>>}, RenameField?:array{Name:string, Inputs:array<string>, SourcePath:array<string>, TargetPath:array<string>}, Spigot?:array{Name:string, Inputs:array<string>, Path:string, Topk?:int, Prob?:float}, Join?:array{Name:string, Inputs:array<string>, JoinType:"equijoin"|"left"|"right"|"outer"|"leftsemi"|"leftanti", Columns:array<array{From:string, Keys:array<array<string>>}>}, SplitFields?:array{Name:string, Inputs:array<string>, Paths:array<array<string>>}, SelectFromCollection?:array{Name:string, Inputs:array<string>, Index:int}, FillMissingValues?:array{Name:string, Inputs:array<string>, ImputedPath:string, FilledPath?:string}, Filter?:array{Name:string, Inputs:array<string>, LogicalOperator:"AND"|"OR", Filters:array<array{Operation:"EQ"|"LT"|"GT"|"LTE"|"GTE"|"REGEX"|"ISNULL", Negated?:bool, Values:array<array{Type:"COLUMNEXTRACTED"|"CONSTANT", Value:array<string>}>}>}, CustomCode?:array{Name:string, Inputs:array<string>, Code:string, ClassName:string, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, SparkSQL?:array{Name:string, Inputs:array<string>, SqlQuery:string, SqlAliases:array<array{From:string, Alias:string}>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, DirectKinesisSource?:array{Name:string, WindowSize?:int, DetectSchema?:bool, StreamingOptions?:array{EndpointUrl?:string, StreamName?:string, Classification?:string, Delimiter?:string, StartingPosition?:"latest"|"trim_horizon"|"earliest"|"timestamp", MaxFetchTimeInMs?:int, MaxFetchRecordsPerShard?:int, MaxRecordPerRead?:int, AddIdleTimeBetweenReads?:bool, IdleTimeBetweenReadsInMs?:int, DescribeShardInterval?:int, NumRetries?:int, RetryIntervalMs?:int, MaxRetryIntervalMs?:int, AvoidEmptyBatches?:bool, StreamArn?:string, RoleArn?:string, RoleSessionName?:string, AddRecordTimestamp?:string, EmitConsumerLagMetrics?:string, StartingTimestamp?:int|string|\DateTimeInterface}, DataPreviewOptions?:array{PollingTime?:int, RecordPollingLimit?:int}}, DirectKafkaSource?:array{Name:string, StreamingOptions?:array{BootstrapServers?:string, SecurityProtocol?:string, ConnectionName?:string, TopicName?:string, Assign?:string, SubscribePattern?:string, Classification?:string, Delimiter?:string, StartingOffsets?:string, EndingOffsets?:string, PollTimeoutMs?:int, NumRetries?:int, RetryIntervalMs?:int, MaxOffsetsPerTrigger?:int, MinPartitions?:int, IncludeHeaders?:bool, AddRecordTimestamp?:string, EmitConsumerLagMetrics?:string, StartingTimestamp?:int|string|\DateTimeInterface}, WindowSize?:int, DetectSchema?:bool, DataPreviewOptions?:array{PollingTime?:int, RecordPollingLimit?:int}}, CatalogKinesisSource?:array{Name:string, WindowSize?:int, DetectSchema?:bool, Table:string, Database:string, StreamingOptions?:array{EndpointUrl?:string, StreamName?:string, Classification?:string, Delimiter?:string, StartingPosition?:"latest"|"trim_horizon"|"earliest"|"timestamp", MaxFetchTimeInMs?:int, MaxFetchRecordsPerShard?:int, MaxRecordPerRead?:int, AddIdleTimeBetweenReads?:bool, IdleTimeBetweenReadsInMs?:int, DescribeShardInterval?:int, NumRetries?:int, RetryIntervalMs?:int, MaxRetryIntervalMs?:int, AvoidEmptyBatches?:bool, StreamArn?:string, RoleArn?:string, RoleSessionName?:string, AddRecordTimestamp?:string, EmitConsumerLagMetrics?:string, StartingTimestamp?:int|string|\DateTimeInterface}, DataPreviewOptions?:array{PollingTime?:int, RecordPollingLimit?:int}}, CatalogKafkaSource?:array{Name:string, WindowSize?:int, DetectSchema?:bool, Table:string, Database:string, StreamingOptions?:array{BootstrapServers?:string, SecurityProtocol?:string, ConnectionName?:string, TopicName?:string, Assign?:string, SubscribePattern?:string, Classification?:string, Delimiter?:string, StartingOffsets?:string, EndingOffsets?:string, PollTimeoutMs?:int, NumRetries?:int, RetryIntervalMs?:int, MaxOffsetsPerTrigger?:int, MinPartitions?:int, IncludeHeaders?:bool, AddRecordTimestamp?:string, EmitConsumerLagMetrics?:string, StartingTimestamp?:int|string|\DateTimeInterface}, DataPreviewOptions?:array{PollingTime?:int, RecordPollingLimit?:int}}, DropNullFields?:array{Name:string, Inputs:array<string>, NullCheckBoxList?:array{IsEmpty?:bool, IsNullString?:bool, IsNegOne?:bool}, NullTextList?:array<array{Value:string, Datatype:array{Id:string, Label:string}}>}, Merge?:array{Name:string, Inputs:array<string>, Source:string, PrimaryKeys:array<array<string>>}, Union?:array{Name:string, Inputs:array<string>, UnionType:"ALL"|"DISTINCT"}, PIIDetection?:array{Name:string, Inputs:array<string>, PiiType:"RowAudit"|"RowMasking"|"ColumnAudit"|"ColumnMasking", EntityTypesToDetect:array<string>, OutputColumnName?:string, SampleFraction?:float, ThresholdFraction?:float, MaskValue?:string}, Aggregate?:array{Name:string, Inputs:array<string>, Groups:array<array<string>>, Aggs:array<array{Column:array<string>, AggFunc:"avg"|"countDistinct"|"count"|"first"|"last"|"kurtosis"|"max"|"min"|"skewness"|"stddev_samp"|"stddev_pop"|"sum"|"sumDistinct"|"var_samp"|"var_pop"}>}, DropDuplicates?:array{Name:string, Inputs:array<string>, Columns?:array<array<string>>}, GovernedCatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Table:string, Database:string, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG"}}, GovernedCatalogSource?:array{Name:string, Database:string, Table:string, PartitionPredicate?:string, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int}}, MicrosoftSQLServerCatalogSource?:array{Name:string, Database:string, Table:string}, MySQLCatalogSource?:array{Name:string, Database:string, Table:string}, OracleSQLCatalogSource?:array{Name:string, Database:string, Table:string}, PostgreSQLCatalogSource?:array{Name:string, Database:string, Table:string}, MicrosoftSQLServerCatalogTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string}, MySQLCatalogTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string}, OracleSQLCatalogTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string}, PostgreSQLCatalogTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string}, DynamicTransform?:array{Name:string, TransformName:string, Inputs:array<string>, Parameters?:array<array{Name:string, Type:"str"|"int"|"float"|"complex"|"bool"|"list"|"null", ValidationRule?:string, ValidationMessage?:string, Value?:array<string>, ListType?:"str"|"int"|"float"|"complex"|"bool"|"list"|"null", IsOptional?:bool}>, FunctionName:string, Path:string, Version?:string, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, EvaluateDataQuality?:array{Name:string, Inputs:array<string>, Ruleset:string, Output?:"PrimaryInput"|"EvaluationResults", PublishingOptions?:array{EvaluationContext?:string, ResultsS3Prefix?:string, CloudWatchMetricsEnabled?:bool, ResultsPublishingEnabled?:bool}, StopJobOnFailureOptions?:array{StopJobOnFailureTiming?:"Immediate"|"AfterDataLoad"}}, S3CatalogHudiSource?:array{Name:string, Database:string, Table:string, AdditionalHudiOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, CatalogHudiSource?:array{Name:string, Database:string, Table:string, AdditionalHudiOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3HudiSource?:array{Name:string, Paths:array<string>, AdditionalHudiOptions?:array<string, string>, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3HudiCatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Table:string, Database:string, AdditionalOptions:array<string, string>, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG"}}, S3HudiDirectTarget?:array{Name:string, Inputs:array<string>, Path:string, Compression:"gzip"|"lzo"|"uncompressed"|"snappy", PartitionKeys?:array<array<string>>, Format:"json"|"csv"|"avro"|"orc"|"parquet"|"hudi"|"delta", AdditionalOptions:array<string, string>, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG", Table?:string, Database?:string}}, DirectJDBCSource?:array{Name:string, Database:string, Table:string, ConnectionName:string, ConnectionType:"sqlserver"|"mysql"|"oracle"|"postgresql"|"redshift", RedshiftTmpDir?:string}, S3CatalogDeltaSource?:array{Name:string, Database:string, Table:string, AdditionalDeltaOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, CatalogDeltaSource?:array{Name:string, Database:string, Table:string, AdditionalDeltaOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3DeltaSource?:array{Name:string, Paths:array<string>, AdditionalDeltaOptions?:array<string, string>, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3DeltaCatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Table:string, Database:string, AdditionalOptions?:array<string, string>, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG"}}, S3DeltaDirectTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Path:string, Compression:"uncompressed"|"snappy", Format:"json"|"csv"|"avro"|"orc"|"parquet"|"hudi"|"delta", AdditionalOptions?:array<string, string>, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG", Table?:string, Database?:string}}, AmazonRedshiftSource?:array{Name?:string, Data?:array{AccessType?:string, SourceType?:string, Connection?:array{Value?:string, Label?:string, Description?:string}, Schema?:array{Value?:string, Label?:string, Description?:string}, Table?:array{Value?:string, Label?:string, Description?:string}, CatalogDatabase?:array{Value?:string, Label?:string, Description?:string}, CatalogTable?:array{Value?:string, Label?:string, Description?:string}, CatalogRedshiftSchema?:string, CatalogRedshiftTable?:string, TempDir?:string, IamRole?:array{Value?:string, Label?:string, Description?:string}, AdvancedOptions?:array<array{Key?:string, Value?:string}>, SampleQuery?:string, PreAction?:string, PostAction?:string, Action?:string, TablePrefix?:string, Upsert?:bool, MergeAction?:string, MergeWhenMatched?:string, MergeWhenNotMatched?:string, MergeClause?:string, CrawlerConnection?:string, TableSchema?:array<array{Value?:string, Label?:string, Description?:string}>, StagingTable?:string, SelectedColumns?:array<array{Value?:string, Label?:string, Description?:string}>}}, AmazonRedshiftTarget?:array{Name?:string, Data?:array{AccessType?:string, SourceType?:string, Connection?:array{Value?:string, Label?:string, Description?:string}, Schema?:array{Value?:string, Label?:string, Description?:string}, Table?:array{Value?:string, Label?:string, Description?:string}, CatalogDatabase?:array{Value?:string, Label?:string, Description?:string}, CatalogTable?:array{Value?:string, Label?:string, Description?:string}, CatalogRedshiftSchema?:string, CatalogRedshiftTable?:string, TempDir?:string, IamRole?:array{Value?:string, Label?:string, Description?:string}, AdvancedOptions?:array<array{Key?:string, Value?:string}>, SampleQuery?:string, PreAction?:string, PostAction?:string, Action?:string, TablePrefix?:string, Upsert?:bool, MergeAction?:string, MergeWhenMatched?:string, MergeWhenNotMatched?:string, MergeClause?:string, CrawlerConnection?:string, TableSchema?:array<array{Value?:string, Label?:string, Description?:string}>, StagingTable?:string, SelectedColumns?:array<array{Value?:string, Label?:string, Description?:string}>}, Inputs?:array<string>}, EvaluateDataQualityMultiFrame?:array{Name:string, Inputs:array<string>, AdditionalDataSources?:array<string, string>, Ruleset:string, PublishingOptions?:array{EvaluationContext?:string, ResultsS3Prefix?:string, CloudWatchMetricsEnabled?:bool, ResultsPublishingEnabled?:bool}, AdditionalOptions?:array<"performanceTuning.caching"|"observations.scope", string>, StopJobOnFailureOptions?:array{StopJobOnFailureTiming?:"Immediate"|"AfterDataLoad"}}, Recipe?:array{Name:string, Inputs:array<string>, RecipeReference?:array{RecipeArn:string, RecipeVersion:string}, RecipeSteps?:array<array{Action:array{Operation:string, Parameters?:array<string, string>}, ConditionExpressions?:array<array{Condition:string, Value?:string, TargetColumn:string}>}>}, SnowflakeSource?:array{Name:string, Data:array{SourceType?:string, Connection?:array{Value?:string, Label?:string, Description?:string}, Schema?:string, Table?:string, Database?:string, TempDir?:string, IamRole?:array{Value?:string, Label?:string, Description?:string}, AdditionalOptions?:array<string, string>, SampleQuery?:string, PreAction?:string, PostAction?:string, Action?:string, Upsert?:bool, MergeAction?:string, MergeWhenMatched?:string, MergeWhenNotMatched?:string, MergeClause?:string, StagingTable?:string, SelectedColumns?:array<array{Value?:string, Label?:string, Description?:string}>, AutoPushdown?:bool, TableSchema?:array<array{Value?:string, Label?:string, Description?:string}>}, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, SnowflakeTarget?:array{Name:string, Data:array{SourceType?:string, Connection?:array{Value?:string, Label?:string, Description?:string}, Schema?:string, Table?:string, Database?:string, TempDir?:string, IamRole?:array{Value?:string, Label?:string, Description?:string}, AdditionalOptions?:array<string, string>, SampleQuery?:string, PreAction?:string, PostAction?:string, Action?:string, Upsert?:bool, MergeAction?:string, MergeWhenMatched?:string, MergeWhenNotMatched?:string, MergeClause?:string, StagingTable?:string, SelectedColumns?:array<array{Value?:string, Label?:string, Description?:string}>, AutoPushdown?:bool, TableSchema?:array<array{Value?:string, Label?:string, Description?:string}>}, Inputs?:array<string>}, ConnectorDataSource?:array{Name:string, ConnectionType:string, Data:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, ConnectorDataTarget?:array{Name:string, ConnectionType:string, Data:array<string, string>, Inputs?:array<string>}}>, ExecutionClass?:"FLEX"|"STANDARD", SourceControlDetails?:array{Provider?:"GITHUB"|"GITLAB"|"BITBUCKET"|"AWS_CODE_COMMIT", Repository?:string, Owner?:string, Branch?:string, Folder?:string, LastCommitId?:string, AuthStrategy?:"PERSONAL_ACCESS_TOKEN"|"AWS_SECRETS_MANAGER", AuthToken?:string}, MaintenanceWindow?:string, ProfileName?:string}>, JobsNotFound?:array<string>}>
     */
    public function batchGetJobsAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, TableName:string, PartitionsToGet:array<array{Values:array<string>}>} $args
     * @return \AWS\Result<array{Partitions?:array<array{Values?:array<string>, DatabaseName?:string, TableName?:string, CreationTime?:int|string|\DateTimeInterface, LastAccessTime?:int|string|\DateTimeInterface, StorageDescriptor?:array{Columns?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, Location?:string, AdditionalLocations?:array<string>, InputFormat?:string, OutputFormat?:string, Compressed?:bool, NumberOfBuckets?:int, SerdeInfo?:array{Name?:string, SerializationLibrary?:string, Parameters?:array<string, string>}, BucketColumns?:array<string>, SortColumns?:array<array{Column:string, SortOrder:int}>, Parameters?:array<string, string>, SkewedInfo?:array{SkewedColumnNames?:array<string>, SkewedColumnValues?:array<string>, SkewedColumnValueLocationMaps?:array<string, string>}, StoredAsSubDirectories?:bool, SchemaReference?:array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionId?:string, SchemaVersionNumber?:int}}, Parameters?:array<string, string>, LastAnalyzedTime?:int|string|\DateTimeInterface, CatalogId?:string}>, UnprocessedKeys?:array<array{Values:array<string>}>}>
     */
    public function batchGetPartition(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, TableName:string, PartitionsToGet:array<array{Values:array<string>}>} $args
     * @return \GuzzleHttp\Promise\Promise<array{Partitions?:array<array{Values?:array<string>, DatabaseName?:string, TableName?:string, CreationTime?:int|string|\DateTimeInterface, LastAccessTime?:int|string|\DateTimeInterface, StorageDescriptor?:array{Columns?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, Location?:string, AdditionalLocations?:array<string>, InputFormat?:string, OutputFormat?:string, Compressed?:bool, NumberOfBuckets?:int, SerdeInfo?:array{Name?:string, SerializationLibrary?:string, Parameters?:array<string, string>}, BucketColumns?:array<string>, SortColumns?:array<array{Column:string, SortOrder:int}>, Parameters?:array<string, string>, SkewedInfo?:array{SkewedColumnNames?:array<string>, SkewedColumnValues?:array<string>, SkewedColumnValueLocationMaps?:array<string, string>}, StoredAsSubDirectories?:bool, SchemaReference?:array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionId?:string, SchemaVersionNumber?:int}}, Parameters?:array<string, string>, LastAnalyzedTime?:int|string|\DateTimeInterface, CatalogId?:string}>, UnprocessedKeys?:array<array{Values:array<string>}>}>
     */
    public function batchGetPartitionAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Entries:array<array{catalogId?:string, databaseName?:string, tableName?:string, type?:"compaction"|"retention"|"orphan_file_deletion"}>} $args
     * @return \AWS\Result<array{TableOptimizers?:array<array{catalogId?:string, databaseName?:string, tableName?:string, tableOptimizer?:array{type?:"compaction"|"retention"|"orphan_file_deletion", configuration?:array{roleArn?:string, enabled?:bool, vpcConfiguration?:array{glueConnectionName?:string}, retentionConfiguration?:array{icebergConfiguration?:array{snapshotRetentionPeriodInDays?:int, numberOfSnapshotsToRetain?:int, cleanExpiredFiles?:bool}}, orphanFileDeletionConfiguration?:array{icebergConfiguration?:array{orphanFileRetentionPeriodInDays?:int, location?:string}}}, lastRun?:array{eventType?:"starting"|"completed"|"failed"|"in_progress", startTimestamp?:int|string|\DateTimeInterface, endTimestamp?:int|string|\DateTimeInterface, metrics?:array{NumberOfBytesCompacted?:string, NumberOfFilesCompacted?:string, NumberOfDpus?:string, JobDurationInHour?:string}, error?:string, compactionMetrics?:array{IcebergMetrics?:array{NumberOfBytesCompacted?:int, NumberOfFilesCompacted?:int, NumberOfDpus?:int, JobDurationInHour?:float}}, retentionMetrics?:array{IcebergMetrics?:array{NumberOfDataFilesDeleted?:int, NumberOfManifestFilesDeleted?:int, NumberOfManifestListsDeleted?:int, NumberOfDpus?:int, JobDurationInHour?:float}}, orphanFileDeletionMetrics?:array{IcebergMetrics?:array{NumberOfOrphanFilesDeleted?:int, NumberOfDpus?:int, JobDurationInHour?:float}}}}}>, Failures?:array<array{error?:array{ErrorCode?:string, ErrorMessage?:string}, catalogId?:string, databaseName?:string, tableName?:string, type?:"compaction"|"retention"|"orphan_file_deletion"}>}>
     */
    public function batchGetTableOptimizer(array $args): \AWS\Result { }

    /**
     * @param array{Entries:array<array{catalogId?:string, databaseName?:string, tableName?:string, type?:"compaction"|"retention"|"orphan_file_deletion"}>} $args
     * @return \GuzzleHttp\Promise\Promise<array{TableOptimizers?:array<array{catalogId?:string, databaseName?:string, tableName?:string, tableOptimizer?:array{type?:"compaction"|"retention"|"orphan_file_deletion", configuration?:array{roleArn?:string, enabled?:bool, vpcConfiguration?:array{glueConnectionName?:string}, retentionConfiguration?:array{icebergConfiguration?:array{snapshotRetentionPeriodInDays?:int, numberOfSnapshotsToRetain?:int, cleanExpiredFiles?:bool}}, orphanFileDeletionConfiguration?:array{icebergConfiguration?:array{orphanFileRetentionPeriodInDays?:int, location?:string}}}, lastRun?:array{eventType?:"starting"|"completed"|"failed"|"in_progress", startTimestamp?:int|string|\DateTimeInterface, endTimestamp?:int|string|\DateTimeInterface, metrics?:array{NumberOfBytesCompacted?:string, NumberOfFilesCompacted?:string, NumberOfDpus?:string, JobDurationInHour?:string}, error?:string, compactionMetrics?:array{IcebergMetrics?:array{NumberOfBytesCompacted?:int, NumberOfFilesCompacted?:int, NumberOfDpus?:int, JobDurationInHour?:float}}, retentionMetrics?:array{IcebergMetrics?:array{NumberOfDataFilesDeleted?:int, NumberOfManifestFilesDeleted?:int, NumberOfManifestListsDeleted?:int, NumberOfDpus?:int, JobDurationInHour?:float}}, orphanFileDeletionMetrics?:array{IcebergMetrics?:array{NumberOfOrphanFilesDeleted?:int, NumberOfDpus?:int, JobDurationInHour?:float}}}}}>, Failures?:array<array{error?:array{ErrorCode?:string, ErrorMessage?:string}, catalogId?:string, databaseName?:string, tableName?:string, type?:"compaction"|"retention"|"orphan_file_deletion"}>}>
     */
    public function batchGetTableOptimizerAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{TriggerNames:array<string>} $args
     * @return \AWS\Result<array{Triggers?:array<array{Name?:string, WorkflowName?:string, Id?:string, Type?:"SCHEDULED"|"CONDITIONAL"|"ON_DEMAND"|"EVENT", State?:"CREATING"|"CREATED"|"ACTIVATING"|"ACTIVATED"|"DEACTIVATING"|"DEACTIVATED"|"DELETING"|"UPDATING", Description?:string, Schedule?:string, Actions?:array<array{JobName?:string, Arguments?:array<string, string>, Timeout?:int, SecurityConfiguration?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, CrawlerName?:string}>, Predicate?:array{Logical?:"AND"|"ANY", Conditions?:array<array{LogicalOperator?:"EQUALS", JobName?:string, State?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED", CrawlerName?:string, CrawlState?:"RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR"}>}, EventBatchingCondition?:array{BatchSize:int, BatchWindow?:int}}>, TriggersNotFound?:array<string>}>
     */
    public function batchGetTriggers(array $args): \AWS\Result { }

    /**
     * @param array{TriggerNames:array<string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{Triggers?:array<array{Name?:string, WorkflowName?:string, Id?:string, Type?:"SCHEDULED"|"CONDITIONAL"|"ON_DEMAND"|"EVENT", State?:"CREATING"|"CREATED"|"ACTIVATING"|"ACTIVATED"|"DEACTIVATING"|"DEACTIVATED"|"DELETING"|"UPDATING", Description?:string, Schedule?:string, Actions?:array<array{JobName?:string, Arguments?:array<string, string>, Timeout?:int, SecurityConfiguration?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, CrawlerName?:string}>, Predicate?:array{Logical?:"AND"|"ANY", Conditions?:array<array{LogicalOperator?:"EQUALS", JobName?:string, State?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED", CrawlerName?:string, CrawlState?:"RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR"}>}, EventBatchingCondition?:array{BatchSize:int, BatchWindow?:int}}>, TriggersNotFound?:array<string>}>
     */
    public function batchGetTriggersAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Names:array<string>, IncludeGraph?:bool} $args
     * @return \AWS\Result<array{Workflows?:array<array{Name?:string, Description?:string, DefaultRunProperties?:array<string, string>, CreatedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface, LastRun?:array{Name?:string, WorkflowRunId?:string, PreviousRunId?:string, WorkflowRunProperties?:array<string, string>, StartedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, Status?:"RUNNING"|"COMPLETED"|"STOPPING"|"STOPPED"|"ERROR", ErrorMessage?:string, Statistics?:array{TotalActions?:int, TimeoutActions?:int, FailedActions?:int, StoppedActions?:int, SucceededActions?:int, RunningActions?:int, ErroredActions?:int, WaitingActions?:int}, Graph?:array{Nodes?:array<array{Type?:"CRAWLER"|"JOB"|"TRIGGER", Name?:string, UniqueId?:string, TriggerDetails?:array{Trigger?:array{Name?:string, WorkflowName?:string, Id?:string, Type?:"SCHEDULED"|"CONDITIONAL"|"ON_DEMAND"|"EVENT", State?:"CREATING"|"CREATED"|"ACTIVATING"|"ACTIVATED"|"DEACTIVATING"|"DEACTIVATED"|"DELETING"|"UPDATING", Description?:string, Schedule?:string, Actions?:array<array{JobName?:string, Arguments?:array<string, string>, Timeout?:int, SecurityConfiguration?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, CrawlerName?:string}>, Predicate?:array{Logical?:"AND"|"ANY", Conditions?:array<array{LogicalOperator?:"EQUALS", JobName?:string, State?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED", CrawlerName?:string, CrawlState?:"RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR"}>}, EventBatchingCondition?:array{BatchSize:int, BatchWindow?:int}}}, JobDetails?:array{JobRuns?:array<array{Id?:string, Attempt?:int, PreviousRunId?:string, TriggerName?:string, JobName?:string, JobMode?:"SCRIPT"|"VISUAL"|"NOTEBOOK", JobRunQueuingEnabled?:bool, StartedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, JobRunState?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED", Arguments?:array<string, string>, ErrorMessage?:string, PredecessorRuns?:array<array{JobName?:string, RunId?:string}>, AllocatedCapacity?:int, ExecutionTime?:int, Timeout?:int, MaxCapacity?:float, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", NumberOfWorkers?:int, SecurityConfiguration?:string, LogGroupName?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, GlueVersion?:string, DPUSeconds?:float, ExecutionClass?:"FLEX"|"STANDARD", MaintenanceWindow?:string, ProfileName?:string, StateDetail?:string}>}, CrawlerDetails?:array{Crawls?:array<array{State?:"RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR", StartedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, ErrorMessage?:string, LogGroup?:string, LogStream?:string}>}}>, Edges?:array<array{SourceId?:string, DestinationId?:string}>}, StartingEventBatchCondition?:array{BatchSize?:int, BatchWindow?:int}}, Graph?:array{Nodes?:array<array{Type?:"CRAWLER"|"JOB"|"TRIGGER", Name?:string, UniqueId?:string, TriggerDetails?:array{Trigger?:array{Name?:string, WorkflowName?:string, Id?:string, Type?:"SCHEDULED"|"CONDITIONAL"|"ON_DEMAND"|"EVENT", State?:"CREATING"|"CREATED"|"ACTIVATING"|"ACTIVATED"|"DEACTIVATING"|"DEACTIVATED"|"DELETING"|"UPDATING", Description?:string, Schedule?:string, Actions?:array<array{JobName?:string, Arguments?:array<string, string>, Timeout?:int, SecurityConfiguration?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, CrawlerName?:string}>, Predicate?:array{Logical?:"AND"|"ANY", Conditions?:array<array{LogicalOperator?:"EQUALS", JobName?:string, State?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED", CrawlerName?:string, CrawlState?:"RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR"}>}, EventBatchingCondition?:array{BatchSize:int, BatchWindow?:int}}}, JobDetails?:array{JobRuns?:array<array{Id?:string, Attempt?:int, PreviousRunId?:string, TriggerName?:string, JobName?:string, JobMode?:"SCRIPT"|"VISUAL"|"NOTEBOOK", JobRunQueuingEnabled?:bool, StartedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, JobRunState?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED", Arguments?:array<string, string>, ErrorMessage?:string, PredecessorRuns?:array<array{JobName?:string, RunId?:string}>, AllocatedCapacity?:int, ExecutionTime?:int, Timeout?:int, MaxCapacity?:float, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", NumberOfWorkers?:int, SecurityConfiguration?:string, LogGroupName?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, GlueVersion?:string, DPUSeconds?:float, ExecutionClass?:"FLEX"|"STANDARD", MaintenanceWindow?:string, ProfileName?:string, StateDetail?:string}>}, CrawlerDetails?:array{Crawls?:array<array{State?:"RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR", StartedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, ErrorMessage?:string, LogGroup?:string, LogStream?:string}>}}>, Edges?:array<array{SourceId?:string, DestinationId?:string}>}, MaxConcurrentRuns?:int, BlueprintDetails?:array{BlueprintName?:string, RunId?:string}}>, MissingWorkflows?:array<string>}>
     */
    public function batchGetWorkflows(array $args): \AWS\Result { }

    /**
     * @param array{Names:array<string>, IncludeGraph?:bool} $args
     * @return \GuzzleHttp\Promise\Promise<array{Workflows?:array<array{Name?:string, Description?:string, DefaultRunProperties?:array<string, string>, CreatedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface, LastRun?:array{Name?:string, WorkflowRunId?:string, PreviousRunId?:string, WorkflowRunProperties?:array<string, string>, StartedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, Status?:"RUNNING"|"COMPLETED"|"STOPPING"|"STOPPED"|"ERROR", ErrorMessage?:string, Statistics?:array{TotalActions?:int, TimeoutActions?:int, FailedActions?:int, StoppedActions?:int, SucceededActions?:int, RunningActions?:int, ErroredActions?:int, WaitingActions?:int}, Graph?:array{Nodes?:array<array{Type?:"CRAWLER"|"JOB"|"TRIGGER", Name?:string, UniqueId?:string, TriggerDetails?:array{Trigger?:array{Name?:string, WorkflowName?:string, Id?:string, Type?:"SCHEDULED"|"CONDITIONAL"|"ON_DEMAND"|"EVENT", State?:"CREATING"|"CREATED"|"ACTIVATING"|"ACTIVATED"|"DEACTIVATING"|"DEACTIVATED"|"DELETING"|"UPDATING", Description?:string, Schedule?:string, Actions?:array<array{JobName?:string, Arguments?:array<string, string>, Timeout?:int, SecurityConfiguration?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, CrawlerName?:string}>, Predicate?:array{Logical?:"AND"|"ANY", Conditions?:array<array{LogicalOperator?:"EQUALS", JobName?:string, State?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED", CrawlerName?:string, CrawlState?:"RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR"}>}, EventBatchingCondition?:array{BatchSize:int, BatchWindow?:int}}}, JobDetails?:array{JobRuns?:array<array{Id?:string, Attempt?:int, PreviousRunId?:string, TriggerName?:string, JobName?:string, JobMode?:"SCRIPT"|"VISUAL"|"NOTEBOOK", JobRunQueuingEnabled?:bool, StartedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, JobRunState?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED", Arguments?:array<string, string>, ErrorMessage?:string, PredecessorRuns?:array<array{JobName?:string, RunId?:string}>, AllocatedCapacity?:int, ExecutionTime?:int, Timeout?:int, MaxCapacity?:float, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", NumberOfWorkers?:int, SecurityConfiguration?:string, LogGroupName?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, GlueVersion?:string, DPUSeconds?:float, ExecutionClass?:"FLEX"|"STANDARD", MaintenanceWindow?:string, ProfileName?:string, StateDetail?:string}>}, CrawlerDetails?:array{Crawls?:array<array{State?:"RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR", StartedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, ErrorMessage?:string, LogGroup?:string, LogStream?:string}>}}>, Edges?:array<array{SourceId?:string, DestinationId?:string}>}, StartingEventBatchCondition?:array{BatchSize?:int, BatchWindow?:int}}, Graph?:array{Nodes?:array<array{Type?:"CRAWLER"|"JOB"|"TRIGGER", Name?:string, UniqueId?:string, TriggerDetails?:array{Trigger?:array{Name?:string, WorkflowName?:string, Id?:string, Type?:"SCHEDULED"|"CONDITIONAL"|"ON_DEMAND"|"EVENT", State?:"CREATING"|"CREATED"|"ACTIVATING"|"ACTIVATED"|"DEACTIVATING"|"DEACTIVATED"|"DELETING"|"UPDATING", Description?:string, Schedule?:string, Actions?:array<array{JobName?:string, Arguments?:array<string, string>, Timeout?:int, SecurityConfiguration?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, CrawlerName?:string}>, Predicate?:array{Logical?:"AND"|"ANY", Conditions?:array<array{LogicalOperator?:"EQUALS", JobName?:string, State?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED", CrawlerName?:string, CrawlState?:"RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR"}>}, EventBatchingCondition?:array{BatchSize:int, BatchWindow?:int}}}, JobDetails?:array{JobRuns?:array<array{Id?:string, Attempt?:int, PreviousRunId?:string, TriggerName?:string, JobName?:string, JobMode?:"SCRIPT"|"VISUAL"|"NOTEBOOK", JobRunQueuingEnabled?:bool, StartedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, JobRunState?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED", Arguments?:array<string, string>, ErrorMessage?:string, PredecessorRuns?:array<array{JobName?:string, RunId?:string}>, AllocatedCapacity?:int, ExecutionTime?:int, Timeout?:int, MaxCapacity?:float, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", NumberOfWorkers?:int, SecurityConfiguration?:string, LogGroupName?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, GlueVersion?:string, DPUSeconds?:float, ExecutionClass?:"FLEX"|"STANDARD", MaintenanceWindow?:string, ProfileName?:string, StateDetail?:string}>}, CrawlerDetails?:array{Crawls?:array<array{State?:"RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR", StartedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, ErrorMessage?:string, LogGroup?:string, LogStream?:string}>}}>, Edges?:array<array{SourceId?:string, DestinationId?:string}>}, MaxConcurrentRuns?:int, BlueprintDetails?:array{BlueprintName?:string, RunId?:string}}>, MissingWorkflows?:array<string>}>
     */
    public function batchGetWorkflowsAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{InclusionAnnotations:array<array{ProfileId?:string, StatisticId?:string, InclusionAnnotation?:"INCLUDE"|"EXCLUDE"}>, ClientToken?:string} $args
     * @return \AWS\Result<array{FailedInclusionAnnotations?:array<array{ProfileId?:string, StatisticId?:string, FailureReason?:string}>}>
     */
    public function batchPutDataQualityStatisticAnnotation(array $args): \AWS\Result { }

    /**
     * @param array{InclusionAnnotations:array<array{ProfileId?:string, StatisticId?:string, InclusionAnnotation?:"INCLUDE"|"EXCLUDE"}>, ClientToken?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{FailedInclusionAnnotations?:array<array{ProfileId?:string, StatisticId?:string, FailureReason?:string}>}>
     */
    public function batchPutDataQualityStatisticAnnotationAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{JobName:string, JobRunIds:array<string>} $args
     * @return \AWS\Result<array{SuccessfulSubmissions?:array<array{JobName?:string, JobRunId?:string}>, Errors?:array<array{JobName?:string, JobRunId?:string, ErrorDetail?:array{ErrorCode?:string, ErrorMessage?:string}}>}>
     */
    public function batchStopJobRun(array $args): \AWS\Result { }

    /**
     * @param array{JobName:string, JobRunIds:array<string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{SuccessfulSubmissions?:array<array{JobName?:string, JobRunId?:string}>, Errors?:array<array{JobName?:string, JobRunId?:string, ErrorDetail?:array{ErrorCode?:string, ErrorMessage?:string}}>}>
     */
    public function batchStopJobRunAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, TableName:string, Entries:array<array{PartitionValueList:array<string>, PartitionInput:array{Values?:array<string>, LastAccessTime?:int|string|\DateTimeInterface, StorageDescriptor?:array{Columns?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, Location?:string, AdditionalLocations?:array<string>, InputFormat?:string, OutputFormat?:string, Compressed?:bool, NumberOfBuckets?:int, SerdeInfo?:array{Name?:string, SerializationLibrary?:string, Parameters?:array<string, string>}, BucketColumns?:array<string>, SortColumns?:array<array{Column:string, SortOrder:int}>, Parameters?:array<string, string>, SkewedInfo?:array{SkewedColumnNames?:array<string>, SkewedColumnValues?:array<string>, SkewedColumnValueLocationMaps?:array<string, string>}, StoredAsSubDirectories?:bool, SchemaReference?:array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionId?:string, SchemaVersionNumber?:int}}, Parameters?:array<string, string>, LastAnalyzedTime?:int|string|\DateTimeInterface}}>} $args
     * @return \AWS\Result<array{Errors?:array<array{PartitionValueList?:array<string>, ErrorDetail?:array{ErrorCode?:string, ErrorMessage?:string}}>}>
     */
    public function batchUpdatePartition(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, TableName:string, Entries:array<array{PartitionValueList:array<string>, PartitionInput:array{Values?:array<string>, LastAccessTime?:int|string|\DateTimeInterface, StorageDescriptor?:array{Columns?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, Location?:string, AdditionalLocations?:array<string>, InputFormat?:string, OutputFormat?:string, Compressed?:bool, NumberOfBuckets?:int, SerdeInfo?:array{Name?:string, SerializationLibrary?:string, Parameters?:array<string, string>}, BucketColumns?:array<string>, SortColumns?:array<array{Column:string, SortOrder:int}>, Parameters?:array<string, string>, SkewedInfo?:array{SkewedColumnNames?:array<string>, SkewedColumnValues?:array<string>, SkewedColumnValueLocationMaps?:array<string, string>}, StoredAsSubDirectories?:bool, SchemaReference?:array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionId?:string, SchemaVersionNumber?:int}}, Parameters?:array<string, string>, LastAnalyzedTime?:int|string|\DateTimeInterface}}>} $args
     * @return \GuzzleHttp\Promise\Promise<array{Errors?:array<array{PartitionValueList?:array<string>, ErrorDetail?:array{ErrorCode?:string, ErrorMessage?:string}}>}>
     */
    public function batchUpdatePartitionAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{RunId:string} $args
     * @return \AWS\Result<array{}>
     */
    public function cancelDataQualityRuleRecommendationRun(array $args): \AWS\Result { }

    /**
     * @param array{RunId:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function cancelDataQualityRuleRecommendationRunAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{RunId:string} $args
     * @return \AWS\Result<array{}>
     */
    public function cancelDataQualityRulesetEvaluationRun(array $args): \AWS\Result { }

    /**
     * @param array{RunId:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function cancelDataQualityRulesetEvaluationRunAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{TransformId:string, TaskRunId:string} $args
     * @return \AWS\Result<array{TransformId?:string, TaskRunId?:string, Status?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"}>
     */
    public function cancelMLTaskRun(array $args): \AWS\Result { }

    /**
     * @param array{TransformId:string, TaskRunId:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{TransformId?:string, TaskRunId?:string, Status?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"}>
     */
    public function cancelMLTaskRunAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{SessionId:string, Id:int, RequestOrigin?:string} $args
     * @return \AWS\Result<array{}>
     */
    public function cancelStatement(array $args): \AWS\Result { }

    /**
     * @param array{SessionId:string, Id:int, RequestOrigin?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function cancelStatementAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{DataFormat:"AVRO"|"JSON"|"PROTOBUF", SchemaDefinition:string} $args
     * @return \AWS\Result<array{Valid?:bool, Error?:string}>
     */
    public function checkSchemaVersionValidity(array $args): \AWS\Result { }

    /**
     * @param array{DataFormat:"AVRO"|"JSON"|"PROTOBUF", SchemaDefinition:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Valid?:bool, Error?:string}>
     */
    public function checkSchemaVersionValidityAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Name:string, Description?:string, BlueprintLocation:string, Tags?:array<string, string>} $args
     * @return \AWS\Result<array{Name?:string}>
     */
    public function createBlueprint(array $args): \AWS\Result { }

    /**
     * @param array{Name:string, Description?:string, BlueprintLocation:string, Tags?:array<string, string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{Name?:string}>
     */
    public function createBlueprintAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Name:string, CatalogInput:array{Description?:string, FederatedCatalog?:array{Identifier?:string, ConnectionName?:string}, Parameters?:array<string, string>, TargetRedshiftCatalog?:array{CatalogArn:string}, CatalogProperties?:array{DataLakeAccessProperties?:array{DataLakeAccess?:bool, DataTransferRole?:string, KmsKey?:string, CatalogType?:string}, CustomProperties?:array<string, string>}, CreateTableDefaultPermissions?:array<array{Principal?:array{DataLakePrincipalIdentifier?:string}, Permissions?:array<"ALL"|"SELECT"|"ALTER"|"DROP"|"DELETE"|"INSERT"|"CREATE_DATABASE"|"CREATE_TABLE"|"DATA_LOCATION_ACCESS">}>, CreateDatabaseDefaultPermissions?:array<array{Principal?:array{DataLakePrincipalIdentifier?:string}, Permissions?:array<"ALL"|"SELECT"|"ALTER"|"DROP"|"DELETE"|"INSERT"|"CREATE_DATABASE"|"CREATE_TABLE"|"DATA_LOCATION_ACCESS">}>}, Tags?:array<string, string>} $args
     * @return \AWS\Result<array{}>
     */
    public function createCatalog(array $args): \AWS\Result { }

    /**
     * @param array{Name:string, CatalogInput:array{Description?:string, FederatedCatalog?:array{Identifier?:string, ConnectionName?:string}, Parameters?:array<string, string>, TargetRedshiftCatalog?:array{CatalogArn:string}, CatalogProperties?:array{DataLakeAccessProperties?:array{DataLakeAccess?:bool, DataTransferRole?:string, KmsKey?:string, CatalogType?:string}, CustomProperties?:array<string, string>}, CreateTableDefaultPermissions?:array<array{Principal?:array{DataLakePrincipalIdentifier?:string}, Permissions?:array<"ALL"|"SELECT"|"ALTER"|"DROP"|"DELETE"|"INSERT"|"CREATE_DATABASE"|"CREATE_TABLE"|"DATA_LOCATION_ACCESS">}>, CreateDatabaseDefaultPermissions?:array<array{Principal?:array{DataLakePrincipalIdentifier?:string}, Permissions?:array<"ALL"|"SELECT"|"ALTER"|"DROP"|"DELETE"|"INSERT"|"CREATE_DATABASE"|"CREATE_TABLE"|"DATA_LOCATION_ACCESS">}>}, Tags?:array<string, string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function createCatalogAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{GrokClassifier?:array{Classification:string, Name:string, GrokPattern:string, CustomPatterns?:string}, XMLClassifier?:array{Classification:string, Name:string, RowTag?:string}, JsonClassifier?:array{Name:string, JsonPath:string}, CsvClassifier?:array{Name:string, Delimiter?:string, QuoteSymbol?:string, ContainsHeader?:"UNKNOWN"|"PRESENT"|"ABSENT", Header?:array<string>, DisableValueTrimming?:bool, AllowSingleColumn?:bool, CustomDatatypeConfigured?:bool, CustomDatatypes?:array<string>, Serde?:"OpenCSVSerDe"|"LazySimpleSerDe"|"None"}} $args
     * @return \AWS\Result<array{}>
     */
    public function createClassifier(array $args = []): \AWS\Result { }

    /**
     * @param array{GrokClassifier?:array{Classification:string, Name:string, GrokPattern:string, CustomPatterns?:string}, XMLClassifier?:array{Classification:string, Name:string, RowTag?:string}, JsonClassifier?:array{Name:string, JsonPath:string}, CsvClassifier?:array{Name:string, Delimiter?:string, QuoteSymbol?:string, ContainsHeader?:"UNKNOWN"|"PRESENT"|"ABSENT", Header?:array<string>, DisableValueTrimming?:bool, AllowSingleColumn?:bool, CustomDatatypeConfigured?:bool, CustomDatatypes?:array<string>, Serde?:"OpenCSVSerDe"|"LazySimpleSerDe"|"None"}} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function createClassifierAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{DatabaseName:string, TableName:string, Role:string, Schedule?:string, ColumnNameList?:array<string>, SampleSize?:float, CatalogID?:string, SecurityConfiguration?:string, Tags?:array<string, string>} $args
     * @return \AWS\Result<array{}>
     */
    public function createColumnStatisticsTaskSettings(array $args): \AWS\Result { }

    /**
     * @param array{DatabaseName:string, TableName:string, Role:string, Schedule?:string, ColumnNameList?:array<string>, SampleSize?:float, CatalogID?:string, SecurityConfiguration?:string, Tags?:array<string, string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function createColumnStatisticsTaskSettingsAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId?:string, ConnectionInput:array{Name:string, Description?:string, ConnectionType:"JDBC"|"SFTP"|"MONGODB"|"KAFKA"|"NETWORK"|"MARKETPLACE"|"CUSTOM"|"SALESFORCE"|"VIEW_VALIDATION_REDSHIFT"|"VIEW_VALIDATION_ATHENA"|"GOOGLEADS"|"GOOGLESHEETS"|"GOOGLEANALYTICS4"|"SERVICENOW"|"MARKETO"|"SAPODATA"|"ZENDESK"|"JIRACLOUD"|"NETSUITEERP"|"HUBSPOT"|"FACEBOOKADS"|"INSTAGRAMADS"|"ZOHOCRM"|"SALESFORCEPARDOT"|"SALESFORCEMARKETINGCLOUD"|"SLACK"|"STRIPE"|"INTERCOM"|"SNAPCHATADS", MatchCriteria?:array<string>, ConnectionProperties:array<"HOST"|"PORT"|"USERNAME"|"PASSWORD"|"ENCRYPTED_PASSWORD"|"JDBC_DRIVER_JAR_URI"|"JDBC_DRIVER_CLASS_NAME"|"JDBC_ENGINE"|"JDBC_ENGINE_VERSION"|"CONFIG_FILES"|"INSTANCE_ID"|"JDBC_CONNECTION_URL"|"JDBC_ENFORCE_SSL"|"CUSTOM_JDBC_CERT"|"SKIP_CUSTOM_JDBC_CERT_VALIDATION"|"CUSTOM_JDBC_CERT_STRING"|"CONNECTION_URL"|"KAFKA_BOOTSTRAP_SERVERS"|"KAFKA_SSL_ENABLED"|"KAFKA_CUSTOM_CERT"|"KAFKA_SKIP_CUSTOM_CERT_VALIDATION"|"KAFKA_CLIENT_KEYSTORE"|"KAFKA_CLIENT_KEYSTORE_PASSWORD"|"KAFKA_CLIENT_KEY_PASSWORD"|"ENCRYPTED_KAFKA_CLIENT_KEYSTORE_PASSWORD"|"ENCRYPTED_KAFKA_CLIENT_KEY_PASSWORD"|"KAFKA_SASL_MECHANISM"|"KAFKA_SASL_PLAIN_USERNAME"|"KAFKA_SASL_PLAIN_PASSWORD"|"ENCRYPTED_KAFKA_SASL_PLAIN_PASSWORD"|"KAFKA_SASL_SCRAM_USERNAME"|"KAFKA_SASL_SCRAM_PASSWORD"|"KAFKA_SASL_SCRAM_SECRETS_ARN"|"ENCRYPTED_KAFKA_SASL_SCRAM_PASSWORD"|"KAFKA_SASL_GSSAPI_KEYTAB"|"KAFKA_SASL_GSSAPI_KRB5_CONF"|"KAFKA_SASL_GSSAPI_SERVICE"|"KAFKA_SASL_GSSAPI_PRINCIPAL"|"SECRET_ID"|"CONNECTOR_URL"|"CONNECTOR_TYPE"|"CONNECTOR_CLASS_NAME"|"ENDPOINT"|"ENDPOINT_TYPE"|"ROLE_ARN"|"REGION"|"WORKGROUP_NAME"|"CLUSTER_IDENTIFIER"|"DATABASE", string>, SparkProperties?:array<string, string>, AthenaProperties?:array<string, string>, PythonProperties?:array<string, string>, PhysicalConnectionRequirements?:array{SubnetId?:string, SecurityGroupIdList?:array<string>, AvailabilityZone?:string}, AuthenticationConfiguration?:array{AuthenticationType?:"BASIC"|"OAUTH2"|"CUSTOM"|"IAM", OAuth2Properties?:array{OAuth2GrantType?:"AUTHORIZATION_CODE"|"CLIENT_CREDENTIALS"|"JWT_BEARER", OAuth2ClientApplication?:array{UserManagedClientApplicationClientId?:string, AWSManagedClientApplicationReference?:string}, TokenUrl?:string, TokenUrlParametersMap?:array<string, string>, AuthorizationCodeProperties?:array{AuthorizationCode?:string, RedirectUri?:string}, OAuth2Credentials?:array{UserManagedClientApplicationClientSecret?:string, AccessToken?:string, RefreshToken?:string, JwtToken?:string}}, SecretArn?:string, KmsKeyArn?:string, BasicAuthenticationCredentials?:array{Username?:string, Password?:string}, CustomAuthenticationCredentials?:array<string, string>}, ValidateCredentials?:bool, ValidateForComputeEnvironments?:array<"SPARK"|"ATHENA"|"PYTHON">}, Tags?:array<string, string>} $args
     * @return \AWS\Result<array{CreateConnectionStatus?:"READY"|"IN_PROGRESS"|"FAILED"}>
     */
    public function createConnection(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId?:string, ConnectionInput:array{Name:string, Description?:string, ConnectionType:"JDBC"|"SFTP"|"MONGODB"|"KAFKA"|"NETWORK"|"MARKETPLACE"|"CUSTOM"|"SALESFORCE"|"VIEW_VALIDATION_REDSHIFT"|"VIEW_VALIDATION_ATHENA"|"GOOGLEADS"|"GOOGLESHEETS"|"GOOGLEANALYTICS4"|"SERVICENOW"|"MARKETO"|"SAPODATA"|"ZENDESK"|"JIRACLOUD"|"NETSUITEERP"|"HUBSPOT"|"FACEBOOKADS"|"INSTAGRAMADS"|"ZOHOCRM"|"SALESFORCEPARDOT"|"SALESFORCEMARKETINGCLOUD"|"SLACK"|"STRIPE"|"INTERCOM"|"SNAPCHATADS", MatchCriteria?:array<string>, ConnectionProperties:array<"HOST"|"PORT"|"USERNAME"|"PASSWORD"|"ENCRYPTED_PASSWORD"|"JDBC_DRIVER_JAR_URI"|"JDBC_DRIVER_CLASS_NAME"|"JDBC_ENGINE"|"JDBC_ENGINE_VERSION"|"CONFIG_FILES"|"INSTANCE_ID"|"JDBC_CONNECTION_URL"|"JDBC_ENFORCE_SSL"|"CUSTOM_JDBC_CERT"|"SKIP_CUSTOM_JDBC_CERT_VALIDATION"|"CUSTOM_JDBC_CERT_STRING"|"CONNECTION_URL"|"KAFKA_BOOTSTRAP_SERVERS"|"KAFKA_SSL_ENABLED"|"KAFKA_CUSTOM_CERT"|"KAFKA_SKIP_CUSTOM_CERT_VALIDATION"|"KAFKA_CLIENT_KEYSTORE"|"KAFKA_CLIENT_KEYSTORE_PASSWORD"|"KAFKA_CLIENT_KEY_PASSWORD"|"ENCRYPTED_KAFKA_CLIENT_KEYSTORE_PASSWORD"|"ENCRYPTED_KAFKA_CLIENT_KEY_PASSWORD"|"KAFKA_SASL_MECHANISM"|"KAFKA_SASL_PLAIN_USERNAME"|"KAFKA_SASL_PLAIN_PASSWORD"|"ENCRYPTED_KAFKA_SASL_PLAIN_PASSWORD"|"KAFKA_SASL_SCRAM_USERNAME"|"KAFKA_SASL_SCRAM_PASSWORD"|"KAFKA_SASL_SCRAM_SECRETS_ARN"|"ENCRYPTED_KAFKA_SASL_SCRAM_PASSWORD"|"KAFKA_SASL_GSSAPI_KEYTAB"|"KAFKA_SASL_GSSAPI_KRB5_CONF"|"KAFKA_SASL_GSSAPI_SERVICE"|"KAFKA_SASL_GSSAPI_PRINCIPAL"|"SECRET_ID"|"CONNECTOR_URL"|"CONNECTOR_TYPE"|"CONNECTOR_CLASS_NAME"|"ENDPOINT"|"ENDPOINT_TYPE"|"ROLE_ARN"|"REGION"|"WORKGROUP_NAME"|"CLUSTER_IDENTIFIER"|"DATABASE", string>, SparkProperties?:array<string, string>, AthenaProperties?:array<string, string>, PythonProperties?:array<string, string>, PhysicalConnectionRequirements?:array{SubnetId?:string, SecurityGroupIdList?:array<string>, AvailabilityZone?:string}, AuthenticationConfiguration?:array{AuthenticationType?:"BASIC"|"OAUTH2"|"CUSTOM"|"IAM", OAuth2Properties?:array{OAuth2GrantType?:"AUTHORIZATION_CODE"|"CLIENT_CREDENTIALS"|"JWT_BEARER", OAuth2ClientApplication?:array{UserManagedClientApplicationClientId?:string, AWSManagedClientApplicationReference?:string}, TokenUrl?:string, TokenUrlParametersMap?:array<string, string>, AuthorizationCodeProperties?:array{AuthorizationCode?:string, RedirectUri?:string}, OAuth2Credentials?:array{UserManagedClientApplicationClientSecret?:string, AccessToken?:string, RefreshToken?:string, JwtToken?:string}}, SecretArn?:string, KmsKeyArn?:string, BasicAuthenticationCredentials?:array{Username?:string, Password?:string}, CustomAuthenticationCredentials?:array<string, string>}, ValidateCredentials?:bool, ValidateForComputeEnvironments?:array<"SPARK"|"ATHENA"|"PYTHON">}, Tags?:array<string, string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{CreateConnectionStatus?:"READY"|"IN_PROGRESS"|"FAILED"}>
     */
    public function createConnectionAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Name:string, Role:string, DatabaseName?:string, Description?:string, Targets:array{S3Targets?:array<array{Path?:string, Exclusions?:array<string>, ConnectionName?:string, SampleSize?:int, EventQueueArn?:string, DlqEventQueueArn?:string}>, JdbcTargets?:array<array{ConnectionName?:string, Path?:string, Exclusions?:array<string>, EnableAdditionalMetadata?:array<"COMMENTS"|"RAWTYPES">}>, MongoDBTargets?:array<array{ConnectionName?:string, Path?:string, ScanAll?:bool}>, DynamoDBTargets?:array<array{Path?:string, scanAll?:bool, scanRate?:float}>, CatalogTargets?:array<array{DatabaseName:string, Tables:array<string>, ConnectionName?:string, EventQueueArn?:string, DlqEventQueueArn?:string}>, DeltaTargets?:array<array{DeltaTables?:array<string>, ConnectionName?:string, WriteManifest?:bool, CreateNativeDeltaTable?:bool}>, IcebergTargets?:array<array{Paths?:array<string>, ConnectionName?:string, Exclusions?:array<string>, MaximumTraversalDepth?:int}>, HudiTargets?:array<array{Paths?:array<string>, ConnectionName?:string, Exclusions?:array<string>, MaximumTraversalDepth?:int}>}, Schedule?:string, Classifiers?:array<string>, TablePrefix?:string, SchemaChangePolicy?:array{UpdateBehavior?:"LOG"|"UPDATE_IN_DATABASE", DeleteBehavior?:"LOG"|"DELETE_FROM_DATABASE"|"DEPRECATE_IN_DATABASE"}, RecrawlPolicy?:array{RecrawlBehavior?:"CRAWL_EVERYTHING"|"CRAWL_NEW_FOLDERS_ONLY"|"CRAWL_EVENT_MODE"}, LineageConfiguration?:array{CrawlerLineageSettings?:"ENABLE"|"DISABLE"}, LakeFormationConfiguration?:array{UseLakeFormationCredentials?:bool, AccountId?:string}, Configuration?:string, CrawlerSecurityConfiguration?:string, Tags?:array<string, string>} $args
     * @return \AWS\Result<array{}>
     */
    public function createCrawler(array $args): \AWS\Result { }

    /**
     * @param array{Name:string, Role:string, DatabaseName?:string, Description?:string, Targets:array{S3Targets?:array<array{Path?:string, Exclusions?:array<string>, ConnectionName?:string, SampleSize?:int, EventQueueArn?:string, DlqEventQueueArn?:string}>, JdbcTargets?:array<array{ConnectionName?:string, Path?:string, Exclusions?:array<string>, EnableAdditionalMetadata?:array<"COMMENTS"|"RAWTYPES">}>, MongoDBTargets?:array<array{ConnectionName?:string, Path?:string, ScanAll?:bool}>, DynamoDBTargets?:array<array{Path?:string, scanAll?:bool, scanRate?:float}>, CatalogTargets?:array<array{DatabaseName:string, Tables:array<string>, ConnectionName?:string, EventQueueArn?:string, DlqEventQueueArn?:string}>, DeltaTargets?:array<array{DeltaTables?:array<string>, ConnectionName?:string, WriteManifest?:bool, CreateNativeDeltaTable?:bool}>, IcebergTargets?:array<array{Paths?:array<string>, ConnectionName?:string, Exclusions?:array<string>, MaximumTraversalDepth?:int}>, HudiTargets?:array<array{Paths?:array<string>, ConnectionName?:string, Exclusions?:array<string>, MaximumTraversalDepth?:int}>}, Schedule?:string, Classifiers?:array<string>, TablePrefix?:string, SchemaChangePolicy?:array{UpdateBehavior?:"LOG"|"UPDATE_IN_DATABASE", DeleteBehavior?:"LOG"|"DELETE_FROM_DATABASE"|"DEPRECATE_IN_DATABASE"}, RecrawlPolicy?:array{RecrawlBehavior?:"CRAWL_EVERYTHING"|"CRAWL_NEW_FOLDERS_ONLY"|"CRAWL_EVENT_MODE"}, LineageConfiguration?:array{CrawlerLineageSettings?:"ENABLE"|"DISABLE"}, LakeFormationConfiguration?:array{UseLakeFormationCredentials?:bool, AccountId?:string}, Configuration?:string, CrawlerSecurityConfiguration?:string, Tags?:array<string, string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function createCrawlerAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Name:string, RegexString:string, ContextWords?:array<string>, Tags?:array<string, string>} $args
     * @return \AWS\Result<array{Name?:string}>
     */
    public function createCustomEntityType(array $args): \AWS\Result { }

    /**
     * @param array{Name:string, RegexString:string, ContextWords?:array<string>, Tags?:array<string, string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{Name?:string}>
     */
    public function createCustomEntityTypeAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Name:string, Description?:string, Ruleset:string, Tags?:array<string, string>, TargetTable?:array{TableName:string, DatabaseName:string, CatalogId?:string}, DataQualitySecurityConfiguration?:string, ClientToken?:string} $args
     * @return \AWS\Result<array{Name?:string}>
     */
    public function createDataQualityRuleset(array $args): \AWS\Result { }

    /**
     * @param array{Name:string, Description?:string, Ruleset:string, Tags?:array<string, string>, TargetTable?:array{TableName:string, DatabaseName:string, CatalogId?:string}, DataQualitySecurityConfiguration?:string, ClientToken?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Name?:string}>
     */
    public function createDataQualityRulesetAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId?:string, DatabaseInput:array{Name:string, Description?:string, LocationUri?:string, Parameters?:array<string, string>, CreateTableDefaultPermissions?:array<array{Principal?:array{DataLakePrincipalIdentifier?:string}, Permissions?:array<"ALL"|"SELECT"|"ALTER"|"DROP"|"DELETE"|"INSERT"|"CREATE_DATABASE"|"CREATE_TABLE"|"DATA_LOCATION_ACCESS">}>, TargetDatabase?:array{CatalogId?:string, DatabaseName?:string, Region?:string}, FederatedDatabase?:array{Identifier?:string, ConnectionName?:string}}, Tags?:array<string, string>} $args
     * @return \AWS\Result<array{}>
     */
    public function createDatabase(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId?:string, DatabaseInput:array{Name:string, Description?:string, LocationUri?:string, Parameters?:array<string, string>, CreateTableDefaultPermissions?:array<array{Principal?:array{DataLakePrincipalIdentifier?:string}, Permissions?:array<"ALL"|"SELECT"|"ALTER"|"DROP"|"DELETE"|"INSERT"|"CREATE_DATABASE"|"CREATE_TABLE"|"DATA_LOCATION_ACCESS">}>, TargetDatabase?:array{CatalogId?:string, DatabaseName?:string, Region?:string}, FederatedDatabase?:array{Identifier?:string, ConnectionName?:string}}, Tags?:array<string, string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function createDatabaseAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{EndpointName:string, RoleArn:string, SecurityGroupIds?:array<string>, SubnetId?:string, PublicKey?:string, PublicKeys?:array<string>, NumberOfNodes?:int, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", GlueVersion?:string, NumberOfWorkers?:int, ExtraPythonLibsS3Path?:string, ExtraJarsS3Path?:string, SecurityConfiguration?:string, Tags?:array<string, string>, Arguments?:array<string, string>} $args
     * @return \AWS\Result<array{EndpointName?:string, Status?:string, SecurityGroupIds?:array<string>, SubnetId?:string, RoleArn?:string, YarnEndpointAddress?:string, ZeppelinRemoteSparkInterpreterPort?:int, NumberOfNodes?:int, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", GlueVersion?:string, NumberOfWorkers?:int, AvailabilityZone?:string, VpcId?:string, ExtraPythonLibsS3Path?:string, ExtraJarsS3Path?:string, FailureReason?:string, SecurityConfiguration?:string, CreatedTimestamp?:int|string|\DateTimeInterface, Arguments?:array<string, string>}>
     */
    public function createDevEndpoint(array $args): \AWS\Result { }

    /**
     * @param array{EndpointName:string, RoleArn:string, SecurityGroupIds?:array<string>, SubnetId?:string, PublicKey?:string, PublicKeys?:array<string>, NumberOfNodes?:int, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", GlueVersion?:string, NumberOfWorkers?:int, ExtraPythonLibsS3Path?:string, ExtraJarsS3Path?:string, SecurityConfiguration?:string, Tags?:array<string, string>, Arguments?:array<string, string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{EndpointName?:string, Status?:string, SecurityGroupIds?:array<string>, SubnetId?:string, RoleArn?:string, YarnEndpointAddress?:string, ZeppelinRemoteSparkInterpreterPort?:int, NumberOfNodes?:int, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", GlueVersion?:string, NumberOfWorkers?:int, AvailabilityZone?:string, VpcId?:string, ExtraPythonLibsS3Path?:string, ExtraJarsS3Path?:string, FailureReason?:string, SecurityConfiguration?:string, CreatedTimestamp?:int|string|\DateTimeInterface, Arguments?:array<string, string>}>
     */
    public function createDevEndpointAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{IntegrationName:string, SourceArn:string, TargetArn:string, Description?:string, DataFilter?:string, KmsKeyId?:string, AdditionalEncryptionContext?:array<string, string>, Tags?:array<array{key?:string, value?:string}>} $args
     * @return \AWS\Result<array{SourceArn:string, TargetArn:string, IntegrationName:string, Description?:string, IntegrationArn:string, KmsKeyId?:string, AdditionalEncryptionContext?:array<string, string>, Tags?:array<array{key?:string, value?:string}>, Status:"CREATING"|"ACTIVE"|"MODIFYING"|"FAILED"|"DELETING"|"SYNCING"|"NEEDS_ATTENTION", CreateTime:int|string|\DateTimeInterface, Errors?:array<array{ErrorCode?:string, ErrorMessage?:string}>, DataFilter?:string}>
     */
    public function createIntegration(array $args): \AWS\Result { }

    /**
     * @param array{IntegrationName:string, SourceArn:string, TargetArn:string, Description?:string, DataFilter?:string, KmsKeyId?:string, AdditionalEncryptionContext?:array<string, string>, Tags?:array<array{key?:string, value?:string}>} $args
     * @return \GuzzleHttp\Promise\Promise<array{SourceArn:string, TargetArn:string, IntegrationName:string, Description?:string, IntegrationArn:string, KmsKeyId?:string, AdditionalEncryptionContext?:array<string, string>, Tags?:array<array{key?:string, value?:string}>, Status:"CREATING"|"ACTIVE"|"MODIFYING"|"FAILED"|"DELETING"|"SYNCING"|"NEEDS_ATTENTION", CreateTime:int|string|\DateTimeInterface, Errors?:array<array{ErrorCode?:string, ErrorMessage?:string}>, DataFilter?:string}>
     */
    public function createIntegrationAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ResourceArn:string, SourceProcessingProperties?:array{RoleArn?:string}, TargetProcessingProperties?:array{RoleArn?:string, KmsArn?:string, ConnectionName?:string, EventBusArn?:string}} $args
     * @return \AWS\Result<array{ResourceArn:string, SourceProcessingProperties?:array{RoleArn?:string}, TargetProcessingProperties?:array{RoleArn?:string, KmsArn?:string, ConnectionName?:string, EventBusArn?:string}}>
     */
    public function createIntegrationResourceProperty(array $args): \AWS\Result { }

    /**
     * @param array{ResourceArn:string, SourceProcessingProperties?:array{RoleArn?:string}, TargetProcessingProperties?:array{RoleArn?:string, KmsArn?:string, ConnectionName?:string, EventBusArn?:string}} $args
     * @return \GuzzleHttp\Promise\Promise<array{ResourceArn:string, SourceProcessingProperties?:array{RoleArn?:string}, TargetProcessingProperties?:array{RoleArn?:string, KmsArn?:string, ConnectionName?:string, EventBusArn?:string}}>
     */
    public function createIntegrationResourcePropertyAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ResourceArn:string, TableName:string, SourceTableConfig?:array{Fields?:array<string>, FilterPredicate?:string, PrimaryKey?:array<string>, RecordUpdateField?:string}, TargetTableConfig?:array{UnnestSpec?:"TOPLEVEL"|"FULL"|"NOUNNEST", PartitionSpec?:array<array{FieldName?:string, FunctionSpec?:string}>, TargetTableName?:string}} $args
     * @return \AWS\Result<array{}>
     */
    public function createIntegrationTableProperties(array $args): \AWS\Result { }

    /**
     * @param array{ResourceArn:string, TableName:string, SourceTableConfig?:array{Fields?:array<string>, FilterPredicate?:string, PrimaryKey?:array<string>, RecordUpdateField?:string}, TargetTableConfig?:array{UnnestSpec?:"TOPLEVEL"|"FULL"|"NOUNNEST", PartitionSpec?:array<array{FieldName?:string, FunctionSpec?:string}>, TargetTableName?:string}} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function createIntegrationTablePropertiesAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Name:string, JobMode?:"SCRIPT"|"VISUAL"|"NOTEBOOK", JobRunQueuingEnabled?:bool, Description?:string, LogUri?:string, Role:string, ExecutionProperty?:array{MaxConcurrentRuns?:int}, Command:array{Name?:string, ScriptLocation?:string, PythonVersion?:string, Runtime?:string}, DefaultArguments?:array<string, string>, NonOverridableArguments?:array<string, string>, Connections?:array{Connections?:mixed}, MaxRetries?:int, AllocatedCapacity?:int, Timeout?:int, MaxCapacity?:float, SecurityConfiguration?:string, Tags?:array<string, string>, NotificationProperty?:array{NotifyDelayAfter?:int}, GlueVersion?:string, NumberOfWorkers?:int, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", CodeGenConfigurationNodes?:array<string, array{AthenaConnectorSource?:array{Name:string, ConnectionName:string, ConnectorName:string, ConnectionType:string, ConnectionTable?:string, SchemaName:string, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, JDBCConnectorSource?:array{Name:string, ConnectionName:string, ConnectorName:string, ConnectionType:string, AdditionalOptions?:array{FilterPredicate?:string, PartitionColumn?:string, LowerBound?:int, UpperBound?:int, NumPartitions?:int, JobBookmarkKeys?:array<string>, JobBookmarkKeysSortOrder?:string, DataTypeMapping?:array<"ARRAY"|"BIGINT"|"BINARY"|"BIT"|"BLOB"|"BOOLEAN"|"CHAR"|"CLOB"|"DATALINK"|"DATE"|"DECIMAL"|"DISTINCT"|"DOUBLE"|"FLOAT"|"INTEGER"|"JAVA_OBJECT"|"LONGNVARCHAR"|"LONGVARBINARY"|"LONGVARCHAR"|"NCHAR"|"NCLOB"|"NULL"|"NUMERIC"|"NVARCHAR"|"OTHER"|"REAL"|"REF"|"REF_CURSOR"|"ROWID"|"SMALLINT"|"SQLXML"|"STRUCT"|"TIME"|"TIME_WITH_TIMEZONE"|"TIMESTAMP"|"TIMESTAMP_WITH_TIMEZONE"|"TINYINT"|"VARBINARY"|"VARCHAR", "DATE"|"STRING"|"TIMESTAMP"|"INT"|"FLOAT"|"LONG"|"BIGDECIMAL"|"BYTE"|"SHORT"|"DOUBLE">}, ConnectionTable?:string, Query?:string, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, SparkConnectorSource?:array{Name:string, ConnectionName:string, ConnectorName:string, ConnectionType:string, AdditionalOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, CatalogSource?:array{Name:string, Database:string, Table:string}, RedshiftSource?:array{Name:string, Database:string, Table:string, RedshiftTmpDir?:string, TmpDirIAMRole?:string}, S3CatalogSource?:array{Name:string, Database:string, Table:string, PartitionPredicate?:string, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int}}, S3CsvSource?:array{Name:string, Paths:array<string>, CompressionType?:"gzip"|"bzip2", Exclusions?:array<string>, GroupSize?:string, GroupFiles?:string, Recurse?:bool, MaxBand?:int, MaxFilesInBand?:int, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, Separator:"comma"|"ctrla"|"pipe"|"semicolon"|"tab", Escaper?:string, QuoteChar:"quote"|"quillemet"|"single_quote"|"disabled", Multiline?:bool, WithHeader?:bool, WriteHeader?:bool, SkipFirst?:bool, OptimizePerformance?:bool, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3JsonSource?:array{Name:string, Paths:array<string>, CompressionType?:"gzip"|"bzip2", Exclusions?:array<string>, GroupSize?:string, GroupFiles?:string, Recurse?:bool, MaxBand?:int, MaxFilesInBand?:int, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, JsonPath?:string, Multiline?:bool, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3ParquetSource?:array{Name:string, Paths:array<string>, CompressionType?:"snappy"|"lzo"|"gzip"|"uncompressed"|"none", Exclusions?:array<string>, GroupSize?:string, GroupFiles?:string, Recurse?:bool, MaxBand?:int, MaxFilesInBand?:int, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, RelationalCatalogSource?:array{Name:string, Database:string, Table:string}, DynamoDBCatalogSource?:array{Name:string, Database:string, Table:string}, JDBCConnectorTarget?:array{Name:string, Inputs:array<string>, ConnectionName:string, ConnectionTable:string, ConnectorName:string, ConnectionType:string, AdditionalOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, SparkConnectorTarget?:array{Name:string, Inputs:array<string>, ConnectionName:string, ConnectorName:string, ConnectionType:string, AdditionalOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, CatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Database:string, Table:string}, RedshiftTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string, RedshiftTmpDir?:string, TmpDirIAMRole?:string, UpsertRedshiftOptions?:array{TableLocation?:string, ConnectionName?:string, UpsertKeys?:array<string>}}, S3CatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Table:string, Database:string, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG"}}, S3GlueParquetTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Path:string, Compression?:"snappy"|"lzo"|"gzip"|"uncompressed"|"none", SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG", Table?:string, Database?:string}}, S3DirectTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Path:string, Compression?:string, Format:"json"|"csv"|"avro"|"orc"|"parquet"|"hudi"|"delta", SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG", Table?:string, Database?:string}}, ApplyMapping?:array{Name:string, Inputs:array<string>, Mapping:array<array{ToKey?:string, FromPath?:array<string>, FromType?:string, ToType?:string, Dropped?:bool, Children?:array<array{ToKey?:string, FromPath?:array<string>, FromType?:string, ToType?:string, Dropped?:bool, Children?:mixed}>}>}, SelectFields?:array{Name:string, Inputs:array<string>, Paths:array<array<string>>}, DropFields?:array{Name:string, Inputs:array<string>, Paths:array<array<string>>}, RenameField?:array{Name:string, Inputs:array<string>, SourcePath:array<string>, TargetPath:array<string>}, Spigot?:array{Name:string, Inputs:array<string>, Path:string, Topk?:int, Prob?:float}, Join?:array{Name:string, Inputs:array<string>, JoinType:"equijoin"|"left"|"right"|"outer"|"leftsemi"|"leftanti", Columns:array<array{From:string, Keys:array<array<string>>}>}, SplitFields?:array{Name:string, Inputs:array<string>, Paths:array<array<string>>}, SelectFromCollection?:array{Name:string, Inputs:array<string>, Index:int}, FillMissingValues?:array{Name:string, Inputs:array<string>, ImputedPath:string, FilledPath?:string}, Filter?:array{Name:string, Inputs:array<string>, LogicalOperator:"AND"|"OR", Filters:array<array{Operation:"EQ"|"LT"|"GT"|"LTE"|"GTE"|"REGEX"|"ISNULL", Negated?:bool, Values:array<array{Type:"COLUMNEXTRACTED"|"CONSTANT", Value:array<string>}>}>}, CustomCode?:array{Name:string, Inputs:array<string>, Code:string, ClassName:string, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, SparkSQL?:array{Name:string, Inputs:array<string>, SqlQuery:string, SqlAliases:array<array{From:string, Alias:string}>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, DirectKinesisSource?:array{Name:string, WindowSize?:int, DetectSchema?:bool, StreamingOptions?:array{EndpointUrl?:string, StreamName?:string, Classification?:string, Delimiter?:string, StartingPosition?:"latest"|"trim_horizon"|"earliest"|"timestamp", MaxFetchTimeInMs?:int, MaxFetchRecordsPerShard?:int, MaxRecordPerRead?:int, AddIdleTimeBetweenReads?:bool, IdleTimeBetweenReadsInMs?:int, DescribeShardInterval?:int, NumRetries?:int, RetryIntervalMs?:int, MaxRetryIntervalMs?:int, AvoidEmptyBatches?:bool, StreamArn?:string, RoleArn?:string, RoleSessionName?:string, AddRecordTimestamp?:string, EmitConsumerLagMetrics?:string, StartingTimestamp?:int|string|\DateTimeInterface}, DataPreviewOptions?:array{PollingTime?:int, RecordPollingLimit?:int}}, DirectKafkaSource?:array{Name:string, StreamingOptions?:array{BootstrapServers?:string, SecurityProtocol?:string, ConnectionName?:string, TopicName?:string, Assign?:string, SubscribePattern?:string, Classification?:string, Delimiter?:string, StartingOffsets?:string, EndingOffsets?:string, PollTimeoutMs?:int, NumRetries?:int, RetryIntervalMs?:int, MaxOffsetsPerTrigger?:int, MinPartitions?:int, IncludeHeaders?:bool, AddRecordTimestamp?:string, EmitConsumerLagMetrics?:string, StartingTimestamp?:int|string|\DateTimeInterface}, WindowSize?:int, DetectSchema?:bool, DataPreviewOptions?:array{PollingTime?:int, RecordPollingLimit?:int}}, CatalogKinesisSource?:array{Name:string, WindowSize?:int, DetectSchema?:bool, Table:string, Database:string, StreamingOptions?:array{EndpointUrl?:string, StreamName?:string, Classification?:string, Delimiter?:string, StartingPosition?:"latest"|"trim_horizon"|"earliest"|"timestamp", MaxFetchTimeInMs?:int, MaxFetchRecordsPerShard?:int, MaxRecordPerRead?:int, AddIdleTimeBetweenReads?:bool, IdleTimeBetweenReadsInMs?:int, DescribeShardInterval?:int, NumRetries?:int, RetryIntervalMs?:int, MaxRetryIntervalMs?:int, AvoidEmptyBatches?:bool, StreamArn?:string, RoleArn?:string, RoleSessionName?:string, AddRecordTimestamp?:string, EmitConsumerLagMetrics?:string, StartingTimestamp?:int|string|\DateTimeInterface}, DataPreviewOptions?:array{PollingTime?:int, RecordPollingLimit?:int}}, CatalogKafkaSource?:array{Name:string, WindowSize?:int, DetectSchema?:bool, Table:string, Database:string, StreamingOptions?:array{BootstrapServers?:string, SecurityProtocol?:string, ConnectionName?:string, TopicName?:string, Assign?:string, SubscribePattern?:string, Classification?:string, Delimiter?:string, StartingOffsets?:string, EndingOffsets?:string, PollTimeoutMs?:int, NumRetries?:int, RetryIntervalMs?:int, MaxOffsetsPerTrigger?:int, MinPartitions?:int, IncludeHeaders?:bool, AddRecordTimestamp?:string, EmitConsumerLagMetrics?:string, StartingTimestamp?:int|string|\DateTimeInterface}, DataPreviewOptions?:array{PollingTime?:int, RecordPollingLimit?:int}}, DropNullFields?:array{Name:string, Inputs:array<string>, NullCheckBoxList?:array{IsEmpty?:bool, IsNullString?:bool, IsNegOne?:bool}, NullTextList?:array<array{Value:string, Datatype:array{Id:string, Label:string}}>}, Merge?:array{Name:string, Inputs:array<string>, Source:string, PrimaryKeys:array<array<string>>}, Union?:array{Name:string, Inputs:array<string>, UnionType:"ALL"|"DISTINCT"}, PIIDetection?:array{Name:string, Inputs:array<string>, PiiType:"RowAudit"|"RowMasking"|"ColumnAudit"|"ColumnMasking", EntityTypesToDetect:array<string>, OutputColumnName?:string, SampleFraction?:float, ThresholdFraction?:float, MaskValue?:string}, Aggregate?:array{Name:string, Inputs:array<string>, Groups:array<array<string>>, Aggs:array<array{Column:array<string>, AggFunc:"avg"|"countDistinct"|"count"|"first"|"last"|"kurtosis"|"max"|"min"|"skewness"|"stddev_samp"|"stddev_pop"|"sum"|"sumDistinct"|"var_samp"|"var_pop"}>}, DropDuplicates?:array{Name:string, Inputs:array<string>, Columns?:array<array<string>>}, GovernedCatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Table:string, Database:string, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG"}}, GovernedCatalogSource?:array{Name:string, Database:string, Table:string, PartitionPredicate?:string, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int}}, MicrosoftSQLServerCatalogSource?:array{Name:string, Database:string, Table:string}, MySQLCatalogSource?:array{Name:string, Database:string, Table:string}, OracleSQLCatalogSource?:array{Name:string, Database:string, Table:string}, PostgreSQLCatalogSource?:array{Name:string, Database:string, Table:string}, MicrosoftSQLServerCatalogTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string}, MySQLCatalogTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string}, OracleSQLCatalogTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string}, PostgreSQLCatalogTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string}, DynamicTransform?:array{Name:string, TransformName:string, Inputs:array<string>, Parameters?:array<array{Name:string, Type:"str"|"int"|"float"|"complex"|"bool"|"list"|"null", ValidationRule?:string, ValidationMessage?:string, Value?:array<string>, ListType?:"str"|"int"|"float"|"complex"|"bool"|"list"|"null", IsOptional?:bool}>, FunctionName:string, Path:string, Version?:string, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, EvaluateDataQuality?:array{Name:string, Inputs:array<string>, Ruleset:string, Output?:"PrimaryInput"|"EvaluationResults", PublishingOptions?:array{EvaluationContext?:string, ResultsS3Prefix?:string, CloudWatchMetricsEnabled?:bool, ResultsPublishingEnabled?:bool}, StopJobOnFailureOptions?:array{StopJobOnFailureTiming?:"Immediate"|"AfterDataLoad"}}, S3CatalogHudiSource?:array{Name:string, Database:string, Table:string, AdditionalHudiOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, CatalogHudiSource?:array{Name:string, Database:string, Table:string, AdditionalHudiOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3HudiSource?:array{Name:string, Paths:array<string>, AdditionalHudiOptions?:array<string, string>, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3HudiCatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Table:string, Database:string, AdditionalOptions:array<string, string>, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG"}}, S3HudiDirectTarget?:array{Name:string, Inputs:array<string>, Path:string, Compression:"gzip"|"lzo"|"uncompressed"|"snappy", PartitionKeys?:array<array<string>>, Format:"json"|"csv"|"avro"|"orc"|"parquet"|"hudi"|"delta", AdditionalOptions:array<string, string>, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG", Table?:string, Database?:string}}, DirectJDBCSource?:array{Name:string, Database:string, Table:string, ConnectionName:string, ConnectionType:"sqlserver"|"mysql"|"oracle"|"postgresql"|"redshift", RedshiftTmpDir?:string}, S3CatalogDeltaSource?:array{Name:string, Database:string, Table:string, AdditionalDeltaOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, CatalogDeltaSource?:array{Name:string, Database:string, Table:string, AdditionalDeltaOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3DeltaSource?:array{Name:string, Paths:array<string>, AdditionalDeltaOptions?:array<string, string>, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3DeltaCatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Table:string, Database:string, AdditionalOptions?:array<string, string>, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG"}}, S3DeltaDirectTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Path:string, Compression:"uncompressed"|"snappy", Format:"json"|"csv"|"avro"|"orc"|"parquet"|"hudi"|"delta", AdditionalOptions?:array<string, string>, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG", Table?:string, Database?:string}}, AmazonRedshiftSource?:array{Name?:string, Data?:array{AccessType?:string, SourceType?:string, Connection?:array{Value?:string, Label?:string, Description?:string}, Schema?:array{Value?:string, Label?:string, Description?:string}, Table?:array{Value?:string, Label?:string, Description?:string}, CatalogDatabase?:array{Value?:string, Label?:string, Description?:string}, CatalogTable?:array{Value?:string, Label?:string, Description?:string}, CatalogRedshiftSchema?:string, CatalogRedshiftTable?:string, TempDir?:string, IamRole?:array{Value?:string, Label?:string, Description?:string}, AdvancedOptions?:array<array{Key?:string, Value?:string}>, SampleQuery?:string, PreAction?:string, PostAction?:string, Action?:string, TablePrefix?:string, Upsert?:bool, MergeAction?:string, MergeWhenMatched?:string, MergeWhenNotMatched?:string, MergeClause?:string, CrawlerConnection?:string, TableSchema?:array<array{Value?:string, Label?:string, Description?:string}>, StagingTable?:string, SelectedColumns?:array<array{Value?:string, Label?:string, Description?:string}>}}, AmazonRedshiftTarget?:array{Name?:string, Data?:array{AccessType?:string, SourceType?:string, Connection?:array{Value?:string, Label?:string, Description?:string}, Schema?:array{Value?:string, Label?:string, Description?:string}, Table?:array{Value?:string, Label?:string, Description?:string}, CatalogDatabase?:array{Value?:string, Label?:string, Description?:string}, CatalogTable?:array{Value?:string, Label?:string, Description?:string}, CatalogRedshiftSchema?:string, CatalogRedshiftTable?:string, TempDir?:string, IamRole?:array{Value?:string, Label?:string, Description?:string}, AdvancedOptions?:array<array{Key?:string, Value?:string}>, SampleQuery?:string, PreAction?:string, PostAction?:string, Action?:string, TablePrefix?:string, Upsert?:bool, MergeAction?:string, MergeWhenMatched?:string, MergeWhenNotMatched?:string, MergeClause?:string, CrawlerConnection?:string, TableSchema?:array<array{Value?:string, Label?:string, Description?:string}>, StagingTable?:string, SelectedColumns?:array<array{Value?:string, Label?:string, Description?:string}>}, Inputs?:array<string>}, EvaluateDataQualityMultiFrame?:array{Name:string, Inputs:array<string>, AdditionalDataSources?:array<string, string>, Ruleset:string, PublishingOptions?:array{EvaluationContext?:string, ResultsS3Prefix?:string, CloudWatchMetricsEnabled?:bool, ResultsPublishingEnabled?:bool}, AdditionalOptions?:array<"performanceTuning.caching"|"observations.scope", string>, StopJobOnFailureOptions?:array{StopJobOnFailureTiming?:"Immediate"|"AfterDataLoad"}}, Recipe?:array{Name:string, Inputs:array<string>, RecipeReference?:array{RecipeArn:string, RecipeVersion:string}, RecipeSteps?:array<array{Action:array{Operation:string, Parameters?:array<string, string>}, ConditionExpressions?:array<array{Condition:string, Value?:string, TargetColumn:string}>}>}, SnowflakeSource?:array{Name:string, Data:array{SourceType?:string, Connection?:array{Value?:string, Label?:string, Description?:string}, Schema?:string, Table?:string, Database?:string, TempDir?:string, IamRole?:array{Value?:string, Label?:string, Description?:string}, AdditionalOptions?:array<string, string>, SampleQuery?:string, PreAction?:string, PostAction?:string, Action?:string, Upsert?:bool, MergeAction?:string, MergeWhenMatched?:string, MergeWhenNotMatched?:string, MergeClause?:string, StagingTable?:string, SelectedColumns?:array<array{Value?:string, Label?:string, Description?:string}>, AutoPushdown?:bool, TableSchema?:array<array{Value?:string, Label?:string, Description?:string}>}, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, SnowflakeTarget?:array{Name:string, Data:array{SourceType?:string, Connection?:array{Value?:string, Label?:string, Description?:string}, Schema?:string, Table?:string, Database?:string, TempDir?:string, IamRole?:array{Value?:string, Label?:string, Description?:string}, AdditionalOptions?:array<string, string>, SampleQuery?:string, PreAction?:string, PostAction?:string, Action?:string, Upsert?:bool, MergeAction?:string, MergeWhenMatched?:string, MergeWhenNotMatched?:string, MergeClause?:string, StagingTable?:string, SelectedColumns?:array<array{Value?:string, Label?:string, Description?:string}>, AutoPushdown?:bool, TableSchema?:array<array{Value?:string, Label?:string, Description?:string}>}, Inputs?:array<string>}, ConnectorDataSource?:array{Name:string, ConnectionType:string, Data:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, ConnectorDataTarget?:array{Name:string, ConnectionType:string, Data:array<string, string>, Inputs?:array<string>}}>, ExecutionClass?:"FLEX"|"STANDARD", SourceControlDetails?:array{Provider?:"GITHUB"|"GITLAB"|"BITBUCKET"|"AWS_CODE_COMMIT", Repository?:string, Owner?:string, Branch?:string, Folder?:string, LastCommitId?:string, AuthStrategy?:"PERSONAL_ACCESS_TOKEN"|"AWS_SECRETS_MANAGER", AuthToken?:string}, MaintenanceWindow?:string} $args
     * @return \AWS\Result<array{Name?:string}>
     */
    public function createJob(array $args): \AWS\Result { }

    /**
     * @param array{Name:string, JobMode?:"SCRIPT"|"VISUAL"|"NOTEBOOK", JobRunQueuingEnabled?:bool, Description?:string, LogUri?:string, Role:string, ExecutionProperty?:array{MaxConcurrentRuns?:int}, Command:array{Name?:string, ScriptLocation?:string, PythonVersion?:string, Runtime?:string}, DefaultArguments?:array<string, string>, NonOverridableArguments?:array<string, string>, Connections?:array{Connections?:mixed}, MaxRetries?:int, AllocatedCapacity?:int, Timeout?:int, MaxCapacity?:float, SecurityConfiguration?:string, Tags?:array<string, string>, NotificationProperty?:array{NotifyDelayAfter?:int}, GlueVersion?:string, NumberOfWorkers?:int, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", CodeGenConfigurationNodes?:array<string, array{AthenaConnectorSource?:array{Name:string, ConnectionName:string, ConnectorName:string, ConnectionType:string, ConnectionTable?:string, SchemaName:string, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, JDBCConnectorSource?:array{Name:string, ConnectionName:string, ConnectorName:string, ConnectionType:string, AdditionalOptions?:array{FilterPredicate?:string, PartitionColumn?:string, LowerBound?:int, UpperBound?:int, NumPartitions?:int, JobBookmarkKeys?:array<string>, JobBookmarkKeysSortOrder?:string, DataTypeMapping?:array<"ARRAY"|"BIGINT"|"BINARY"|"BIT"|"BLOB"|"BOOLEAN"|"CHAR"|"CLOB"|"DATALINK"|"DATE"|"DECIMAL"|"DISTINCT"|"DOUBLE"|"FLOAT"|"INTEGER"|"JAVA_OBJECT"|"LONGNVARCHAR"|"LONGVARBINARY"|"LONGVARCHAR"|"NCHAR"|"NCLOB"|"NULL"|"NUMERIC"|"NVARCHAR"|"OTHER"|"REAL"|"REF"|"REF_CURSOR"|"ROWID"|"SMALLINT"|"SQLXML"|"STRUCT"|"TIME"|"TIME_WITH_TIMEZONE"|"TIMESTAMP"|"TIMESTAMP_WITH_TIMEZONE"|"TINYINT"|"VARBINARY"|"VARCHAR", "DATE"|"STRING"|"TIMESTAMP"|"INT"|"FLOAT"|"LONG"|"BIGDECIMAL"|"BYTE"|"SHORT"|"DOUBLE">}, ConnectionTable?:string, Query?:string, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, SparkConnectorSource?:array{Name:string, ConnectionName:string, ConnectorName:string, ConnectionType:string, AdditionalOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, CatalogSource?:array{Name:string, Database:string, Table:string}, RedshiftSource?:array{Name:string, Database:string, Table:string, RedshiftTmpDir?:string, TmpDirIAMRole?:string}, S3CatalogSource?:array{Name:string, Database:string, Table:string, PartitionPredicate?:string, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int}}, S3CsvSource?:array{Name:string, Paths:array<string>, CompressionType?:"gzip"|"bzip2", Exclusions?:array<string>, GroupSize?:string, GroupFiles?:string, Recurse?:bool, MaxBand?:int, MaxFilesInBand?:int, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, Separator:"comma"|"ctrla"|"pipe"|"semicolon"|"tab", Escaper?:string, QuoteChar:"quote"|"quillemet"|"single_quote"|"disabled", Multiline?:bool, WithHeader?:bool, WriteHeader?:bool, SkipFirst?:bool, OptimizePerformance?:bool, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3JsonSource?:array{Name:string, Paths:array<string>, CompressionType?:"gzip"|"bzip2", Exclusions?:array<string>, GroupSize?:string, GroupFiles?:string, Recurse?:bool, MaxBand?:int, MaxFilesInBand?:int, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, JsonPath?:string, Multiline?:bool, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3ParquetSource?:array{Name:string, Paths:array<string>, CompressionType?:"snappy"|"lzo"|"gzip"|"uncompressed"|"none", Exclusions?:array<string>, GroupSize?:string, GroupFiles?:string, Recurse?:bool, MaxBand?:int, MaxFilesInBand?:int, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, RelationalCatalogSource?:array{Name:string, Database:string, Table:string}, DynamoDBCatalogSource?:array{Name:string, Database:string, Table:string}, JDBCConnectorTarget?:array{Name:string, Inputs:array<string>, ConnectionName:string, ConnectionTable:string, ConnectorName:string, ConnectionType:string, AdditionalOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, SparkConnectorTarget?:array{Name:string, Inputs:array<string>, ConnectionName:string, ConnectorName:string, ConnectionType:string, AdditionalOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, CatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Database:string, Table:string}, RedshiftTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string, RedshiftTmpDir?:string, TmpDirIAMRole?:string, UpsertRedshiftOptions?:array{TableLocation?:string, ConnectionName?:string, UpsertKeys?:array<string>}}, S3CatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Table:string, Database:string, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG"}}, S3GlueParquetTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Path:string, Compression?:"snappy"|"lzo"|"gzip"|"uncompressed"|"none", SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG", Table?:string, Database?:string}}, S3DirectTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Path:string, Compression?:string, Format:"json"|"csv"|"avro"|"orc"|"parquet"|"hudi"|"delta", SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG", Table?:string, Database?:string}}, ApplyMapping?:array{Name:string, Inputs:array<string>, Mapping:array<array{ToKey?:string, FromPath?:array<string>, FromType?:string, ToType?:string, Dropped?:bool, Children?:array<array{ToKey?:string, FromPath?:array<string>, FromType?:string, ToType?:string, Dropped?:bool, Children?:mixed}>}>}, SelectFields?:array{Name:string, Inputs:array<string>, Paths:array<array<string>>}, DropFields?:array{Name:string, Inputs:array<string>, Paths:array<array<string>>}, RenameField?:array{Name:string, Inputs:array<string>, SourcePath:array<string>, TargetPath:array<string>}, Spigot?:array{Name:string, Inputs:array<string>, Path:string, Topk?:int, Prob?:float}, Join?:array{Name:string, Inputs:array<string>, JoinType:"equijoin"|"left"|"right"|"outer"|"leftsemi"|"leftanti", Columns:array<array{From:string, Keys:array<array<string>>}>}, SplitFields?:array{Name:string, Inputs:array<string>, Paths:array<array<string>>}, SelectFromCollection?:array{Name:string, Inputs:array<string>, Index:int}, FillMissingValues?:array{Name:string, Inputs:array<string>, ImputedPath:string, FilledPath?:string}, Filter?:array{Name:string, Inputs:array<string>, LogicalOperator:"AND"|"OR", Filters:array<array{Operation:"EQ"|"LT"|"GT"|"LTE"|"GTE"|"REGEX"|"ISNULL", Negated?:bool, Values:array<array{Type:"COLUMNEXTRACTED"|"CONSTANT", Value:array<string>}>}>}, CustomCode?:array{Name:string, Inputs:array<string>, Code:string, ClassName:string, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, SparkSQL?:array{Name:string, Inputs:array<string>, SqlQuery:string, SqlAliases:array<array{From:string, Alias:string}>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, DirectKinesisSource?:array{Name:string, WindowSize?:int, DetectSchema?:bool, StreamingOptions?:array{EndpointUrl?:string, StreamName?:string, Classification?:string, Delimiter?:string, StartingPosition?:"latest"|"trim_horizon"|"earliest"|"timestamp", MaxFetchTimeInMs?:int, MaxFetchRecordsPerShard?:int, MaxRecordPerRead?:int, AddIdleTimeBetweenReads?:bool, IdleTimeBetweenReadsInMs?:int, DescribeShardInterval?:int, NumRetries?:int, RetryIntervalMs?:int, MaxRetryIntervalMs?:int, AvoidEmptyBatches?:bool, StreamArn?:string, RoleArn?:string, RoleSessionName?:string, AddRecordTimestamp?:string, EmitConsumerLagMetrics?:string, StartingTimestamp?:int|string|\DateTimeInterface}, DataPreviewOptions?:array{PollingTime?:int, RecordPollingLimit?:int}}, DirectKafkaSource?:array{Name:string, StreamingOptions?:array{BootstrapServers?:string, SecurityProtocol?:string, ConnectionName?:string, TopicName?:string, Assign?:string, SubscribePattern?:string, Classification?:string, Delimiter?:string, StartingOffsets?:string, EndingOffsets?:string, PollTimeoutMs?:int, NumRetries?:int, RetryIntervalMs?:int, MaxOffsetsPerTrigger?:int, MinPartitions?:int, IncludeHeaders?:bool, AddRecordTimestamp?:string, EmitConsumerLagMetrics?:string, StartingTimestamp?:int|string|\DateTimeInterface}, WindowSize?:int, DetectSchema?:bool, DataPreviewOptions?:array{PollingTime?:int, RecordPollingLimit?:int}}, CatalogKinesisSource?:array{Name:string, WindowSize?:int, DetectSchema?:bool, Table:string, Database:string, StreamingOptions?:array{EndpointUrl?:string, StreamName?:string, Classification?:string, Delimiter?:string, StartingPosition?:"latest"|"trim_horizon"|"earliest"|"timestamp", MaxFetchTimeInMs?:int, MaxFetchRecordsPerShard?:int, MaxRecordPerRead?:int, AddIdleTimeBetweenReads?:bool, IdleTimeBetweenReadsInMs?:int, DescribeShardInterval?:int, NumRetries?:int, RetryIntervalMs?:int, MaxRetryIntervalMs?:int, AvoidEmptyBatches?:bool, StreamArn?:string, RoleArn?:string, RoleSessionName?:string, AddRecordTimestamp?:string, EmitConsumerLagMetrics?:string, StartingTimestamp?:int|string|\DateTimeInterface}, DataPreviewOptions?:array{PollingTime?:int, RecordPollingLimit?:int}}, CatalogKafkaSource?:array{Name:string, WindowSize?:int, DetectSchema?:bool, Table:string, Database:string, StreamingOptions?:array{BootstrapServers?:string, SecurityProtocol?:string, ConnectionName?:string, TopicName?:string, Assign?:string, SubscribePattern?:string, Classification?:string, Delimiter?:string, StartingOffsets?:string, EndingOffsets?:string, PollTimeoutMs?:int, NumRetries?:int, RetryIntervalMs?:int, MaxOffsetsPerTrigger?:int, MinPartitions?:int, IncludeHeaders?:bool, AddRecordTimestamp?:string, EmitConsumerLagMetrics?:string, StartingTimestamp?:int|string|\DateTimeInterface}, DataPreviewOptions?:array{PollingTime?:int, RecordPollingLimit?:int}}, DropNullFields?:array{Name:string, Inputs:array<string>, NullCheckBoxList?:array{IsEmpty?:bool, IsNullString?:bool, IsNegOne?:bool}, NullTextList?:array<array{Value:string, Datatype:array{Id:string, Label:string}}>}, Merge?:array{Name:string, Inputs:array<string>, Source:string, PrimaryKeys:array<array<string>>}, Union?:array{Name:string, Inputs:array<string>, UnionType:"ALL"|"DISTINCT"}, PIIDetection?:array{Name:string, Inputs:array<string>, PiiType:"RowAudit"|"RowMasking"|"ColumnAudit"|"ColumnMasking", EntityTypesToDetect:array<string>, OutputColumnName?:string, SampleFraction?:float, ThresholdFraction?:float, MaskValue?:string}, Aggregate?:array{Name:string, Inputs:array<string>, Groups:array<array<string>>, Aggs:array<array{Column:array<string>, AggFunc:"avg"|"countDistinct"|"count"|"first"|"last"|"kurtosis"|"max"|"min"|"skewness"|"stddev_samp"|"stddev_pop"|"sum"|"sumDistinct"|"var_samp"|"var_pop"}>}, DropDuplicates?:array{Name:string, Inputs:array<string>, Columns?:array<array<string>>}, GovernedCatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Table:string, Database:string, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG"}}, GovernedCatalogSource?:array{Name:string, Database:string, Table:string, PartitionPredicate?:string, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int}}, MicrosoftSQLServerCatalogSource?:array{Name:string, Database:string, Table:string}, MySQLCatalogSource?:array{Name:string, Database:string, Table:string}, OracleSQLCatalogSource?:array{Name:string, Database:string, Table:string}, PostgreSQLCatalogSource?:array{Name:string, Database:string, Table:string}, MicrosoftSQLServerCatalogTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string}, MySQLCatalogTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string}, OracleSQLCatalogTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string}, PostgreSQLCatalogTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string}, DynamicTransform?:array{Name:string, TransformName:string, Inputs:array<string>, Parameters?:array<array{Name:string, Type:"str"|"int"|"float"|"complex"|"bool"|"list"|"null", ValidationRule?:string, ValidationMessage?:string, Value?:array<string>, ListType?:"str"|"int"|"float"|"complex"|"bool"|"list"|"null", IsOptional?:bool}>, FunctionName:string, Path:string, Version?:string, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, EvaluateDataQuality?:array{Name:string, Inputs:array<string>, Ruleset:string, Output?:"PrimaryInput"|"EvaluationResults", PublishingOptions?:array{EvaluationContext?:string, ResultsS3Prefix?:string, CloudWatchMetricsEnabled?:bool, ResultsPublishingEnabled?:bool}, StopJobOnFailureOptions?:array{StopJobOnFailureTiming?:"Immediate"|"AfterDataLoad"}}, S3CatalogHudiSource?:array{Name:string, Database:string, Table:string, AdditionalHudiOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, CatalogHudiSource?:array{Name:string, Database:string, Table:string, AdditionalHudiOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3HudiSource?:array{Name:string, Paths:array<string>, AdditionalHudiOptions?:array<string, string>, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3HudiCatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Table:string, Database:string, AdditionalOptions:array<string, string>, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG"}}, S3HudiDirectTarget?:array{Name:string, Inputs:array<string>, Path:string, Compression:"gzip"|"lzo"|"uncompressed"|"snappy", PartitionKeys?:array<array<string>>, Format:"json"|"csv"|"avro"|"orc"|"parquet"|"hudi"|"delta", AdditionalOptions:array<string, string>, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG", Table?:string, Database?:string}}, DirectJDBCSource?:array{Name:string, Database:string, Table:string, ConnectionName:string, ConnectionType:"sqlserver"|"mysql"|"oracle"|"postgresql"|"redshift", RedshiftTmpDir?:string}, S3CatalogDeltaSource?:array{Name:string, Database:string, Table:string, AdditionalDeltaOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, CatalogDeltaSource?:array{Name:string, Database:string, Table:string, AdditionalDeltaOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3DeltaSource?:array{Name:string, Paths:array<string>, AdditionalDeltaOptions?:array<string, string>, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3DeltaCatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Table:string, Database:string, AdditionalOptions?:array<string, string>, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG"}}, S3DeltaDirectTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Path:string, Compression:"uncompressed"|"snappy", Format:"json"|"csv"|"avro"|"orc"|"parquet"|"hudi"|"delta", AdditionalOptions?:array<string, string>, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG", Table?:string, Database?:string}}, AmazonRedshiftSource?:array{Name?:string, Data?:array{AccessType?:string, SourceType?:string, Connection?:array{Value?:string, Label?:string, Description?:string}, Schema?:array{Value?:string, Label?:string, Description?:string}, Table?:array{Value?:string, Label?:string, Description?:string}, CatalogDatabase?:array{Value?:string, Label?:string, Description?:string}, CatalogTable?:array{Value?:string, Label?:string, Description?:string}, CatalogRedshiftSchema?:string, CatalogRedshiftTable?:string, TempDir?:string, IamRole?:array{Value?:string, Label?:string, Description?:string}, AdvancedOptions?:array<array{Key?:string, Value?:string}>, SampleQuery?:string, PreAction?:string, PostAction?:string, Action?:string, TablePrefix?:string, Upsert?:bool, MergeAction?:string, MergeWhenMatched?:string, MergeWhenNotMatched?:string, MergeClause?:string, CrawlerConnection?:string, TableSchema?:array<array{Value?:string, Label?:string, Description?:string}>, StagingTable?:string, SelectedColumns?:array<array{Value?:string, Label?:string, Description?:string}>}}, AmazonRedshiftTarget?:array{Name?:string, Data?:array{AccessType?:string, SourceType?:string, Connection?:array{Value?:string, Label?:string, Description?:string}, Schema?:array{Value?:string, Label?:string, Description?:string}, Table?:array{Value?:string, Label?:string, Description?:string}, CatalogDatabase?:array{Value?:string, Label?:string, Description?:string}, CatalogTable?:array{Value?:string, Label?:string, Description?:string}, CatalogRedshiftSchema?:string, CatalogRedshiftTable?:string, TempDir?:string, IamRole?:array{Value?:string, Label?:string, Description?:string}, AdvancedOptions?:array<array{Key?:string, Value?:string}>, SampleQuery?:string, PreAction?:string, PostAction?:string, Action?:string, TablePrefix?:string, Upsert?:bool, MergeAction?:string, MergeWhenMatched?:string, MergeWhenNotMatched?:string, MergeClause?:string, CrawlerConnection?:string, TableSchema?:array<array{Value?:string, Label?:string, Description?:string}>, StagingTable?:string, SelectedColumns?:array<array{Value?:string, Label?:string, Description?:string}>}, Inputs?:array<string>}, EvaluateDataQualityMultiFrame?:array{Name:string, Inputs:array<string>, AdditionalDataSources?:array<string, string>, Ruleset:string, PublishingOptions?:array{EvaluationContext?:string, ResultsS3Prefix?:string, CloudWatchMetricsEnabled?:bool, ResultsPublishingEnabled?:bool}, AdditionalOptions?:array<"performanceTuning.caching"|"observations.scope", string>, StopJobOnFailureOptions?:array{StopJobOnFailureTiming?:"Immediate"|"AfterDataLoad"}}, Recipe?:array{Name:string, Inputs:array<string>, RecipeReference?:array{RecipeArn:string, RecipeVersion:string}, RecipeSteps?:array<array{Action:array{Operation:string, Parameters?:array<string, string>}, ConditionExpressions?:array<array{Condition:string, Value?:string, TargetColumn:string}>}>}, SnowflakeSource?:array{Name:string, Data:array{SourceType?:string, Connection?:array{Value?:string, Label?:string, Description?:string}, Schema?:string, Table?:string, Database?:string, TempDir?:string, IamRole?:array{Value?:string, Label?:string, Description?:string}, AdditionalOptions?:array<string, string>, SampleQuery?:string, PreAction?:string, PostAction?:string, Action?:string, Upsert?:bool, MergeAction?:string, MergeWhenMatched?:string, MergeWhenNotMatched?:string, MergeClause?:string, StagingTable?:string, SelectedColumns?:array<array{Value?:string, Label?:string, Description?:string}>, AutoPushdown?:bool, TableSchema?:array<array{Value?:string, Label?:string, Description?:string}>}, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, SnowflakeTarget?:array{Name:string, Data:array{SourceType?:string, Connection?:array{Value?:string, Label?:string, Description?:string}, Schema?:string, Table?:string, Database?:string, TempDir?:string, IamRole?:array{Value?:string, Label?:string, Description?:string}, AdditionalOptions?:array<string, string>, SampleQuery?:string, PreAction?:string, PostAction?:string, Action?:string, Upsert?:bool, MergeAction?:string, MergeWhenMatched?:string, MergeWhenNotMatched?:string, MergeClause?:string, StagingTable?:string, SelectedColumns?:array<array{Value?:string, Label?:string, Description?:string}>, AutoPushdown?:bool, TableSchema?:array<array{Value?:string, Label?:string, Description?:string}>}, Inputs?:array<string>}, ConnectorDataSource?:array{Name:string, ConnectionType:string, Data:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, ConnectorDataTarget?:array{Name:string, ConnectionType:string, Data:array<string, string>, Inputs?:array<string>}}>, ExecutionClass?:"FLEX"|"STANDARD", SourceControlDetails?:array{Provider?:"GITHUB"|"GITLAB"|"BITBUCKET"|"AWS_CODE_COMMIT", Repository?:string, Owner?:string, Branch?:string, Folder?:string, LastCommitId?:string, AuthStrategy?:"PERSONAL_ACCESS_TOKEN"|"AWS_SECRETS_MANAGER", AuthToken?:string}, MaintenanceWindow?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Name?:string}>
     */
    public function createJobAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Name:string, Description?:string, InputRecordTables:array<array{DatabaseName:string, TableName:string, CatalogId?:string, ConnectionName?:string, AdditionalOptions?:array<string, string>}>, Parameters:array{TransformType:"FIND_MATCHES", FindMatchesParameters?:array{PrimaryKeyColumnName?:string, PrecisionRecallTradeoff?:float, AccuracyCostTradeoff?:float, EnforceProvidedLabels?:bool}}, Role:string, GlueVersion?:string, MaxCapacity?:float, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", NumberOfWorkers?:int, Timeout?:int, MaxRetries?:int, Tags?:array<string, string>, TransformEncryption?:array{MlUserDataEncryption?:array{MlUserDataEncryptionMode:"DISABLED"|"SSE-KMS", KmsKeyId?:string}, TaskRunSecurityConfigurationName?:string}} $args
     * @return \AWS\Result<array{TransformId?:string}>
     */
    public function createMLTransform(array $args): \AWS\Result { }

    /**
     * @param array{Name:string, Description?:string, InputRecordTables:array<array{DatabaseName:string, TableName:string, CatalogId?:string, ConnectionName?:string, AdditionalOptions?:array<string, string>}>, Parameters:array{TransformType:"FIND_MATCHES", FindMatchesParameters?:array{PrimaryKeyColumnName?:string, PrecisionRecallTradeoff?:float, AccuracyCostTradeoff?:float, EnforceProvidedLabels?:bool}}, Role:string, GlueVersion?:string, MaxCapacity?:float, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", NumberOfWorkers?:int, Timeout?:int, MaxRetries?:int, Tags?:array<string, string>, TransformEncryption?:array{MlUserDataEncryption?:array{MlUserDataEncryptionMode:"DISABLED"|"SSE-KMS", KmsKeyId?:string}, TaskRunSecurityConfigurationName?:string}} $args
     * @return \GuzzleHttp\Promise\Promise<array{TransformId?:string}>
     */
    public function createMLTransformAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, TableName:string, PartitionInput:array{Values?:array<string>, LastAccessTime?:int|string|\DateTimeInterface, StorageDescriptor?:array{Columns?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, Location?:string, AdditionalLocations?:array<string>, InputFormat?:string, OutputFormat?:string, Compressed?:bool, NumberOfBuckets?:int, SerdeInfo?:array{Name?:string, SerializationLibrary?:string, Parameters?:array<string, string>}, BucketColumns?:array<string>, SortColumns?:array<array{Column:string, SortOrder:int}>, Parameters?:array<string, string>, SkewedInfo?:array{SkewedColumnNames?:array<string>, SkewedColumnValues?:array<string>, SkewedColumnValueLocationMaps?:array<string, string>}, StoredAsSubDirectories?:bool, SchemaReference?:array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionId?:string, SchemaVersionNumber?:int}}, Parameters?:array<string, string>, LastAnalyzedTime?:int|string|\DateTimeInterface}} $args
     * @return \AWS\Result<array{}>
     */
    public function createPartition(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, TableName:string, PartitionInput:array{Values?:array<string>, LastAccessTime?:int|string|\DateTimeInterface, StorageDescriptor?:array{Columns?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, Location?:string, AdditionalLocations?:array<string>, InputFormat?:string, OutputFormat?:string, Compressed?:bool, NumberOfBuckets?:int, SerdeInfo?:array{Name?:string, SerializationLibrary?:string, Parameters?:array<string, string>}, BucketColumns?:array<string>, SortColumns?:array<array{Column:string, SortOrder:int}>, Parameters?:array<string, string>, SkewedInfo?:array{SkewedColumnNames?:array<string>, SkewedColumnValues?:array<string>, SkewedColumnValueLocationMaps?:array<string, string>}, StoredAsSubDirectories?:bool, SchemaReference?:array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionId?:string, SchemaVersionNumber?:int}}, Parameters?:array<string, string>, LastAnalyzedTime?:int|string|\DateTimeInterface}} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function createPartitionAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, TableName:string, PartitionIndex:array{Keys:array<string>, IndexName:string}} $args
     * @return \AWS\Result<array{}>
     */
    public function createPartitionIndex(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, TableName:string, PartitionIndex:array{Keys:array<string>, IndexName:string}} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function createPartitionIndexAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{RegistryName:string, Description?:string, Tags?:array<string, string>} $args
     * @return \AWS\Result<array{RegistryArn?:string, RegistryName?:string, Description?:string, Tags?:array<string, string>}>
     */
    public function createRegistry(array $args): \AWS\Result { }

    /**
     * @param array{RegistryName:string, Description?:string, Tags?:array<string, string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{RegistryArn?:string, RegistryName?:string, Description?:string, Tags?:array<string, string>}>
     */
    public function createRegistryAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{RegistryId?:array{RegistryName?:string, RegistryArn?:string}, SchemaName:string, DataFormat:"AVRO"|"JSON"|"PROTOBUF", Compatibility?:"NONE"|"DISABLED"|"BACKWARD"|"BACKWARD_ALL"|"FORWARD"|"FORWARD_ALL"|"FULL"|"FULL_ALL", Description?:string, Tags?:array<string, string>, SchemaDefinition?:string} $args
     * @return \AWS\Result<array{RegistryName?:string, RegistryArn?:string, SchemaName?:string, SchemaArn?:string, Description?:string, DataFormat?:"AVRO"|"JSON"|"PROTOBUF", Compatibility?:"NONE"|"DISABLED"|"BACKWARD"|"BACKWARD_ALL"|"FORWARD"|"FORWARD_ALL"|"FULL"|"FULL_ALL", SchemaCheckpoint?:int, LatestSchemaVersion?:int, NextSchemaVersion?:int, SchemaStatus?:"AVAILABLE"|"PENDING"|"DELETING", Tags?:array<string, string>, SchemaVersionId?:string, SchemaVersionStatus?:"AVAILABLE"|"PENDING"|"FAILURE"|"DELETING"}>
     */
    public function createSchema(array $args): \AWS\Result { }

    /**
     * @param array{RegistryId?:array{RegistryName?:string, RegistryArn?:string}, SchemaName:string, DataFormat:"AVRO"|"JSON"|"PROTOBUF", Compatibility?:"NONE"|"DISABLED"|"BACKWARD"|"BACKWARD_ALL"|"FORWARD"|"FORWARD_ALL"|"FULL"|"FULL_ALL", Description?:string, Tags?:array<string, string>, SchemaDefinition?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{RegistryName?:string, RegistryArn?:string, SchemaName?:string, SchemaArn?:string, Description?:string, DataFormat?:"AVRO"|"JSON"|"PROTOBUF", Compatibility?:"NONE"|"DISABLED"|"BACKWARD"|"BACKWARD_ALL"|"FORWARD"|"FORWARD_ALL"|"FULL"|"FULL_ALL", SchemaCheckpoint?:int, LatestSchemaVersion?:int, NextSchemaVersion?:int, SchemaStatus?:"AVAILABLE"|"PENDING"|"DELETING", Tags?:array<string, string>, SchemaVersionId?:string, SchemaVersionStatus?:"AVAILABLE"|"PENDING"|"FAILURE"|"DELETING"}>
     */
    public function createSchemaAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{DagNodes?:array<array{Id:string, NodeType:string, Args:array<array{Name:string, Value:string, Param?:bool}>, LineNumber?:int}>, DagEdges?:array<array{Source:string, Target:string, TargetParameter?:string}>, Language?:"PYTHON"|"SCALA"} $args
     * @return \AWS\Result<array{PythonScript?:string, ScalaCode?:string}>
     */
    public function createScript(array $args = []): \AWS\Result { }

    /**
     * @param array{DagNodes?:array<array{Id:string, NodeType:string, Args:array<array{Name:string, Value:string, Param?:bool}>, LineNumber?:int}>, DagEdges?:array<array{Source:string, Target:string, TargetParameter?:string}>, Language?:"PYTHON"|"SCALA"} $args
     * @return \GuzzleHttp\Promise\Promise<array{PythonScript?:string, ScalaCode?:string}>
     */
    public function createScriptAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Name:string, EncryptionConfiguration:array{S3Encryption?:array<array{S3EncryptionMode?:"DISABLED"|"SSE-KMS"|"SSE-S3", KmsKeyArn?:string}>, CloudWatchEncryption?:array{CloudWatchEncryptionMode?:"DISABLED"|"SSE-KMS", KmsKeyArn?:string}, JobBookmarksEncryption?:array{JobBookmarksEncryptionMode?:"DISABLED"|"CSE-KMS", KmsKeyArn?:string}, DataQualityEncryption?:array{DataQualityEncryptionMode?:"DISABLED"|"SSE-KMS", KmsKeyArn?:string}}} $args
     * @return \AWS\Result<array{Name?:string, CreatedTimestamp?:int|string|\DateTimeInterface}>
     */
    public function createSecurityConfiguration(array $args): \AWS\Result { }

    /**
     * @param array{Name:string, EncryptionConfiguration:array{S3Encryption?:array<array{S3EncryptionMode?:"DISABLED"|"SSE-KMS"|"SSE-S3", KmsKeyArn?:string}>, CloudWatchEncryption?:array{CloudWatchEncryptionMode?:"DISABLED"|"SSE-KMS", KmsKeyArn?:string}, JobBookmarksEncryption?:array{JobBookmarksEncryptionMode?:"DISABLED"|"CSE-KMS", KmsKeyArn?:string}, DataQualityEncryption?:array{DataQualityEncryptionMode?:"DISABLED"|"SSE-KMS", KmsKeyArn?:string}}} $args
     * @return \GuzzleHttp\Promise\Promise<array{Name?:string, CreatedTimestamp?:int|string|\DateTimeInterface}>
     */
    public function createSecurityConfigurationAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Id:string, Description?:string, Role:string, Command:array{Name?:string, PythonVersion?:string}, Timeout?:int, IdleTimeout?:int, DefaultArguments?:array<string, string>, Connections?:array{Connections?:mixed}, MaxCapacity?:float, NumberOfWorkers?:int, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", SecurityConfiguration?:string, GlueVersion?:string, Tags?:array<string, string>, RequestOrigin?:string} $args
     * @return \AWS\Result<array{Session?:array{Id?:string, CreatedOn?:int|string|\DateTimeInterface, Status?:"PROVISIONING"|"READY"|"FAILED"|"TIMEOUT"|"STOPPING"|"STOPPED", ErrorMessage?:string, Description?:string, Role?:string, Command?:array{Name?:string, PythonVersion?:string}, DefaultArguments?:array<string, string>, Connections?:array{Connections?:mixed}, Progress?:float, MaxCapacity?:float, SecurityConfiguration?:string, GlueVersion?:string, NumberOfWorkers?:int, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", CompletedOn?:int|string|\DateTimeInterface, ExecutionTime?:float, DPUSeconds?:float, IdleTimeout?:int, ProfileName?:string}}>
     */
    public function createSession(array $args): \AWS\Result { }

    /**
     * @param array{Id:string, Description?:string, Role:string, Command:array{Name?:string, PythonVersion?:string}, Timeout?:int, IdleTimeout?:int, DefaultArguments?:array<string, string>, Connections?:array{Connections?:mixed}, MaxCapacity?:float, NumberOfWorkers?:int, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", SecurityConfiguration?:string, GlueVersion?:string, Tags?:array<string, string>, RequestOrigin?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Session?:array{Id?:string, CreatedOn?:int|string|\DateTimeInterface, Status?:"PROVISIONING"|"READY"|"FAILED"|"TIMEOUT"|"STOPPING"|"STOPPED", ErrorMessage?:string, Description?:string, Role?:string, Command?:array{Name?:string, PythonVersion?:string}, DefaultArguments?:array<string, string>, Connections?:array{Connections?:mixed}, Progress?:float, MaxCapacity?:float, SecurityConfiguration?:string, GlueVersion?:string, NumberOfWorkers?:int, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", CompletedOn?:int|string|\DateTimeInterface, ExecutionTime?:float, DPUSeconds?:float, IdleTimeout?:int, ProfileName?:string}}>
     */
    public function createSessionAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, TableInput:array{Name:string, Description?:string, Owner?:string, LastAccessTime?:int|string|\DateTimeInterface, LastAnalyzedTime?:int|string|\DateTimeInterface, Retention?:int, StorageDescriptor?:array{Columns?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, Location?:string, AdditionalLocations?:array<string>, InputFormat?:string, OutputFormat?:string, Compressed?:bool, NumberOfBuckets?:int, SerdeInfo?:array{Name?:string, SerializationLibrary?:string, Parameters?:array<string, string>}, BucketColumns?:array<string>, SortColumns?:array<array{Column:string, SortOrder:int}>, Parameters?:array<string, string>, SkewedInfo?:array{SkewedColumnNames?:array<string>, SkewedColumnValues?:array<string>, SkewedColumnValueLocationMaps?:array<string, string>}, StoredAsSubDirectories?:bool, SchemaReference?:array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionId?:string, SchemaVersionNumber?:int}}, PartitionKeys?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, ViewOriginalText?:string, ViewExpandedText?:string, TableType?:string, Parameters?:array<string, string>, TargetTable?:array{CatalogId?:string, DatabaseName?:string, Name?:string, Region?:string}, ViewDefinition?:array{IsProtected?:bool, Definer?:string, Representations?:array<array{Dialect?:"REDSHIFT"|"ATHENA"|"SPARK", DialectVersion?:string, ViewOriginalText?:string, ValidationConnection?:string, ViewExpandedText?:string}>, SubObjects?:array<string>}}, PartitionIndexes?:array<array{Keys:array<string>, IndexName:string}>, TransactionId?:string, OpenTableFormatInput?:array{IcebergInput?:array{MetadataOperation:"CREATE", Version?:string}}} $args
     * @return \AWS\Result<array{}>
     */
    public function createTable(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, TableInput:array{Name:string, Description?:string, Owner?:string, LastAccessTime?:int|string|\DateTimeInterface, LastAnalyzedTime?:int|string|\DateTimeInterface, Retention?:int, StorageDescriptor?:array{Columns?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, Location?:string, AdditionalLocations?:array<string>, InputFormat?:string, OutputFormat?:string, Compressed?:bool, NumberOfBuckets?:int, SerdeInfo?:array{Name?:string, SerializationLibrary?:string, Parameters?:array<string, string>}, BucketColumns?:array<string>, SortColumns?:array<array{Column:string, SortOrder:int}>, Parameters?:array<string, string>, SkewedInfo?:array{SkewedColumnNames?:array<string>, SkewedColumnValues?:array<string>, SkewedColumnValueLocationMaps?:array<string, string>}, StoredAsSubDirectories?:bool, SchemaReference?:array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionId?:string, SchemaVersionNumber?:int}}, PartitionKeys?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, ViewOriginalText?:string, ViewExpandedText?:string, TableType?:string, Parameters?:array<string, string>, TargetTable?:array{CatalogId?:string, DatabaseName?:string, Name?:string, Region?:string}, ViewDefinition?:array{IsProtected?:bool, Definer?:string, Representations?:array<array{Dialect?:"REDSHIFT"|"ATHENA"|"SPARK", DialectVersion?:string, ViewOriginalText?:string, ValidationConnection?:string, ViewExpandedText?:string}>, SubObjects?:array<string>}}, PartitionIndexes?:array<array{Keys:array<string>, IndexName:string}>, TransactionId?:string, OpenTableFormatInput?:array{IcebergInput?:array{MetadataOperation:"CREATE", Version?:string}}} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function createTableAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId:string, DatabaseName:string, TableName:string, Type:"compaction"|"retention"|"orphan_file_deletion", TableOptimizerConfiguration:array{roleArn?:string, enabled?:bool, vpcConfiguration?:array{glueConnectionName?:string}, retentionConfiguration?:array{icebergConfiguration?:array{snapshotRetentionPeriodInDays?:int, numberOfSnapshotsToRetain?:int, cleanExpiredFiles?:bool}}, orphanFileDeletionConfiguration?:array{icebergConfiguration?:array{orphanFileRetentionPeriodInDays?:int, location?:string}}}} $args
     * @return \AWS\Result<array{}>
     */
    public function createTableOptimizer(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId:string, DatabaseName:string, TableName:string, Type:"compaction"|"retention"|"orphan_file_deletion", TableOptimizerConfiguration:array{roleArn?:string, enabled?:bool, vpcConfiguration?:array{glueConnectionName?:string}, retentionConfiguration?:array{icebergConfiguration?:array{snapshotRetentionPeriodInDays?:int, numberOfSnapshotsToRetain?:int, cleanExpiredFiles?:bool}}, orphanFileDeletionConfiguration?:array{icebergConfiguration?:array{orphanFileRetentionPeriodInDays?:int, location?:string}}}} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function createTableOptimizerAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Name:string, WorkflowName?:string, Type:"SCHEDULED"|"CONDITIONAL"|"ON_DEMAND"|"EVENT", Schedule?:string, Predicate?:array{Logical?:"AND"|"ANY", Conditions?:array<array{LogicalOperator?:"EQUALS", JobName?:string, State?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED", CrawlerName?:string, CrawlState?:"RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR"}>}, Actions:array<array{JobName?:string, Arguments?:array<string, string>, Timeout?:int, SecurityConfiguration?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, CrawlerName?:string}>, Description?:string, StartOnCreation?:bool, Tags?:array<string, string>, EventBatchingCondition?:array{BatchSize:int, BatchWindow?:int}} $args
     * @return \AWS\Result<array{Name?:string}>
     */
    public function createTrigger(array $args): \AWS\Result { }

    /**
     * @param array{Name:string, WorkflowName?:string, Type:"SCHEDULED"|"CONDITIONAL"|"ON_DEMAND"|"EVENT", Schedule?:string, Predicate?:array{Logical?:"AND"|"ANY", Conditions?:array<array{LogicalOperator?:"EQUALS", JobName?:string, State?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED", CrawlerName?:string, CrawlState?:"RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR"}>}, Actions:array<array{JobName?:string, Arguments?:array<string, string>, Timeout?:int, SecurityConfiguration?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, CrawlerName?:string}>, Description?:string, StartOnCreation?:bool, Tags?:array<string, string>, EventBatchingCondition?:array{BatchSize:int, BatchWindow?:int}} $args
     * @return \GuzzleHttp\Promise\Promise<array{Name?:string}>
     */
    public function createTriggerAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Name:string, Description?:string, Configuration:array{SessionConfiguration?:array<string, array{DefaultValue?:string, AllowedValues?:array<string>, MinValue?:string, MaxValue?:string}>, JobConfiguration?:array<string, array{DefaultValue?:string, AllowedValues?:array<string>, MinValue?:string, MaxValue?:string}>}, Tags?:array<string, string>} $args
     * @return \AWS\Result<array{Name?:string}>
     */
    public function createUsageProfile(array $args): \AWS\Result { }

    /**
     * @param array{Name:string, Description?:string, Configuration:array{SessionConfiguration?:array<string, array{DefaultValue?:string, AllowedValues?:array<string>, MinValue?:string, MaxValue?:string}>, JobConfiguration?:array<string, array{DefaultValue?:string, AllowedValues?:array<string>, MinValue?:string, MaxValue?:string}>}, Tags?:array<string, string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{Name?:string}>
     */
    public function createUsageProfileAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, FunctionInput:array{FunctionName?:string, ClassName?:string, OwnerName?:string, OwnerType?:"USER"|"ROLE"|"GROUP", ResourceUris?:array<array{ResourceType?:"JAR"|"FILE"|"ARCHIVE", Uri?:string}>}} $args
     * @return \AWS\Result<array{}>
     */
    public function createUserDefinedFunction(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, FunctionInput:array{FunctionName?:string, ClassName?:string, OwnerName?:string, OwnerType?:"USER"|"ROLE"|"GROUP", ResourceUris?:array<array{ResourceType?:"JAR"|"FILE"|"ARCHIVE", Uri?:string}>}} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function createUserDefinedFunctionAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Name:string, Description?:string, DefaultRunProperties?:array<string, string>, Tags?:array<string, string>, MaxConcurrentRuns?:int} $args
     * @return \AWS\Result<array{Name?:string}>
     */
    public function createWorkflow(array $args): \AWS\Result { }

    /**
     * @param array{Name:string, Description?:string, DefaultRunProperties?:array<string, string>, Tags?:array<string, string>, MaxConcurrentRuns?:int} $args
     * @return \GuzzleHttp\Promise\Promise<array{Name?:string}>
     */
    public function createWorkflowAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Name:string} $args
     * @return \AWS\Result<array{Name?:string}>
     */
    public function deleteBlueprint(array $args): \AWS\Result { }

    /**
     * @param array{Name:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Name?:string}>
     */
    public function deleteBlueprintAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId:string} $args
     * @return \AWS\Result<array{}>
     */
    public function deleteCatalog(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function deleteCatalogAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Name:string} $args
     * @return \AWS\Result<array{}>
     */
    public function deleteClassifier(array $args): \AWS\Result { }

    /**
     * @param array{Name:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function deleteClassifierAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, TableName:string, PartitionValues:array<string>, ColumnName:string} $args
     * @return \AWS\Result<array{}>
     */
    public function deleteColumnStatisticsForPartition(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, TableName:string, PartitionValues:array<string>, ColumnName:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function deleteColumnStatisticsForPartitionAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, TableName:string, ColumnName:string} $args
     * @return \AWS\Result<array{}>
     */
    public function deleteColumnStatisticsForTable(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, TableName:string, ColumnName:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function deleteColumnStatisticsForTableAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{DatabaseName:string, TableName:string} $args
     * @return \AWS\Result<array{}>
     */
    public function deleteColumnStatisticsTaskSettings(array $args): \AWS\Result { }

    /**
     * @param array{DatabaseName:string, TableName:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function deleteColumnStatisticsTaskSettingsAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId?:string, ConnectionName:string} $args
     * @return \AWS\Result<array{}>
     */
    public function deleteConnection(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId?:string, ConnectionName:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function deleteConnectionAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Name:string} $args
     * @return \AWS\Result<array{}>
     */
    public function deleteCrawler(array $args): \AWS\Result { }

    /**
     * @param array{Name:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function deleteCrawlerAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Name:string} $args
     * @return \AWS\Result<array{Name?:string}>
     */
    public function deleteCustomEntityType(array $args): \AWS\Result { }

    /**
     * @param array{Name:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Name?:string}>
     */
    public function deleteCustomEntityTypeAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Name:string} $args
     * @return \AWS\Result<array{}>
     */
    public function deleteDataQualityRuleset(array $args): \AWS\Result { }

    /**
     * @param array{Name:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function deleteDataQualityRulesetAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId?:string, Name:string} $args
     * @return \AWS\Result<array{}>
     */
    public function deleteDatabase(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId?:string, Name:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function deleteDatabaseAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{EndpointName:string} $args
     * @return \AWS\Result<array{}>
     */
    public function deleteDevEndpoint(array $args): \AWS\Result { }

    /**
     * @param array{EndpointName:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function deleteDevEndpointAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{IntegrationIdentifier:string} $args
     * @return \AWS\Result<array{SourceArn:string, TargetArn:string, IntegrationName:string, Description?:string, IntegrationArn:string, KmsKeyId?:string, AdditionalEncryptionContext?:array<string, string>, Tags?:array<array{key?:string, value?:string}>, Status:"CREATING"|"ACTIVE"|"MODIFYING"|"FAILED"|"DELETING"|"SYNCING"|"NEEDS_ATTENTION", CreateTime:int|string|\DateTimeInterface, Errors?:array<array{ErrorCode?:string, ErrorMessage?:string}>, DataFilter?:string}>
     */
    public function deleteIntegration(array $args): \AWS\Result { }

    /**
     * @param array{IntegrationIdentifier:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{SourceArn:string, TargetArn:string, IntegrationName:string, Description?:string, IntegrationArn:string, KmsKeyId?:string, AdditionalEncryptionContext?:array<string, string>, Tags?:array<array{key?:string, value?:string}>, Status:"CREATING"|"ACTIVE"|"MODIFYING"|"FAILED"|"DELETING"|"SYNCING"|"NEEDS_ATTENTION", CreateTime:int|string|\DateTimeInterface, Errors?:array<array{ErrorCode?:string, ErrorMessage?:string}>, DataFilter?:string}>
     */
    public function deleteIntegrationAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ResourceArn:string, TableName:string} $args
     * @return \AWS\Result<array{}>
     */
    public function deleteIntegrationTableProperties(array $args): \AWS\Result { }

    /**
     * @param array{ResourceArn:string, TableName:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function deleteIntegrationTablePropertiesAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{JobName:string} $args
     * @return \AWS\Result<array{JobName?:string}>
     */
    public function deleteJob(array $args): \AWS\Result { }

    /**
     * @param array{JobName:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{JobName?:string}>
     */
    public function deleteJobAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{TransformId:string} $args
     * @return \AWS\Result<array{TransformId?:string}>
     */
    public function deleteMLTransform(array $args): \AWS\Result { }

    /**
     * @param array{TransformId:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{TransformId?:string}>
     */
    public function deleteMLTransformAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, TableName:string, PartitionValues:array<string>} $args
     * @return \AWS\Result<array{}>
     */
    public function deletePartition(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, TableName:string, PartitionValues:array<string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function deletePartitionAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, TableName:string, IndexName:string} $args
     * @return \AWS\Result<array{}>
     */
    public function deletePartitionIndex(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, TableName:string, IndexName:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function deletePartitionIndexAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{RegistryId:array{RegistryName?:string, RegistryArn?:string}} $args
     * @return \AWS\Result<array{RegistryName?:string, RegistryArn?:string, Status?:"AVAILABLE"|"DELETING"}>
     */
    public function deleteRegistry(array $args): \AWS\Result { }

    /**
     * @param array{RegistryId:array{RegistryName?:string, RegistryArn?:string}} $args
     * @return \GuzzleHttp\Promise\Promise<array{RegistryName?:string, RegistryArn?:string, Status?:"AVAILABLE"|"DELETING"}>
     */
    public function deleteRegistryAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{PolicyHashCondition?:string, ResourceArn?:string} $args
     * @return \AWS\Result<array{}>
     */
    public function deleteResourcePolicy(array $args = []): \AWS\Result { }

    /**
     * @param array{PolicyHashCondition?:string, ResourceArn?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function deleteResourcePolicyAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{SchemaId:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}} $args
     * @return \AWS\Result<array{SchemaArn?:string, SchemaName?:string, Status?:"AVAILABLE"|"PENDING"|"DELETING"}>
     */
    public function deleteSchema(array $args): \AWS\Result { }

    /**
     * @param array{SchemaId:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}} $args
     * @return \GuzzleHttp\Promise\Promise<array{SchemaArn?:string, SchemaName?:string, Status?:"AVAILABLE"|"PENDING"|"DELETING"}>
     */
    public function deleteSchemaAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{SchemaId:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, Versions:string} $args
     * @return \AWS\Result<array{SchemaVersionErrors?:array<array{VersionNumber?:int, ErrorDetails?:array{ErrorCode?:string, ErrorMessage?:string}}>}>
     */
    public function deleteSchemaVersions(array $args): \AWS\Result { }

    /**
     * @param array{SchemaId:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, Versions:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{SchemaVersionErrors?:array<array{VersionNumber?:int, ErrorDetails?:array{ErrorCode?:string, ErrorMessage?:string}}>}>
     */
    public function deleteSchemaVersionsAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Name:string} $args
     * @return \AWS\Result<array{}>
     */
    public function deleteSecurityConfiguration(array $args): \AWS\Result { }

    /**
     * @param array{Name:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function deleteSecurityConfigurationAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Id:string, RequestOrigin?:string} $args
     * @return \AWS\Result<array{Id?:string}>
     */
    public function deleteSession(array $args): \AWS\Result { }

    /**
     * @param array{Id:string, RequestOrigin?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Id?:string}>
     */
    public function deleteSessionAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, Name:string, TransactionId?:string} $args
     * @return \AWS\Result<array{}>
     */
    public function deleteTable(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, Name:string, TransactionId?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function deleteTableAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId:string, DatabaseName:string, TableName:string, Type:"compaction"|"retention"|"orphan_file_deletion"} $args
     * @return \AWS\Result<array{}>
     */
    public function deleteTableOptimizer(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId:string, DatabaseName:string, TableName:string, Type:"compaction"|"retention"|"orphan_file_deletion"} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function deleteTableOptimizerAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, TableName:string, VersionId:string} $args
     * @return \AWS\Result<array{}>
     */
    public function deleteTableVersion(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, TableName:string, VersionId:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function deleteTableVersionAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Name:string} $args
     * @return \AWS\Result<array{Name?:string}>
     */
    public function deleteTrigger(array $args): \AWS\Result { }

    /**
     * @param array{Name:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Name?:string}>
     */
    public function deleteTriggerAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Name:string} $args
     * @return \AWS\Result<array{}>
     */
    public function deleteUsageProfile(array $args): \AWS\Result { }

    /**
     * @param array{Name:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function deleteUsageProfileAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, FunctionName:string} $args
     * @return \AWS\Result<array{}>
     */
    public function deleteUserDefinedFunction(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, FunctionName:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function deleteUserDefinedFunctionAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Name:string} $args
     * @return \AWS\Result<array{Name?:string}>
     */
    public function deleteWorkflow(array $args): \AWS\Result { }

    /**
     * @param array{Name:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Name?:string}>
     */
    public function deleteWorkflowAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ConnectionType:string} $args
     * @return \AWS\Result<array{ConnectionType?:string, Description?:string, Capabilities?:array{SupportedAuthenticationTypes:array<"BASIC"|"OAUTH2"|"CUSTOM"|"IAM">, SupportedDataOperations:array<"READ"|"WRITE">, SupportedComputeEnvironments:array<"SPARK"|"ATHENA"|"PYTHON">}, ConnectionProperties?:array<string, array{Name:string, Description:string, Required:bool, DefaultValue?:string, PropertyTypes:array<"USER_INPUT"|"SECRET"|"READ_ONLY"|"UNUSED"|"SECRET_OR_USER_INPUT">, AllowedValues?:array<array{Description?:string, Value:string}>, DataOperationScopes?:array<"READ"|"WRITE">}>, ConnectionOptions?:array<string, array{Name:string, Description:string, Required:bool, DefaultValue?:string, PropertyTypes:array<"USER_INPUT"|"SECRET"|"READ_ONLY"|"UNUSED"|"SECRET_OR_USER_INPUT">, AllowedValues?:array<array{Description?:string, Value:string}>, DataOperationScopes?:array<"READ"|"WRITE">}>, AuthenticationConfiguration?:array{AuthenticationType:array{Name:string, Description:string, Required:bool, DefaultValue?:string, PropertyTypes:array<"USER_INPUT"|"SECRET"|"READ_ONLY"|"UNUSED"|"SECRET_OR_USER_INPUT">, AllowedValues?:array<array{Description?:string, Value:string}>, DataOperationScopes?:array<"READ"|"WRITE">}, SecretArn?:array{Name:string, Description:string, Required:bool, DefaultValue?:string, PropertyTypes:array<"USER_INPUT"|"SECRET"|"READ_ONLY"|"UNUSED"|"SECRET_OR_USER_INPUT">, AllowedValues?:array<array{Description?:string, Value:string}>, DataOperationScopes?:array<"READ"|"WRITE">}, OAuth2Properties?:array<string, array{Name:string, Description:string, Required:bool, DefaultValue?:string, PropertyTypes:array<"USER_INPUT"|"SECRET"|"READ_ONLY"|"UNUSED"|"SECRET_OR_USER_INPUT">, AllowedValues?:array<array{Description?:string, Value:string}>, DataOperationScopes?:array<"READ"|"WRITE">}>, BasicAuthenticationProperties?:array<string, array{Name:string, Description:string, Required:bool, DefaultValue?:string, PropertyTypes:array<"USER_INPUT"|"SECRET"|"READ_ONLY"|"UNUSED"|"SECRET_OR_USER_INPUT">, AllowedValues?:array<array{Description?:string, Value:string}>, DataOperationScopes?:array<"READ"|"WRITE">}>, CustomAuthenticationProperties?:array<string, array{Name:string, Description:string, Required:bool, DefaultValue?:string, PropertyTypes:array<"USER_INPUT"|"SECRET"|"READ_ONLY"|"UNUSED"|"SECRET_OR_USER_INPUT">, AllowedValues?:array<array{Description?:string, Value:string}>, DataOperationScopes?:array<"READ"|"WRITE">}>}, ComputeEnvironmentConfigurations?:array<string, array{Name:string, Description:string, ComputeEnvironment:"SPARK"|"ATHENA"|"PYTHON", SupportedAuthenticationTypes:array<"BASIC"|"OAUTH2"|"CUSTOM"|"IAM">, ConnectionOptions:array<string, array{Name:string, Description:string, Required:bool, DefaultValue?:string, PropertyTypes:array<"USER_INPUT"|"SECRET"|"READ_ONLY"|"UNUSED"|"SECRET_OR_USER_INPUT">, AllowedValues?:array<array{Description?:string, Value:string}>, DataOperationScopes?:array<"READ"|"WRITE">}>, ConnectionPropertyNameOverrides:array<string, string>, ConnectionOptionNameOverrides:array<string, string>, ConnectionPropertiesRequiredOverrides:array<string>, PhysicalConnectionPropertiesRequired?:bool}>, PhysicalConnectionRequirements?:array<string, array{Name:string, Description:string, Required:bool, DefaultValue?:string, PropertyTypes:array<"USER_INPUT"|"SECRET"|"READ_ONLY"|"UNUSED"|"SECRET_OR_USER_INPUT">, AllowedValues?:array<array{Description?:string, Value:string}>, DataOperationScopes?:array<"READ"|"WRITE">}>, AthenaConnectionProperties?:array<string, array{Name:string, Description:string, Required:bool, DefaultValue?:string, PropertyTypes:array<"USER_INPUT"|"SECRET"|"READ_ONLY"|"UNUSED"|"SECRET_OR_USER_INPUT">, AllowedValues?:array<array{Description?:string, Value:string}>, DataOperationScopes?:array<"READ"|"WRITE">}>, PythonConnectionProperties?:array<string, array{Name:string, Description:string, Required:bool, DefaultValue?:string, PropertyTypes:array<"USER_INPUT"|"SECRET"|"READ_ONLY"|"UNUSED"|"SECRET_OR_USER_INPUT">, AllowedValues?:array<array{Description?:string, Value:string}>, DataOperationScopes?:array<"READ"|"WRITE">}>, SparkConnectionProperties?:array<string, array{Name:string, Description:string, Required:bool, DefaultValue?:string, PropertyTypes:array<"USER_INPUT"|"SECRET"|"READ_ONLY"|"UNUSED"|"SECRET_OR_USER_INPUT">, AllowedValues?:array<array{Description?:string, Value:string}>, DataOperationScopes?:array<"READ"|"WRITE">}>}>
     */
    public function describeConnectionType(array $args): \AWS\Result { }

    /**
     * @param array{ConnectionType:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{ConnectionType?:string, Description?:string, Capabilities?:array{SupportedAuthenticationTypes:array<"BASIC"|"OAUTH2"|"CUSTOM"|"IAM">, SupportedDataOperations:array<"READ"|"WRITE">, SupportedComputeEnvironments:array<"SPARK"|"ATHENA"|"PYTHON">}, ConnectionProperties?:array<string, array{Name:string, Description:string, Required:bool, DefaultValue?:string, PropertyTypes:array<"USER_INPUT"|"SECRET"|"READ_ONLY"|"UNUSED"|"SECRET_OR_USER_INPUT">, AllowedValues?:array<array{Description?:string, Value:string}>, DataOperationScopes?:array<"READ"|"WRITE">}>, ConnectionOptions?:array<string, array{Name:string, Description:string, Required:bool, DefaultValue?:string, PropertyTypes:array<"USER_INPUT"|"SECRET"|"READ_ONLY"|"UNUSED"|"SECRET_OR_USER_INPUT">, AllowedValues?:array<array{Description?:string, Value:string}>, DataOperationScopes?:array<"READ"|"WRITE">}>, AuthenticationConfiguration?:array{AuthenticationType:array{Name:string, Description:string, Required:bool, DefaultValue?:string, PropertyTypes:array<"USER_INPUT"|"SECRET"|"READ_ONLY"|"UNUSED"|"SECRET_OR_USER_INPUT">, AllowedValues?:array<array{Description?:string, Value:string}>, DataOperationScopes?:array<"READ"|"WRITE">}, SecretArn?:array{Name:string, Description:string, Required:bool, DefaultValue?:string, PropertyTypes:array<"USER_INPUT"|"SECRET"|"READ_ONLY"|"UNUSED"|"SECRET_OR_USER_INPUT">, AllowedValues?:array<array{Description?:string, Value:string}>, DataOperationScopes?:array<"READ"|"WRITE">}, OAuth2Properties?:array<string, array{Name:string, Description:string, Required:bool, DefaultValue?:string, PropertyTypes:array<"USER_INPUT"|"SECRET"|"READ_ONLY"|"UNUSED"|"SECRET_OR_USER_INPUT">, AllowedValues?:array<array{Description?:string, Value:string}>, DataOperationScopes?:array<"READ"|"WRITE">}>, BasicAuthenticationProperties?:array<string, array{Name:string, Description:string, Required:bool, DefaultValue?:string, PropertyTypes:array<"USER_INPUT"|"SECRET"|"READ_ONLY"|"UNUSED"|"SECRET_OR_USER_INPUT">, AllowedValues?:array<array{Description?:string, Value:string}>, DataOperationScopes?:array<"READ"|"WRITE">}>, CustomAuthenticationProperties?:array<string, array{Name:string, Description:string, Required:bool, DefaultValue?:string, PropertyTypes:array<"USER_INPUT"|"SECRET"|"READ_ONLY"|"UNUSED"|"SECRET_OR_USER_INPUT">, AllowedValues?:array<array{Description?:string, Value:string}>, DataOperationScopes?:array<"READ"|"WRITE">}>}, ComputeEnvironmentConfigurations?:array<string, array{Name:string, Description:string, ComputeEnvironment:"SPARK"|"ATHENA"|"PYTHON", SupportedAuthenticationTypes:array<"BASIC"|"OAUTH2"|"CUSTOM"|"IAM">, ConnectionOptions:array<string, array{Name:string, Description:string, Required:bool, DefaultValue?:string, PropertyTypes:array<"USER_INPUT"|"SECRET"|"READ_ONLY"|"UNUSED"|"SECRET_OR_USER_INPUT">, AllowedValues?:array<array{Description?:string, Value:string}>, DataOperationScopes?:array<"READ"|"WRITE">}>, ConnectionPropertyNameOverrides:array<string, string>, ConnectionOptionNameOverrides:array<string, string>, ConnectionPropertiesRequiredOverrides:array<string>, PhysicalConnectionPropertiesRequired?:bool}>, PhysicalConnectionRequirements?:array<string, array{Name:string, Description:string, Required:bool, DefaultValue?:string, PropertyTypes:array<"USER_INPUT"|"SECRET"|"READ_ONLY"|"UNUSED"|"SECRET_OR_USER_INPUT">, AllowedValues?:array<array{Description?:string, Value:string}>, DataOperationScopes?:array<"READ"|"WRITE">}>, AthenaConnectionProperties?:array<string, array{Name:string, Description:string, Required:bool, DefaultValue?:string, PropertyTypes:array<"USER_INPUT"|"SECRET"|"READ_ONLY"|"UNUSED"|"SECRET_OR_USER_INPUT">, AllowedValues?:array<array{Description?:string, Value:string}>, DataOperationScopes?:array<"READ"|"WRITE">}>, PythonConnectionProperties?:array<string, array{Name:string, Description:string, Required:bool, DefaultValue?:string, PropertyTypes:array<"USER_INPUT"|"SECRET"|"READ_ONLY"|"UNUSED"|"SECRET_OR_USER_INPUT">, AllowedValues?:array<array{Description?:string, Value:string}>, DataOperationScopes?:array<"READ"|"WRITE">}>, SparkConnectionProperties?:array<string, array{Name:string, Description:string, Required:bool, DefaultValue?:string, PropertyTypes:array<"USER_INPUT"|"SECRET"|"READ_ONLY"|"UNUSED"|"SECRET_OR_USER_INPUT">, AllowedValues?:array<array{Description?:string, Value:string}>, DataOperationScopes?:array<"READ"|"WRITE">}>}>
     */
    public function describeConnectionTypeAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ConnectionName:string, CatalogId?:string, EntityName:string, NextToken?:string, DataStoreApiVersion?:string} $args
     * @return \AWS\Result<array{Fields?:array<array{FieldName?:string, Label?:string, Description?:string, FieldType?:"INT"|"SMALLINT"|"BIGINT"|"FLOAT"|"LONG"|"DATE"|"BOOLEAN"|"MAP"|"ARRAY"|"STRING"|"TIMESTAMP"|"DECIMAL"|"BYTE"|"SHORT"|"DOUBLE"|"STRUCT", IsPrimaryKey?:bool, IsNullable?:bool, IsRetrievable?:bool, IsFilterable?:bool, IsPartitionable?:bool, IsCreateable?:bool, IsUpdateable?:bool, IsUpsertable?:bool, IsDefaultOnCreate?:bool, SupportedValues?:array<string>, SupportedFilterOperators?:array<"LESS_THAN"|"GREATER_THAN"|"BETWEEN"|"EQUAL_TO"|"NOT_EQUAL_TO"|"GREATER_THAN_OR_EQUAL_TO"|"LESS_THAN_OR_EQUAL_TO"|"CONTAINS"|"ORDER_BY">, ParentField?:string, NativeDataType?:string, CustomProperties?:array<string, string>}>, NextToken?:string}>
     */
    public function describeEntity(array $args): \AWS\Result { }

    /**
     * @param array{ConnectionName:string, CatalogId?:string, EntityName:string, NextToken?:string, DataStoreApiVersion?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Fields?:array<array{FieldName?:string, Label?:string, Description?:string, FieldType?:"INT"|"SMALLINT"|"BIGINT"|"FLOAT"|"LONG"|"DATE"|"BOOLEAN"|"MAP"|"ARRAY"|"STRING"|"TIMESTAMP"|"DECIMAL"|"BYTE"|"SHORT"|"DOUBLE"|"STRUCT", IsPrimaryKey?:bool, IsNullable?:bool, IsRetrievable?:bool, IsFilterable?:bool, IsPartitionable?:bool, IsCreateable?:bool, IsUpdateable?:bool, IsUpsertable?:bool, IsDefaultOnCreate?:bool, SupportedValues?:array<string>, SupportedFilterOperators?:array<"LESS_THAN"|"GREATER_THAN"|"BETWEEN"|"EQUAL_TO"|"NOT_EQUAL_TO"|"GREATER_THAN_OR_EQUAL_TO"|"LESS_THAN_OR_EQUAL_TO"|"CONTAINS"|"ORDER_BY">, ParentField?:string, NativeDataType?:string, CustomProperties?:array<string, string>}>, NextToken?:string}>
     */
    public function describeEntityAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{IntegrationArn?:string, Marker?:string, MaxRecords?:int, TargetArn?:string} $args
     * @return \AWS\Result<array{InboundIntegrations?:array<array{SourceArn:string, TargetArn:string, IntegrationArn:string, Status:"CREATING"|"ACTIVE"|"MODIFYING"|"FAILED"|"DELETING"|"SYNCING"|"NEEDS_ATTENTION", CreateTime:int|string|\DateTimeInterface, Errors?:array<array{ErrorCode?:string, ErrorMessage?:string}>}>, Marker?:string}>
     */
    public function describeInboundIntegrations(array $args = []): \AWS\Result { }

    /**
     * @param array{IntegrationArn?:string, Marker?:string, MaxRecords?:int, TargetArn?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{InboundIntegrations?:array<array{SourceArn:string, TargetArn:string, IntegrationArn:string, Status:"CREATING"|"ACTIVE"|"MODIFYING"|"FAILED"|"DELETING"|"SYNCING"|"NEEDS_ATTENTION", CreateTime:int|string|\DateTimeInterface, Errors?:array<array{ErrorCode?:string, ErrorMessage?:string}>}>, Marker?:string}>
     */
    public function describeInboundIntegrationsAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{IntegrationIdentifier?:string, Marker?:string, MaxRecords?:int, Filters?:array<array{Name?:string, Values?:array<string>}>} $args
     * @return \AWS\Result<array{Integrations?:array<array{SourceArn:string, TargetArn:string, Description?:string, IntegrationName:string, IntegrationArn:string, KmsKeyId?:string, AdditionalEncryptionContext?:array<string, string>, Tags?:array<array{key?:string, value?:string}>, Status:"CREATING"|"ACTIVE"|"MODIFYING"|"FAILED"|"DELETING"|"SYNCING"|"NEEDS_ATTENTION", CreateTime:int|string|\DateTimeInterface, Errors?:array<array{ErrorCode?:string, ErrorMessage?:string}>, DataFilter?:string}>, Marker?:string}>
     */
    public function describeIntegrations(array $args = []): \AWS\Result { }

    /**
     * @param array{IntegrationIdentifier?:string, Marker?:string, MaxRecords?:int, Filters?:array<array{Name?:string, Values?:array<string>}>} $args
     * @return \GuzzleHttp\Promise\Promise<array{Integrations?:array<array{SourceArn:string, TargetArn:string, Description?:string, IntegrationName:string, IntegrationArn:string, KmsKeyId?:string, AdditionalEncryptionContext?:array<string, string>, Tags?:array<array{key?:string, value?:string}>, Status:"CREATING"|"ACTIVE"|"MODIFYING"|"FAILED"|"DELETING"|"SYNCING"|"NEEDS_ATTENTION", CreateTime:int|string|\DateTimeInterface, Errors?:array<array{ErrorCode?:string, ErrorMessage?:string}>, DataFilter?:string}>, Marker?:string}>
     */
    public function describeIntegrationsAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Name:string, IncludeBlueprint?:bool, IncludeParameterSpec?:bool} $args
     * @return \AWS\Result<array{Blueprint?:array{Name?:string, Description?:string, CreatedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface, ParameterSpec?:string, BlueprintLocation?:string, BlueprintServiceLocation?:string, Status?:"CREATING"|"ACTIVE"|"UPDATING"|"FAILED", ErrorMessage?:string, LastActiveDefinition?:array{Description?:string, LastModifiedOn?:int|string|\DateTimeInterface, ParameterSpec?:string, BlueprintLocation?:string, BlueprintServiceLocation?:string}}}>
     */
    public function getBlueprint(array $args): \AWS\Result { }

    /**
     * @param array{Name:string, IncludeBlueprint?:bool, IncludeParameterSpec?:bool} $args
     * @return \GuzzleHttp\Promise\Promise<array{Blueprint?:array{Name?:string, Description?:string, CreatedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface, ParameterSpec?:string, BlueprintLocation?:string, BlueprintServiceLocation?:string, Status?:"CREATING"|"ACTIVE"|"UPDATING"|"FAILED", ErrorMessage?:string, LastActiveDefinition?:array{Description?:string, LastModifiedOn?:int|string|\DateTimeInterface, ParameterSpec?:string, BlueprintLocation?:string, BlueprintServiceLocation?:string}}}>
     */
    public function getBlueprintAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{BlueprintName:string, RunId:string} $args
     * @return \AWS\Result<array{BlueprintRun?:array{BlueprintName?:string, RunId?:string, WorkflowName?:string, State?:"RUNNING"|"SUCCEEDED"|"FAILED"|"ROLLING_BACK", StartedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, ErrorMessage?:string, RollbackErrorMessage?:string, Parameters?:string, RoleArn?:string}}>
     */
    public function getBlueprintRun(array $args): \AWS\Result { }

    /**
     * @param array{BlueprintName:string, RunId:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{BlueprintRun?:array{BlueprintName?:string, RunId?:string, WorkflowName?:string, State?:"RUNNING"|"SUCCEEDED"|"FAILED"|"ROLLING_BACK", StartedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, ErrorMessage?:string, RollbackErrorMessage?:string, Parameters?:string, RoleArn?:string}}>
     */
    public function getBlueprintRunAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{BlueprintName:string, NextToken?:string, MaxResults?:int} $args
     * @return \AWS\Result<array{BlueprintRuns?:array<array{BlueprintName?:string, RunId?:string, WorkflowName?:string, State?:"RUNNING"|"SUCCEEDED"|"FAILED"|"ROLLING_BACK", StartedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, ErrorMessage?:string, RollbackErrorMessage?:string, Parameters?:string, RoleArn?:string}>, NextToken?:string}>
     */
    public function getBlueprintRuns(array $args): \AWS\Result { }

    /**
     * @param array{BlueprintName:string, NextToken?:string, MaxResults?:int} $args
     * @return \GuzzleHttp\Promise\Promise<array{BlueprintRuns?:array<array{BlueprintName?:string, RunId?:string, WorkflowName?:string, State?:"RUNNING"|"SUCCEEDED"|"FAILED"|"ROLLING_BACK", StartedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, ErrorMessage?:string, RollbackErrorMessage?:string, Parameters?:string, RoleArn?:string}>, NextToken?:string}>
     */
    public function getBlueprintRunsAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId:string} $args
     * @return \AWS\Result<array{Catalog?:array{CatalogId?:string, Name:string, ResourceArn?:string, Description?:string, Parameters?:array<string, string>, CreateTime?:int|string|\DateTimeInterface, UpdateTime?:int|string|\DateTimeInterface, TargetRedshiftCatalog?:array{CatalogArn:string}, FederatedCatalog?:array{Identifier?:string, ConnectionName?:string}, CatalogProperties?:array{DataLakeAccessProperties?:array{DataLakeAccess?:bool, DataTransferRole?:string, KmsKey?:string, ManagedWorkgroupName?:string, ManagedWorkgroupStatus?:string, RedshiftDatabaseName?:string, StatusMessage?:string, CatalogType?:string}, CustomProperties?:array<string, string>}, CreateTableDefaultPermissions?:array<array{Principal?:array{DataLakePrincipalIdentifier?:string}, Permissions?:array<"ALL"|"SELECT"|"ALTER"|"DROP"|"DELETE"|"INSERT"|"CREATE_DATABASE"|"CREATE_TABLE"|"DATA_LOCATION_ACCESS">}>, CreateDatabaseDefaultPermissions?:array<array{Principal?:array{DataLakePrincipalIdentifier?:string}, Permissions?:array<"ALL"|"SELECT"|"ALTER"|"DROP"|"DELETE"|"INSERT"|"CREATE_DATABASE"|"CREATE_TABLE"|"DATA_LOCATION_ACCESS">}>}}>
     */
    public function getCatalog(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Catalog?:array{CatalogId?:string, Name:string, ResourceArn?:string, Description?:string, Parameters?:array<string, string>, CreateTime?:int|string|\DateTimeInterface, UpdateTime?:int|string|\DateTimeInterface, TargetRedshiftCatalog?:array{CatalogArn:string}, FederatedCatalog?:array{Identifier?:string, ConnectionName?:string}, CatalogProperties?:array{DataLakeAccessProperties?:array{DataLakeAccess?:bool, DataTransferRole?:string, KmsKey?:string, ManagedWorkgroupName?:string, ManagedWorkgroupStatus?:string, RedshiftDatabaseName?:string, StatusMessage?:string, CatalogType?:string}, CustomProperties?:array<string, string>}, CreateTableDefaultPermissions?:array<array{Principal?:array{DataLakePrincipalIdentifier?:string}, Permissions?:array<"ALL"|"SELECT"|"ALTER"|"DROP"|"DELETE"|"INSERT"|"CREATE_DATABASE"|"CREATE_TABLE"|"DATA_LOCATION_ACCESS">}>, CreateDatabaseDefaultPermissions?:array<array{Principal?:array{DataLakePrincipalIdentifier?:string}, Permissions?:array<"ALL"|"SELECT"|"ALTER"|"DROP"|"DELETE"|"INSERT"|"CREATE_DATABASE"|"CREATE_TABLE"|"DATA_LOCATION_ACCESS">}>}}>
     */
    public function getCatalogAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId?:string} $args
     * @return \AWS\Result<array{ImportStatus?:array{ImportCompleted?:bool, ImportTime?:int|string|\DateTimeInterface, ImportedBy?:string}}>
     */
    public function getCatalogImportStatus(array $args = []): \AWS\Result { }

    /**
     * @param array{CatalogId?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{ImportStatus?:array{ImportCompleted?:bool, ImportTime?:int|string|\DateTimeInterface, ImportedBy?:string}}>
     */
    public function getCatalogImportStatusAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ParentCatalogId?:string, NextToken?:string, MaxResults?:int, Recursive?:bool, IncludeRoot?:bool} $args
     * @return \AWS\Result<array{CatalogList:array<array{CatalogId?:string, Name:string, ResourceArn?:string, Description?:string, Parameters?:array<string, string>, CreateTime?:int|string|\DateTimeInterface, UpdateTime?:int|string|\DateTimeInterface, TargetRedshiftCatalog?:array{CatalogArn:string}, FederatedCatalog?:array{Identifier?:string, ConnectionName?:string}, CatalogProperties?:array{DataLakeAccessProperties?:array{DataLakeAccess?:bool, DataTransferRole?:string, KmsKey?:string, ManagedWorkgroupName?:string, ManagedWorkgroupStatus?:string, RedshiftDatabaseName?:string, StatusMessage?:string, CatalogType?:string}, CustomProperties?:array<string, string>}, CreateTableDefaultPermissions?:array<array{Principal?:array{DataLakePrincipalIdentifier?:string}, Permissions?:array<"ALL"|"SELECT"|"ALTER"|"DROP"|"DELETE"|"INSERT"|"CREATE_DATABASE"|"CREATE_TABLE"|"DATA_LOCATION_ACCESS">}>, CreateDatabaseDefaultPermissions?:array<array{Principal?:array{DataLakePrincipalIdentifier?:string}, Permissions?:array<"ALL"|"SELECT"|"ALTER"|"DROP"|"DELETE"|"INSERT"|"CREATE_DATABASE"|"CREATE_TABLE"|"DATA_LOCATION_ACCESS">}>}>, NextToken?:string}>
     */
    public function getCatalogs(array $args = []): \AWS\Result { }

    /**
     * @param array{ParentCatalogId?:string, NextToken?:string, MaxResults?:int, Recursive?:bool, IncludeRoot?:bool} $args
     * @return \GuzzleHttp\Promise\Promise<array{CatalogList:array<array{CatalogId?:string, Name:string, ResourceArn?:string, Description?:string, Parameters?:array<string, string>, CreateTime?:int|string|\DateTimeInterface, UpdateTime?:int|string|\DateTimeInterface, TargetRedshiftCatalog?:array{CatalogArn:string}, FederatedCatalog?:array{Identifier?:string, ConnectionName?:string}, CatalogProperties?:array{DataLakeAccessProperties?:array{DataLakeAccess?:bool, DataTransferRole?:string, KmsKey?:string, ManagedWorkgroupName?:string, ManagedWorkgroupStatus?:string, RedshiftDatabaseName?:string, StatusMessage?:string, CatalogType?:string}, CustomProperties?:array<string, string>}, CreateTableDefaultPermissions?:array<array{Principal?:array{DataLakePrincipalIdentifier?:string}, Permissions?:array<"ALL"|"SELECT"|"ALTER"|"DROP"|"DELETE"|"INSERT"|"CREATE_DATABASE"|"CREATE_TABLE"|"DATA_LOCATION_ACCESS">}>, CreateDatabaseDefaultPermissions?:array<array{Principal?:array{DataLakePrincipalIdentifier?:string}, Permissions?:array<"ALL"|"SELECT"|"ALTER"|"DROP"|"DELETE"|"INSERT"|"CREATE_DATABASE"|"CREATE_TABLE"|"DATA_LOCATION_ACCESS">}>}>, NextToken?:string}>
     */
    public function getCatalogsAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Name:string} $args
     * @return \AWS\Result<array{Classifier?:array{GrokClassifier?:array{Name:string, Classification:string, CreationTime?:int|string|\DateTimeInterface, LastUpdated?:int|string|\DateTimeInterface, Version?:int, GrokPattern:string, CustomPatterns?:string}, XMLClassifier?:array{Name:string, Classification:string, CreationTime?:int|string|\DateTimeInterface, LastUpdated?:int|string|\DateTimeInterface, Version?:int, RowTag?:string}, JsonClassifier?:array{Name:string, CreationTime?:int|string|\DateTimeInterface, LastUpdated?:int|string|\DateTimeInterface, Version?:int, JsonPath:string}, CsvClassifier?:array{Name:string, CreationTime?:int|string|\DateTimeInterface, LastUpdated?:int|string|\DateTimeInterface, Version?:int, Delimiter?:string, QuoteSymbol?:string, ContainsHeader?:"UNKNOWN"|"PRESENT"|"ABSENT", Header?:array<string>, DisableValueTrimming?:bool, AllowSingleColumn?:bool, CustomDatatypeConfigured?:bool, CustomDatatypes?:array<string>, Serde?:"OpenCSVSerDe"|"LazySimpleSerDe"|"None"}}}>
     */
    public function getClassifier(array $args): \AWS\Result { }

    /**
     * @param array{Name:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Classifier?:array{GrokClassifier?:array{Name:string, Classification:string, CreationTime?:int|string|\DateTimeInterface, LastUpdated?:int|string|\DateTimeInterface, Version?:int, GrokPattern:string, CustomPatterns?:string}, XMLClassifier?:array{Name:string, Classification:string, CreationTime?:int|string|\DateTimeInterface, LastUpdated?:int|string|\DateTimeInterface, Version?:int, RowTag?:string}, JsonClassifier?:array{Name:string, CreationTime?:int|string|\DateTimeInterface, LastUpdated?:int|string|\DateTimeInterface, Version?:int, JsonPath:string}, CsvClassifier?:array{Name:string, CreationTime?:int|string|\DateTimeInterface, LastUpdated?:int|string|\DateTimeInterface, Version?:int, Delimiter?:string, QuoteSymbol?:string, ContainsHeader?:"UNKNOWN"|"PRESENT"|"ABSENT", Header?:array<string>, DisableValueTrimming?:bool, AllowSingleColumn?:bool, CustomDatatypeConfigured?:bool, CustomDatatypes?:array<string>, Serde?:"OpenCSVSerDe"|"LazySimpleSerDe"|"None"}}}>
     */
    public function getClassifierAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{MaxResults?:int, NextToken?:string} $args
     * @return \AWS\Result<array{Classifiers?:array<array{GrokClassifier?:array{Name:string, Classification:string, CreationTime?:int|string|\DateTimeInterface, LastUpdated?:int|string|\DateTimeInterface, Version?:int, GrokPattern:string, CustomPatterns?:string}, XMLClassifier?:array{Name:string, Classification:string, CreationTime?:int|string|\DateTimeInterface, LastUpdated?:int|string|\DateTimeInterface, Version?:int, RowTag?:string}, JsonClassifier?:array{Name:string, CreationTime?:int|string|\DateTimeInterface, LastUpdated?:int|string|\DateTimeInterface, Version?:int, JsonPath:string}, CsvClassifier?:array{Name:string, CreationTime?:int|string|\DateTimeInterface, LastUpdated?:int|string|\DateTimeInterface, Version?:int, Delimiter?:string, QuoteSymbol?:string, ContainsHeader?:"UNKNOWN"|"PRESENT"|"ABSENT", Header?:array<string>, DisableValueTrimming?:bool, AllowSingleColumn?:bool, CustomDatatypeConfigured?:bool, CustomDatatypes?:array<string>, Serde?:"OpenCSVSerDe"|"LazySimpleSerDe"|"None"}}>, NextToken?:string}>
     */
    public function getClassifiers(array $args = []): \AWS\Result { }

    /**
     * @param array{MaxResults?:int, NextToken?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Classifiers?:array<array{GrokClassifier?:array{Name:string, Classification:string, CreationTime?:int|string|\DateTimeInterface, LastUpdated?:int|string|\DateTimeInterface, Version?:int, GrokPattern:string, CustomPatterns?:string}, XMLClassifier?:array{Name:string, Classification:string, CreationTime?:int|string|\DateTimeInterface, LastUpdated?:int|string|\DateTimeInterface, Version?:int, RowTag?:string}, JsonClassifier?:array{Name:string, CreationTime?:int|string|\DateTimeInterface, LastUpdated?:int|string|\DateTimeInterface, Version?:int, JsonPath:string}, CsvClassifier?:array{Name:string, CreationTime?:int|string|\DateTimeInterface, LastUpdated?:int|string|\DateTimeInterface, Version?:int, Delimiter?:string, QuoteSymbol?:string, ContainsHeader?:"UNKNOWN"|"PRESENT"|"ABSENT", Header?:array<string>, DisableValueTrimming?:bool, AllowSingleColumn?:bool, CustomDatatypeConfigured?:bool, CustomDatatypes?:array<string>, Serde?:"OpenCSVSerDe"|"LazySimpleSerDe"|"None"}}>, NextToken?:string}>
     */
    public function getClassifiersAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, TableName:string, PartitionValues:array<string>, ColumnNames:array<string>} $args
     * @return \AWS\Result<array{ColumnStatisticsList?:array<array{ColumnName:string, ColumnType:string, AnalyzedTime:int|string|\DateTimeInterface, StatisticsData:array{Type:"BOOLEAN"|"DATE"|"DECIMAL"|"DOUBLE"|"LONG"|"STRING"|"BINARY", BooleanColumnStatisticsData?:array{NumberOfTrues:int, NumberOfFalses:int, NumberOfNulls:int}, DateColumnStatisticsData?:array{MinimumValue?:int|string|\DateTimeInterface, MaximumValue?:int|string|\DateTimeInterface, NumberOfNulls:int, NumberOfDistinctValues:int}, DecimalColumnStatisticsData?:array{MinimumValue?:array{UnscaledValue:string|resource|\Psr\Http\Message\StreamInterface, Scale:int}, MaximumValue?:array{UnscaledValue:string|resource|\Psr\Http\Message\StreamInterface, Scale:int}, NumberOfNulls:int, NumberOfDistinctValues:int}, DoubleColumnStatisticsData?:array{MinimumValue?:float, MaximumValue?:float, NumberOfNulls:int, NumberOfDistinctValues:int}, LongColumnStatisticsData?:array{MinimumValue?:int, MaximumValue?:int, NumberOfNulls:int, NumberOfDistinctValues:int}, StringColumnStatisticsData?:array{MaximumLength:int, AverageLength:float, NumberOfNulls:int, NumberOfDistinctValues:int}, BinaryColumnStatisticsData?:array{MaximumLength:int, AverageLength:float, NumberOfNulls:int}}}>, Errors?:array<array{ColumnName?:string, Error?:array{ErrorCode?:string, ErrorMessage?:string}}>}>
     */
    public function getColumnStatisticsForPartition(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, TableName:string, PartitionValues:array<string>, ColumnNames:array<string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{ColumnStatisticsList?:array<array{ColumnName:string, ColumnType:string, AnalyzedTime:int|string|\DateTimeInterface, StatisticsData:array{Type:"BOOLEAN"|"DATE"|"DECIMAL"|"DOUBLE"|"LONG"|"STRING"|"BINARY", BooleanColumnStatisticsData?:array{NumberOfTrues:int, NumberOfFalses:int, NumberOfNulls:int}, DateColumnStatisticsData?:array{MinimumValue?:int|string|\DateTimeInterface, MaximumValue?:int|string|\DateTimeInterface, NumberOfNulls:int, NumberOfDistinctValues:int}, DecimalColumnStatisticsData?:array{MinimumValue?:array{UnscaledValue:string|resource|\Psr\Http\Message\StreamInterface, Scale:int}, MaximumValue?:array{UnscaledValue:string|resource|\Psr\Http\Message\StreamInterface, Scale:int}, NumberOfNulls:int, NumberOfDistinctValues:int}, DoubleColumnStatisticsData?:array{MinimumValue?:float, MaximumValue?:float, NumberOfNulls:int, NumberOfDistinctValues:int}, LongColumnStatisticsData?:array{MinimumValue?:int, MaximumValue?:int, NumberOfNulls:int, NumberOfDistinctValues:int}, StringColumnStatisticsData?:array{MaximumLength:int, AverageLength:float, NumberOfNulls:int, NumberOfDistinctValues:int}, BinaryColumnStatisticsData?:array{MaximumLength:int, AverageLength:float, NumberOfNulls:int}}}>, Errors?:array<array{ColumnName?:string, Error?:array{ErrorCode?:string, ErrorMessage?:string}}>}>
     */
    public function getColumnStatisticsForPartitionAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, TableName:string, ColumnNames:array<string>} $args
     * @return \AWS\Result<array{ColumnStatisticsList?:array<array{ColumnName:string, ColumnType:string, AnalyzedTime:int|string|\DateTimeInterface, StatisticsData:array{Type:"BOOLEAN"|"DATE"|"DECIMAL"|"DOUBLE"|"LONG"|"STRING"|"BINARY", BooleanColumnStatisticsData?:array{NumberOfTrues:int, NumberOfFalses:int, NumberOfNulls:int}, DateColumnStatisticsData?:array{MinimumValue?:int|string|\DateTimeInterface, MaximumValue?:int|string|\DateTimeInterface, NumberOfNulls:int, NumberOfDistinctValues:int}, DecimalColumnStatisticsData?:array{MinimumValue?:array{UnscaledValue:string|resource|\Psr\Http\Message\StreamInterface, Scale:int}, MaximumValue?:array{UnscaledValue:string|resource|\Psr\Http\Message\StreamInterface, Scale:int}, NumberOfNulls:int, NumberOfDistinctValues:int}, DoubleColumnStatisticsData?:array{MinimumValue?:float, MaximumValue?:float, NumberOfNulls:int, NumberOfDistinctValues:int}, LongColumnStatisticsData?:array{MinimumValue?:int, MaximumValue?:int, NumberOfNulls:int, NumberOfDistinctValues:int}, StringColumnStatisticsData?:array{MaximumLength:int, AverageLength:float, NumberOfNulls:int, NumberOfDistinctValues:int}, BinaryColumnStatisticsData?:array{MaximumLength:int, AverageLength:float, NumberOfNulls:int}}}>, Errors?:array<array{ColumnName?:string, Error?:array{ErrorCode?:string, ErrorMessage?:string}}>}>
     */
    public function getColumnStatisticsForTable(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, TableName:string, ColumnNames:array<string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{ColumnStatisticsList?:array<array{ColumnName:string, ColumnType:string, AnalyzedTime:int|string|\DateTimeInterface, StatisticsData:array{Type:"BOOLEAN"|"DATE"|"DECIMAL"|"DOUBLE"|"LONG"|"STRING"|"BINARY", BooleanColumnStatisticsData?:array{NumberOfTrues:int, NumberOfFalses:int, NumberOfNulls:int}, DateColumnStatisticsData?:array{MinimumValue?:int|string|\DateTimeInterface, MaximumValue?:int|string|\DateTimeInterface, NumberOfNulls:int, NumberOfDistinctValues:int}, DecimalColumnStatisticsData?:array{MinimumValue?:array{UnscaledValue:string|resource|\Psr\Http\Message\StreamInterface, Scale:int}, MaximumValue?:array{UnscaledValue:string|resource|\Psr\Http\Message\StreamInterface, Scale:int}, NumberOfNulls:int, NumberOfDistinctValues:int}, DoubleColumnStatisticsData?:array{MinimumValue?:float, MaximumValue?:float, NumberOfNulls:int, NumberOfDistinctValues:int}, LongColumnStatisticsData?:array{MinimumValue?:int, MaximumValue?:int, NumberOfNulls:int, NumberOfDistinctValues:int}, StringColumnStatisticsData?:array{MaximumLength:int, AverageLength:float, NumberOfNulls:int, NumberOfDistinctValues:int}, BinaryColumnStatisticsData?:array{MaximumLength:int, AverageLength:float, NumberOfNulls:int}}}>, Errors?:array<array{ColumnName?:string, Error?:array{ErrorCode?:string, ErrorMessage?:string}}>}>
     */
    public function getColumnStatisticsForTableAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ColumnStatisticsTaskRunId:string} $args
     * @return \AWS\Result<array{ColumnStatisticsTaskRun?:array{CustomerId?:string, ColumnStatisticsTaskRunId?:string, DatabaseName?:string, TableName?:string, ColumnNameList?:array<string>, CatalogID?:string, Role?:string, SampleSize?:float, SecurityConfiguration?:string, NumberOfWorkers?:int, WorkerType?:string, ComputationType?:"FULL"|"INCREMENTAL", Status?:"STARTING"|"RUNNING"|"SUCCEEDED"|"FAILED"|"STOPPED", CreationTime?:int|string|\DateTimeInterface, LastUpdated?:int|string|\DateTimeInterface, StartTime?:int|string|\DateTimeInterface, EndTime?:int|string|\DateTimeInterface, ErrorMessage?:string, DPUSeconds?:float}}>
     */
    public function getColumnStatisticsTaskRun(array $args): \AWS\Result { }

    /**
     * @param array{ColumnStatisticsTaskRunId:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{ColumnStatisticsTaskRun?:array{CustomerId?:string, ColumnStatisticsTaskRunId?:string, DatabaseName?:string, TableName?:string, ColumnNameList?:array<string>, CatalogID?:string, Role?:string, SampleSize?:float, SecurityConfiguration?:string, NumberOfWorkers?:int, WorkerType?:string, ComputationType?:"FULL"|"INCREMENTAL", Status?:"STARTING"|"RUNNING"|"SUCCEEDED"|"FAILED"|"STOPPED", CreationTime?:int|string|\DateTimeInterface, LastUpdated?:int|string|\DateTimeInterface, StartTime?:int|string|\DateTimeInterface, EndTime?:int|string|\DateTimeInterface, ErrorMessage?:string, DPUSeconds?:float}}>
     */
    public function getColumnStatisticsTaskRunAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{DatabaseName:string, TableName:string, MaxResults?:int, NextToken?:string} $args
     * @return \AWS\Result<array{ColumnStatisticsTaskRuns?:array<array{CustomerId?:string, ColumnStatisticsTaskRunId?:string, DatabaseName?:string, TableName?:string, ColumnNameList?:array<string>, CatalogID?:string, Role?:string, SampleSize?:float, SecurityConfiguration?:string, NumberOfWorkers?:int, WorkerType?:string, ComputationType?:"FULL"|"INCREMENTAL", Status?:"STARTING"|"RUNNING"|"SUCCEEDED"|"FAILED"|"STOPPED", CreationTime?:int|string|\DateTimeInterface, LastUpdated?:int|string|\DateTimeInterface, StartTime?:int|string|\DateTimeInterface, EndTime?:int|string|\DateTimeInterface, ErrorMessage?:string, DPUSeconds?:float}>, NextToken?:string}>
     */
    public function getColumnStatisticsTaskRuns(array $args): \AWS\Result { }

    /**
     * @param array{DatabaseName:string, TableName:string, MaxResults?:int, NextToken?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{ColumnStatisticsTaskRuns?:array<array{CustomerId?:string, ColumnStatisticsTaskRunId?:string, DatabaseName?:string, TableName?:string, ColumnNameList?:array<string>, CatalogID?:string, Role?:string, SampleSize?:float, SecurityConfiguration?:string, NumberOfWorkers?:int, WorkerType?:string, ComputationType?:"FULL"|"INCREMENTAL", Status?:"STARTING"|"RUNNING"|"SUCCEEDED"|"FAILED"|"STOPPED", CreationTime?:int|string|\DateTimeInterface, LastUpdated?:int|string|\DateTimeInterface, StartTime?:int|string|\DateTimeInterface, EndTime?:int|string|\DateTimeInterface, ErrorMessage?:string, DPUSeconds?:float}>, NextToken?:string}>
     */
    public function getColumnStatisticsTaskRunsAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{DatabaseName:string, TableName:string} $args
     * @return \AWS\Result<array{ColumnStatisticsTaskSettings?:array{DatabaseName?:string, TableName?:string, Schedule?:array{ScheduleExpression?:string, State?:"SCHEDULED"|"NOT_SCHEDULED"|"TRANSITIONING"}, ColumnNameList?:array<string>, CatalogID?:string, Role?:string, SampleSize?:float, SecurityConfiguration?:string, ScheduleType?:"CRON"|"AUTO", SettingSource?:"CATALOG"|"TABLE", LastExecutionAttempt?:array{Status?:"FAILED"|"STARTED", ColumnStatisticsTaskRunId?:string, ExecutionTimestamp?:int|string|\DateTimeInterface, ErrorMessage?:string}}}>
     */
    public function getColumnStatisticsTaskSettings(array $args): \AWS\Result { }

    /**
     * @param array{DatabaseName:string, TableName:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{ColumnStatisticsTaskSettings?:array{DatabaseName?:string, TableName?:string, Schedule?:array{ScheduleExpression?:string, State?:"SCHEDULED"|"NOT_SCHEDULED"|"TRANSITIONING"}, ColumnNameList?:array<string>, CatalogID?:string, Role?:string, SampleSize?:float, SecurityConfiguration?:string, ScheduleType?:"CRON"|"AUTO", SettingSource?:"CATALOG"|"TABLE", LastExecutionAttempt?:array{Status?:"FAILED"|"STARTED", ColumnStatisticsTaskRunId?:string, ExecutionTimestamp?:int|string|\DateTimeInterface, ErrorMessage?:string}}}>
     */
    public function getColumnStatisticsTaskSettingsAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId?:string, Name:string, HidePassword?:bool, ApplyOverrideForComputeEnvironment?:"SPARK"|"ATHENA"|"PYTHON"} $args
     * @return \AWS\Result<array{Connection?:array{Name?:string, Description?:string, ConnectionType?:"JDBC"|"SFTP"|"MONGODB"|"KAFKA"|"NETWORK"|"MARKETPLACE"|"CUSTOM"|"SALESFORCE"|"VIEW_VALIDATION_REDSHIFT"|"VIEW_VALIDATION_ATHENA"|"GOOGLEADS"|"GOOGLESHEETS"|"GOOGLEANALYTICS4"|"SERVICENOW"|"MARKETO"|"SAPODATA"|"ZENDESK"|"JIRACLOUD"|"NETSUITEERP"|"HUBSPOT"|"FACEBOOKADS"|"INSTAGRAMADS"|"ZOHOCRM"|"SALESFORCEPARDOT"|"SALESFORCEMARKETINGCLOUD"|"SLACK"|"STRIPE"|"INTERCOM"|"SNAPCHATADS", MatchCriteria?:array<string>, ConnectionProperties?:array<"HOST"|"PORT"|"USERNAME"|"PASSWORD"|"ENCRYPTED_PASSWORD"|"JDBC_DRIVER_JAR_URI"|"JDBC_DRIVER_CLASS_NAME"|"JDBC_ENGINE"|"JDBC_ENGINE_VERSION"|"CONFIG_FILES"|"INSTANCE_ID"|"JDBC_CONNECTION_URL"|"JDBC_ENFORCE_SSL"|"CUSTOM_JDBC_CERT"|"SKIP_CUSTOM_JDBC_CERT_VALIDATION"|"CUSTOM_JDBC_CERT_STRING"|"CONNECTION_URL"|"KAFKA_BOOTSTRAP_SERVERS"|"KAFKA_SSL_ENABLED"|"KAFKA_CUSTOM_CERT"|"KAFKA_SKIP_CUSTOM_CERT_VALIDATION"|"KAFKA_CLIENT_KEYSTORE"|"KAFKA_CLIENT_KEYSTORE_PASSWORD"|"KAFKA_CLIENT_KEY_PASSWORD"|"ENCRYPTED_KAFKA_CLIENT_KEYSTORE_PASSWORD"|"ENCRYPTED_KAFKA_CLIENT_KEY_PASSWORD"|"KAFKA_SASL_MECHANISM"|"KAFKA_SASL_PLAIN_USERNAME"|"KAFKA_SASL_PLAIN_PASSWORD"|"ENCRYPTED_KAFKA_SASL_PLAIN_PASSWORD"|"KAFKA_SASL_SCRAM_USERNAME"|"KAFKA_SASL_SCRAM_PASSWORD"|"KAFKA_SASL_SCRAM_SECRETS_ARN"|"ENCRYPTED_KAFKA_SASL_SCRAM_PASSWORD"|"KAFKA_SASL_GSSAPI_KEYTAB"|"KAFKA_SASL_GSSAPI_KRB5_CONF"|"KAFKA_SASL_GSSAPI_SERVICE"|"KAFKA_SASL_GSSAPI_PRINCIPAL"|"SECRET_ID"|"CONNECTOR_URL"|"CONNECTOR_TYPE"|"CONNECTOR_CLASS_NAME"|"ENDPOINT"|"ENDPOINT_TYPE"|"ROLE_ARN"|"REGION"|"WORKGROUP_NAME"|"CLUSTER_IDENTIFIER"|"DATABASE", string>, SparkProperties?:array<string, string>, AthenaProperties?:array<string, string>, PythonProperties?:array<string, string>, PhysicalConnectionRequirements?:array{SubnetId?:string, SecurityGroupIdList?:array<string>, AvailabilityZone?:string}, CreationTime?:int|string|\DateTimeInterface, LastUpdatedTime?:int|string|\DateTimeInterface, LastUpdatedBy?:string, Status?:"READY"|"IN_PROGRESS"|"FAILED", StatusReason?:string, LastConnectionValidationTime?:int|string|\DateTimeInterface, AuthenticationConfiguration?:array{AuthenticationType?:"BASIC"|"OAUTH2"|"CUSTOM"|"IAM", SecretArn?:string, OAuth2Properties?:array{OAuth2GrantType?:"AUTHORIZATION_CODE"|"CLIENT_CREDENTIALS"|"JWT_BEARER", OAuth2ClientApplication?:array{UserManagedClientApplicationClientId?:string, AWSManagedClientApplicationReference?:string}, TokenUrl?:string, TokenUrlParametersMap?:array<string, string>}}, ConnectionSchemaVersion?:int, CompatibleComputeEnvironments?:array<"SPARK"|"ATHENA"|"PYTHON">}}>
     */
    public function getConnection(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId?:string, Name:string, HidePassword?:bool, ApplyOverrideForComputeEnvironment?:"SPARK"|"ATHENA"|"PYTHON"} $args
     * @return \GuzzleHttp\Promise\Promise<array{Connection?:array{Name?:string, Description?:string, ConnectionType?:"JDBC"|"SFTP"|"MONGODB"|"KAFKA"|"NETWORK"|"MARKETPLACE"|"CUSTOM"|"SALESFORCE"|"VIEW_VALIDATION_REDSHIFT"|"VIEW_VALIDATION_ATHENA"|"GOOGLEADS"|"GOOGLESHEETS"|"GOOGLEANALYTICS4"|"SERVICENOW"|"MARKETO"|"SAPODATA"|"ZENDESK"|"JIRACLOUD"|"NETSUITEERP"|"HUBSPOT"|"FACEBOOKADS"|"INSTAGRAMADS"|"ZOHOCRM"|"SALESFORCEPARDOT"|"SALESFORCEMARKETINGCLOUD"|"SLACK"|"STRIPE"|"INTERCOM"|"SNAPCHATADS", MatchCriteria?:array<string>, ConnectionProperties?:array<"HOST"|"PORT"|"USERNAME"|"PASSWORD"|"ENCRYPTED_PASSWORD"|"JDBC_DRIVER_JAR_URI"|"JDBC_DRIVER_CLASS_NAME"|"JDBC_ENGINE"|"JDBC_ENGINE_VERSION"|"CONFIG_FILES"|"INSTANCE_ID"|"JDBC_CONNECTION_URL"|"JDBC_ENFORCE_SSL"|"CUSTOM_JDBC_CERT"|"SKIP_CUSTOM_JDBC_CERT_VALIDATION"|"CUSTOM_JDBC_CERT_STRING"|"CONNECTION_URL"|"KAFKA_BOOTSTRAP_SERVERS"|"KAFKA_SSL_ENABLED"|"KAFKA_CUSTOM_CERT"|"KAFKA_SKIP_CUSTOM_CERT_VALIDATION"|"KAFKA_CLIENT_KEYSTORE"|"KAFKA_CLIENT_KEYSTORE_PASSWORD"|"KAFKA_CLIENT_KEY_PASSWORD"|"ENCRYPTED_KAFKA_CLIENT_KEYSTORE_PASSWORD"|"ENCRYPTED_KAFKA_CLIENT_KEY_PASSWORD"|"KAFKA_SASL_MECHANISM"|"KAFKA_SASL_PLAIN_USERNAME"|"KAFKA_SASL_PLAIN_PASSWORD"|"ENCRYPTED_KAFKA_SASL_PLAIN_PASSWORD"|"KAFKA_SASL_SCRAM_USERNAME"|"KAFKA_SASL_SCRAM_PASSWORD"|"KAFKA_SASL_SCRAM_SECRETS_ARN"|"ENCRYPTED_KAFKA_SASL_SCRAM_PASSWORD"|"KAFKA_SASL_GSSAPI_KEYTAB"|"KAFKA_SASL_GSSAPI_KRB5_CONF"|"KAFKA_SASL_GSSAPI_SERVICE"|"KAFKA_SASL_GSSAPI_PRINCIPAL"|"SECRET_ID"|"CONNECTOR_URL"|"CONNECTOR_TYPE"|"CONNECTOR_CLASS_NAME"|"ENDPOINT"|"ENDPOINT_TYPE"|"ROLE_ARN"|"REGION"|"WORKGROUP_NAME"|"CLUSTER_IDENTIFIER"|"DATABASE", string>, SparkProperties?:array<string, string>, AthenaProperties?:array<string, string>, PythonProperties?:array<string, string>, PhysicalConnectionRequirements?:array{SubnetId?:string, SecurityGroupIdList?:array<string>, AvailabilityZone?:string}, CreationTime?:int|string|\DateTimeInterface, LastUpdatedTime?:int|string|\DateTimeInterface, LastUpdatedBy?:string, Status?:"READY"|"IN_PROGRESS"|"FAILED", StatusReason?:string, LastConnectionValidationTime?:int|string|\DateTimeInterface, AuthenticationConfiguration?:array{AuthenticationType?:"BASIC"|"OAUTH2"|"CUSTOM"|"IAM", SecretArn?:string, OAuth2Properties?:array{OAuth2GrantType?:"AUTHORIZATION_CODE"|"CLIENT_CREDENTIALS"|"JWT_BEARER", OAuth2ClientApplication?:array{UserManagedClientApplicationClientId?:string, AWSManagedClientApplicationReference?:string}, TokenUrl?:string, TokenUrlParametersMap?:array<string, string>}}, ConnectionSchemaVersion?:int, CompatibleComputeEnvironments?:array<"SPARK"|"ATHENA"|"PYTHON">}}>
     */
    public function getConnectionAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId?:string, Filter?:array{MatchCriteria?:array<string>, ConnectionType?:"JDBC"|"SFTP"|"MONGODB"|"KAFKA"|"NETWORK"|"MARKETPLACE"|"CUSTOM"|"SALESFORCE"|"VIEW_VALIDATION_REDSHIFT"|"VIEW_VALIDATION_ATHENA"|"GOOGLEADS"|"GOOGLESHEETS"|"GOOGLEANALYTICS4"|"SERVICENOW"|"MARKETO"|"SAPODATA"|"ZENDESK"|"JIRACLOUD"|"NETSUITEERP"|"HUBSPOT"|"FACEBOOKADS"|"INSTAGRAMADS"|"ZOHOCRM"|"SALESFORCEPARDOT"|"SALESFORCEMARKETINGCLOUD"|"SLACK"|"STRIPE"|"INTERCOM"|"SNAPCHATADS", ConnectionSchemaVersion?:int}, HidePassword?:bool, NextToken?:string, MaxResults?:int} $args
     * @return \AWS\Result<array{ConnectionList?:array<array{Name?:string, Description?:string, ConnectionType?:"JDBC"|"SFTP"|"MONGODB"|"KAFKA"|"NETWORK"|"MARKETPLACE"|"CUSTOM"|"SALESFORCE"|"VIEW_VALIDATION_REDSHIFT"|"VIEW_VALIDATION_ATHENA"|"GOOGLEADS"|"GOOGLESHEETS"|"GOOGLEANALYTICS4"|"SERVICENOW"|"MARKETO"|"SAPODATA"|"ZENDESK"|"JIRACLOUD"|"NETSUITEERP"|"HUBSPOT"|"FACEBOOKADS"|"INSTAGRAMADS"|"ZOHOCRM"|"SALESFORCEPARDOT"|"SALESFORCEMARKETINGCLOUD"|"SLACK"|"STRIPE"|"INTERCOM"|"SNAPCHATADS", MatchCriteria?:array<string>, ConnectionProperties?:array<"HOST"|"PORT"|"USERNAME"|"PASSWORD"|"ENCRYPTED_PASSWORD"|"JDBC_DRIVER_JAR_URI"|"JDBC_DRIVER_CLASS_NAME"|"JDBC_ENGINE"|"JDBC_ENGINE_VERSION"|"CONFIG_FILES"|"INSTANCE_ID"|"JDBC_CONNECTION_URL"|"JDBC_ENFORCE_SSL"|"CUSTOM_JDBC_CERT"|"SKIP_CUSTOM_JDBC_CERT_VALIDATION"|"CUSTOM_JDBC_CERT_STRING"|"CONNECTION_URL"|"KAFKA_BOOTSTRAP_SERVERS"|"KAFKA_SSL_ENABLED"|"KAFKA_CUSTOM_CERT"|"KAFKA_SKIP_CUSTOM_CERT_VALIDATION"|"KAFKA_CLIENT_KEYSTORE"|"KAFKA_CLIENT_KEYSTORE_PASSWORD"|"KAFKA_CLIENT_KEY_PASSWORD"|"ENCRYPTED_KAFKA_CLIENT_KEYSTORE_PASSWORD"|"ENCRYPTED_KAFKA_CLIENT_KEY_PASSWORD"|"KAFKA_SASL_MECHANISM"|"KAFKA_SASL_PLAIN_USERNAME"|"KAFKA_SASL_PLAIN_PASSWORD"|"ENCRYPTED_KAFKA_SASL_PLAIN_PASSWORD"|"KAFKA_SASL_SCRAM_USERNAME"|"KAFKA_SASL_SCRAM_PASSWORD"|"KAFKA_SASL_SCRAM_SECRETS_ARN"|"ENCRYPTED_KAFKA_SASL_SCRAM_PASSWORD"|"KAFKA_SASL_GSSAPI_KEYTAB"|"KAFKA_SASL_GSSAPI_KRB5_CONF"|"KAFKA_SASL_GSSAPI_SERVICE"|"KAFKA_SASL_GSSAPI_PRINCIPAL"|"SECRET_ID"|"CONNECTOR_URL"|"CONNECTOR_TYPE"|"CONNECTOR_CLASS_NAME"|"ENDPOINT"|"ENDPOINT_TYPE"|"ROLE_ARN"|"REGION"|"WORKGROUP_NAME"|"CLUSTER_IDENTIFIER"|"DATABASE", string>, SparkProperties?:array<string, string>, AthenaProperties?:array<string, string>, PythonProperties?:array<string, string>, PhysicalConnectionRequirements?:array{SubnetId?:string, SecurityGroupIdList?:array<string>, AvailabilityZone?:string}, CreationTime?:int|string|\DateTimeInterface, LastUpdatedTime?:int|string|\DateTimeInterface, LastUpdatedBy?:string, Status?:"READY"|"IN_PROGRESS"|"FAILED", StatusReason?:string, LastConnectionValidationTime?:int|string|\DateTimeInterface, AuthenticationConfiguration?:array{AuthenticationType?:"BASIC"|"OAUTH2"|"CUSTOM"|"IAM", SecretArn?:string, OAuth2Properties?:array{OAuth2GrantType?:"AUTHORIZATION_CODE"|"CLIENT_CREDENTIALS"|"JWT_BEARER", OAuth2ClientApplication?:array{UserManagedClientApplicationClientId?:string, AWSManagedClientApplicationReference?:string}, TokenUrl?:string, TokenUrlParametersMap?:array<string, string>}}, ConnectionSchemaVersion?:int, CompatibleComputeEnvironments?:array<"SPARK"|"ATHENA"|"PYTHON">}>, NextToken?:string}>
     */
    public function getConnections(array $args = []): \AWS\Result { }

    /**
     * @param array{CatalogId?:string, Filter?:array{MatchCriteria?:array<string>, ConnectionType?:"JDBC"|"SFTP"|"MONGODB"|"KAFKA"|"NETWORK"|"MARKETPLACE"|"CUSTOM"|"SALESFORCE"|"VIEW_VALIDATION_REDSHIFT"|"VIEW_VALIDATION_ATHENA"|"GOOGLEADS"|"GOOGLESHEETS"|"GOOGLEANALYTICS4"|"SERVICENOW"|"MARKETO"|"SAPODATA"|"ZENDESK"|"JIRACLOUD"|"NETSUITEERP"|"HUBSPOT"|"FACEBOOKADS"|"INSTAGRAMADS"|"ZOHOCRM"|"SALESFORCEPARDOT"|"SALESFORCEMARKETINGCLOUD"|"SLACK"|"STRIPE"|"INTERCOM"|"SNAPCHATADS", ConnectionSchemaVersion?:int}, HidePassword?:bool, NextToken?:string, MaxResults?:int} $args
     * @return \GuzzleHttp\Promise\Promise<array{ConnectionList?:array<array{Name?:string, Description?:string, ConnectionType?:"JDBC"|"SFTP"|"MONGODB"|"KAFKA"|"NETWORK"|"MARKETPLACE"|"CUSTOM"|"SALESFORCE"|"VIEW_VALIDATION_REDSHIFT"|"VIEW_VALIDATION_ATHENA"|"GOOGLEADS"|"GOOGLESHEETS"|"GOOGLEANALYTICS4"|"SERVICENOW"|"MARKETO"|"SAPODATA"|"ZENDESK"|"JIRACLOUD"|"NETSUITEERP"|"HUBSPOT"|"FACEBOOKADS"|"INSTAGRAMADS"|"ZOHOCRM"|"SALESFORCEPARDOT"|"SALESFORCEMARKETINGCLOUD"|"SLACK"|"STRIPE"|"INTERCOM"|"SNAPCHATADS", MatchCriteria?:array<string>, ConnectionProperties?:array<"HOST"|"PORT"|"USERNAME"|"PASSWORD"|"ENCRYPTED_PASSWORD"|"JDBC_DRIVER_JAR_URI"|"JDBC_DRIVER_CLASS_NAME"|"JDBC_ENGINE"|"JDBC_ENGINE_VERSION"|"CONFIG_FILES"|"INSTANCE_ID"|"JDBC_CONNECTION_URL"|"JDBC_ENFORCE_SSL"|"CUSTOM_JDBC_CERT"|"SKIP_CUSTOM_JDBC_CERT_VALIDATION"|"CUSTOM_JDBC_CERT_STRING"|"CONNECTION_URL"|"KAFKA_BOOTSTRAP_SERVERS"|"KAFKA_SSL_ENABLED"|"KAFKA_CUSTOM_CERT"|"KAFKA_SKIP_CUSTOM_CERT_VALIDATION"|"KAFKA_CLIENT_KEYSTORE"|"KAFKA_CLIENT_KEYSTORE_PASSWORD"|"KAFKA_CLIENT_KEY_PASSWORD"|"ENCRYPTED_KAFKA_CLIENT_KEYSTORE_PASSWORD"|"ENCRYPTED_KAFKA_CLIENT_KEY_PASSWORD"|"KAFKA_SASL_MECHANISM"|"KAFKA_SASL_PLAIN_USERNAME"|"KAFKA_SASL_PLAIN_PASSWORD"|"ENCRYPTED_KAFKA_SASL_PLAIN_PASSWORD"|"KAFKA_SASL_SCRAM_USERNAME"|"KAFKA_SASL_SCRAM_PASSWORD"|"KAFKA_SASL_SCRAM_SECRETS_ARN"|"ENCRYPTED_KAFKA_SASL_SCRAM_PASSWORD"|"KAFKA_SASL_GSSAPI_KEYTAB"|"KAFKA_SASL_GSSAPI_KRB5_CONF"|"KAFKA_SASL_GSSAPI_SERVICE"|"KAFKA_SASL_GSSAPI_PRINCIPAL"|"SECRET_ID"|"CONNECTOR_URL"|"CONNECTOR_TYPE"|"CONNECTOR_CLASS_NAME"|"ENDPOINT"|"ENDPOINT_TYPE"|"ROLE_ARN"|"REGION"|"WORKGROUP_NAME"|"CLUSTER_IDENTIFIER"|"DATABASE", string>, SparkProperties?:array<string, string>, AthenaProperties?:array<string, string>, PythonProperties?:array<string, string>, PhysicalConnectionRequirements?:array{SubnetId?:string, SecurityGroupIdList?:array<string>, AvailabilityZone?:string}, CreationTime?:int|string|\DateTimeInterface, LastUpdatedTime?:int|string|\DateTimeInterface, LastUpdatedBy?:string, Status?:"READY"|"IN_PROGRESS"|"FAILED", StatusReason?:string, LastConnectionValidationTime?:int|string|\DateTimeInterface, AuthenticationConfiguration?:array{AuthenticationType?:"BASIC"|"OAUTH2"|"CUSTOM"|"IAM", SecretArn?:string, OAuth2Properties?:array{OAuth2GrantType?:"AUTHORIZATION_CODE"|"CLIENT_CREDENTIALS"|"JWT_BEARER", OAuth2ClientApplication?:array{UserManagedClientApplicationClientId?:string, AWSManagedClientApplicationReference?:string}, TokenUrl?:string, TokenUrlParametersMap?:array<string, string>}}, ConnectionSchemaVersion?:int, CompatibleComputeEnvironments?:array<"SPARK"|"ATHENA"|"PYTHON">}>, NextToken?:string}>
     */
    public function getConnectionsAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Name:string} $args
     * @return \AWS\Result<array{Crawler?:array{Name?:string, Role?:string, Targets?:array{S3Targets?:array<array{Path?:string, Exclusions?:array<string>, ConnectionName?:string, SampleSize?:int, EventQueueArn?:string, DlqEventQueueArn?:string}>, JdbcTargets?:array<array{ConnectionName?:string, Path?:string, Exclusions?:array<string>, EnableAdditionalMetadata?:array<"COMMENTS"|"RAWTYPES">}>, MongoDBTargets?:array<array{ConnectionName?:string, Path?:string, ScanAll?:bool}>, DynamoDBTargets?:array<array{Path?:string, scanAll?:bool, scanRate?:float}>, CatalogTargets?:array<array{DatabaseName:string, Tables:array<string>, ConnectionName?:string, EventQueueArn?:string, DlqEventQueueArn?:string}>, DeltaTargets?:array<array{DeltaTables?:array<string>, ConnectionName?:string, WriteManifest?:bool, CreateNativeDeltaTable?:bool}>, IcebergTargets?:array<array{Paths?:array<string>, ConnectionName?:string, Exclusions?:array<string>, MaximumTraversalDepth?:int}>, HudiTargets?:array<array{Paths?:array<string>, ConnectionName?:string, Exclusions?:array<string>, MaximumTraversalDepth?:int}>}, DatabaseName?:string, Description?:string, Classifiers?:array<string>, RecrawlPolicy?:array{RecrawlBehavior?:"CRAWL_EVERYTHING"|"CRAWL_NEW_FOLDERS_ONLY"|"CRAWL_EVENT_MODE"}, SchemaChangePolicy?:array{UpdateBehavior?:"LOG"|"UPDATE_IN_DATABASE", DeleteBehavior?:"LOG"|"DELETE_FROM_DATABASE"|"DEPRECATE_IN_DATABASE"}, LineageConfiguration?:array{CrawlerLineageSettings?:"ENABLE"|"DISABLE"}, State?:"READY"|"RUNNING"|"STOPPING", TablePrefix?:string, Schedule?:array{ScheduleExpression?:string, State?:"SCHEDULED"|"NOT_SCHEDULED"|"TRANSITIONING"}, CrawlElapsedTime?:int, CreationTime?:int|string|\DateTimeInterface, LastUpdated?:int|string|\DateTimeInterface, LastCrawl?:array{Status?:"SUCCEEDED"|"CANCELLED"|"FAILED", ErrorMessage?:string, LogGroup?:string, LogStream?:string, MessagePrefix?:string, StartTime?:int|string|\DateTimeInterface}, Version?:int, Configuration?:string, CrawlerSecurityConfiguration?:string, LakeFormationConfiguration?:array{UseLakeFormationCredentials?:bool, AccountId?:string}}}>
     */
    public function getCrawler(array $args): \AWS\Result { }

    /**
     * @param array{Name:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Crawler?:array{Name?:string, Role?:string, Targets?:array{S3Targets?:array<array{Path?:string, Exclusions?:array<string>, ConnectionName?:string, SampleSize?:int, EventQueueArn?:string, DlqEventQueueArn?:string}>, JdbcTargets?:array<array{ConnectionName?:string, Path?:string, Exclusions?:array<string>, EnableAdditionalMetadata?:array<"COMMENTS"|"RAWTYPES">}>, MongoDBTargets?:array<array{ConnectionName?:string, Path?:string, ScanAll?:bool}>, DynamoDBTargets?:array<array{Path?:string, scanAll?:bool, scanRate?:float}>, CatalogTargets?:array<array{DatabaseName:string, Tables:array<string>, ConnectionName?:string, EventQueueArn?:string, DlqEventQueueArn?:string}>, DeltaTargets?:array<array{DeltaTables?:array<string>, ConnectionName?:string, WriteManifest?:bool, CreateNativeDeltaTable?:bool}>, IcebergTargets?:array<array{Paths?:array<string>, ConnectionName?:string, Exclusions?:array<string>, MaximumTraversalDepth?:int}>, HudiTargets?:array<array{Paths?:array<string>, ConnectionName?:string, Exclusions?:array<string>, MaximumTraversalDepth?:int}>}, DatabaseName?:string, Description?:string, Classifiers?:array<string>, RecrawlPolicy?:array{RecrawlBehavior?:"CRAWL_EVERYTHING"|"CRAWL_NEW_FOLDERS_ONLY"|"CRAWL_EVENT_MODE"}, SchemaChangePolicy?:array{UpdateBehavior?:"LOG"|"UPDATE_IN_DATABASE", DeleteBehavior?:"LOG"|"DELETE_FROM_DATABASE"|"DEPRECATE_IN_DATABASE"}, LineageConfiguration?:array{CrawlerLineageSettings?:"ENABLE"|"DISABLE"}, State?:"READY"|"RUNNING"|"STOPPING", TablePrefix?:string, Schedule?:array{ScheduleExpression?:string, State?:"SCHEDULED"|"NOT_SCHEDULED"|"TRANSITIONING"}, CrawlElapsedTime?:int, CreationTime?:int|string|\DateTimeInterface, LastUpdated?:int|string|\DateTimeInterface, LastCrawl?:array{Status?:"SUCCEEDED"|"CANCELLED"|"FAILED", ErrorMessage?:string, LogGroup?:string, LogStream?:string, MessagePrefix?:string, StartTime?:int|string|\DateTimeInterface}, Version?:int, Configuration?:string, CrawlerSecurityConfiguration?:string, LakeFormationConfiguration?:array{UseLakeFormationCredentials?:bool, AccountId?:string}}}>
     */
    public function getCrawlerAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CrawlerNameList?:array<string>, MaxResults?:int, NextToken?:string} $args
     * @return \AWS\Result<array{CrawlerMetricsList?:array<array{CrawlerName?:string, TimeLeftSeconds?:float, StillEstimating?:bool, LastRuntimeSeconds?:float, MedianRuntimeSeconds?:float, TablesCreated?:int, TablesUpdated?:int, TablesDeleted?:int}>, NextToken?:string}>
     */
    public function getCrawlerMetrics(array $args = []): \AWS\Result { }

    /**
     * @param array{CrawlerNameList?:array<string>, MaxResults?:int, NextToken?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{CrawlerMetricsList?:array<array{CrawlerName?:string, TimeLeftSeconds?:float, StillEstimating?:bool, LastRuntimeSeconds?:float, MedianRuntimeSeconds?:float, TablesCreated?:int, TablesUpdated?:int, TablesDeleted?:int}>, NextToken?:string}>
     */
    public function getCrawlerMetricsAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{MaxResults?:int, NextToken?:string} $args
     * @return \AWS\Result<array{Crawlers?:array<array{Name?:string, Role?:string, Targets?:array{S3Targets?:array<array{Path?:string, Exclusions?:array<string>, ConnectionName?:string, SampleSize?:int, EventQueueArn?:string, DlqEventQueueArn?:string}>, JdbcTargets?:array<array{ConnectionName?:string, Path?:string, Exclusions?:array<string>, EnableAdditionalMetadata?:array<"COMMENTS"|"RAWTYPES">}>, MongoDBTargets?:array<array{ConnectionName?:string, Path?:string, ScanAll?:bool}>, DynamoDBTargets?:array<array{Path?:string, scanAll?:bool, scanRate?:float}>, CatalogTargets?:array<array{DatabaseName:string, Tables:array<string>, ConnectionName?:string, EventQueueArn?:string, DlqEventQueueArn?:string}>, DeltaTargets?:array<array{DeltaTables?:array<string>, ConnectionName?:string, WriteManifest?:bool, CreateNativeDeltaTable?:bool}>, IcebergTargets?:array<array{Paths?:array<string>, ConnectionName?:string, Exclusions?:array<string>, MaximumTraversalDepth?:int}>, HudiTargets?:array<array{Paths?:array<string>, ConnectionName?:string, Exclusions?:array<string>, MaximumTraversalDepth?:int}>}, DatabaseName?:string, Description?:string, Classifiers?:array<string>, RecrawlPolicy?:array{RecrawlBehavior?:"CRAWL_EVERYTHING"|"CRAWL_NEW_FOLDERS_ONLY"|"CRAWL_EVENT_MODE"}, SchemaChangePolicy?:array{UpdateBehavior?:"LOG"|"UPDATE_IN_DATABASE", DeleteBehavior?:"LOG"|"DELETE_FROM_DATABASE"|"DEPRECATE_IN_DATABASE"}, LineageConfiguration?:array{CrawlerLineageSettings?:"ENABLE"|"DISABLE"}, State?:"READY"|"RUNNING"|"STOPPING", TablePrefix?:string, Schedule?:array{ScheduleExpression?:string, State?:"SCHEDULED"|"NOT_SCHEDULED"|"TRANSITIONING"}, CrawlElapsedTime?:int, CreationTime?:int|string|\DateTimeInterface, LastUpdated?:int|string|\DateTimeInterface, LastCrawl?:array{Status?:"SUCCEEDED"|"CANCELLED"|"FAILED", ErrorMessage?:string, LogGroup?:string, LogStream?:string, MessagePrefix?:string, StartTime?:int|string|\DateTimeInterface}, Version?:int, Configuration?:string, CrawlerSecurityConfiguration?:string, LakeFormationConfiguration?:array{UseLakeFormationCredentials?:bool, AccountId?:string}}>, NextToken?:string}>
     */
    public function getCrawlers(array $args = []): \AWS\Result { }

    /**
     * @param array{MaxResults?:int, NextToken?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Crawlers?:array<array{Name?:string, Role?:string, Targets?:array{S3Targets?:array<array{Path?:string, Exclusions?:array<string>, ConnectionName?:string, SampleSize?:int, EventQueueArn?:string, DlqEventQueueArn?:string}>, JdbcTargets?:array<array{ConnectionName?:string, Path?:string, Exclusions?:array<string>, EnableAdditionalMetadata?:array<"COMMENTS"|"RAWTYPES">}>, MongoDBTargets?:array<array{ConnectionName?:string, Path?:string, ScanAll?:bool}>, DynamoDBTargets?:array<array{Path?:string, scanAll?:bool, scanRate?:float}>, CatalogTargets?:array<array{DatabaseName:string, Tables:array<string>, ConnectionName?:string, EventQueueArn?:string, DlqEventQueueArn?:string}>, DeltaTargets?:array<array{DeltaTables?:array<string>, ConnectionName?:string, WriteManifest?:bool, CreateNativeDeltaTable?:bool}>, IcebergTargets?:array<array{Paths?:array<string>, ConnectionName?:string, Exclusions?:array<string>, MaximumTraversalDepth?:int}>, HudiTargets?:array<array{Paths?:array<string>, ConnectionName?:string, Exclusions?:array<string>, MaximumTraversalDepth?:int}>}, DatabaseName?:string, Description?:string, Classifiers?:array<string>, RecrawlPolicy?:array{RecrawlBehavior?:"CRAWL_EVERYTHING"|"CRAWL_NEW_FOLDERS_ONLY"|"CRAWL_EVENT_MODE"}, SchemaChangePolicy?:array{UpdateBehavior?:"LOG"|"UPDATE_IN_DATABASE", DeleteBehavior?:"LOG"|"DELETE_FROM_DATABASE"|"DEPRECATE_IN_DATABASE"}, LineageConfiguration?:array{CrawlerLineageSettings?:"ENABLE"|"DISABLE"}, State?:"READY"|"RUNNING"|"STOPPING", TablePrefix?:string, Schedule?:array{ScheduleExpression?:string, State?:"SCHEDULED"|"NOT_SCHEDULED"|"TRANSITIONING"}, CrawlElapsedTime?:int, CreationTime?:int|string|\DateTimeInterface, LastUpdated?:int|string|\DateTimeInterface, LastCrawl?:array{Status?:"SUCCEEDED"|"CANCELLED"|"FAILED", ErrorMessage?:string, LogGroup?:string, LogStream?:string, MessagePrefix?:string, StartTime?:int|string|\DateTimeInterface}, Version?:int, Configuration?:string, CrawlerSecurityConfiguration?:string, LakeFormationConfiguration?:array{UseLakeFormationCredentials?:bool, AccountId?:string}}>, NextToken?:string}>
     */
    public function getCrawlersAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Name:string} $args
     * @return \AWS\Result<array{Name?:string, RegexString?:string, ContextWords?:array<string>}>
     */
    public function getCustomEntityType(array $args): \AWS\Result { }

    /**
     * @param array{Name:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Name?:string, RegexString?:string, ContextWords?:array<string>}>
     */
    public function getCustomEntityTypeAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId?:string} $args
     * @return \AWS\Result<array{DataCatalogEncryptionSettings?:array{EncryptionAtRest?:array{CatalogEncryptionMode:"DISABLED"|"SSE-KMS"|"SSE-KMS-WITH-SERVICE-ROLE", SseAwsKmsKeyId?:string, CatalogEncryptionServiceRole?:string}, ConnectionPasswordEncryption?:array{ReturnConnectionPasswordEncrypted:bool, AwsKmsKeyId?:string}}}>
     */
    public function getDataCatalogEncryptionSettings(array $args = []): \AWS\Result { }

    /**
     * @param array{CatalogId?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{DataCatalogEncryptionSettings?:array{EncryptionAtRest?:array{CatalogEncryptionMode:"DISABLED"|"SSE-KMS"|"SSE-KMS-WITH-SERVICE-ROLE", SseAwsKmsKeyId?:string, CatalogEncryptionServiceRole?:string}, ConnectionPasswordEncryption?:array{ReturnConnectionPasswordEncrypted:bool, AwsKmsKeyId?:string}}}>
     */
    public function getDataCatalogEncryptionSettingsAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{StatisticId?:string, ProfileId:string} $args
     * @return \AWS\Result<array{Status?:"RUNNING"|"SUCCEEDED"|"FAILED", StartedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, FailureReason?:string}>
     */
    public function getDataQualityModel(array $args): \AWS\Result { }

    /**
     * @param array{StatisticId?:string, ProfileId:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Status?:"RUNNING"|"SUCCEEDED"|"FAILED", StartedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, FailureReason?:string}>
     */
    public function getDataQualityModelAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{StatisticId:string, ProfileId:string} $args
     * @return \AWS\Result<array{CompletedOn?:int|string|\DateTimeInterface, Model?:array<array{LowerBound?:float, UpperBound?:float, PredictedValue?:float, ActualValue?:float, Date?:int|string|\DateTimeInterface, InclusionAnnotation?:"INCLUDE"|"EXCLUDE"}>}>
     */
    public function getDataQualityModelResult(array $args): \AWS\Result { }

    /**
     * @param array{StatisticId:string, ProfileId:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{CompletedOn?:int|string|\DateTimeInterface, Model?:array<array{LowerBound?:float, UpperBound?:float, PredictedValue?:float, ActualValue?:float, Date?:int|string|\DateTimeInterface, InclusionAnnotation?:"INCLUDE"|"EXCLUDE"}>}>
     */
    public function getDataQualityModelResultAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ResultId:string} $args
     * @return \AWS\Result<array{ResultId?:string, ProfileId?:string, Score?:float, DataSource?:array{GlueTable:array{DatabaseName:string, TableName:string, CatalogId?:string, ConnectionName?:string, AdditionalOptions?:array<string, string>}}, RulesetName?:string, EvaluationContext?:string, StartedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, JobName?:string, JobRunId?:string, RulesetEvaluationRunId?:string, RuleResults?:array<array{Name?:string, Description?:string, EvaluationMessage?:string, Result?:"PASS"|"FAIL"|"ERROR", EvaluatedMetrics?:array<string, float>, EvaluatedRule?:string}>, AnalyzerResults?:array<array{Name?:string, Description?:string, EvaluationMessage?:string, EvaluatedMetrics?:array<string, float>}>, Observations?:array<array{Description?:string, MetricBasedObservation?:array{MetricName?:string, StatisticId?:string, MetricValues?:array{ActualValue?:float, ExpectedValue?:float, LowerLimit?:float, UpperLimit?:float}, NewRules?:array<string>}}>}>
     */
    public function getDataQualityResult(array $args): \AWS\Result { }

    /**
     * @param array{ResultId:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{ResultId?:string, ProfileId?:string, Score?:float, DataSource?:array{GlueTable:array{DatabaseName:string, TableName:string, CatalogId?:string, ConnectionName?:string, AdditionalOptions?:array<string, string>}}, RulesetName?:string, EvaluationContext?:string, StartedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, JobName?:string, JobRunId?:string, RulesetEvaluationRunId?:string, RuleResults?:array<array{Name?:string, Description?:string, EvaluationMessage?:string, Result?:"PASS"|"FAIL"|"ERROR", EvaluatedMetrics?:array<string, float>, EvaluatedRule?:string}>, AnalyzerResults?:array<array{Name?:string, Description?:string, EvaluationMessage?:string, EvaluatedMetrics?:array<string, float>}>, Observations?:array<array{Description?:string, MetricBasedObservation?:array{MetricName?:string, StatisticId?:string, MetricValues?:array{ActualValue?:float, ExpectedValue?:float, LowerLimit?:float, UpperLimit?:float}, NewRules?:array<string>}}>}>
     */
    public function getDataQualityResultAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{RunId:string} $args
     * @return \AWS\Result<array{RunId?:string, DataSource?:array{GlueTable:array{DatabaseName:string, TableName:string, CatalogId?:string, ConnectionName?:string, AdditionalOptions?:array<string, string>}}, Role?:string, NumberOfWorkers?:int, Timeout?:int, Status?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT", ErrorString?:string, StartedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, ExecutionTime?:int, RecommendedRuleset?:string, CreatedRulesetName?:string, DataQualitySecurityConfiguration?:string}>
     */
    public function getDataQualityRuleRecommendationRun(array $args): \AWS\Result { }

    /**
     * @param array{RunId:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{RunId?:string, DataSource?:array{GlueTable:array{DatabaseName:string, TableName:string, CatalogId?:string, ConnectionName?:string, AdditionalOptions?:array<string, string>}}, Role?:string, NumberOfWorkers?:int, Timeout?:int, Status?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT", ErrorString?:string, StartedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, ExecutionTime?:int, RecommendedRuleset?:string, CreatedRulesetName?:string, DataQualitySecurityConfiguration?:string}>
     */
    public function getDataQualityRuleRecommendationRunAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Name:string} $args
     * @return \AWS\Result<array{Name?:string, Description?:string, Ruleset?:string, TargetTable?:array{TableName:string, DatabaseName:string, CatalogId?:string}, CreatedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface, RecommendationRunId?:string, DataQualitySecurityConfiguration?:string}>
     */
    public function getDataQualityRuleset(array $args): \AWS\Result { }

    /**
     * @param array{Name:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Name?:string, Description?:string, Ruleset?:string, TargetTable?:array{TableName:string, DatabaseName:string, CatalogId?:string}, CreatedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface, RecommendationRunId?:string, DataQualitySecurityConfiguration?:string}>
     */
    public function getDataQualityRulesetAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{RunId:string} $args
     * @return \AWS\Result<array{RunId?:string, DataSource?:array{GlueTable:array{DatabaseName:string, TableName:string, CatalogId?:string, ConnectionName?:string, AdditionalOptions?:array<string, string>}}, Role?:string, NumberOfWorkers?:int, Timeout?:int, AdditionalRunOptions?:array{CloudWatchMetricsEnabled?:bool, ResultsS3Prefix?:string, CompositeRuleEvaluationMethod?:"COLUMN"|"ROW"}, Status?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT", ErrorString?:string, StartedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, ExecutionTime?:int, RulesetNames?:array<string>, ResultIds?:array<string>, AdditionalDataSources?:array<string, array{GlueTable:array{DatabaseName:string, TableName:string, CatalogId?:string, ConnectionName?:string, AdditionalOptions?:array<string, string>}}>}>
     */
    public function getDataQualityRulesetEvaluationRun(array $args): \AWS\Result { }

    /**
     * @param array{RunId:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{RunId?:string, DataSource?:array{GlueTable:array{DatabaseName:string, TableName:string, CatalogId?:string, ConnectionName?:string, AdditionalOptions?:array<string, string>}}, Role?:string, NumberOfWorkers?:int, Timeout?:int, AdditionalRunOptions?:array{CloudWatchMetricsEnabled?:bool, ResultsS3Prefix?:string, CompositeRuleEvaluationMethod?:"COLUMN"|"ROW"}, Status?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT", ErrorString?:string, StartedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, ExecutionTime?:int, RulesetNames?:array<string>, ResultIds?:array<string>, AdditionalDataSources?:array<string, array{GlueTable:array{DatabaseName:string, TableName:string, CatalogId?:string, ConnectionName?:string, AdditionalOptions?:array<string, string>}}>}>
     */
    public function getDataQualityRulesetEvaluationRunAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId?:string, Name:string} $args
     * @return \AWS\Result<array{Database?:array{Name:string, Description?:string, LocationUri?:string, Parameters?:array<string, string>, CreateTime?:int|string|\DateTimeInterface, CreateTableDefaultPermissions?:array<array{Principal?:array{DataLakePrincipalIdentifier?:string}, Permissions?:array<"ALL"|"SELECT"|"ALTER"|"DROP"|"DELETE"|"INSERT"|"CREATE_DATABASE"|"CREATE_TABLE"|"DATA_LOCATION_ACCESS">}>, TargetDatabase?:array{CatalogId?:string, DatabaseName?:string, Region?:string}, CatalogId?:string, FederatedDatabase?:array{Identifier?:string, ConnectionName?:string}}}>
     */
    public function getDatabase(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId?:string, Name:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Database?:array{Name:string, Description?:string, LocationUri?:string, Parameters?:array<string, string>, CreateTime?:int|string|\DateTimeInterface, CreateTableDefaultPermissions?:array<array{Principal?:array{DataLakePrincipalIdentifier?:string}, Permissions?:array<"ALL"|"SELECT"|"ALTER"|"DROP"|"DELETE"|"INSERT"|"CREATE_DATABASE"|"CREATE_TABLE"|"DATA_LOCATION_ACCESS">}>, TargetDatabase?:array{CatalogId?:string, DatabaseName?:string, Region?:string}, CatalogId?:string, FederatedDatabase?:array{Identifier?:string, ConnectionName?:string}}}>
     */
    public function getDatabaseAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId?:string, NextToken?:string, MaxResults?:int, ResourceShareType?:"FOREIGN"|"ALL"|"FEDERATED", AttributesToGet?:array<"NAME">} $args
     * @return \AWS\Result<array{DatabaseList:array<array{Name:string, Description?:string, LocationUri?:string, Parameters?:array<string, string>, CreateTime?:int|string|\DateTimeInterface, CreateTableDefaultPermissions?:array<array{Principal?:array{DataLakePrincipalIdentifier?:string}, Permissions?:array<"ALL"|"SELECT"|"ALTER"|"DROP"|"DELETE"|"INSERT"|"CREATE_DATABASE"|"CREATE_TABLE"|"DATA_LOCATION_ACCESS">}>, TargetDatabase?:array{CatalogId?:string, DatabaseName?:string, Region?:string}, CatalogId?:string, FederatedDatabase?:array{Identifier?:string, ConnectionName?:string}}>, NextToken?:string}>
     */
    public function getDatabases(array $args = []): \AWS\Result { }

    /**
     * @param array{CatalogId?:string, NextToken?:string, MaxResults?:int, ResourceShareType?:"FOREIGN"|"ALL"|"FEDERATED", AttributesToGet?:array<"NAME">} $args
     * @return \GuzzleHttp\Promise\Promise<array{DatabaseList:array<array{Name:string, Description?:string, LocationUri?:string, Parameters?:array<string, string>, CreateTime?:int|string|\DateTimeInterface, CreateTableDefaultPermissions?:array<array{Principal?:array{DataLakePrincipalIdentifier?:string}, Permissions?:array<"ALL"|"SELECT"|"ALTER"|"DROP"|"DELETE"|"INSERT"|"CREATE_DATABASE"|"CREATE_TABLE"|"DATA_LOCATION_ACCESS">}>, TargetDatabase?:array{CatalogId?:string, DatabaseName?:string, Region?:string}, CatalogId?:string, FederatedDatabase?:array{Identifier?:string, ConnectionName?:string}}>, NextToken?:string}>
     */
    public function getDatabasesAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{PythonScript?:string} $args
     * @return \AWS\Result<array{DagNodes?:array<array{Id:string, NodeType:string, Args:array<array{Name:string, Value:string, Param?:bool}>, LineNumber?:int}>, DagEdges?:array<array{Source:string, Target:string, TargetParameter?:string}>}>
     */
    public function getDataflowGraph(array $args = []): \AWS\Result { }

    /**
     * @param array{PythonScript?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{DagNodes?:array<array{Id:string, NodeType:string, Args:array<array{Name:string, Value:string, Param?:bool}>, LineNumber?:int}>, DagEdges?:array<array{Source:string, Target:string, TargetParameter?:string}>}>
     */
    public function getDataflowGraphAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{EndpointName:string} $args
     * @return \AWS\Result<array{DevEndpoint?:array{EndpointName?:string, RoleArn?:string, SecurityGroupIds?:array<string>, SubnetId?:string, YarnEndpointAddress?:string, PrivateAddress?:string, ZeppelinRemoteSparkInterpreterPort?:int, PublicAddress?:string, Status?:string, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", GlueVersion?:string, NumberOfWorkers?:int, NumberOfNodes?:int, AvailabilityZone?:string, VpcId?:string, ExtraPythonLibsS3Path?:string, ExtraJarsS3Path?:string, FailureReason?:string, LastUpdateStatus?:string, CreatedTimestamp?:int|string|\DateTimeInterface, LastModifiedTimestamp?:int|string|\DateTimeInterface, PublicKey?:string, PublicKeys?:array<string>, SecurityConfiguration?:string, Arguments?:array<string, string>}}>
     */
    public function getDevEndpoint(array $args): \AWS\Result { }

    /**
     * @param array{EndpointName:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{DevEndpoint?:array{EndpointName?:string, RoleArn?:string, SecurityGroupIds?:array<string>, SubnetId?:string, YarnEndpointAddress?:string, PrivateAddress?:string, ZeppelinRemoteSparkInterpreterPort?:int, PublicAddress?:string, Status?:string, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", GlueVersion?:string, NumberOfWorkers?:int, NumberOfNodes?:int, AvailabilityZone?:string, VpcId?:string, ExtraPythonLibsS3Path?:string, ExtraJarsS3Path?:string, FailureReason?:string, LastUpdateStatus?:string, CreatedTimestamp?:int|string|\DateTimeInterface, LastModifiedTimestamp?:int|string|\DateTimeInterface, PublicKey?:string, PublicKeys?:array<string>, SecurityConfiguration?:string, Arguments?:array<string, string>}}>
     */
    public function getDevEndpointAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{MaxResults?:int, NextToken?:string} $args
     * @return \AWS\Result<array{DevEndpoints?:array<array{EndpointName?:string, RoleArn?:string, SecurityGroupIds?:array<string>, SubnetId?:string, YarnEndpointAddress?:string, PrivateAddress?:string, ZeppelinRemoteSparkInterpreterPort?:int, PublicAddress?:string, Status?:string, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", GlueVersion?:string, NumberOfWorkers?:int, NumberOfNodes?:int, AvailabilityZone?:string, VpcId?:string, ExtraPythonLibsS3Path?:string, ExtraJarsS3Path?:string, FailureReason?:string, LastUpdateStatus?:string, CreatedTimestamp?:int|string|\DateTimeInterface, LastModifiedTimestamp?:int|string|\DateTimeInterface, PublicKey?:string, PublicKeys?:array<string>, SecurityConfiguration?:string, Arguments?:array<string, string>}>, NextToken?:string}>
     */
    public function getDevEndpoints(array $args = []): \AWS\Result { }

    /**
     * @param array{MaxResults?:int, NextToken?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{DevEndpoints?:array<array{EndpointName?:string, RoleArn?:string, SecurityGroupIds?:array<string>, SubnetId?:string, YarnEndpointAddress?:string, PrivateAddress?:string, ZeppelinRemoteSparkInterpreterPort?:int, PublicAddress?:string, Status?:string, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", GlueVersion?:string, NumberOfWorkers?:int, NumberOfNodes?:int, AvailabilityZone?:string, VpcId?:string, ExtraPythonLibsS3Path?:string, ExtraJarsS3Path?:string, FailureReason?:string, LastUpdateStatus?:string, CreatedTimestamp?:int|string|\DateTimeInterface, LastModifiedTimestamp?:int|string|\DateTimeInterface, PublicKey?:string, PublicKeys?:array<string>, SecurityConfiguration?:string, Arguments?:array<string, string>}>, NextToken?:string}>
     */
    public function getDevEndpointsAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ConnectionName?:string, CatalogId?:string, EntityName:string, NextToken?:string, DataStoreApiVersion?:string, ConnectionOptions?:array<string, string>, FilterPredicate?:string, Limit:int, OrderBy?:string, SelectedFields?:array<string>} $args
     * @return \AWS\Result<array{Records?:array<array{}>, NextToken?:string}>
     */
    public function getEntityRecords(array $args): \AWS\Result { }

    /**
     * @param array{ConnectionName?:string, CatalogId?:string, EntityName:string, NextToken?:string, DataStoreApiVersion?:string, ConnectionOptions?:array<string, string>, FilterPredicate?:string, Limit:int, OrderBy?:string, SelectedFields?:array<string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{Records?:array<array{}>, NextToken?:string}>
     */
    public function getEntityRecordsAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ResourceArn:string} $args
     * @return \AWS\Result<array{ResourceArn?:string, SourceProcessingProperties?:array{RoleArn?:string}, TargetProcessingProperties?:array{RoleArn?:string, KmsArn?:string, ConnectionName?:string, EventBusArn?:string}}>
     */
    public function getIntegrationResourceProperty(array $args): \AWS\Result { }

    /**
     * @param array{ResourceArn:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{ResourceArn?:string, SourceProcessingProperties?:array{RoleArn?:string}, TargetProcessingProperties?:array{RoleArn?:string, KmsArn?:string, ConnectionName?:string, EventBusArn?:string}}>
     */
    public function getIntegrationResourcePropertyAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ResourceArn:string, TableName:string} $args
     * @return \AWS\Result<array{ResourceArn?:string, TableName?:string, SourceTableConfig?:array{Fields?:array<string>, FilterPredicate?:string, PrimaryKey?:array<string>, RecordUpdateField?:string}, TargetTableConfig?:array{UnnestSpec?:"TOPLEVEL"|"FULL"|"NOUNNEST", PartitionSpec?:array<array{FieldName?:string, FunctionSpec?:string}>, TargetTableName?:string}}>
     */
    public function getIntegrationTableProperties(array $args): \AWS\Result { }

    /**
     * @param array{ResourceArn:string, TableName:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{ResourceArn?:string, TableName?:string, SourceTableConfig?:array{Fields?:array<string>, FilterPredicate?:string, PrimaryKey?:array<string>, RecordUpdateField?:string}, TargetTableConfig?:array{UnnestSpec?:"TOPLEVEL"|"FULL"|"NOUNNEST", PartitionSpec?:array<array{FieldName?:string, FunctionSpec?:string}>, TargetTableName?:string}}>
     */
    public function getIntegrationTablePropertiesAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{JobName:string} $args
     * @return \AWS\Result<array{Job?:array{Name?:string, JobMode?:"SCRIPT"|"VISUAL"|"NOTEBOOK", JobRunQueuingEnabled?:bool, Description?:string, LogUri?:string, Role?:string, CreatedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface, ExecutionProperty?:array{MaxConcurrentRuns?:int}, Command?:array{Name?:string, ScriptLocation?:string, PythonVersion?:string, Runtime?:string}, DefaultArguments?:array<string, string>, NonOverridableArguments?:array<string, string>, Connections?:array{Connections?:mixed}, MaxRetries?:int, AllocatedCapacity?:int, Timeout?:int, MaxCapacity?:float, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", NumberOfWorkers?:int, SecurityConfiguration?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, GlueVersion?:string, CodeGenConfigurationNodes?:array<string, array{AthenaConnectorSource?:array{Name:string, ConnectionName:string, ConnectorName:string, ConnectionType:string, ConnectionTable?:string, SchemaName:string, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, JDBCConnectorSource?:array{Name:string, ConnectionName:string, ConnectorName:string, ConnectionType:string, AdditionalOptions?:array{FilterPredicate?:string, PartitionColumn?:string, LowerBound?:int, UpperBound?:int, NumPartitions?:int, JobBookmarkKeys?:array<string>, JobBookmarkKeysSortOrder?:string, DataTypeMapping?:array<"ARRAY"|"BIGINT"|"BINARY"|"BIT"|"BLOB"|"BOOLEAN"|"CHAR"|"CLOB"|"DATALINK"|"DATE"|"DECIMAL"|"DISTINCT"|"DOUBLE"|"FLOAT"|"INTEGER"|"JAVA_OBJECT"|"LONGNVARCHAR"|"LONGVARBINARY"|"LONGVARCHAR"|"NCHAR"|"NCLOB"|"NULL"|"NUMERIC"|"NVARCHAR"|"OTHER"|"REAL"|"REF"|"REF_CURSOR"|"ROWID"|"SMALLINT"|"SQLXML"|"STRUCT"|"TIME"|"TIME_WITH_TIMEZONE"|"TIMESTAMP"|"TIMESTAMP_WITH_TIMEZONE"|"TINYINT"|"VARBINARY"|"VARCHAR", "DATE"|"STRING"|"TIMESTAMP"|"INT"|"FLOAT"|"LONG"|"BIGDECIMAL"|"BYTE"|"SHORT"|"DOUBLE">}, ConnectionTable?:string, Query?:string, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, SparkConnectorSource?:array{Name:string, ConnectionName:string, ConnectorName:string, ConnectionType:string, AdditionalOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, CatalogSource?:array{Name:string, Database:string, Table:string}, RedshiftSource?:array{Name:string, Database:string, Table:string, RedshiftTmpDir?:string, TmpDirIAMRole?:string}, S3CatalogSource?:array{Name:string, Database:string, Table:string, PartitionPredicate?:string, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int}}, S3CsvSource?:array{Name:string, Paths:array<string>, CompressionType?:"gzip"|"bzip2", Exclusions?:array<string>, GroupSize?:string, GroupFiles?:string, Recurse?:bool, MaxBand?:int, MaxFilesInBand?:int, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, Separator:"comma"|"ctrla"|"pipe"|"semicolon"|"tab", Escaper?:string, QuoteChar:"quote"|"quillemet"|"single_quote"|"disabled", Multiline?:bool, WithHeader?:bool, WriteHeader?:bool, SkipFirst?:bool, OptimizePerformance?:bool, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3JsonSource?:array{Name:string, Paths:array<string>, CompressionType?:"gzip"|"bzip2", Exclusions?:array<string>, GroupSize?:string, GroupFiles?:string, Recurse?:bool, MaxBand?:int, MaxFilesInBand?:int, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, JsonPath?:string, Multiline?:bool, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3ParquetSource?:array{Name:string, Paths:array<string>, CompressionType?:"snappy"|"lzo"|"gzip"|"uncompressed"|"none", Exclusions?:array<string>, GroupSize?:string, GroupFiles?:string, Recurse?:bool, MaxBand?:int, MaxFilesInBand?:int, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, RelationalCatalogSource?:array{Name:string, Database:string, Table:string}, DynamoDBCatalogSource?:array{Name:string, Database:string, Table:string}, JDBCConnectorTarget?:array{Name:string, Inputs:array<string>, ConnectionName:string, ConnectionTable:string, ConnectorName:string, ConnectionType:string, AdditionalOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, SparkConnectorTarget?:array{Name:string, Inputs:array<string>, ConnectionName:string, ConnectorName:string, ConnectionType:string, AdditionalOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, CatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Database:string, Table:string}, RedshiftTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string, RedshiftTmpDir?:string, TmpDirIAMRole?:string, UpsertRedshiftOptions?:array{TableLocation?:string, ConnectionName?:string, UpsertKeys?:array<string>}}, S3CatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Table:string, Database:string, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG"}}, S3GlueParquetTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Path:string, Compression?:"snappy"|"lzo"|"gzip"|"uncompressed"|"none", SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG", Table?:string, Database?:string}}, S3DirectTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Path:string, Compression?:string, Format:"json"|"csv"|"avro"|"orc"|"parquet"|"hudi"|"delta", SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG", Table?:string, Database?:string}}, ApplyMapping?:array{Name:string, Inputs:array<string>, Mapping:array<array{ToKey?:string, FromPath?:array<string>, FromType?:string, ToType?:string, Dropped?:bool, Children?:array<array{ToKey?:string, FromPath?:array<string>, FromType?:string, ToType?:string, Dropped?:bool, Children?:mixed}>}>}, SelectFields?:array{Name:string, Inputs:array<string>, Paths:array<array<string>>}, DropFields?:array{Name:string, Inputs:array<string>, Paths:array<array<string>>}, RenameField?:array{Name:string, Inputs:array<string>, SourcePath:array<string>, TargetPath:array<string>}, Spigot?:array{Name:string, Inputs:array<string>, Path:string, Topk?:int, Prob?:float}, Join?:array{Name:string, Inputs:array<string>, JoinType:"equijoin"|"left"|"right"|"outer"|"leftsemi"|"leftanti", Columns:array<array{From:string, Keys:array<array<string>>}>}, SplitFields?:array{Name:string, Inputs:array<string>, Paths:array<array<string>>}, SelectFromCollection?:array{Name:string, Inputs:array<string>, Index:int}, FillMissingValues?:array{Name:string, Inputs:array<string>, ImputedPath:string, FilledPath?:string}, Filter?:array{Name:string, Inputs:array<string>, LogicalOperator:"AND"|"OR", Filters:array<array{Operation:"EQ"|"LT"|"GT"|"LTE"|"GTE"|"REGEX"|"ISNULL", Negated?:bool, Values:array<array{Type:"COLUMNEXTRACTED"|"CONSTANT", Value:array<string>}>}>}, CustomCode?:array{Name:string, Inputs:array<string>, Code:string, ClassName:string, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, SparkSQL?:array{Name:string, Inputs:array<string>, SqlQuery:string, SqlAliases:array<array{From:string, Alias:string}>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, DirectKinesisSource?:array{Name:string, WindowSize?:int, DetectSchema?:bool, StreamingOptions?:array{EndpointUrl?:string, StreamName?:string, Classification?:string, Delimiter?:string, StartingPosition?:"latest"|"trim_horizon"|"earliest"|"timestamp", MaxFetchTimeInMs?:int, MaxFetchRecordsPerShard?:int, MaxRecordPerRead?:int, AddIdleTimeBetweenReads?:bool, IdleTimeBetweenReadsInMs?:int, DescribeShardInterval?:int, NumRetries?:int, RetryIntervalMs?:int, MaxRetryIntervalMs?:int, AvoidEmptyBatches?:bool, StreamArn?:string, RoleArn?:string, RoleSessionName?:string, AddRecordTimestamp?:string, EmitConsumerLagMetrics?:string, StartingTimestamp?:int|string|\DateTimeInterface}, DataPreviewOptions?:array{PollingTime?:int, RecordPollingLimit?:int}}, DirectKafkaSource?:array{Name:string, StreamingOptions?:array{BootstrapServers?:string, SecurityProtocol?:string, ConnectionName?:string, TopicName?:string, Assign?:string, SubscribePattern?:string, Classification?:string, Delimiter?:string, StartingOffsets?:string, EndingOffsets?:string, PollTimeoutMs?:int, NumRetries?:int, RetryIntervalMs?:int, MaxOffsetsPerTrigger?:int, MinPartitions?:int, IncludeHeaders?:bool, AddRecordTimestamp?:string, EmitConsumerLagMetrics?:string, StartingTimestamp?:int|string|\DateTimeInterface}, WindowSize?:int, DetectSchema?:bool, DataPreviewOptions?:array{PollingTime?:int, RecordPollingLimit?:int}}, CatalogKinesisSource?:array{Name:string, WindowSize?:int, DetectSchema?:bool, Table:string, Database:string, StreamingOptions?:array{EndpointUrl?:string, StreamName?:string, Classification?:string, Delimiter?:string, StartingPosition?:"latest"|"trim_horizon"|"earliest"|"timestamp", MaxFetchTimeInMs?:int, MaxFetchRecordsPerShard?:int, MaxRecordPerRead?:int, AddIdleTimeBetweenReads?:bool, IdleTimeBetweenReadsInMs?:int, DescribeShardInterval?:int, NumRetries?:int, RetryIntervalMs?:int, MaxRetryIntervalMs?:int, AvoidEmptyBatches?:bool, StreamArn?:string, RoleArn?:string, RoleSessionName?:string, AddRecordTimestamp?:string, EmitConsumerLagMetrics?:string, StartingTimestamp?:int|string|\DateTimeInterface}, DataPreviewOptions?:array{PollingTime?:int, RecordPollingLimit?:int}}, CatalogKafkaSource?:array{Name:string, WindowSize?:int, DetectSchema?:bool, Table:string, Database:string, StreamingOptions?:array{BootstrapServers?:string, SecurityProtocol?:string, ConnectionName?:string, TopicName?:string, Assign?:string, SubscribePattern?:string, Classification?:string, Delimiter?:string, StartingOffsets?:string, EndingOffsets?:string, PollTimeoutMs?:int, NumRetries?:int, RetryIntervalMs?:int, MaxOffsetsPerTrigger?:int, MinPartitions?:int, IncludeHeaders?:bool, AddRecordTimestamp?:string, EmitConsumerLagMetrics?:string, StartingTimestamp?:int|string|\DateTimeInterface}, DataPreviewOptions?:array{PollingTime?:int, RecordPollingLimit?:int}}, DropNullFields?:array{Name:string, Inputs:array<string>, NullCheckBoxList?:array{IsEmpty?:bool, IsNullString?:bool, IsNegOne?:bool}, NullTextList?:array<array{Value:string, Datatype:array{Id:string, Label:string}}>}, Merge?:array{Name:string, Inputs:array<string>, Source:string, PrimaryKeys:array<array<string>>}, Union?:array{Name:string, Inputs:array<string>, UnionType:"ALL"|"DISTINCT"}, PIIDetection?:array{Name:string, Inputs:array<string>, PiiType:"RowAudit"|"RowMasking"|"ColumnAudit"|"ColumnMasking", EntityTypesToDetect:array<string>, OutputColumnName?:string, SampleFraction?:float, ThresholdFraction?:float, MaskValue?:string}, Aggregate?:array{Name:string, Inputs:array<string>, Groups:array<array<string>>, Aggs:array<array{Column:array<string>, AggFunc:"avg"|"countDistinct"|"count"|"first"|"last"|"kurtosis"|"max"|"min"|"skewness"|"stddev_samp"|"stddev_pop"|"sum"|"sumDistinct"|"var_samp"|"var_pop"}>}, DropDuplicates?:array{Name:string, Inputs:array<string>, Columns?:array<array<string>>}, GovernedCatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Table:string, Database:string, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG"}}, GovernedCatalogSource?:array{Name:string, Database:string, Table:string, PartitionPredicate?:string, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int}}, MicrosoftSQLServerCatalogSource?:array{Name:string, Database:string, Table:string}, MySQLCatalogSource?:array{Name:string, Database:string, Table:string}, OracleSQLCatalogSource?:array{Name:string, Database:string, Table:string}, PostgreSQLCatalogSource?:array{Name:string, Database:string, Table:string}, MicrosoftSQLServerCatalogTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string}, MySQLCatalogTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string}, OracleSQLCatalogTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string}, PostgreSQLCatalogTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string}, DynamicTransform?:array{Name:string, TransformName:string, Inputs:array<string>, Parameters?:array<array{Name:string, Type:"str"|"int"|"float"|"complex"|"bool"|"list"|"null", ValidationRule?:string, ValidationMessage?:string, Value?:array<string>, ListType?:"str"|"int"|"float"|"complex"|"bool"|"list"|"null", IsOptional?:bool}>, FunctionName:string, Path:string, Version?:string, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, EvaluateDataQuality?:array{Name:string, Inputs:array<string>, Ruleset:string, Output?:"PrimaryInput"|"EvaluationResults", PublishingOptions?:array{EvaluationContext?:string, ResultsS3Prefix?:string, CloudWatchMetricsEnabled?:bool, ResultsPublishingEnabled?:bool}, StopJobOnFailureOptions?:array{StopJobOnFailureTiming?:"Immediate"|"AfterDataLoad"}}, S3CatalogHudiSource?:array{Name:string, Database:string, Table:string, AdditionalHudiOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, CatalogHudiSource?:array{Name:string, Database:string, Table:string, AdditionalHudiOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3HudiSource?:array{Name:string, Paths:array<string>, AdditionalHudiOptions?:array<string, string>, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3HudiCatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Table:string, Database:string, AdditionalOptions:array<string, string>, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG"}}, S3HudiDirectTarget?:array{Name:string, Inputs:array<string>, Path:string, Compression:"gzip"|"lzo"|"uncompressed"|"snappy", PartitionKeys?:array<array<string>>, Format:"json"|"csv"|"avro"|"orc"|"parquet"|"hudi"|"delta", AdditionalOptions:array<string, string>, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG", Table?:string, Database?:string}}, DirectJDBCSource?:array{Name:string, Database:string, Table:string, ConnectionName:string, ConnectionType:"sqlserver"|"mysql"|"oracle"|"postgresql"|"redshift", RedshiftTmpDir?:string}, S3CatalogDeltaSource?:array{Name:string, Database:string, Table:string, AdditionalDeltaOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, CatalogDeltaSource?:array{Name:string, Database:string, Table:string, AdditionalDeltaOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3DeltaSource?:array{Name:string, Paths:array<string>, AdditionalDeltaOptions?:array<string, string>, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3DeltaCatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Table:string, Database:string, AdditionalOptions?:array<string, string>, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG"}}, S3DeltaDirectTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Path:string, Compression:"uncompressed"|"snappy", Format:"json"|"csv"|"avro"|"orc"|"parquet"|"hudi"|"delta", AdditionalOptions?:array<string, string>, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG", Table?:string, Database?:string}}, AmazonRedshiftSource?:array{Name?:string, Data?:array{AccessType?:string, SourceType?:string, Connection?:array{Value?:string, Label?:string, Description?:string}, Schema?:array{Value?:string, Label?:string, Description?:string}, Table?:array{Value?:string, Label?:string, Description?:string}, CatalogDatabase?:array{Value?:string, Label?:string, Description?:string}, CatalogTable?:array{Value?:string, Label?:string, Description?:string}, CatalogRedshiftSchema?:string, CatalogRedshiftTable?:string, TempDir?:string, IamRole?:array{Value?:string, Label?:string, Description?:string}, AdvancedOptions?:array<array{Key?:string, Value?:string}>, SampleQuery?:string, PreAction?:string, PostAction?:string, Action?:string, TablePrefix?:string, Upsert?:bool, MergeAction?:string, MergeWhenMatched?:string, MergeWhenNotMatched?:string, MergeClause?:string, CrawlerConnection?:string, TableSchema?:array<array{Value?:string, Label?:string, Description?:string}>, StagingTable?:string, SelectedColumns?:array<array{Value?:string, Label?:string, Description?:string}>}}, AmazonRedshiftTarget?:array{Name?:string, Data?:array{AccessType?:string, SourceType?:string, Connection?:array{Value?:string, Label?:string, Description?:string}, Schema?:array{Value?:string, Label?:string, Description?:string}, Table?:array{Value?:string, Label?:string, Description?:string}, CatalogDatabase?:array{Value?:string, Label?:string, Description?:string}, CatalogTable?:array{Value?:string, Label?:string, Description?:string}, CatalogRedshiftSchema?:string, CatalogRedshiftTable?:string, TempDir?:string, IamRole?:array{Value?:string, Label?:string, Description?:string}, AdvancedOptions?:array<array{Key?:string, Value?:string}>, SampleQuery?:string, PreAction?:string, PostAction?:string, Action?:string, TablePrefix?:string, Upsert?:bool, MergeAction?:string, MergeWhenMatched?:string, MergeWhenNotMatched?:string, MergeClause?:string, CrawlerConnection?:string, TableSchema?:array<array{Value?:string, Label?:string, Description?:string}>, StagingTable?:string, SelectedColumns?:array<array{Value?:string, Label?:string, Description?:string}>}, Inputs?:array<string>}, EvaluateDataQualityMultiFrame?:array{Name:string, Inputs:array<string>, AdditionalDataSources?:array<string, string>, Ruleset:string, PublishingOptions?:array{EvaluationContext?:string, ResultsS3Prefix?:string, CloudWatchMetricsEnabled?:bool, ResultsPublishingEnabled?:bool}, AdditionalOptions?:array<"performanceTuning.caching"|"observations.scope", string>, StopJobOnFailureOptions?:array{StopJobOnFailureTiming?:"Immediate"|"AfterDataLoad"}}, Recipe?:array{Name:string, Inputs:array<string>, RecipeReference?:array{RecipeArn:string, RecipeVersion:string}, RecipeSteps?:array<array{Action:array{Operation:string, Parameters?:array<string, string>}, ConditionExpressions?:array<array{Condition:string, Value?:string, TargetColumn:string}>}>}, SnowflakeSource?:array{Name:string, Data:array{SourceType?:string, Connection?:array{Value?:string, Label?:string, Description?:string}, Schema?:string, Table?:string, Database?:string, TempDir?:string, IamRole?:array{Value?:string, Label?:string, Description?:string}, AdditionalOptions?:array<string, string>, SampleQuery?:string, PreAction?:string, PostAction?:string, Action?:string, Upsert?:bool, MergeAction?:string, MergeWhenMatched?:string, MergeWhenNotMatched?:string, MergeClause?:string, StagingTable?:string, SelectedColumns?:array<array{Value?:string, Label?:string, Description?:string}>, AutoPushdown?:bool, TableSchema?:array<array{Value?:string, Label?:string, Description?:string}>}, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, SnowflakeTarget?:array{Name:string, Data:array{SourceType?:string, Connection?:array{Value?:string, Label?:string, Description?:string}, Schema?:string, Table?:string, Database?:string, TempDir?:string, IamRole?:array{Value?:string, Label?:string, Description?:string}, AdditionalOptions?:array<string, string>, SampleQuery?:string, PreAction?:string, PostAction?:string, Action?:string, Upsert?:bool, MergeAction?:string, MergeWhenMatched?:string, MergeWhenNotMatched?:string, MergeClause?:string, StagingTable?:string, SelectedColumns?:array<array{Value?:string, Label?:string, Description?:string}>, AutoPushdown?:bool, TableSchema?:array<array{Value?:string, Label?:string, Description?:string}>}, Inputs?:array<string>}, ConnectorDataSource?:array{Name:string, ConnectionType:string, Data:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, ConnectorDataTarget?:array{Name:string, ConnectionType:string, Data:array<string, string>, Inputs?:array<string>}}>, ExecutionClass?:"FLEX"|"STANDARD", SourceControlDetails?:array{Provider?:"GITHUB"|"GITLAB"|"BITBUCKET"|"AWS_CODE_COMMIT", Repository?:string, Owner?:string, Branch?:string, Folder?:string, LastCommitId?:string, AuthStrategy?:"PERSONAL_ACCESS_TOKEN"|"AWS_SECRETS_MANAGER", AuthToken?:string}, MaintenanceWindow?:string, ProfileName?:string}}>
     */
    public function getJob(array $args): \AWS\Result { }

    /**
     * @param array{JobName:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Job?:array{Name?:string, JobMode?:"SCRIPT"|"VISUAL"|"NOTEBOOK", JobRunQueuingEnabled?:bool, Description?:string, LogUri?:string, Role?:string, CreatedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface, ExecutionProperty?:array{MaxConcurrentRuns?:int}, Command?:array{Name?:string, ScriptLocation?:string, PythonVersion?:string, Runtime?:string}, DefaultArguments?:array<string, string>, NonOverridableArguments?:array<string, string>, Connections?:array{Connections?:mixed}, MaxRetries?:int, AllocatedCapacity?:int, Timeout?:int, MaxCapacity?:float, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", NumberOfWorkers?:int, SecurityConfiguration?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, GlueVersion?:string, CodeGenConfigurationNodes?:array<string, array{AthenaConnectorSource?:array{Name:string, ConnectionName:string, ConnectorName:string, ConnectionType:string, ConnectionTable?:string, SchemaName:string, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, JDBCConnectorSource?:array{Name:string, ConnectionName:string, ConnectorName:string, ConnectionType:string, AdditionalOptions?:array{FilterPredicate?:string, PartitionColumn?:string, LowerBound?:int, UpperBound?:int, NumPartitions?:int, JobBookmarkKeys?:array<string>, JobBookmarkKeysSortOrder?:string, DataTypeMapping?:array<"ARRAY"|"BIGINT"|"BINARY"|"BIT"|"BLOB"|"BOOLEAN"|"CHAR"|"CLOB"|"DATALINK"|"DATE"|"DECIMAL"|"DISTINCT"|"DOUBLE"|"FLOAT"|"INTEGER"|"JAVA_OBJECT"|"LONGNVARCHAR"|"LONGVARBINARY"|"LONGVARCHAR"|"NCHAR"|"NCLOB"|"NULL"|"NUMERIC"|"NVARCHAR"|"OTHER"|"REAL"|"REF"|"REF_CURSOR"|"ROWID"|"SMALLINT"|"SQLXML"|"STRUCT"|"TIME"|"TIME_WITH_TIMEZONE"|"TIMESTAMP"|"TIMESTAMP_WITH_TIMEZONE"|"TINYINT"|"VARBINARY"|"VARCHAR", "DATE"|"STRING"|"TIMESTAMP"|"INT"|"FLOAT"|"LONG"|"BIGDECIMAL"|"BYTE"|"SHORT"|"DOUBLE">}, ConnectionTable?:string, Query?:string, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, SparkConnectorSource?:array{Name:string, ConnectionName:string, ConnectorName:string, ConnectionType:string, AdditionalOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, CatalogSource?:array{Name:string, Database:string, Table:string}, RedshiftSource?:array{Name:string, Database:string, Table:string, RedshiftTmpDir?:string, TmpDirIAMRole?:string}, S3CatalogSource?:array{Name:string, Database:string, Table:string, PartitionPredicate?:string, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int}}, S3CsvSource?:array{Name:string, Paths:array<string>, CompressionType?:"gzip"|"bzip2", Exclusions?:array<string>, GroupSize?:string, GroupFiles?:string, Recurse?:bool, MaxBand?:int, MaxFilesInBand?:int, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, Separator:"comma"|"ctrla"|"pipe"|"semicolon"|"tab", Escaper?:string, QuoteChar:"quote"|"quillemet"|"single_quote"|"disabled", Multiline?:bool, WithHeader?:bool, WriteHeader?:bool, SkipFirst?:bool, OptimizePerformance?:bool, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3JsonSource?:array{Name:string, Paths:array<string>, CompressionType?:"gzip"|"bzip2", Exclusions?:array<string>, GroupSize?:string, GroupFiles?:string, Recurse?:bool, MaxBand?:int, MaxFilesInBand?:int, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, JsonPath?:string, Multiline?:bool, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3ParquetSource?:array{Name:string, Paths:array<string>, CompressionType?:"snappy"|"lzo"|"gzip"|"uncompressed"|"none", Exclusions?:array<string>, GroupSize?:string, GroupFiles?:string, Recurse?:bool, MaxBand?:int, MaxFilesInBand?:int, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, RelationalCatalogSource?:array{Name:string, Database:string, Table:string}, DynamoDBCatalogSource?:array{Name:string, Database:string, Table:string}, JDBCConnectorTarget?:array{Name:string, Inputs:array<string>, ConnectionName:string, ConnectionTable:string, ConnectorName:string, ConnectionType:string, AdditionalOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, SparkConnectorTarget?:array{Name:string, Inputs:array<string>, ConnectionName:string, ConnectorName:string, ConnectionType:string, AdditionalOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, CatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Database:string, Table:string}, RedshiftTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string, RedshiftTmpDir?:string, TmpDirIAMRole?:string, UpsertRedshiftOptions?:array{TableLocation?:string, ConnectionName?:string, UpsertKeys?:array<string>}}, S3CatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Table:string, Database:string, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG"}}, S3GlueParquetTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Path:string, Compression?:"snappy"|"lzo"|"gzip"|"uncompressed"|"none", SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG", Table?:string, Database?:string}}, S3DirectTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Path:string, Compression?:string, Format:"json"|"csv"|"avro"|"orc"|"parquet"|"hudi"|"delta", SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG", Table?:string, Database?:string}}, ApplyMapping?:array{Name:string, Inputs:array<string>, Mapping:array<array{ToKey?:string, FromPath?:array<string>, FromType?:string, ToType?:string, Dropped?:bool, Children?:array<array{ToKey?:string, FromPath?:array<string>, FromType?:string, ToType?:string, Dropped?:bool, Children?:mixed}>}>}, SelectFields?:array{Name:string, Inputs:array<string>, Paths:array<array<string>>}, DropFields?:array{Name:string, Inputs:array<string>, Paths:array<array<string>>}, RenameField?:array{Name:string, Inputs:array<string>, SourcePath:array<string>, TargetPath:array<string>}, Spigot?:array{Name:string, Inputs:array<string>, Path:string, Topk?:int, Prob?:float}, Join?:array{Name:string, Inputs:array<string>, JoinType:"equijoin"|"left"|"right"|"outer"|"leftsemi"|"leftanti", Columns:array<array{From:string, Keys:array<array<string>>}>}, SplitFields?:array{Name:string, Inputs:array<string>, Paths:array<array<string>>}, SelectFromCollection?:array{Name:string, Inputs:array<string>, Index:int}, FillMissingValues?:array{Name:string, Inputs:array<string>, ImputedPath:string, FilledPath?:string}, Filter?:array{Name:string, Inputs:array<string>, LogicalOperator:"AND"|"OR", Filters:array<array{Operation:"EQ"|"LT"|"GT"|"LTE"|"GTE"|"REGEX"|"ISNULL", Negated?:bool, Values:array<array{Type:"COLUMNEXTRACTED"|"CONSTANT", Value:array<string>}>}>}, CustomCode?:array{Name:string, Inputs:array<string>, Code:string, ClassName:string, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, SparkSQL?:array{Name:string, Inputs:array<string>, SqlQuery:string, SqlAliases:array<array{From:string, Alias:string}>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, DirectKinesisSource?:array{Name:string, WindowSize?:int, DetectSchema?:bool, StreamingOptions?:array{EndpointUrl?:string, StreamName?:string, Classification?:string, Delimiter?:string, StartingPosition?:"latest"|"trim_horizon"|"earliest"|"timestamp", MaxFetchTimeInMs?:int, MaxFetchRecordsPerShard?:int, MaxRecordPerRead?:int, AddIdleTimeBetweenReads?:bool, IdleTimeBetweenReadsInMs?:int, DescribeShardInterval?:int, NumRetries?:int, RetryIntervalMs?:int, MaxRetryIntervalMs?:int, AvoidEmptyBatches?:bool, StreamArn?:string, RoleArn?:string, RoleSessionName?:string, AddRecordTimestamp?:string, EmitConsumerLagMetrics?:string, StartingTimestamp?:int|string|\DateTimeInterface}, DataPreviewOptions?:array{PollingTime?:int, RecordPollingLimit?:int}}, DirectKafkaSource?:array{Name:string, StreamingOptions?:array{BootstrapServers?:string, SecurityProtocol?:string, ConnectionName?:string, TopicName?:string, Assign?:string, SubscribePattern?:string, Classification?:string, Delimiter?:string, StartingOffsets?:string, EndingOffsets?:string, PollTimeoutMs?:int, NumRetries?:int, RetryIntervalMs?:int, MaxOffsetsPerTrigger?:int, MinPartitions?:int, IncludeHeaders?:bool, AddRecordTimestamp?:string, EmitConsumerLagMetrics?:string, StartingTimestamp?:int|string|\DateTimeInterface}, WindowSize?:int, DetectSchema?:bool, DataPreviewOptions?:array{PollingTime?:int, RecordPollingLimit?:int}}, CatalogKinesisSource?:array{Name:string, WindowSize?:int, DetectSchema?:bool, Table:string, Database:string, StreamingOptions?:array{EndpointUrl?:string, StreamName?:string, Classification?:string, Delimiter?:string, StartingPosition?:"latest"|"trim_horizon"|"earliest"|"timestamp", MaxFetchTimeInMs?:int, MaxFetchRecordsPerShard?:int, MaxRecordPerRead?:int, AddIdleTimeBetweenReads?:bool, IdleTimeBetweenReadsInMs?:int, DescribeShardInterval?:int, NumRetries?:int, RetryIntervalMs?:int, MaxRetryIntervalMs?:int, AvoidEmptyBatches?:bool, StreamArn?:string, RoleArn?:string, RoleSessionName?:string, AddRecordTimestamp?:string, EmitConsumerLagMetrics?:string, StartingTimestamp?:int|string|\DateTimeInterface}, DataPreviewOptions?:array{PollingTime?:int, RecordPollingLimit?:int}}, CatalogKafkaSource?:array{Name:string, WindowSize?:int, DetectSchema?:bool, Table:string, Database:string, StreamingOptions?:array{BootstrapServers?:string, SecurityProtocol?:string, ConnectionName?:string, TopicName?:string, Assign?:string, SubscribePattern?:string, Classification?:string, Delimiter?:string, StartingOffsets?:string, EndingOffsets?:string, PollTimeoutMs?:int, NumRetries?:int, RetryIntervalMs?:int, MaxOffsetsPerTrigger?:int, MinPartitions?:int, IncludeHeaders?:bool, AddRecordTimestamp?:string, EmitConsumerLagMetrics?:string, StartingTimestamp?:int|string|\DateTimeInterface}, DataPreviewOptions?:array{PollingTime?:int, RecordPollingLimit?:int}}, DropNullFields?:array{Name:string, Inputs:array<string>, NullCheckBoxList?:array{IsEmpty?:bool, IsNullString?:bool, IsNegOne?:bool}, NullTextList?:array<array{Value:string, Datatype:array{Id:string, Label:string}}>}, Merge?:array{Name:string, Inputs:array<string>, Source:string, PrimaryKeys:array<array<string>>}, Union?:array{Name:string, Inputs:array<string>, UnionType:"ALL"|"DISTINCT"}, PIIDetection?:array{Name:string, Inputs:array<string>, PiiType:"RowAudit"|"RowMasking"|"ColumnAudit"|"ColumnMasking", EntityTypesToDetect:array<string>, OutputColumnName?:string, SampleFraction?:float, ThresholdFraction?:float, MaskValue?:string}, Aggregate?:array{Name:string, Inputs:array<string>, Groups:array<array<string>>, Aggs:array<array{Column:array<string>, AggFunc:"avg"|"countDistinct"|"count"|"first"|"last"|"kurtosis"|"max"|"min"|"skewness"|"stddev_samp"|"stddev_pop"|"sum"|"sumDistinct"|"var_samp"|"var_pop"}>}, DropDuplicates?:array{Name:string, Inputs:array<string>, Columns?:array<array<string>>}, GovernedCatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Table:string, Database:string, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG"}}, GovernedCatalogSource?:array{Name:string, Database:string, Table:string, PartitionPredicate?:string, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int}}, MicrosoftSQLServerCatalogSource?:array{Name:string, Database:string, Table:string}, MySQLCatalogSource?:array{Name:string, Database:string, Table:string}, OracleSQLCatalogSource?:array{Name:string, Database:string, Table:string}, PostgreSQLCatalogSource?:array{Name:string, Database:string, Table:string}, MicrosoftSQLServerCatalogTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string}, MySQLCatalogTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string}, OracleSQLCatalogTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string}, PostgreSQLCatalogTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string}, DynamicTransform?:array{Name:string, TransformName:string, Inputs:array<string>, Parameters?:array<array{Name:string, Type:"str"|"int"|"float"|"complex"|"bool"|"list"|"null", ValidationRule?:string, ValidationMessage?:string, Value?:array<string>, ListType?:"str"|"int"|"float"|"complex"|"bool"|"list"|"null", IsOptional?:bool}>, FunctionName:string, Path:string, Version?:string, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, EvaluateDataQuality?:array{Name:string, Inputs:array<string>, Ruleset:string, Output?:"PrimaryInput"|"EvaluationResults", PublishingOptions?:array{EvaluationContext?:string, ResultsS3Prefix?:string, CloudWatchMetricsEnabled?:bool, ResultsPublishingEnabled?:bool}, StopJobOnFailureOptions?:array{StopJobOnFailureTiming?:"Immediate"|"AfterDataLoad"}}, S3CatalogHudiSource?:array{Name:string, Database:string, Table:string, AdditionalHudiOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, CatalogHudiSource?:array{Name:string, Database:string, Table:string, AdditionalHudiOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3HudiSource?:array{Name:string, Paths:array<string>, AdditionalHudiOptions?:array<string, string>, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3HudiCatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Table:string, Database:string, AdditionalOptions:array<string, string>, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG"}}, S3HudiDirectTarget?:array{Name:string, Inputs:array<string>, Path:string, Compression:"gzip"|"lzo"|"uncompressed"|"snappy", PartitionKeys?:array<array<string>>, Format:"json"|"csv"|"avro"|"orc"|"parquet"|"hudi"|"delta", AdditionalOptions:array<string, string>, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG", Table?:string, Database?:string}}, DirectJDBCSource?:array{Name:string, Database:string, Table:string, ConnectionName:string, ConnectionType:"sqlserver"|"mysql"|"oracle"|"postgresql"|"redshift", RedshiftTmpDir?:string}, S3CatalogDeltaSource?:array{Name:string, Database:string, Table:string, AdditionalDeltaOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, CatalogDeltaSource?:array{Name:string, Database:string, Table:string, AdditionalDeltaOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3DeltaSource?:array{Name:string, Paths:array<string>, AdditionalDeltaOptions?:array<string, string>, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3DeltaCatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Table:string, Database:string, AdditionalOptions?:array<string, string>, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG"}}, S3DeltaDirectTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Path:string, Compression:"uncompressed"|"snappy", Format:"json"|"csv"|"avro"|"orc"|"parquet"|"hudi"|"delta", AdditionalOptions?:array<string, string>, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG", Table?:string, Database?:string}}, AmazonRedshiftSource?:array{Name?:string, Data?:array{AccessType?:string, SourceType?:string, Connection?:array{Value?:string, Label?:string, Description?:string}, Schema?:array{Value?:string, Label?:string, Description?:string}, Table?:array{Value?:string, Label?:string, Description?:string}, CatalogDatabase?:array{Value?:string, Label?:string, Description?:string}, CatalogTable?:array{Value?:string, Label?:string, Description?:string}, CatalogRedshiftSchema?:string, CatalogRedshiftTable?:string, TempDir?:string, IamRole?:array{Value?:string, Label?:string, Description?:string}, AdvancedOptions?:array<array{Key?:string, Value?:string}>, SampleQuery?:string, PreAction?:string, PostAction?:string, Action?:string, TablePrefix?:string, Upsert?:bool, MergeAction?:string, MergeWhenMatched?:string, MergeWhenNotMatched?:string, MergeClause?:string, CrawlerConnection?:string, TableSchema?:array<array{Value?:string, Label?:string, Description?:string}>, StagingTable?:string, SelectedColumns?:array<array{Value?:string, Label?:string, Description?:string}>}}, AmazonRedshiftTarget?:array{Name?:string, Data?:array{AccessType?:string, SourceType?:string, Connection?:array{Value?:string, Label?:string, Description?:string}, Schema?:array{Value?:string, Label?:string, Description?:string}, Table?:array{Value?:string, Label?:string, Description?:string}, CatalogDatabase?:array{Value?:string, Label?:string, Description?:string}, CatalogTable?:array{Value?:string, Label?:string, Description?:string}, CatalogRedshiftSchema?:string, CatalogRedshiftTable?:string, TempDir?:string, IamRole?:array{Value?:string, Label?:string, Description?:string}, AdvancedOptions?:array<array{Key?:string, Value?:string}>, SampleQuery?:string, PreAction?:string, PostAction?:string, Action?:string, TablePrefix?:string, Upsert?:bool, MergeAction?:string, MergeWhenMatched?:string, MergeWhenNotMatched?:string, MergeClause?:string, CrawlerConnection?:string, TableSchema?:array<array{Value?:string, Label?:string, Description?:string}>, StagingTable?:string, SelectedColumns?:array<array{Value?:string, Label?:string, Description?:string}>}, Inputs?:array<string>}, EvaluateDataQualityMultiFrame?:array{Name:string, Inputs:array<string>, AdditionalDataSources?:array<string, string>, Ruleset:string, PublishingOptions?:array{EvaluationContext?:string, ResultsS3Prefix?:string, CloudWatchMetricsEnabled?:bool, ResultsPublishingEnabled?:bool}, AdditionalOptions?:array<"performanceTuning.caching"|"observations.scope", string>, StopJobOnFailureOptions?:array{StopJobOnFailureTiming?:"Immediate"|"AfterDataLoad"}}, Recipe?:array{Name:string, Inputs:array<string>, RecipeReference?:array{RecipeArn:string, RecipeVersion:string}, RecipeSteps?:array<array{Action:array{Operation:string, Parameters?:array<string, string>}, ConditionExpressions?:array<array{Condition:string, Value?:string, TargetColumn:string}>}>}, SnowflakeSource?:array{Name:string, Data:array{SourceType?:string, Connection?:array{Value?:string, Label?:string, Description?:string}, Schema?:string, Table?:string, Database?:string, TempDir?:string, IamRole?:array{Value?:string, Label?:string, Description?:string}, AdditionalOptions?:array<string, string>, SampleQuery?:string, PreAction?:string, PostAction?:string, Action?:string, Upsert?:bool, MergeAction?:string, MergeWhenMatched?:string, MergeWhenNotMatched?:string, MergeClause?:string, StagingTable?:string, SelectedColumns?:array<array{Value?:string, Label?:string, Description?:string}>, AutoPushdown?:bool, TableSchema?:array<array{Value?:string, Label?:string, Description?:string}>}, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, SnowflakeTarget?:array{Name:string, Data:array{SourceType?:string, Connection?:array{Value?:string, Label?:string, Description?:string}, Schema?:string, Table?:string, Database?:string, TempDir?:string, IamRole?:array{Value?:string, Label?:string, Description?:string}, AdditionalOptions?:array<string, string>, SampleQuery?:string, PreAction?:string, PostAction?:string, Action?:string, Upsert?:bool, MergeAction?:string, MergeWhenMatched?:string, MergeWhenNotMatched?:string, MergeClause?:string, StagingTable?:string, SelectedColumns?:array<array{Value?:string, Label?:string, Description?:string}>, AutoPushdown?:bool, TableSchema?:array<array{Value?:string, Label?:string, Description?:string}>}, Inputs?:array<string>}, ConnectorDataSource?:array{Name:string, ConnectionType:string, Data:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, ConnectorDataTarget?:array{Name:string, ConnectionType:string, Data:array<string, string>, Inputs?:array<string>}}>, ExecutionClass?:"FLEX"|"STANDARD", SourceControlDetails?:array{Provider?:"GITHUB"|"GITLAB"|"BITBUCKET"|"AWS_CODE_COMMIT", Repository?:string, Owner?:string, Branch?:string, Folder?:string, LastCommitId?:string, AuthStrategy?:"PERSONAL_ACCESS_TOKEN"|"AWS_SECRETS_MANAGER", AuthToken?:string}, MaintenanceWindow?:string, ProfileName?:string}}>
     */
    public function getJobAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{JobName:string, RunId?:string} $args
     * @return \AWS\Result<array{JobBookmarkEntry?:array{JobName?:string, Version?:int, Run?:int, Attempt?:int, PreviousRunId?:string, RunId?:string, JobBookmark?:string}}>
     */
    public function getJobBookmark(array $args): \AWS\Result { }

    /**
     * @param array{JobName:string, RunId?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{JobBookmarkEntry?:array{JobName?:string, Version?:int, Run?:int, Attempt?:int, PreviousRunId?:string, RunId?:string, JobBookmark?:string}}>
     */
    public function getJobBookmarkAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{JobName:string, RunId:string, PredecessorsIncluded?:bool} $args
     * @return \AWS\Result<array{JobRun?:array{Id?:string, Attempt?:int, PreviousRunId?:string, TriggerName?:string, JobName?:string, JobMode?:"SCRIPT"|"VISUAL"|"NOTEBOOK", JobRunQueuingEnabled?:bool, StartedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, JobRunState?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED", Arguments?:array<string, string>, ErrorMessage?:string, PredecessorRuns?:array<array{JobName?:string, RunId?:string}>, AllocatedCapacity?:int, ExecutionTime?:int, Timeout?:int, MaxCapacity?:float, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", NumberOfWorkers?:int, SecurityConfiguration?:string, LogGroupName?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, GlueVersion?:string, DPUSeconds?:float, ExecutionClass?:"FLEX"|"STANDARD", MaintenanceWindow?:string, ProfileName?:string, StateDetail?:string}}>
     */
    public function getJobRun(array $args): \AWS\Result { }

    /**
     * @param array{JobName:string, RunId:string, PredecessorsIncluded?:bool} $args
     * @return \GuzzleHttp\Promise\Promise<array{JobRun?:array{Id?:string, Attempt?:int, PreviousRunId?:string, TriggerName?:string, JobName?:string, JobMode?:"SCRIPT"|"VISUAL"|"NOTEBOOK", JobRunQueuingEnabled?:bool, StartedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, JobRunState?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED", Arguments?:array<string, string>, ErrorMessage?:string, PredecessorRuns?:array<array{JobName?:string, RunId?:string}>, AllocatedCapacity?:int, ExecutionTime?:int, Timeout?:int, MaxCapacity?:float, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", NumberOfWorkers?:int, SecurityConfiguration?:string, LogGroupName?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, GlueVersion?:string, DPUSeconds?:float, ExecutionClass?:"FLEX"|"STANDARD", MaintenanceWindow?:string, ProfileName?:string, StateDetail?:string}}>
     */
    public function getJobRunAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{JobName:string, NextToken?:string, MaxResults?:int} $args
     * @return \AWS\Result<array{JobRuns?:array<array{Id?:string, Attempt?:int, PreviousRunId?:string, TriggerName?:string, JobName?:string, JobMode?:"SCRIPT"|"VISUAL"|"NOTEBOOK", JobRunQueuingEnabled?:bool, StartedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, JobRunState?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED", Arguments?:array<string, string>, ErrorMessage?:string, PredecessorRuns?:array<array{JobName?:string, RunId?:string}>, AllocatedCapacity?:int, ExecutionTime?:int, Timeout?:int, MaxCapacity?:float, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", NumberOfWorkers?:int, SecurityConfiguration?:string, LogGroupName?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, GlueVersion?:string, DPUSeconds?:float, ExecutionClass?:"FLEX"|"STANDARD", MaintenanceWindow?:string, ProfileName?:string, StateDetail?:string}>, NextToken?:string}>
     */
    public function getJobRuns(array $args): \AWS\Result { }

    /**
     * @param array{JobName:string, NextToken?:string, MaxResults?:int} $args
     * @return \GuzzleHttp\Promise\Promise<array{JobRuns?:array<array{Id?:string, Attempt?:int, PreviousRunId?:string, TriggerName?:string, JobName?:string, JobMode?:"SCRIPT"|"VISUAL"|"NOTEBOOK", JobRunQueuingEnabled?:bool, StartedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, JobRunState?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED", Arguments?:array<string, string>, ErrorMessage?:string, PredecessorRuns?:array<array{JobName?:string, RunId?:string}>, AllocatedCapacity?:int, ExecutionTime?:int, Timeout?:int, MaxCapacity?:float, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", NumberOfWorkers?:int, SecurityConfiguration?:string, LogGroupName?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, GlueVersion?:string, DPUSeconds?:float, ExecutionClass?:"FLEX"|"STANDARD", MaintenanceWindow?:string, ProfileName?:string, StateDetail?:string}>, NextToken?:string}>
     */
    public function getJobRunsAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{NextToken?:string, MaxResults?:int} $args
     * @return \AWS\Result<array{Jobs?:array<array{Name?:string, JobMode?:"SCRIPT"|"VISUAL"|"NOTEBOOK", JobRunQueuingEnabled?:bool, Description?:string, LogUri?:string, Role?:string, CreatedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface, ExecutionProperty?:array{MaxConcurrentRuns?:int}, Command?:array{Name?:string, ScriptLocation?:string, PythonVersion?:string, Runtime?:string}, DefaultArguments?:array<string, string>, NonOverridableArguments?:array<string, string>, Connections?:array{Connections?:mixed}, MaxRetries?:int, AllocatedCapacity?:int, Timeout?:int, MaxCapacity?:float, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", NumberOfWorkers?:int, SecurityConfiguration?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, GlueVersion?:string, CodeGenConfigurationNodes?:array<string, array{AthenaConnectorSource?:array{Name:string, ConnectionName:string, ConnectorName:string, ConnectionType:string, ConnectionTable?:string, SchemaName:string, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, JDBCConnectorSource?:array{Name:string, ConnectionName:string, ConnectorName:string, ConnectionType:string, AdditionalOptions?:array{FilterPredicate?:string, PartitionColumn?:string, LowerBound?:int, UpperBound?:int, NumPartitions?:int, JobBookmarkKeys?:array<string>, JobBookmarkKeysSortOrder?:string, DataTypeMapping?:array<"ARRAY"|"BIGINT"|"BINARY"|"BIT"|"BLOB"|"BOOLEAN"|"CHAR"|"CLOB"|"DATALINK"|"DATE"|"DECIMAL"|"DISTINCT"|"DOUBLE"|"FLOAT"|"INTEGER"|"JAVA_OBJECT"|"LONGNVARCHAR"|"LONGVARBINARY"|"LONGVARCHAR"|"NCHAR"|"NCLOB"|"NULL"|"NUMERIC"|"NVARCHAR"|"OTHER"|"REAL"|"REF"|"REF_CURSOR"|"ROWID"|"SMALLINT"|"SQLXML"|"STRUCT"|"TIME"|"TIME_WITH_TIMEZONE"|"TIMESTAMP"|"TIMESTAMP_WITH_TIMEZONE"|"TINYINT"|"VARBINARY"|"VARCHAR", "DATE"|"STRING"|"TIMESTAMP"|"INT"|"FLOAT"|"LONG"|"BIGDECIMAL"|"BYTE"|"SHORT"|"DOUBLE">}, ConnectionTable?:string, Query?:string, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, SparkConnectorSource?:array{Name:string, ConnectionName:string, ConnectorName:string, ConnectionType:string, AdditionalOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, CatalogSource?:array{Name:string, Database:string, Table:string}, RedshiftSource?:array{Name:string, Database:string, Table:string, RedshiftTmpDir?:string, TmpDirIAMRole?:string}, S3CatalogSource?:array{Name:string, Database:string, Table:string, PartitionPredicate?:string, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int}}, S3CsvSource?:array{Name:string, Paths:array<string>, CompressionType?:"gzip"|"bzip2", Exclusions?:array<string>, GroupSize?:string, GroupFiles?:string, Recurse?:bool, MaxBand?:int, MaxFilesInBand?:int, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, Separator:"comma"|"ctrla"|"pipe"|"semicolon"|"tab", Escaper?:string, QuoteChar:"quote"|"quillemet"|"single_quote"|"disabled", Multiline?:bool, WithHeader?:bool, WriteHeader?:bool, SkipFirst?:bool, OptimizePerformance?:bool, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3JsonSource?:array{Name:string, Paths:array<string>, CompressionType?:"gzip"|"bzip2", Exclusions?:array<string>, GroupSize?:string, GroupFiles?:string, Recurse?:bool, MaxBand?:int, MaxFilesInBand?:int, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, JsonPath?:string, Multiline?:bool, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3ParquetSource?:array{Name:string, Paths:array<string>, CompressionType?:"snappy"|"lzo"|"gzip"|"uncompressed"|"none", Exclusions?:array<string>, GroupSize?:string, GroupFiles?:string, Recurse?:bool, MaxBand?:int, MaxFilesInBand?:int, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, RelationalCatalogSource?:array{Name:string, Database:string, Table:string}, DynamoDBCatalogSource?:array{Name:string, Database:string, Table:string}, JDBCConnectorTarget?:array{Name:string, Inputs:array<string>, ConnectionName:string, ConnectionTable:string, ConnectorName:string, ConnectionType:string, AdditionalOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, SparkConnectorTarget?:array{Name:string, Inputs:array<string>, ConnectionName:string, ConnectorName:string, ConnectionType:string, AdditionalOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, CatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Database:string, Table:string}, RedshiftTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string, RedshiftTmpDir?:string, TmpDirIAMRole?:string, UpsertRedshiftOptions?:array{TableLocation?:string, ConnectionName?:string, UpsertKeys?:array<string>}}, S3CatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Table:string, Database:string, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG"}}, S3GlueParquetTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Path:string, Compression?:"snappy"|"lzo"|"gzip"|"uncompressed"|"none", SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG", Table?:string, Database?:string}}, S3DirectTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Path:string, Compression?:string, Format:"json"|"csv"|"avro"|"orc"|"parquet"|"hudi"|"delta", SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG", Table?:string, Database?:string}}, ApplyMapping?:array{Name:string, Inputs:array<string>, Mapping:array<array{ToKey?:string, FromPath?:array<string>, FromType?:string, ToType?:string, Dropped?:bool, Children?:array<array{ToKey?:string, FromPath?:array<string>, FromType?:string, ToType?:string, Dropped?:bool, Children?:mixed}>}>}, SelectFields?:array{Name:string, Inputs:array<string>, Paths:array<array<string>>}, DropFields?:array{Name:string, Inputs:array<string>, Paths:array<array<string>>}, RenameField?:array{Name:string, Inputs:array<string>, SourcePath:array<string>, TargetPath:array<string>}, Spigot?:array{Name:string, Inputs:array<string>, Path:string, Topk?:int, Prob?:float}, Join?:array{Name:string, Inputs:array<string>, JoinType:"equijoin"|"left"|"right"|"outer"|"leftsemi"|"leftanti", Columns:array<array{From:string, Keys:array<array<string>>}>}, SplitFields?:array{Name:string, Inputs:array<string>, Paths:array<array<string>>}, SelectFromCollection?:array{Name:string, Inputs:array<string>, Index:int}, FillMissingValues?:array{Name:string, Inputs:array<string>, ImputedPath:string, FilledPath?:string}, Filter?:array{Name:string, Inputs:array<string>, LogicalOperator:"AND"|"OR", Filters:array<array{Operation:"EQ"|"LT"|"GT"|"LTE"|"GTE"|"REGEX"|"ISNULL", Negated?:bool, Values:array<array{Type:"COLUMNEXTRACTED"|"CONSTANT", Value:array<string>}>}>}, CustomCode?:array{Name:string, Inputs:array<string>, Code:string, ClassName:string, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, SparkSQL?:array{Name:string, Inputs:array<string>, SqlQuery:string, SqlAliases:array<array{From:string, Alias:string}>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, DirectKinesisSource?:array{Name:string, WindowSize?:int, DetectSchema?:bool, StreamingOptions?:array{EndpointUrl?:string, StreamName?:string, Classification?:string, Delimiter?:string, StartingPosition?:"latest"|"trim_horizon"|"earliest"|"timestamp", MaxFetchTimeInMs?:int, MaxFetchRecordsPerShard?:int, MaxRecordPerRead?:int, AddIdleTimeBetweenReads?:bool, IdleTimeBetweenReadsInMs?:int, DescribeShardInterval?:int, NumRetries?:int, RetryIntervalMs?:int, MaxRetryIntervalMs?:int, AvoidEmptyBatches?:bool, StreamArn?:string, RoleArn?:string, RoleSessionName?:string, AddRecordTimestamp?:string, EmitConsumerLagMetrics?:string, StartingTimestamp?:int|string|\DateTimeInterface}, DataPreviewOptions?:array{PollingTime?:int, RecordPollingLimit?:int}}, DirectKafkaSource?:array{Name:string, StreamingOptions?:array{BootstrapServers?:string, SecurityProtocol?:string, ConnectionName?:string, TopicName?:string, Assign?:string, SubscribePattern?:string, Classification?:string, Delimiter?:string, StartingOffsets?:string, EndingOffsets?:string, PollTimeoutMs?:int, NumRetries?:int, RetryIntervalMs?:int, MaxOffsetsPerTrigger?:int, MinPartitions?:int, IncludeHeaders?:bool, AddRecordTimestamp?:string, EmitConsumerLagMetrics?:string, StartingTimestamp?:int|string|\DateTimeInterface}, WindowSize?:int, DetectSchema?:bool, DataPreviewOptions?:array{PollingTime?:int, RecordPollingLimit?:int}}, CatalogKinesisSource?:array{Name:string, WindowSize?:int, DetectSchema?:bool, Table:string, Database:string, StreamingOptions?:array{EndpointUrl?:string, StreamName?:string, Classification?:string, Delimiter?:string, StartingPosition?:"latest"|"trim_horizon"|"earliest"|"timestamp", MaxFetchTimeInMs?:int, MaxFetchRecordsPerShard?:int, MaxRecordPerRead?:int, AddIdleTimeBetweenReads?:bool, IdleTimeBetweenReadsInMs?:int, DescribeShardInterval?:int, NumRetries?:int, RetryIntervalMs?:int, MaxRetryIntervalMs?:int, AvoidEmptyBatches?:bool, StreamArn?:string, RoleArn?:string, RoleSessionName?:string, AddRecordTimestamp?:string, EmitConsumerLagMetrics?:string, StartingTimestamp?:int|string|\DateTimeInterface}, DataPreviewOptions?:array{PollingTime?:int, RecordPollingLimit?:int}}, CatalogKafkaSource?:array{Name:string, WindowSize?:int, DetectSchema?:bool, Table:string, Database:string, StreamingOptions?:array{BootstrapServers?:string, SecurityProtocol?:string, ConnectionName?:string, TopicName?:string, Assign?:string, SubscribePattern?:string, Classification?:string, Delimiter?:string, StartingOffsets?:string, EndingOffsets?:string, PollTimeoutMs?:int, NumRetries?:int, RetryIntervalMs?:int, MaxOffsetsPerTrigger?:int, MinPartitions?:int, IncludeHeaders?:bool, AddRecordTimestamp?:string, EmitConsumerLagMetrics?:string, StartingTimestamp?:int|string|\DateTimeInterface}, DataPreviewOptions?:array{PollingTime?:int, RecordPollingLimit?:int}}, DropNullFields?:array{Name:string, Inputs:array<string>, NullCheckBoxList?:array{IsEmpty?:bool, IsNullString?:bool, IsNegOne?:bool}, NullTextList?:array<array{Value:string, Datatype:array{Id:string, Label:string}}>}, Merge?:array{Name:string, Inputs:array<string>, Source:string, PrimaryKeys:array<array<string>>}, Union?:array{Name:string, Inputs:array<string>, UnionType:"ALL"|"DISTINCT"}, PIIDetection?:array{Name:string, Inputs:array<string>, PiiType:"RowAudit"|"RowMasking"|"ColumnAudit"|"ColumnMasking", EntityTypesToDetect:array<string>, OutputColumnName?:string, SampleFraction?:float, ThresholdFraction?:float, MaskValue?:string}, Aggregate?:array{Name:string, Inputs:array<string>, Groups:array<array<string>>, Aggs:array<array{Column:array<string>, AggFunc:"avg"|"countDistinct"|"count"|"first"|"last"|"kurtosis"|"max"|"min"|"skewness"|"stddev_samp"|"stddev_pop"|"sum"|"sumDistinct"|"var_samp"|"var_pop"}>}, DropDuplicates?:array{Name:string, Inputs:array<string>, Columns?:array<array<string>>}, GovernedCatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Table:string, Database:string, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG"}}, GovernedCatalogSource?:array{Name:string, Database:string, Table:string, PartitionPredicate?:string, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int}}, MicrosoftSQLServerCatalogSource?:array{Name:string, Database:string, Table:string}, MySQLCatalogSource?:array{Name:string, Database:string, Table:string}, OracleSQLCatalogSource?:array{Name:string, Database:string, Table:string}, PostgreSQLCatalogSource?:array{Name:string, Database:string, Table:string}, MicrosoftSQLServerCatalogTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string}, MySQLCatalogTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string}, OracleSQLCatalogTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string}, PostgreSQLCatalogTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string}, DynamicTransform?:array{Name:string, TransformName:string, Inputs:array<string>, Parameters?:array<array{Name:string, Type:"str"|"int"|"float"|"complex"|"bool"|"list"|"null", ValidationRule?:string, ValidationMessage?:string, Value?:array<string>, ListType?:"str"|"int"|"float"|"complex"|"bool"|"list"|"null", IsOptional?:bool}>, FunctionName:string, Path:string, Version?:string, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, EvaluateDataQuality?:array{Name:string, Inputs:array<string>, Ruleset:string, Output?:"PrimaryInput"|"EvaluationResults", PublishingOptions?:array{EvaluationContext?:string, ResultsS3Prefix?:string, CloudWatchMetricsEnabled?:bool, ResultsPublishingEnabled?:bool}, StopJobOnFailureOptions?:array{StopJobOnFailureTiming?:"Immediate"|"AfterDataLoad"}}, S3CatalogHudiSource?:array{Name:string, Database:string, Table:string, AdditionalHudiOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, CatalogHudiSource?:array{Name:string, Database:string, Table:string, AdditionalHudiOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3HudiSource?:array{Name:string, Paths:array<string>, AdditionalHudiOptions?:array<string, string>, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3HudiCatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Table:string, Database:string, AdditionalOptions:array<string, string>, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG"}}, S3HudiDirectTarget?:array{Name:string, Inputs:array<string>, Path:string, Compression:"gzip"|"lzo"|"uncompressed"|"snappy", PartitionKeys?:array<array<string>>, Format:"json"|"csv"|"avro"|"orc"|"parquet"|"hudi"|"delta", AdditionalOptions:array<string, string>, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG", Table?:string, Database?:string}}, DirectJDBCSource?:array{Name:string, Database:string, Table:string, ConnectionName:string, ConnectionType:"sqlserver"|"mysql"|"oracle"|"postgresql"|"redshift", RedshiftTmpDir?:string}, S3CatalogDeltaSource?:array{Name:string, Database:string, Table:string, AdditionalDeltaOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, CatalogDeltaSource?:array{Name:string, Database:string, Table:string, AdditionalDeltaOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3DeltaSource?:array{Name:string, Paths:array<string>, AdditionalDeltaOptions?:array<string, string>, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3DeltaCatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Table:string, Database:string, AdditionalOptions?:array<string, string>, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG"}}, S3DeltaDirectTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Path:string, Compression:"uncompressed"|"snappy", Format:"json"|"csv"|"avro"|"orc"|"parquet"|"hudi"|"delta", AdditionalOptions?:array<string, string>, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG", Table?:string, Database?:string}}, AmazonRedshiftSource?:array{Name?:string, Data?:array{AccessType?:string, SourceType?:string, Connection?:array{Value?:string, Label?:string, Description?:string}, Schema?:array{Value?:string, Label?:string, Description?:string}, Table?:array{Value?:string, Label?:string, Description?:string}, CatalogDatabase?:array{Value?:string, Label?:string, Description?:string}, CatalogTable?:array{Value?:string, Label?:string, Description?:string}, CatalogRedshiftSchema?:string, CatalogRedshiftTable?:string, TempDir?:string, IamRole?:array{Value?:string, Label?:string, Description?:string}, AdvancedOptions?:array<array{Key?:string, Value?:string}>, SampleQuery?:string, PreAction?:string, PostAction?:string, Action?:string, TablePrefix?:string, Upsert?:bool, MergeAction?:string, MergeWhenMatched?:string, MergeWhenNotMatched?:string, MergeClause?:string, CrawlerConnection?:string, TableSchema?:array<array{Value?:string, Label?:string, Description?:string}>, StagingTable?:string, SelectedColumns?:array<array{Value?:string, Label?:string, Description?:string}>}}, AmazonRedshiftTarget?:array{Name?:string, Data?:array{AccessType?:string, SourceType?:string, Connection?:array{Value?:string, Label?:string, Description?:string}, Schema?:array{Value?:string, Label?:string, Description?:string}, Table?:array{Value?:string, Label?:string, Description?:string}, CatalogDatabase?:array{Value?:string, Label?:string, Description?:string}, CatalogTable?:array{Value?:string, Label?:string, Description?:string}, CatalogRedshiftSchema?:string, CatalogRedshiftTable?:string, TempDir?:string, IamRole?:array{Value?:string, Label?:string, Description?:string}, AdvancedOptions?:array<array{Key?:string, Value?:string}>, SampleQuery?:string, PreAction?:string, PostAction?:string, Action?:string, TablePrefix?:string, Upsert?:bool, MergeAction?:string, MergeWhenMatched?:string, MergeWhenNotMatched?:string, MergeClause?:string, CrawlerConnection?:string, TableSchema?:array<array{Value?:string, Label?:string, Description?:string}>, StagingTable?:string, SelectedColumns?:array<array{Value?:string, Label?:string, Description?:string}>}, Inputs?:array<string>}, EvaluateDataQualityMultiFrame?:array{Name:string, Inputs:array<string>, AdditionalDataSources?:array<string, string>, Ruleset:string, PublishingOptions?:array{EvaluationContext?:string, ResultsS3Prefix?:string, CloudWatchMetricsEnabled?:bool, ResultsPublishingEnabled?:bool}, AdditionalOptions?:array<"performanceTuning.caching"|"observations.scope", string>, StopJobOnFailureOptions?:array{StopJobOnFailureTiming?:"Immediate"|"AfterDataLoad"}}, Recipe?:array{Name:string, Inputs:array<string>, RecipeReference?:array{RecipeArn:string, RecipeVersion:string}, RecipeSteps?:array<array{Action:array{Operation:string, Parameters?:array<string, string>}, ConditionExpressions?:array<array{Condition:string, Value?:string, TargetColumn:string}>}>}, SnowflakeSource?:array{Name:string, Data:array{SourceType?:string, Connection?:array{Value?:string, Label?:string, Description?:string}, Schema?:string, Table?:string, Database?:string, TempDir?:string, IamRole?:array{Value?:string, Label?:string, Description?:string}, AdditionalOptions?:array<string, string>, SampleQuery?:string, PreAction?:string, PostAction?:string, Action?:string, Upsert?:bool, MergeAction?:string, MergeWhenMatched?:string, MergeWhenNotMatched?:string, MergeClause?:string, StagingTable?:string, SelectedColumns?:array<array{Value?:string, Label?:string, Description?:string}>, AutoPushdown?:bool, TableSchema?:array<array{Value?:string, Label?:string, Description?:string}>}, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, SnowflakeTarget?:array{Name:string, Data:array{SourceType?:string, Connection?:array{Value?:string, Label?:string, Description?:string}, Schema?:string, Table?:string, Database?:string, TempDir?:string, IamRole?:array{Value?:string, Label?:string, Description?:string}, AdditionalOptions?:array<string, string>, SampleQuery?:string, PreAction?:string, PostAction?:string, Action?:string, Upsert?:bool, MergeAction?:string, MergeWhenMatched?:string, MergeWhenNotMatched?:string, MergeClause?:string, StagingTable?:string, SelectedColumns?:array<array{Value?:string, Label?:string, Description?:string}>, AutoPushdown?:bool, TableSchema?:array<array{Value?:string, Label?:string, Description?:string}>}, Inputs?:array<string>}, ConnectorDataSource?:array{Name:string, ConnectionType:string, Data:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, ConnectorDataTarget?:array{Name:string, ConnectionType:string, Data:array<string, string>, Inputs?:array<string>}}>, ExecutionClass?:"FLEX"|"STANDARD", SourceControlDetails?:array{Provider?:"GITHUB"|"GITLAB"|"BITBUCKET"|"AWS_CODE_COMMIT", Repository?:string, Owner?:string, Branch?:string, Folder?:string, LastCommitId?:string, AuthStrategy?:"PERSONAL_ACCESS_TOKEN"|"AWS_SECRETS_MANAGER", AuthToken?:string}, MaintenanceWindow?:string, ProfileName?:string}>, NextToken?:string}>
     */
    public function getJobs(array $args = []): \AWS\Result { }

    /**
     * @param array{NextToken?:string, MaxResults?:int} $args
     * @return \GuzzleHttp\Promise\Promise<array{Jobs?:array<array{Name?:string, JobMode?:"SCRIPT"|"VISUAL"|"NOTEBOOK", JobRunQueuingEnabled?:bool, Description?:string, LogUri?:string, Role?:string, CreatedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface, ExecutionProperty?:array{MaxConcurrentRuns?:int}, Command?:array{Name?:string, ScriptLocation?:string, PythonVersion?:string, Runtime?:string}, DefaultArguments?:array<string, string>, NonOverridableArguments?:array<string, string>, Connections?:array{Connections?:mixed}, MaxRetries?:int, AllocatedCapacity?:int, Timeout?:int, MaxCapacity?:float, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", NumberOfWorkers?:int, SecurityConfiguration?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, GlueVersion?:string, CodeGenConfigurationNodes?:array<string, array{AthenaConnectorSource?:array{Name:string, ConnectionName:string, ConnectorName:string, ConnectionType:string, ConnectionTable?:string, SchemaName:string, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, JDBCConnectorSource?:array{Name:string, ConnectionName:string, ConnectorName:string, ConnectionType:string, AdditionalOptions?:array{FilterPredicate?:string, PartitionColumn?:string, LowerBound?:int, UpperBound?:int, NumPartitions?:int, JobBookmarkKeys?:array<string>, JobBookmarkKeysSortOrder?:string, DataTypeMapping?:array<"ARRAY"|"BIGINT"|"BINARY"|"BIT"|"BLOB"|"BOOLEAN"|"CHAR"|"CLOB"|"DATALINK"|"DATE"|"DECIMAL"|"DISTINCT"|"DOUBLE"|"FLOAT"|"INTEGER"|"JAVA_OBJECT"|"LONGNVARCHAR"|"LONGVARBINARY"|"LONGVARCHAR"|"NCHAR"|"NCLOB"|"NULL"|"NUMERIC"|"NVARCHAR"|"OTHER"|"REAL"|"REF"|"REF_CURSOR"|"ROWID"|"SMALLINT"|"SQLXML"|"STRUCT"|"TIME"|"TIME_WITH_TIMEZONE"|"TIMESTAMP"|"TIMESTAMP_WITH_TIMEZONE"|"TINYINT"|"VARBINARY"|"VARCHAR", "DATE"|"STRING"|"TIMESTAMP"|"INT"|"FLOAT"|"LONG"|"BIGDECIMAL"|"BYTE"|"SHORT"|"DOUBLE">}, ConnectionTable?:string, Query?:string, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, SparkConnectorSource?:array{Name:string, ConnectionName:string, ConnectorName:string, ConnectionType:string, AdditionalOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, CatalogSource?:array{Name:string, Database:string, Table:string}, RedshiftSource?:array{Name:string, Database:string, Table:string, RedshiftTmpDir?:string, TmpDirIAMRole?:string}, S3CatalogSource?:array{Name:string, Database:string, Table:string, PartitionPredicate?:string, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int}}, S3CsvSource?:array{Name:string, Paths:array<string>, CompressionType?:"gzip"|"bzip2", Exclusions?:array<string>, GroupSize?:string, GroupFiles?:string, Recurse?:bool, MaxBand?:int, MaxFilesInBand?:int, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, Separator:"comma"|"ctrla"|"pipe"|"semicolon"|"tab", Escaper?:string, QuoteChar:"quote"|"quillemet"|"single_quote"|"disabled", Multiline?:bool, WithHeader?:bool, WriteHeader?:bool, SkipFirst?:bool, OptimizePerformance?:bool, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3JsonSource?:array{Name:string, Paths:array<string>, CompressionType?:"gzip"|"bzip2", Exclusions?:array<string>, GroupSize?:string, GroupFiles?:string, Recurse?:bool, MaxBand?:int, MaxFilesInBand?:int, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, JsonPath?:string, Multiline?:bool, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3ParquetSource?:array{Name:string, Paths:array<string>, CompressionType?:"snappy"|"lzo"|"gzip"|"uncompressed"|"none", Exclusions?:array<string>, GroupSize?:string, GroupFiles?:string, Recurse?:bool, MaxBand?:int, MaxFilesInBand?:int, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, RelationalCatalogSource?:array{Name:string, Database:string, Table:string}, DynamoDBCatalogSource?:array{Name:string, Database:string, Table:string}, JDBCConnectorTarget?:array{Name:string, Inputs:array<string>, ConnectionName:string, ConnectionTable:string, ConnectorName:string, ConnectionType:string, AdditionalOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, SparkConnectorTarget?:array{Name:string, Inputs:array<string>, ConnectionName:string, ConnectorName:string, ConnectionType:string, AdditionalOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, CatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Database:string, Table:string}, RedshiftTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string, RedshiftTmpDir?:string, TmpDirIAMRole?:string, UpsertRedshiftOptions?:array{TableLocation?:string, ConnectionName?:string, UpsertKeys?:array<string>}}, S3CatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Table:string, Database:string, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG"}}, S3GlueParquetTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Path:string, Compression?:"snappy"|"lzo"|"gzip"|"uncompressed"|"none", SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG", Table?:string, Database?:string}}, S3DirectTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Path:string, Compression?:string, Format:"json"|"csv"|"avro"|"orc"|"parquet"|"hudi"|"delta", SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG", Table?:string, Database?:string}}, ApplyMapping?:array{Name:string, Inputs:array<string>, Mapping:array<array{ToKey?:string, FromPath?:array<string>, FromType?:string, ToType?:string, Dropped?:bool, Children?:array<array{ToKey?:string, FromPath?:array<string>, FromType?:string, ToType?:string, Dropped?:bool, Children?:mixed}>}>}, SelectFields?:array{Name:string, Inputs:array<string>, Paths:array<array<string>>}, DropFields?:array{Name:string, Inputs:array<string>, Paths:array<array<string>>}, RenameField?:array{Name:string, Inputs:array<string>, SourcePath:array<string>, TargetPath:array<string>}, Spigot?:array{Name:string, Inputs:array<string>, Path:string, Topk?:int, Prob?:float}, Join?:array{Name:string, Inputs:array<string>, JoinType:"equijoin"|"left"|"right"|"outer"|"leftsemi"|"leftanti", Columns:array<array{From:string, Keys:array<array<string>>}>}, SplitFields?:array{Name:string, Inputs:array<string>, Paths:array<array<string>>}, SelectFromCollection?:array{Name:string, Inputs:array<string>, Index:int}, FillMissingValues?:array{Name:string, Inputs:array<string>, ImputedPath:string, FilledPath?:string}, Filter?:array{Name:string, Inputs:array<string>, LogicalOperator:"AND"|"OR", Filters:array<array{Operation:"EQ"|"LT"|"GT"|"LTE"|"GTE"|"REGEX"|"ISNULL", Negated?:bool, Values:array<array{Type:"COLUMNEXTRACTED"|"CONSTANT", Value:array<string>}>}>}, CustomCode?:array{Name:string, Inputs:array<string>, Code:string, ClassName:string, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, SparkSQL?:array{Name:string, Inputs:array<string>, SqlQuery:string, SqlAliases:array<array{From:string, Alias:string}>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, DirectKinesisSource?:array{Name:string, WindowSize?:int, DetectSchema?:bool, StreamingOptions?:array{EndpointUrl?:string, StreamName?:string, Classification?:string, Delimiter?:string, StartingPosition?:"latest"|"trim_horizon"|"earliest"|"timestamp", MaxFetchTimeInMs?:int, MaxFetchRecordsPerShard?:int, MaxRecordPerRead?:int, AddIdleTimeBetweenReads?:bool, IdleTimeBetweenReadsInMs?:int, DescribeShardInterval?:int, NumRetries?:int, RetryIntervalMs?:int, MaxRetryIntervalMs?:int, AvoidEmptyBatches?:bool, StreamArn?:string, RoleArn?:string, RoleSessionName?:string, AddRecordTimestamp?:string, EmitConsumerLagMetrics?:string, StartingTimestamp?:int|string|\DateTimeInterface}, DataPreviewOptions?:array{PollingTime?:int, RecordPollingLimit?:int}}, DirectKafkaSource?:array{Name:string, StreamingOptions?:array{BootstrapServers?:string, SecurityProtocol?:string, ConnectionName?:string, TopicName?:string, Assign?:string, SubscribePattern?:string, Classification?:string, Delimiter?:string, StartingOffsets?:string, EndingOffsets?:string, PollTimeoutMs?:int, NumRetries?:int, RetryIntervalMs?:int, MaxOffsetsPerTrigger?:int, MinPartitions?:int, IncludeHeaders?:bool, AddRecordTimestamp?:string, EmitConsumerLagMetrics?:string, StartingTimestamp?:int|string|\DateTimeInterface}, WindowSize?:int, DetectSchema?:bool, DataPreviewOptions?:array{PollingTime?:int, RecordPollingLimit?:int}}, CatalogKinesisSource?:array{Name:string, WindowSize?:int, DetectSchema?:bool, Table:string, Database:string, StreamingOptions?:array{EndpointUrl?:string, StreamName?:string, Classification?:string, Delimiter?:string, StartingPosition?:"latest"|"trim_horizon"|"earliest"|"timestamp", MaxFetchTimeInMs?:int, MaxFetchRecordsPerShard?:int, MaxRecordPerRead?:int, AddIdleTimeBetweenReads?:bool, IdleTimeBetweenReadsInMs?:int, DescribeShardInterval?:int, NumRetries?:int, RetryIntervalMs?:int, MaxRetryIntervalMs?:int, AvoidEmptyBatches?:bool, StreamArn?:string, RoleArn?:string, RoleSessionName?:string, AddRecordTimestamp?:string, EmitConsumerLagMetrics?:string, StartingTimestamp?:int|string|\DateTimeInterface}, DataPreviewOptions?:array{PollingTime?:int, RecordPollingLimit?:int}}, CatalogKafkaSource?:array{Name:string, WindowSize?:int, DetectSchema?:bool, Table:string, Database:string, StreamingOptions?:array{BootstrapServers?:string, SecurityProtocol?:string, ConnectionName?:string, TopicName?:string, Assign?:string, SubscribePattern?:string, Classification?:string, Delimiter?:string, StartingOffsets?:string, EndingOffsets?:string, PollTimeoutMs?:int, NumRetries?:int, RetryIntervalMs?:int, MaxOffsetsPerTrigger?:int, MinPartitions?:int, IncludeHeaders?:bool, AddRecordTimestamp?:string, EmitConsumerLagMetrics?:string, StartingTimestamp?:int|string|\DateTimeInterface}, DataPreviewOptions?:array{PollingTime?:int, RecordPollingLimit?:int}}, DropNullFields?:array{Name:string, Inputs:array<string>, NullCheckBoxList?:array{IsEmpty?:bool, IsNullString?:bool, IsNegOne?:bool}, NullTextList?:array<array{Value:string, Datatype:array{Id:string, Label:string}}>}, Merge?:array{Name:string, Inputs:array<string>, Source:string, PrimaryKeys:array<array<string>>}, Union?:array{Name:string, Inputs:array<string>, UnionType:"ALL"|"DISTINCT"}, PIIDetection?:array{Name:string, Inputs:array<string>, PiiType:"RowAudit"|"RowMasking"|"ColumnAudit"|"ColumnMasking", EntityTypesToDetect:array<string>, OutputColumnName?:string, SampleFraction?:float, ThresholdFraction?:float, MaskValue?:string}, Aggregate?:array{Name:string, Inputs:array<string>, Groups:array<array<string>>, Aggs:array<array{Column:array<string>, AggFunc:"avg"|"countDistinct"|"count"|"first"|"last"|"kurtosis"|"max"|"min"|"skewness"|"stddev_samp"|"stddev_pop"|"sum"|"sumDistinct"|"var_samp"|"var_pop"}>}, DropDuplicates?:array{Name:string, Inputs:array<string>, Columns?:array<array<string>>}, GovernedCatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Table:string, Database:string, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG"}}, GovernedCatalogSource?:array{Name:string, Database:string, Table:string, PartitionPredicate?:string, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int}}, MicrosoftSQLServerCatalogSource?:array{Name:string, Database:string, Table:string}, MySQLCatalogSource?:array{Name:string, Database:string, Table:string}, OracleSQLCatalogSource?:array{Name:string, Database:string, Table:string}, PostgreSQLCatalogSource?:array{Name:string, Database:string, Table:string}, MicrosoftSQLServerCatalogTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string}, MySQLCatalogTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string}, OracleSQLCatalogTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string}, PostgreSQLCatalogTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string}, DynamicTransform?:array{Name:string, TransformName:string, Inputs:array<string>, Parameters?:array<array{Name:string, Type:"str"|"int"|"float"|"complex"|"bool"|"list"|"null", ValidationRule?:string, ValidationMessage?:string, Value?:array<string>, ListType?:"str"|"int"|"float"|"complex"|"bool"|"list"|"null", IsOptional?:bool}>, FunctionName:string, Path:string, Version?:string, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, EvaluateDataQuality?:array{Name:string, Inputs:array<string>, Ruleset:string, Output?:"PrimaryInput"|"EvaluationResults", PublishingOptions?:array{EvaluationContext?:string, ResultsS3Prefix?:string, CloudWatchMetricsEnabled?:bool, ResultsPublishingEnabled?:bool}, StopJobOnFailureOptions?:array{StopJobOnFailureTiming?:"Immediate"|"AfterDataLoad"}}, S3CatalogHudiSource?:array{Name:string, Database:string, Table:string, AdditionalHudiOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, CatalogHudiSource?:array{Name:string, Database:string, Table:string, AdditionalHudiOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3HudiSource?:array{Name:string, Paths:array<string>, AdditionalHudiOptions?:array<string, string>, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3HudiCatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Table:string, Database:string, AdditionalOptions:array<string, string>, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG"}}, S3HudiDirectTarget?:array{Name:string, Inputs:array<string>, Path:string, Compression:"gzip"|"lzo"|"uncompressed"|"snappy", PartitionKeys?:array<array<string>>, Format:"json"|"csv"|"avro"|"orc"|"parquet"|"hudi"|"delta", AdditionalOptions:array<string, string>, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG", Table?:string, Database?:string}}, DirectJDBCSource?:array{Name:string, Database:string, Table:string, ConnectionName:string, ConnectionType:"sqlserver"|"mysql"|"oracle"|"postgresql"|"redshift", RedshiftTmpDir?:string}, S3CatalogDeltaSource?:array{Name:string, Database:string, Table:string, AdditionalDeltaOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, CatalogDeltaSource?:array{Name:string, Database:string, Table:string, AdditionalDeltaOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3DeltaSource?:array{Name:string, Paths:array<string>, AdditionalDeltaOptions?:array<string, string>, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3DeltaCatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Table:string, Database:string, AdditionalOptions?:array<string, string>, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG"}}, S3DeltaDirectTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Path:string, Compression:"uncompressed"|"snappy", Format:"json"|"csv"|"avro"|"orc"|"parquet"|"hudi"|"delta", AdditionalOptions?:array<string, string>, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG", Table?:string, Database?:string}}, AmazonRedshiftSource?:array{Name?:string, Data?:array{AccessType?:string, SourceType?:string, Connection?:array{Value?:string, Label?:string, Description?:string}, Schema?:array{Value?:string, Label?:string, Description?:string}, Table?:array{Value?:string, Label?:string, Description?:string}, CatalogDatabase?:array{Value?:string, Label?:string, Description?:string}, CatalogTable?:array{Value?:string, Label?:string, Description?:string}, CatalogRedshiftSchema?:string, CatalogRedshiftTable?:string, TempDir?:string, IamRole?:array{Value?:string, Label?:string, Description?:string}, AdvancedOptions?:array<array{Key?:string, Value?:string}>, SampleQuery?:string, PreAction?:string, PostAction?:string, Action?:string, TablePrefix?:string, Upsert?:bool, MergeAction?:string, MergeWhenMatched?:string, MergeWhenNotMatched?:string, MergeClause?:string, CrawlerConnection?:string, TableSchema?:array<array{Value?:string, Label?:string, Description?:string}>, StagingTable?:string, SelectedColumns?:array<array{Value?:string, Label?:string, Description?:string}>}}, AmazonRedshiftTarget?:array{Name?:string, Data?:array{AccessType?:string, SourceType?:string, Connection?:array{Value?:string, Label?:string, Description?:string}, Schema?:array{Value?:string, Label?:string, Description?:string}, Table?:array{Value?:string, Label?:string, Description?:string}, CatalogDatabase?:array{Value?:string, Label?:string, Description?:string}, CatalogTable?:array{Value?:string, Label?:string, Description?:string}, CatalogRedshiftSchema?:string, CatalogRedshiftTable?:string, TempDir?:string, IamRole?:array{Value?:string, Label?:string, Description?:string}, AdvancedOptions?:array<array{Key?:string, Value?:string}>, SampleQuery?:string, PreAction?:string, PostAction?:string, Action?:string, TablePrefix?:string, Upsert?:bool, MergeAction?:string, MergeWhenMatched?:string, MergeWhenNotMatched?:string, MergeClause?:string, CrawlerConnection?:string, TableSchema?:array<array{Value?:string, Label?:string, Description?:string}>, StagingTable?:string, SelectedColumns?:array<array{Value?:string, Label?:string, Description?:string}>}, Inputs?:array<string>}, EvaluateDataQualityMultiFrame?:array{Name:string, Inputs:array<string>, AdditionalDataSources?:array<string, string>, Ruleset:string, PublishingOptions?:array{EvaluationContext?:string, ResultsS3Prefix?:string, CloudWatchMetricsEnabled?:bool, ResultsPublishingEnabled?:bool}, AdditionalOptions?:array<"performanceTuning.caching"|"observations.scope", string>, StopJobOnFailureOptions?:array{StopJobOnFailureTiming?:"Immediate"|"AfterDataLoad"}}, Recipe?:array{Name:string, Inputs:array<string>, RecipeReference?:array{RecipeArn:string, RecipeVersion:string}, RecipeSteps?:array<array{Action:array{Operation:string, Parameters?:array<string, string>}, ConditionExpressions?:array<array{Condition:string, Value?:string, TargetColumn:string}>}>}, SnowflakeSource?:array{Name:string, Data:array{SourceType?:string, Connection?:array{Value?:string, Label?:string, Description?:string}, Schema?:string, Table?:string, Database?:string, TempDir?:string, IamRole?:array{Value?:string, Label?:string, Description?:string}, AdditionalOptions?:array<string, string>, SampleQuery?:string, PreAction?:string, PostAction?:string, Action?:string, Upsert?:bool, MergeAction?:string, MergeWhenMatched?:string, MergeWhenNotMatched?:string, MergeClause?:string, StagingTable?:string, SelectedColumns?:array<array{Value?:string, Label?:string, Description?:string}>, AutoPushdown?:bool, TableSchema?:array<array{Value?:string, Label?:string, Description?:string}>}, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, SnowflakeTarget?:array{Name:string, Data:array{SourceType?:string, Connection?:array{Value?:string, Label?:string, Description?:string}, Schema?:string, Table?:string, Database?:string, TempDir?:string, IamRole?:array{Value?:string, Label?:string, Description?:string}, AdditionalOptions?:array<string, string>, SampleQuery?:string, PreAction?:string, PostAction?:string, Action?:string, Upsert?:bool, MergeAction?:string, MergeWhenMatched?:string, MergeWhenNotMatched?:string, MergeClause?:string, StagingTable?:string, SelectedColumns?:array<array{Value?:string, Label?:string, Description?:string}>, AutoPushdown?:bool, TableSchema?:array<array{Value?:string, Label?:string, Description?:string}>}, Inputs?:array<string>}, ConnectorDataSource?:array{Name:string, ConnectionType:string, Data:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, ConnectorDataTarget?:array{Name:string, ConnectionType:string, Data:array<string, string>, Inputs?:array<string>}}>, ExecutionClass?:"FLEX"|"STANDARD", SourceControlDetails?:array{Provider?:"GITHUB"|"GITLAB"|"BITBUCKET"|"AWS_CODE_COMMIT", Repository?:string, Owner?:string, Branch?:string, Folder?:string, LastCommitId?:string, AuthStrategy?:"PERSONAL_ACCESS_TOKEN"|"AWS_SECRETS_MANAGER", AuthToken?:string}, MaintenanceWindow?:string, ProfileName?:string}>, NextToken?:string}>
     */
    public function getJobsAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{TransformId:string, TaskRunId:string} $args
     * @return \AWS\Result<array{TransformId?:string, TaskRunId?:string, Status?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT", LogGroupName?:string, Properties?:array{TaskType?:"EVALUATION"|"LABELING_SET_GENERATION"|"IMPORT_LABELS"|"EXPORT_LABELS"|"FIND_MATCHES", ImportLabelsTaskRunProperties?:array{InputS3Path?:string, Replace?:bool}, ExportLabelsTaskRunProperties?:array{OutputS3Path?:string}, LabelingSetGenerationTaskRunProperties?:array{OutputS3Path?:string}, FindMatchesTaskRunProperties?:array{JobId?:string, JobName?:string, JobRunId?:string}}, ErrorString?:string, StartedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, ExecutionTime?:int}>
     */
    public function getMLTaskRun(array $args): \AWS\Result { }

    /**
     * @param array{TransformId:string, TaskRunId:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{TransformId?:string, TaskRunId?:string, Status?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT", LogGroupName?:string, Properties?:array{TaskType?:"EVALUATION"|"LABELING_SET_GENERATION"|"IMPORT_LABELS"|"EXPORT_LABELS"|"FIND_MATCHES", ImportLabelsTaskRunProperties?:array{InputS3Path?:string, Replace?:bool}, ExportLabelsTaskRunProperties?:array{OutputS3Path?:string}, LabelingSetGenerationTaskRunProperties?:array{OutputS3Path?:string}, FindMatchesTaskRunProperties?:array{JobId?:string, JobName?:string, JobRunId?:string}}, ErrorString?:string, StartedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, ExecutionTime?:int}>
     */
    public function getMLTaskRunAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{TransformId:string, NextToken?:string, MaxResults?:int, Filter?:array{TaskRunType?:"EVALUATION"|"LABELING_SET_GENERATION"|"IMPORT_LABELS"|"EXPORT_LABELS"|"FIND_MATCHES", Status?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT", StartedBefore?:int|string|\DateTimeInterface, StartedAfter?:int|string|\DateTimeInterface}, Sort?:array{Column:"TASK_RUN_TYPE"|"STATUS"|"STARTED", SortDirection:"DESCENDING"|"ASCENDING"}} $args
     * @return \AWS\Result<array{TaskRuns?:array<array{TransformId?:string, TaskRunId?:string, Status?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT", LogGroupName?:string, Properties?:array{TaskType?:"EVALUATION"|"LABELING_SET_GENERATION"|"IMPORT_LABELS"|"EXPORT_LABELS"|"FIND_MATCHES", ImportLabelsTaskRunProperties?:array{InputS3Path?:string, Replace?:bool}, ExportLabelsTaskRunProperties?:array{OutputS3Path?:string}, LabelingSetGenerationTaskRunProperties?:array{OutputS3Path?:string}, FindMatchesTaskRunProperties?:array{JobId?:string, JobName?:string, JobRunId?:string}}, ErrorString?:string, StartedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, ExecutionTime?:int}>, NextToken?:string}>
     */
    public function getMLTaskRuns(array $args): \AWS\Result { }

    /**
     * @param array{TransformId:string, NextToken?:string, MaxResults?:int, Filter?:array{TaskRunType?:"EVALUATION"|"LABELING_SET_GENERATION"|"IMPORT_LABELS"|"EXPORT_LABELS"|"FIND_MATCHES", Status?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT", StartedBefore?:int|string|\DateTimeInterface, StartedAfter?:int|string|\DateTimeInterface}, Sort?:array{Column:"TASK_RUN_TYPE"|"STATUS"|"STARTED", SortDirection:"DESCENDING"|"ASCENDING"}} $args
     * @return \GuzzleHttp\Promise\Promise<array{TaskRuns?:array<array{TransformId?:string, TaskRunId?:string, Status?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT", LogGroupName?:string, Properties?:array{TaskType?:"EVALUATION"|"LABELING_SET_GENERATION"|"IMPORT_LABELS"|"EXPORT_LABELS"|"FIND_MATCHES", ImportLabelsTaskRunProperties?:array{InputS3Path?:string, Replace?:bool}, ExportLabelsTaskRunProperties?:array{OutputS3Path?:string}, LabelingSetGenerationTaskRunProperties?:array{OutputS3Path?:string}, FindMatchesTaskRunProperties?:array{JobId?:string, JobName?:string, JobRunId?:string}}, ErrorString?:string, StartedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, ExecutionTime?:int}>, NextToken?:string}>
     */
    public function getMLTaskRunsAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{TransformId:string} $args
     * @return \AWS\Result<array{TransformId?:string, Name?:string, Description?:string, Status?:"NOT_READY"|"READY"|"DELETING", CreatedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface, InputRecordTables?:array<array{DatabaseName:string, TableName:string, CatalogId?:string, ConnectionName?:string, AdditionalOptions?:array<string, string>}>, Parameters?:array{TransformType:"FIND_MATCHES", FindMatchesParameters?:array{PrimaryKeyColumnName?:string, PrecisionRecallTradeoff?:float, AccuracyCostTradeoff?:float, EnforceProvidedLabels?:bool}}, EvaluationMetrics?:array{TransformType:"FIND_MATCHES", FindMatchesMetrics?:array{AreaUnderPRCurve?:float, Precision?:float, Recall?:float, F1?:float, ConfusionMatrix?:array{NumTruePositives?:int, NumFalsePositives?:int, NumTrueNegatives?:int, NumFalseNegatives?:int}, ColumnImportances?:array<array{ColumnName?:string, Importance?:float}>}}, LabelCount?:int, Schema?:array<array{Name?:string, DataType?:string}>, Role?:string, GlueVersion?:string, MaxCapacity?:float, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", NumberOfWorkers?:int, Timeout?:int, MaxRetries?:int, TransformEncryption?:array{MlUserDataEncryption?:array{MlUserDataEncryptionMode:"DISABLED"|"SSE-KMS", KmsKeyId?:string}, TaskRunSecurityConfigurationName?:string}}>
     */
    public function getMLTransform(array $args): \AWS\Result { }

    /**
     * @param array{TransformId:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{TransformId?:string, Name?:string, Description?:string, Status?:"NOT_READY"|"READY"|"DELETING", CreatedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface, InputRecordTables?:array<array{DatabaseName:string, TableName:string, CatalogId?:string, ConnectionName?:string, AdditionalOptions?:array<string, string>}>, Parameters?:array{TransformType:"FIND_MATCHES", FindMatchesParameters?:array{PrimaryKeyColumnName?:string, PrecisionRecallTradeoff?:float, AccuracyCostTradeoff?:float, EnforceProvidedLabels?:bool}}, EvaluationMetrics?:array{TransformType:"FIND_MATCHES", FindMatchesMetrics?:array{AreaUnderPRCurve?:float, Precision?:float, Recall?:float, F1?:float, ConfusionMatrix?:array{NumTruePositives?:int, NumFalsePositives?:int, NumTrueNegatives?:int, NumFalseNegatives?:int}, ColumnImportances?:array<array{ColumnName?:string, Importance?:float}>}}, LabelCount?:int, Schema?:array<array{Name?:string, DataType?:string}>, Role?:string, GlueVersion?:string, MaxCapacity?:float, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", NumberOfWorkers?:int, Timeout?:int, MaxRetries?:int, TransformEncryption?:array{MlUserDataEncryption?:array{MlUserDataEncryptionMode:"DISABLED"|"SSE-KMS", KmsKeyId?:string}, TaskRunSecurityConfigurationName?:string}}>
     */
    public function getMLTransformAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{NextToken?:string, MaxResults?:int, Filter?:array{Name?:string, TransformType?:"FIND_MATCHES", Status?:"NOT_READY"|"READY"|"DELETING", GlueVersion?:string, CreatedBefore?:int|string|\DateTimeInterface, CreatedAfter?:int|string|\DateTimeInterface, LastModifiedBefore?:int|string|\DateTimeInterface, LastModifiedAfter?:int|string|\DateTimeInterface, Schema?:array<array{Name?:string, DataType?:string}>}, Sort?:array{Column:"NAME"|"TRANSFORM_TYPE"|"STATUS"|"CREATED"|"LAST_MODIFIED", SortDirection:"DESCENDING"|"ASCENDING"}} $args
     * @return \AWS\Result<array{Transforms:array<array{TransformId?:string, Name?:string, Description?:string, Status?:"NOT_READY"|"READY"|"DELETING", CreatedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface, InputRecordTables?:array<array{DatabaseName:string, TableName:string, CatalogId?:string, ConnectionName?:string, AdditionalOptions?:array<string, string>}>, Parameters?:array{TransformType:"FIND_MATCHES", FindMatchesParameters?:array{PrimaryKeyColumnName?:string, PrecisionRecallTradeoff?:float, AccuracyCostTradeoff?:float, EnforceProvidedLabels?:bool}}, EvaluationMetrics?:array{TransformType:"FIND_MATCHES", FindMatchesMetrics?:array{AreaUnderPRCurve?:float, Precision?:float, Recall?:float, F1?:float, ConfusionMatrix?:array{NumTruePositives?:int, NumFalsePositives?:int, NumTrueNegatives?:int, NumFalseNegatives?:int}, ColumnImportances?:array<array{ColumnName?:string, Importance?:float}>}}, LabelCount?:int, Schema?:array<array{Name?:string, DataType?:string}>, Role?:string, GlueVersion?:string, MaxCapacity?:float, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", NumberOfWorkers?:int, Timeout?:int, MaxRetries?:int, TransformEncryption?:array{MlUserDataEncryption?:array{MlUserDataEncryptionMode:"DISABLED"|"SSE-KMS", KmsKeyId?:string}, TaskRunSecurityConfigurationName?:string}}>, NextToken?:string}>
     */
    public function getMLTransforms(array $args = []): \AWS\Result { }

    /**
     * @param array{NextToken?:string, MaxResults?:int, Filter?:array{Name?:string, TransformType?:"FIND_MATCHES", Status?:"NOT_READY"|"READY"|"DELETING", GlueVersion?:string, CreatedBefore?:int|string|\DateTimeInterface, CreatedAfter?:int|string|\DateTimeInterface, LastModifiedBefore?:int|string|\DateTimeInterface, LastModifiedAfter?:int|string|\DateTimeInterface, Schema?:array<array{Name?:string, DataType?:string}>}, Sort?:array{Column:"NAME"|"TRANSFORM_TYPE"|"STATUS"|"CREATED"|"LAST_MODIFIED", SortDirection:"DESCENDING"|"ASCENDING"}} $args
     * @return \GuzzleHttp\Promise\Promise<array{Transforms:array<array{TransformId?:string, Name?:string, Description?:string, Status?:"NOT_READY"|"READY"|"DELETING", CreatedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface, InputRecordTables?:array<array{DatabaseName:string, TableName:string, CatalogId?:string, ConnectionName?:string, AdditionalOptions?:array<string, string>}>, Parameters?:array{TransformType:"FIND_MATCHES", FindMatchesParameters?:array{PrimaryKeyColumnName?:string, PrecisionRecallTradeoff?:float, AccuracyCostTradeoff?:float, EnforceProvidedLabels?:bool}}, EvaluationMetrics?:array{TransformType:"FIND_MATCHES", FindMatchesMetrics?:array{AreaUnderPRCurve?:float, Precision?:float, Recall?:float, F1?:float, ConfusionMatrix?:array{NumTruePositives?:int, NumFalsePositives?:int, NumTrueNegatives?:int, NumFalseNegatives?:int}, ColumnImportances?:array<array{ColumnName?:string, Importance?:float}>}}, LabelCount?:int, Schema?:array<array{Name?:string, DataType?:string}>, Role?:string, GlueVersion?:string, MaxCapacity?:float, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", NumberOfWorkers?:int, Timeout?:int, MaxRetries?:int, TransformEncryption?:array{MlUserDataEncryption?:array{MlUserDataEncryptionMode:"DISABLED"|"SSE-KMS", KmsKeyId?:string}, TaskRunSecurityConfigurationName?:string}}>, NextToken?:string}>
     */
    public function getMLTransformsAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Source:array{DatabaseName:string, TableName:string}, Sinks?:array<array{DatabaseName:string, TableName:string}>, Location?:array{Jdbc?:array<array{Name:string, Value:string, Param?:bool}>, S3?:array<array{Name:string, Value:string, Param?:bool}>, DynamoDB?:array<array{Name:string, Value:string, Param?:bool}>}} $args
     * @return \AWS\Result<array{Mapping:array<array{SourceTable?:string, SourcePath?:string, SourceType?:string, TargetTable?:string, TargetPath?:string, TargetType?:string}>}>
     */
    public function getMapping(array $args): \AWS\Result { }

    /**
     * @param array{Source:array{DatabaseName:string, TableName:string}, Sinks?:array<array{DatabaseName:string, TableName:string}>, Location?:array{Jdbc?:array<array{Name:string, Value:string, Param?:bool}>, S3?:array<array{Name:string, Value:string, Param?:bool}>, DynamoDB?:array<array{Name:string, Value:string, Param?:bool}>}} $args
     * @return \GuzzleHttp\Promise\Promise<array{Mapping:array<array{SourceTable?:string, SourcePath?:string, SourceType?:string, TargetTable?:string, TargetPath?:string, TargetType?:string}>}>
     */
    public function getMappingAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, TableName:string, PartitionValues:array<string>} $args
     * @return \AWS\Result<array{Partition?:array{Values?:array<string>, DatabaseName?:string, TableName?:string, CreationTime?:int|string|\DateTimeInterface, LastAccessTime?:int|string|\DateTimeInterface, StorageDescriptor?:array{Columns?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, Location?:string, AdditionalLocations?:array<string>, InputFormat?:string, OutputFormat?:string, Compressed?:bool, NumberOfBuckets?:int, SerdeInfo?:array{Name?:string, SerializationLibrary?:string, Parameters?:array<string, string>}, BucketColumns?:array<string>, SortColumns?:array<array{Column:string, SortOrder:int}>, Parameters?:array<string, string>, SkewedInfo?:array{SkewedColumnNames?:array<string>, SkewedColumnValues?:array<string>, SkewedColumnValueLocationMaps?:array<string, string>}, StoredAsSubDirectories?:bool, SchemaReference?:array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionId?:string, SchemaVersionNumber?:int}}, Parameters?:array<string, string>, LastAnalyzedTime?:int|string|\DateTimeInterface, CatalogId?:string}}>
     */
    public function getPartition(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, TableName:string, PartitionValues:array<string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{Partition?:array{Values?:array<string>, DatabaseName?:string, TableName?:string, CreationTime?:int|string|\DateTimeInterface, LastAccessTime?:int|string|\DateTimeInterface, StorageDescriptor?:array{Columns?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, Location?:string, AdditionalLocations?:array<string>, InputFormat?:string, OutputFormat?:string, Compressed?:bool, NumberOfBuckets?:int, SerdeInfo?:array{Name?:string, SerializationLibrary?:string, Parameters?:array<string, string>}, BucketColumns?:array<string>, SortColumns?:array<array{Column:string, SortOrder:int}>, Parameters?:array<string, string>, SkewedInfo?:array{SkewedColumnNames?:array<string>, SkewedColumnValues?:array<string>, SkewedColumnValueLocationMaps?:array<string, string>}, StoredAsSubDirectories?:bool, SchemaReference?:array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionId?:string, SchemaVersionNumber?:int}}, Parameters?:array<string, string>, LastAnalyzedTime?:int|string|\DateTimeInterface, CatalogId?:string}}>
     */
    public function getPartitionAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, TableName:string, NextToken?:string} $args
     * @return \AWS\Result<array{PartitionIndexDescriptorList?:array<array{IndexName:string, Keys:array<array{Name:string, Type:string}>, IndexStatus:"CREATING"|"ACTIVE"|"DELETING"|"FAILED", BackfillErrors?:array<array{Code?:"ENCRYPTED_PARTITION_ERROR"|"INTERNAL_ERROR"|"INVALID_PARTITION_TYPE_DATA_ERROR"|"MISSING_PARTITION_VALUE_ERROR"|"UNSUPPORTED_PARTITION_CHARACTER_ERROR", Partitions?:array<array{Values:array<string>}>}>}>, NextToken?:string}>
     */
    public function getPartitionIndexes(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, TableName:string, NextToken?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{PartitionIndexDescriptorList?:array<array{IndexName:string, Keys:array<array{Name:string, Type:string}>, IndexStatus:"CREATING"|"ACTIVE"|"DELETING"|"FAILED", BackfillErrors?:array<array{Code?:"ENCRYPTED_PARTITION_ERROR"|"INTERNAL_ERROR"|"INVALID_PARTITION_TYPE_DATA_ERROR"|"MISSING_PARTITION_VALUE_ERROR"|"UNSUPPORTED_PARTITION_CHARACTER_ERROR", Partitions?:array<array{Values:array<string>}>}>}>, NextToken?:string}>
     */
    public function getPartitionIndexesAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, TableName:string, Expression?:string, NextToken?:string, Segment?:array{SegmentNumber:int, TotalSegments:int}, MaxResults?:int, ExcludeColumnSchema?:bool, TransactionId?:string, QueryAsOfTime?:int|string|\DateTimeInterface} $args
     * @return \AWS\Result<array{Partitions?:array<array{Values?:array<string>, DatabaseName?:string, TableName?:string, CreationTime?:int|string|\DateTimeInterface, LastAccessTime?:int|string|\DateTimeInterface, StorageDescriptor?:array{Columns?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, Location?:string, AdditionalLocations?:array<string>, InputFormat?:string, OutputFormat?:string, Compressed?:bool, NumberOfBuckets?:int, SerdeInfo?:array{Name?:string, SerializationLibrary?:string, Parameters?:array<string, string>}, BucketColumns?:array<string>, SortColumns?:array<array{Column:string, SortOrder:int}>, Parameters?:array<string, string>, SkewedInfo?:array{SkewedColumnNames?:array<string>, SkewedColumnValues?:array<string>, SkewedColumnValueLocationMaps?:array<string, string>}, StoredAsSubDirectories?:bool, SchemaReference?:array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionId?:string, SchemaVersionNumber?:int}}, Parameters?:array<string, string>, LastAnalyzedTime?:int|string|\DateTimeInterface, CatalogId?:string}>, NextToken?:string}>
     */
    public function getPartitions(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, TableName:string, Expression?:string, NextToken?:string, Segment?:array{SegmentNumber:int, TotalSegments:int}, MaxResults?:int, ExcludeColumnSchema?:bool, TransactionId?:string, QueryAsOfTime?:int|string|\DateTimeInterface} $args
     * @return \GuzzleHttp\Promise\Promise<array{Partitions?:array<array{Values?:array<string>, DatabaseName?:string, TableName?:string, CreationTime?:int|string|\DateTimeInterface, LastAccessTime?:int|string|\DateTimeInterface, StorageDescriptor?:array{Columns?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, Location?:string, AdditionalLocations?:array<string>, InputFormat?:string, OutputFormat?:string, Compressed?:bool, NumberOfBuckets?:int, SerdeInfo?:array{Name?:string, SerializationLibrary?:string, Parameters?:array<string, string>}, BucketColumns?:array<string>, SortColumns?:array<array{Column:string, SortOrder:int}>, Parameters?:array<string, string>, SkewedInfo?:array{SkewedColumnNames?:array<string>, SkewedColumnValues?:array<string>, SkewedColumnValueLocationMaps?:array<string, string>}, StoredAsSubDirectories?:bool, SchemaReference?:array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionId?:string, SchemaVersionNumber?:int}}, Parameters?:array<string, string>, LastAnalyzedTime?:int|string|\DateTimeInterface, CatalogId?:string}>, NextToken?:string}>
     */
    public function getPartitionsAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Mapping:array<array{SourceTable?:string, SourcePath?:string, SourceType?:string, TargetTable?:string, TargetPath?:string, TargetType?:string}>, Source:array{DatabaseName:string, TableName:string}, Sinks?:array<array{DatabaseName:string, TableName:string}>, Location?:array{Jdbc?:array<array{Name:string, Value:string, Param?:bool}>, S3?:array<array{Name:string, Value:string, Param?:bool}>, DynamoDB?:array<array{Name:string, Value:string, Param?:bool}>}, Language?:"PYTHON"|"SCALA", AdditionalPlanOptionsMap?:array<string, string>} $args
     * @return \AWS\Result<array{PythonScript?:string, ScalaCode?:string}>
     */
    public function getPlan(array $args): \AWS\Result { }

    /**
     * @param array{Mapping:array<array{SourceTable?:string, SourcePath?:string, SourceType?:string, TargetTable?:string, TargetPath?:string, TargetType?:string}>, Source:array{DatabaseName:string, TableName:string}, Sinks?:array<array{DatabaseName:string, TableName:string}>, Location?:array{Jdbc?:array<array{Name:string, Value:string, Param?:bool}>, S3?:array<array{Name:string, Value:string, Param?:bool}>, DynamoDB?:array<array{Name:string, Value:string, Param?:bool}>}, Language?:"PYTHON"|"SCALA", AdditionalPlanOptionsMap?:array<string, string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{PythonScript?:string, ScalaCode?:string}>
     */
    public function getPlanAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{RegistryId:array{RegistryName?:string, RegistryArn?:string}} $args
     * @return \AWS\Result<array{RegistryName?:string, RegistryArn?:string, Description?:string, Status?:"AVAILABLE"|"DELETING", CreatedTime?:string, UpdatedTime?:string}>
     */
    public function getRegistry(array $args): \AWS\Result { }

    /**
     * @param array{RegistryId:array{RegistryName?:string, RegistryArn?:string}} $args
     * @return \GuzzleHttp\Promise\Promise<array{RegistryName?:string, RegistryArn?:string, Description?:string, Status?:"AVAILABLE"|"DELETING", CreatedTime?:string, UpdatedTime?:string}>
     */
    public function getRegistryAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{NextToken?:string, MaxResults?:int} $args
     * @return \AWS\Result<array{GetResourcePoliciesResponseList?:array<array{PolicyInJson?:string, PolicyHash?:string, CreateTime?:int|string|\DateTimeInterface, UpdateTime?:int|string|\DateTimeInterface}>, NextToken?:string}>
     */
    public function getResourcePolicies(array $args = []): \AWS\Result { }

    /**
     * @param array{NextToken?:string, MaxResults?:int} $args
     * @return \GuzzleHttp\Promise\Promise<array{GetResourcePoliciesResponseList?:array<array{PolicyInJson?:string, PolicyHash?:string, CreateTime?:int|string|\DateTimeInterface, UpdateTime?:int|string|\DateTimeInterface}>, NextToken?:string}>
     */
    public function getResourcePoliciesAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ResourceArn?:string} $args
     * @return \AWS\Result<array{PolicyInJson?:string, PolicyHash?:string, CreateTime?:int|string|\DateTimeInterface, UpdateTime?:int|string|\DateTimeInterface}>
     */
    public function getResourcePolicy(array $args = []): \AWS\Result { }

    /**
     * @param array{ResourceArn?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{PolicyInJson?:string, PolicyHash?:string, CreateTime?:int|string|\DateTimeInterface, UpdateTime?:int|string|\DateTimeInterface}>
     */
    public function getResourcePolicyAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{SchemaId:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}} $args
     * @return \AWS\Result<array{RegistryName?:string, RegistryArn?:string, SchemaName?:string, SchemaArn?:string, Description?:string, DataFormat?:"AVRO"|"JSON"|"PROTOBUF", Compatibility?:"NONE"|"DISABLED"|"BACKWARD"|"BACKWARD_ALL"|"FORWARD"|"FORWARD_ALL"|"FULL"|"FULL_ALL", SchemaCheckpoint?:int, LatestSchemaVersion?:int, NextSchemaVersion?:int, SchemaStatus?:"AVAILABLE"|"PENDING"|"DELETING", CreatedTime?:string, UpdatedTime?:string}>
     */
    public function getSchema(array $args): \AWS\Result { }

    /**
     * @param array{SchemaId:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}} $args
     * @return \GuzzleHttp\Promise\Promise<array{RegistryName?:string, RegistryArn?:string, SchemaName?:string, SchemaArn?:string, Description?:string, DataFormat?:"AVRO"|"JSON"|"PROTOBUF", Compatibility?:"NONE"|"DISABLED"|"BACKWARD"|"BACKWARD_ALL"|"FORWARD"|"FORWARD_ALL"|"FULL"|"FULL_ALL", SchemaCheckpoint?:int, LatestSchemaVersion?:int, NextSchemaVersion?:int, SchemaStatus?:"AVAILABLE"|"PENDING"|"DELETING", CreatedTime?:string, UpdatedTime?:string}>
     */
    public function getSchemaAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{SchemaId:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaDefinition:string} $args
     * @return \AWS\Result<array{SchemaVersionId?:string, SchemaArn?:string, DataFormat?:"AVRO"|"JSON"|"PROTOBUF", Status?:"AVAILABLE"|"PENDING"|"FAILURE"|"DELETING", CreatedTime?:string}>
     */
    public function getSchemaByDefinition(array $args): \AWS\Result { }

    /**
     * @param array{SchemaId:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaDefinition:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{SchemaVersionId?:string, SchemaArn?:string, DataFormat?:"AVRO"|"JSON"|"PROTOBUF", Status?:"AVAILABLE"|"PENDING"|"FAILURE"|"DELETING", CreatedTime?:string}>
     */
    public function getSchemaByDefinitionAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionId?:string, SchemaVersionNumber?:array{LatestVersion?:bool, VersionNumber?:int}} $args
     * @return \AWS\Result<array{SchemaVersionId?:string, SchemaDefinition?:string, DataFormat?:"AVRO"|"JSON"|"PROTOBUF", SchemaArn?:string, VersionNumber?:int, Status?:"AVAILABLE"|"PENDING"|"FAILURE"|"DELETING", CreatedTime?:string}>
     */
    public function getSchemaVersion(array $args = []): \AWS\Result { }

    /**
     * @param array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionId?:string, SchemaVersionNumber?:array{LatestVersion?:bool, VersionNumber?:int}} $args
     * @return \GuzzleHttp\Promise\Promise<array{SchemaVersionId?:string, SchemaDefinition?:string, DataFormat?:"AVRO"|"JSON"|"PROTOBUF", SchemaArn?:string, VersionNumber?:int, Status?:"AVAILABLE"|"PENDING"|"FAILURE"|"DELETING", CreatedTime?:string}>
     */
    public function getSchemaVersionAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{SchemaId:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, FirstSchemaVersionNumber:array{LatestVersion?:bool, VersionNumber?:int}, SecondSchemaVersionNumber:array{LatestVersion?:bool, VersionNumber?:int}, SchemaDiffType:"SYNTAX_DIFF"} $args
     * @return \AWS\Result<array{Diff?:string}>
     */
    public function getSchemaVersionsDiff(array $args): \AWS\Result { }

    /**
     * @param array{SchemaId:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, FirstSchemaVersionNumber:array{LatestVersion?:bool, VersionNumber?:int}, SecondSchemaVersionNumber:array{LatestVersion?:bool, VersionNumber?:int}, SchemaDiffType:"SYNTAX_DIFF"} $args
     * @return \GuzzleHttp\Promise\Promise<array{Diff?:string}>
     */
    public function getSchemaVersionsDiffAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Name:string} $args
     * @return \AWS\Result<array{SecurityConfiguration?:array{Name?:string, CreatedTimeStamp?:int|string|\DateTimeInterface, EncryptionConfiguration?:array{S3Encryption?:array<array{S3EncryptionMode?:"DISABLED"|"SSE-KMS"|"SSE-S3", KmsKeyArn?:string}>, CloudWatchEncryption?:array{CloudWatchEncryptionMode?:"DISABLED"|"SSE-KMS", KmsKeyArn?:string}, JobBookmarksEncryption?:array{JobBookmarksEncryptionMode?:"DISABLED"|"CSE-KMS", KmsKeyArn?:string}, DataQualityEncryption?:array{DataQualityEncryptionMode?:"DISABLED"|"SSE-KMS", KmsKeyArn?:string}}}}>
     */
    public function getSecurityConfiguration(array $args): \AWS\Result { }

    /**
     * @param array{Name:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{SecurityConfiguration?:array{Name?:string, CreatedTimeStamp?:int|string|\DateTimeInterface, EncryptionConfiguration?:array{S3Encryption?:array<array{S3EncryptionMode?:"DISABLED"|"SSE-KMS"|"SSE-S3", KmsKeyArn?:string}>, CloudWatchEncryption?:array{CloudWatchEncryptionMode?:"DISABLED"|"SSE-KMS", KmsKeyArn?:string}, JobBookmarksEncryption?:array{JobBookmarksEncryptionMode?:"DISABLED"|"CSE-KMS", KmsKeyArn?:string}, DataQualityEncryption?:array{DataQualityEncryptionMode?:"DISABLED"|"SSE-KMS", KmsKeyArn?:string}}}}>
     */
    public function getSecurityConfigurationAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{MaxResults?:int, NextToken?:string} $args
     * @return \AWS\Result<array{SecurityConfigurations?:array<array{Name?:string, CreatedTimeStamp?:int|string|\DateTimeInterface, EncryptionConfiguration?:array{S3Encryption?:array<array{S3EncryptionMode?:"DISABLED"|"SSE-KMS"|"SSE-S3", KmsKeyArn?:string}>, CloudWatchEncryption?:array{CloudWatchEncryptionMode?:"DISABLED"|"SSE-KMS", KmsKeyArn?:string}, JobBookmarksEncryption?:array{JobBookmarksEncryptionMode?:"DISABLED"|"CSE-KMS", KmsKeyArn?:string}, DataQualityEncryption?:array{DataQualityEncryptionMode?:"DISABLED"|"SSE-KMS", KmsKeyArn?:string}}}>, NextToken?:string}>
     */
    public function getSecurityConfigurations(array $args = []): \AWS\Result { }

    /**
     * @param array{MaxResults?:int, NextToken?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{SecurityConfigurations?:array<array{Name?:string, CreatedTimeStamp?:int|string|\DateTimeInterface, EncryptionConfiguration?:array{S3Encryption?:array<array{S3EncryptionMode?:"DISABLED"|"SSE-KMS"|"SSE-S3", KmsKeyArn?:string}>, CloudWatchEncryption?:array{CloudWatchEncryptionMode?:"DISABLED"|"SSE-KMS", KmsKeyArn?:string}, JobBookmarksEncryption?:array{JobBookmarksEncryptionMode?:"DISABLED"|"CSE-KMS", KmsKeyArn?:string}, DataQualityEncryption?:array{DataQualityEncryptionMode?:"DISABLED"|"SSE-KMS", KmsKeyArn?:string}}}>, NextToken?:string}>
     */
    public function getSecurityConfigurationsAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Id:string, RequestOrigin?:string} $args
     * @return \AWS\Result<array{Session?:array{Id?:string, CreatedOn?:int|string|\DateTimeInterface, Status?:"PROVISIONING"|"READY"|"FAILED"|"TIMEOUT"|"STOPPING"|"STOPPED", ErrorMessage?:string, Description?:string, Role?:string, Command?:array{Name?:string, PythonVersion?:string}, DefaultArguments?:array<string, string>, Connections?:array{Connections?:mixed}, Progress?:float, MaxCapacity?:float, SecurityConfiguration?:string, GlueVersion?:string, NumberOfWorkers?:int, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", CompletedOn?:int|string|\DateTimeInterface, ExecutionTime?:float, DPUSeconds?:float, IdleTimeout?:int, ProfileName?:string}}>
     */
    public function getSession(array $args): \AWS\Result { }

    /**
     * @param array{Id:string, RequestOrigin?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Session?:array{Id?:string, CreatedOn?:int|string|\DateTimeInterface, Status?:"PROVISIONING"|"READY"|"FAILED"|"TIMEOUT"|"STOPPING"|"STOPPED", ErrorMessage?:string, Description?:string, Role?:string, Command?:array{Name?:string, PythonVersion?:string}, DefaultArguments?:array<string, string>, Connections?:array{Connections?:mixed}, Progress?:float, MaxCapacity?:float, SecurityConfiguration?:string, GlueVersion?:string, NumberOfWorkers?:int, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", CompletedOn?:int|string|\DateTimeInterface, ExecutionTime?:float, DPUSeconds?:float, IdleTimeout?:int, ProfileName?:string}}>
     */
    public function getSessionAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{SessionId:string, Id:int, RequestOrigin?:string} $args
     * @return \AWS\Result<array{Statement?:array{Id?:int, Code?:string, State?:"WAITING"|"RUNNING"|"AVAILABLE"|"CANCELLING"|"CANCELLED"|"ERROR", Output?:array{Data?:array{TextPlain?:string}, ExecutionCount?:int, Status?:"WAITING"|"RUNNING"|"AVAILABLE"|"CANCELLING"|"CANCELLED"|"ERROR", ErrorName?:string, ErrorValue?:string, Traceback?:array<string>}, Progress?:float, StartedOn?:int, CompletedOn?:int}}>
     */
    public function getStatement(array $args): \AWS\Result { }

    /**
     * @param array{SessionId:string, Id:int, RequestOrigin?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Statement?:array{Id?:int, Code?:string, State?:"WAITING"|"RUNNING"|"AVAILABLE"|"CANCELLING"|"CANCELLED"|"ERROR", Output?:array{Data?:array{TextPlain?:string}, ExecutionCount?:int, Status?:"WAITING"|"RUNNING"|"AVAILABLE"|"CANCELLING"|"CANCELLED"|"ERROR", ErrorName?:string, ErrorValue?:string, Traceback?:array<string>}, Progress?:float, StartedOn?:int, CompletedOn?:int}}>
     */
    public function getStatementAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, Name:string, TransactionId?:string, QueryAsOfTime?:int|string|\DateTimeInterface, IncludeStatusDetails?:bool} $args
     * @return \AWS\Result<array{Table?:array{Name:string, DatabaseName?:string, Description?:string, Owner?:string, CreateTime?:int|string|\DateTimeInterface, UpdateTime?:int|string|\DateTimeInterface, LastAccessTime?:int|string|\DateTimeInterface, LastAnalyzedTime?:int|string|\DateTimeInterface, Retention?:int, StorageDescriptor?:array{Columns?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, Location?:string, AdditionalLocations?:array<string>, InputFormat?:string, OutputFormat?:string, Compressed?:bool, NumberOfBuckets?:int, SerdeInfo?:array{Name?:string, SerializationLibrary?:string, Parameters?:array<string, string>}, BucketColumns?:array<string>, SortColumns?:array<array{Column:string, SortOrder:int}>, Parameters?:array<string, string>, SkewedInfo?:array{SkewedColumnNames?:array<string>, SkewedColumnValues?:array<string>, SkewedColumnValueLocationMaps?:array<string, string>}, StoredAsSubDirectories?:bool, SchemaReference?:array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionId?:string, SchemaVersionNumber?:int}}, PartitionKeys?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, ViewOriginalText?:string, ViewExpandedText?:string, TableType?:string, Parameters?:array<string, string>, CreatedBy?:string, IsRegisteredWithLakeFormation?:bool, TargetTable?:array{CatalogId?:string, DatabaseName?:string, Name?:string, Region?:string}, CatalogId?:string, VersionId?:string, FederatedTable?:array{Identifier?:string, DatabaseIdentifier?:string, ConnectionName?:string}, ViewDefinition?:array{IsProtected?:bool, Definer?:string, SubObjects?:array<string>, Representations?:array<array{Dialect?:"REDSHIFT"|"ATHENA"|"SPARK", DialectVersion?:string, ViewOriginalText?:string, ViewExpandedText?:string, ValidationConnection?:string, IsStale?:bool}>}, IsMultiDialectView?:bool, Status?:array{RequestedBy?:string, UpdatedBy?:string, RequestTime?:int|string|\DateTimeInterface, UpdateTime?:int|string|\DateTimeInterface, Action?:"UPDATE"|"CREATE", State?:"QUEUED"|"IN_PROGRESS"|"SUCCESS"|"STOPPED"|"FAILED", Error?:array{ErrorCode?:string, ErrorMessage?:string}, Details?:array{RequestedChange?:array{Name:string, DatabaseName?:string, Description?:string, Owner?:string, CreateTime?:int|string|\DateTimeInterface, UpdateTime?:int|string|\DateTimeInterface, LastAccessTime?:int|string|\DateTimeInterface, LastAnalyzedTime?:int|string|\DateTimeInterface, Retention?:int, StorageDescriptor?:array{Columns?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, Location?:string, AdditionalLocations?:array<string>, InputFormat?:string, OutputFormat?:string, Compressed?:bool, NumberOfBuckets?:int, SerdeInfo?:array{Name?:string, SerializationLibrary?:string, Parameters?:array<string, string>}, BucketColumns?:array<string>, SortColumns?:array<array{Column:string, SortOrder:int}>, Parameters?:array<string, string>, SkewedInfo?:array{SkewedColumnNames?:array<string>, SkewedColumnValues?:array<string>, SkewedColumnValueLocationMaps?:array<string, string>}, StoredAsSubDirectories?:bool, SchemaReference?:array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionId?:string, SchemaVersionNumber?:int}}, PartitionKeys?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, ViewOriginalText?:string, ViewExpandedText?:string, TableType?:string, Parameters?:array<string, string>, CreatedBy?:string, IsRegisteredWithLakeFormation?:bool, TargetTable?:array{CatalogId?:string, DatabaseName?:string, Name?:string, Region?:string}, CatalogId?:string, VersionId?:string, FederatedTable?:array{Identifier?:string, DatabaseIdentifier?:string, ConnectionName?:string}, ViewDefinition?:array{IsProtected?:bool, Definer?:string, SubObjects?:array<string>, Representations?:array<array{Dialect?:"REDSHIFT"|"ATHENA"|"SPARK", DialectVersion?:string, ViewOriginalText?:string, ViewExpandedText?:string, ValidationConnection?:string, IsStale?:bool}>}, IsMultiDialectView?:bool, Status?:mixed}, ViewValidations?:array<array{Dialect?:"REDSHIFT"|"ATHENA"|"SPARK", DialectVersion?:string, ViewValidationText?:string, UpdateTime?:int|string|\DateTimeInterface, State?:"QUEUED"|"IN_PROGRESS"|"SUCCESS"|"STOPPED"|"FAILED", Error?:array{ErrorCode?:string, ErrorMessage?:string}}>}}}}>
     */
    public function getTable(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, Name:string, TransactionId?:string, QueryAsOfTime?:int|string|\DateTimeInterface, IncludeStatusDetails?:bool} $args
     * @return \GuzzleHttp\Promise\Promise<array{Table?:array{Name:string, DatabaseName?:string, Description?:string, Owner?:string, CreateTime?:int|string|\DateTimeInterface, UpdateTime?:int|string|\DateTimeInterface, LastAccessTime?:int|string|\DateTimeInterface, LastAnalyzedTime?:int|string|\DateTimeInterface, Retention?:int, StorageDescriptor?:array{Columns?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, Location?:string, AdditionalLocations?:array<string>, InputFormat?:string, OutputFormat?:string, Compressed?:bool, NumberOfBuckets?:int, SerdeInfo?:array{Name?:string, SerializationLibrary?:string, Parameters?:array<string, string>}, BucketColumns?:array<string>, SortColumns?:array<array{Column:string, SortOrder:int}>, Parameters?:array<string, string>, SkewedInfo?:array{SkewedColumnNames?:array<string>, SkewedColumnValues?:array<string>, SkewedColumnValueLocationMaps?:array<string, string>}, StoredAsSubDirectories?:bool, SchemaReference?:array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionId?:string, SchemaVersionNumber?:int}}, PartitionKeys?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, ViewOriginalText?:string, ViewExpandedText?:string, TableType?:string, Parameters?:array<string, string>, CreatedBy?:string, IsRegisteredWithLakeFormation?:bool, TargetTable?:array{CatalogId?:string, DatabaseName?:string, Name?:string, Region?:string}, CatalogId?:string, VersionId?:string, FederatedTable?:array{Identifier?:string, DatabaseIdentifier?:string, ConnectionName?:string}, ViewDefinition?:array{IsProtected?:bool, Definer?:string, SubObjects?:array<string>, Representations?:array<array{Dialect?:"REDSHIFT"|"ATHENA"|"SPARK", DialectVersion?:string, ViewOriginalText?:string, ViewExpandedText?:string, ValidationConnection?:string, IsStale?:bool}>}, IsMultiDialectView?:bool, Status?:array{RequestedBy?:string, UpdatedBy?:string, RequestTime?:int|string|\DateTimeInterface, UpdateTime?:int|string|\DateTimeInterface, Action?:"UPDATE"|"CREATE", State?:"QUEUED"|"IN_PROGRESS"|"SUCCESS"|"STOPPED"|"FAILED", Error?:array{ErrorCode?:string, ErrorMessage?:string}, Details?:array{RequestedChange?:array{Name:string, DatabaseName?:string, Description?:string, Owner?:string, CreateTime?:int|string|\DateTimeInterface, UpdateTime?:int|string|\DateTimeInterface, LastAccessTime?:int|string|\DateTimeInterface, LastAnalyzedTime?:int|string|\DateTimeInterface, Retention?:int, StorageDescriptor?:array{Columns?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, Location?:string, AdditionalLocations?:array<string>, InputFormat?:string, OutputFormat?:string, Compressed?:bool, NumberOfBuckets?:int, SerdeInfo?:array{Name?:string, SerializationLibrary?:string, Parameters?:array<string, string>}, BucketColumns?:array<string>, SortColumns?:array<array{Column:string, SortOrder:int}>, Parameters?:array<string, string>, SkewedInfo?:array{SkewedColumnNames?:array<string>, SkewedColumnValues?:array<string>, SkewedColumnValueLocationMaps?:array<string, string>}, StoredAsSubDirectories?:bool, SchemaReference?:array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionId?:string, SchemaVersionNumber?:int}}, PartitionKeys?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, ViewOriginalText?:string, ViewExpandedText?:string, TableType?:string, Parameters?:array<string, string>, CreatedBy?:string, IsRegisteredWithLakeFormation?:bool, TargetTable?:array{CatalogId?:string, DatabaseName?:string, Name?:string, Region?:string}, CatalogId?:string, VersionId?:string, FederatedTable?:array{Identifier?:string, DatabaseIdentifier?:string, ConnectionName?:string}, ViewDefinition?:array{IsProtected?:bool, Definer?:string, SubObjects?:array<string>, Representations?:array<array{Dialect?:"REDSHIFT"|"ATHENA"|"SPARK", DialectVersion?:string, ViewOriginalText?:string, ViewExpandedText?:string, ValidationConnection?:string, IsStale?:bool}>}, IsMultiDialectView?:bool, Status?:mixed}, ViewValidations?:array<array{Dialect?:"REDSHIFT"|"ATHENA"|"SPARK", DialectVersion?:string, ViewValidationText?:string, UpdateTime?:int|string|\DateTimeInterface, State?:"QUEUED"|"IN_PROGRESS"|"SUCCESS"|"STOPPED"|"FAILED", Error?:array{ErrorCode?:string, ErrorMessage?:string}}>}}}}>
     */
    public function getTableAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId:string, DatabaseName:string, TableName:string, Type:"compaction"|"retention"|"orphan_file_deletion"} $args
     * @return \AWS\Result<array{CatalogId?:string, DatabaseName?:string, TableName?:string, TableOptimizer?:array{type?:"compaction"|"retention"|"orphan_file_deletion", configuration?:array{roleArn?:string, enabled?:bool, vpcConfiguration?:array{glueConnectionName?:string}, retentionConfiguration?:array{icebergConfiguration?:array{snapshotRetentionPeriodInDays?:int, numberOfSnapshotsToRetain?:int, cleanExpiredFiles?:bool}}, orphanFileDeletionConfiguration?:array{icebergConfiguration?:array{orphanFileRetentionPeriodInDays?:int, location?:string}}}, lastRun?:array{eventType?:"starting"|"completed"|"failed"|"in_progress", startTimestamp?:int|string|\DateTimeInterface, endTimestamp?:int|string|\DateTimeInterface, metrics?:array{NumberOfBytesCompacted?:string, NumberOfFilesCompacted?:string, NumberOfDpus?:string, JobDurationInHour?:string}, error?:string, compactionMetrics?:array{IcebergMetrics?:array{NumberOfBytesCompacted?:int, NumberOfFilesCompacted?:int, NumberOfDpus?:int, JobDurationInHour?:float}}, retentionMetrics?:array{IcebergMetrics?:array{NumberOfDataFilesDeleted?:int, NumberOfManifestFilesDeleted?:int, NumberOfManifestListsDeleted?:int, NumberOfDpus?:int, JobDurationInHour?:float}}, orphanFileDeletionMetrics?:array{IcebergMetrics?:array{NumberOfOrphanFilesDeleted?:int, NumberOfDpus?:int, JobDurationInHour?:float}}}}}>
     */
    public function getTableOptimizer(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId:string, DatabaseName:string, TableName:string, Type:"compaction"|"retention"|"orphan_file_deletion"} $args
     * @return \GuzzleHttp\Promise\Promise<array{CatalogId?:string, DatabaseName?:string, TableName?:string, TableOptimizer?:array{type?:"compaction"|"retention"|"orphan_file_deletion", configuration?:array{roleArn?:string, enabled?:bool, vpcConfiguration?:array{glueConnectionName?:string}, retentionConfiguration?:array{icebergConfiguration?:array{snapshotRetentionPeriodInDays?:int, numberOfSnapshotsToRetain?:int, cleanExpiredFiles?:bool}}, orphanFileDeletionConfiguration?:array{icebergConfiguration?:array{orphanFileRetentionPeriodInDays?:int, location?:string}}}, lastRun?:array{eventType?:"starting"|"completed"|"failed"|"in_progress", startTimestamp?:int|string|\DateTimeInterface, endTimestamp?:int|string|\DateTimeInterface, metrics?:array{NumberOfBytesCompacted?:string, NumberOfFilesCompacted?:string, NumberOfDpus?:string, JobDurationInHour?:string}, error?:string, compactionMetrics?:array{IcebergMetrics?:array{NumberOfBytesCompacted?:int, NumberOfFilesCompacted?:int, NumberOfDpus?:int, JobDurationInHour?:float}}, retentionMetrics?:array{IcebergMetrics?:array{NumberOfDataFilesDeleted?:int, NumberOfManifestFilesDeleted?:int, NumberOfManifestListsDeleted?:int, NumberOfDpus?:int, JobDurationInHour?:float}}, orphanFileDeletionMetrics?:array{IcebergMetrics?:array{NumberOfOrphanFilesDeleted?:int, NumberOfDpus?:int, JobDurationInHour?:float}}}}}>
     */
    public function getTableOptimizerAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, TableName:string, VersionId?:string} $args
     * @return \AWS\Result<array{TableVersion?:array{Table?:array{Name:string, DatabaseName?:string, Description?:string, Owner?:string, CreateTime?:int|string|\DateTimeInterface, UpdateTime?:int|string|\DateTimeInterface, LastAccessTime?:int|string|\DateTimeInterface, LastAnalyzedTime?:int|string|\DateTimeInterface, Retention?:int, StorageDescriptor?:array{Columns?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, Location?:string, AdditionalLocations?:array<string>, InputFormat?:string, OutputFormat?:string, Compressed?:bool, NumberOfBuckets?:int, SerdeInfo?:array{Name?:string, SerializationLibrary?:string, Parameters?:array<string, string>}, BucketColumns?:array<string>, SortColumns?:array<array{Column:string, SortOrder:int}>, Parameters?:array<string, string>, SkewedInfo?:array{SkewedColumnNames?:array<string>, SkewedColumnValues?:array<string>, SkewedColumnValueLocationMaps?:array<string, string>}, StoredAsSubDirectories?:bool, SchemaReference?:array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionId?:string, SchemaVersionNumber?:int}}, PartitionKeys?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, ViewOriginalText?:string, ViewExpandedText?:string, TableType?:string, Parameters?:array<string, string>, CreatedBy?:string, IsRegisteredWithLakeFormation?:bool, TargetTable?:array{CatalogId?:string, DatabaseName?:string, Name?:string, Region?:string}, CatalogId?:string, VersionId?:string, FederatedTable?:array{Identifier?:string, DatabaseIdentifier?:string, ConnectionName?:string}, ViewDefinition?:array{IsProtected?:bool, Definer?:string, SubObjects?:array<string>, Representations?:array<array{Dialect?:"REDSHIFT"|"ATHENA"|"SPARK", DialectVersion?:string, ViewOriginalText?:string, ViewExpandedText?:string, ValidationConnection?:string, IsStale?:bool}>}, IsMultiDialectView?:bool, Status?:array{RequestedBy?:string, UpdatedBy?:string, RequestTime?:int|string|\DateTimeInterface, UpdateTime?:int|string|\DateTimeInterface, Action?:"UPDATE"|"CREATE", State?:"QUEUED"|"IN_PROGRESS"|"SUCCESS"|"STOPPED"|"FAILED", Error?:array{ErrorCode?:string, ErrorMessage?:string}, Details?:array{RequestedChange?:array{Name:string, DatabaseName?:string, Description?:string, Owner?:string, CreateTime?:int|string|\DateTimeInterface, UpdateTime?:int|string|\DateTimeInterface, LastAccessTime?:int|string|\DateTimeInterface, LastAnalyzedTime?:int|string|\DateTimeInterface, Retention?:int, StorageDescriptor?:array{Columns?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, Location?:string, AdditionalLocations?:array<string>, InputFormat?:string, OutputFormat?:string, Compressed?:bool, NumberOfBuckets?:int, SerdeInfo?:array{Name?:string, SerializationLibrary?:string, Parameters?:array<string, string>}, BucketColumns?:array<string>, SortColumns?:array<array{Column:string, SortOrder:int}>, Parameters?:array<string, string>, SkewedInfo?:array{SkewedColumnNames?:array<string>, SkewedColumnValues?:array<string>, SkewedColumnValueLocationMaps?:array<string, string>}, StoredAsSubDirectories?:bool, SchemaReference?:array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionId?:string, SchemaVersionNumber?:int}}, PartitionKeys?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, ViewOriginalText?:string, ViewExpandedText?:string, TableType?:string, Parameters?:array<string, string>, CreatedBy?:string, IsRegisteredWithLakeFormation?:bool, TargetTable?:array{CatalogId?:string, DatabaseName?:string, Name?:string, Region?:string}, CatalogId?:string, VersionId?:string, FederatedTable?:array{Identifier?:string, DatabaseIdentifier?:string, ConnectionName?:string}, ViewDefinition?:array{IsProtected?:bool, Definer?:string, SubObjects?:array<string>, Representations?:array<array{Dialect?:"REDSHIFT"|"ATHENA"|"SPARK", DialectVersion?:string, ViewOriginalText?:string, ViewExpandedText?:string, ValidationConnection?:string, IsStale?:bool}>}, IsMultiDialectView?:bool, Status?:mixed}, ViewValidations?:array<array{Dialect?:"REDSHIFT"|"ATHENA"|"SPARK", DialectVersion?:string, ViewValidationText?:string, UpdateTime?:int|string|\DateTimeInterface, State?:"QUEUED"|"IN_PROGRESS"|"SUCCESS"|"STOPPED"|"FAILED", Error?:array{ErrorCode?:string, ErrorMessage?:string}}>}}}, VersionId?:string}}>
     */
    public function getTableVersion(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, TableName:string, VersionId?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{TableVersion?:array{Table?:array{Name:string, DatabaseName?:string, Description?:string, Owner?:string, CreateTime?:int|string|\DateTimeInterface, UpdateTime?:int|string|\DateTimeInterface, LastAccessTime?:int|string|\DateTimeInterface, LastAnalyzedTime?:int|string|\DateTimeInterface, Retention?:int, StorageDescriptor?:array{Columns?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, Location?:string, AdditionalLocations?:array<string>, InputFormat?:string, OutputFormat?:string, Compressed?:bool, NumberOfBuckets?:int, SerdeInfo?:array{Name?:string, SerializationLibrary?:string, Parameters?:array<string, string>}, BucketColumns?:array<string>, SortColumns?:array<array{Column:string, SortOrder:int}>, Parameters?:array<string, string>, SkewedInfo?:array{SkewedColumnNames?:array<string>, SkewedColumnValues?:array<string>, SkewedColumnValueLocationMaps?:array<string, string>}, StoredAsSubDirectories?:bool, SchemaReference?:array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionId?:string, SchemaVersionNumber?:int}}, PartitionKeys?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, ViewOriginalText?:string, ViewExpandedText?:string, TableType?:string, Parameters?:array<string, string>, CreatedBy?:string, IsRegisteredWithLakeFormation?:bool, TargetTable?:array{CatalogId?:string, DatabaseName?:string, Name?:string, Region?:string}, CatalogId?:string, VersionId?:string, FederatedTable?:array{Identifier?:string, DatabaseIdentifier?:string, ConnectionName?:string}, ViewDefinition?:array{IsProtected?:bool, Definer?:string, SubObjects?:array<string>, Representations?:array<array{Dialect?:"REDSHIFT"|"ATHENA"|"SPARK", DialectVersion?:string, ViewOriginalText?:string, ViewExpandedText?:string, ValidationConnection?:string, IsStale?:bool}>}, IsMultiDialectView?:bool, Status?:array{RequestedBy?:string, UpdatedBy?:string, RequestTime?:int|string|\DateTimeInterface, UpdateTime?:int|string|\DateTimeInterface, Action?:"UPDATE"|"CREATE", State?:"QUEUED"|"IN_PROGRESS"|"SUCCESS"|"STOPPED"|"FAILED", Error?:array{ErrorCode?:string, ErrorMessage?:string}, Details?:array{RequestedChange?:array{Name:string, DatabaseName?:string, Description?:string, Owner?:string, CreateTime?:int|string|\DateTimeInterface, UpdateTime?:int|string|\DateTimeInterface, LastAccessTime?:int|string|\DateTimeInterface, LastAnalyzedTime?:int|string|\DateTimeInterface, Retention?:int, StorageDescriptor?:array{Columns?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, Location?:string, AdditionalLocations?:array<string>, InputFormat?:string, OutputFormat?:string, Compressed?:bool, NumberOfBuckets?:int, SerdeInfo?:array{Name?:string, SerializationLibrary?:string, Parameters?:array<string, string>}, BucketColumns?:array<string>, SortColumns?:array<array{Column:string, SortOrder:int}>, Parameters?:array<string, string>, SkewedInfo?:array{SkewedColumnNames?:array<string>, SkewedColumnValues?:array<string>, SkewedColumnValueLocationMaps?:array<string, string>}, StoredAsSubDirectories?:bool, SchemaReference?:array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionId?:string, SchemaVersionNumber?:int}}, PartitionKeys?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, ViewOriginalText?:string, ViewExpandedText?:string, TableType?:string, Parameters?:array<string, string>, CreatedBy?:string, IsRegisteredWithLakeFormation?:bool, TargetTable?:array{CatalogId?:string, DatabaseName?:string, Name?:string, Region?:string}, CatalogId?:string, VersionId?:string, FederatedTable?:array{Identifier?:string, DatabaseIdentifier?:string, ConnectionName?:string}, ViewDefinition?:array{IsProtected?:bool, Definer?:string, SubObjects?:array<string>, Representations?:array<array{Dialect?:"REDSHIFT"|"ATHENA"|"SPARK", DialectVersion?:string, ViewOriginalText?:string, ViewExpandedText?:string, ValidationConnection?:string, IsStale?:bool}>}, IsMultiDialectView?:bool, Status?:mixed}, ViewValidations?:array<array{Dialect?:"REDSHIFT"|"ATHENA"|"SPARK", DialectVersion?:string, ViewValidationText?:string, UpdateTime?:int|string|\DateTimeInterface, State?:"QUEUED"|"IN_PROGRESS"|"SUCCESS"|"STOPPED"|"FAILED", Error?:array{ErrorCode?:string, ErrorMessage?:string}}>}}}, VersionId?:string}}>
     */
    public function getTableVersionAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, TableName:string, NextToken?:string, MaxResults?:int} $args
     * @return \AWS\Result<array{TableVersions?:array<array{Table?:array{Name:string, DatabaseName?:string, Description?:string, Owner?:string, CreateTime?:int|string|\DateTimeInterface, UpdateTime?:int|string|\DateTimeInterface, LastAccessTime?:int|string|\DateTimeInterface, LastAnalyzedTime?:int|string|\DateTimeInterface, Retention?:int, StorageDescriptor?:array{Columns?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, Location?:string, AdditionalLocations?:array<string>, InputFormat?:string, OutputFormat?:string, Compressed?:bool, NumberOfBuckets?:int, SerdeInfo?:array{Name?:string, SerializationLibrary?:string, Parameters?:array<string, string>}, BucketColumns?:array<string>, SortColumns?:array<array{Column:string, SortOrder:int}>, Parameters?:array<string, string>, SkewedInfo?:array{SkewedColumnNames?:array<string>, SkewedColumnValues?:array<string>, SkewedColumnValueLocationMaps?:array<string, string>}, StoredAsSubDirectories?:bool, SchemaReference?:array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionId?:string, SchemaVersionNumber?:int}}, PartitionKeys?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, ViewOriginalText?:string, ViewExpandedText?:string, TableType?:string, Parameters?:array<string, string>, CreatedBy?:string, IsRegisteredWithLakeFormation?:bool, TargetTable?:array{CatalogId?:string, DatabaseName?:string, Name?:string, Region?:string}, CatalogId?:string, VersionId?:string, FederatedTable?:array{Identifier?:string, DatabaseIdentifier?:string, ConnectionName?:string}, ViewDefinition?:array{IsProtected?:bool, Definer?:string, SubObjects?:array<string>, Representations?:array<array{Dialect?:"REDSHIFT"|"ATHENA"|"SPARK", DialectVersion?:string, ViewOriginalText?:string, ViewExpandedText?:string, ValidationConnection?:string, IsStale?:bool}>}, IsMultiDialectView?:bool, Status?:array{RequestedBy?:string, UpdatedBy?:string, RequestTime?:int|string|\DateTimeInterface, UpdateTime?:int|string|\DateTimeInterface, Action?:"UPDATE"|"CREATE", State?:"QUEUED"|"IN_PROGRESS"|"SUCCESS"|"STOPPED"|"FAILED", Error?:array{ErrorCode?:string, ErrorMessage?:string}, Details?:array{RequestedChange?:array{Name:string, DatabaseName?:string, Description?:string, Owner?:string, CreateTime?:int|string|\DateTimeInterface, UpdateTime?:int|string|\DateTimeInterface, LastAccessTime?:int|string|\DateTimeInterface, LastAnalyzedTime?:int|string|\DateTimeInterface, Retention?:int, StorageDescriptor?:array{Columns?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, Location?:string, AdditionalLocations?:array<string>, InputFormat?:string, OutputFormat?:string, Compressed?:bool, NumberOfBuckets?:int, SerdeInfo?:array{Name?:string, SerializationLibrary?:string, Parameters?:array<string, string>}, BucketColumns?:array<string>, SortColumns?:array<array{Column:string, SortOrder:int}>, Parameters?:array<string, string>, SkewedInfo?:array{SkewedColumnNames?:array<string>, SkewedColumnValues?:array<string>, SkewedColumnValueLocationMaps?:array<string, string>}, StoredAsSubDirectories?:bool, SchemaReference?:array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionId?:string, SchemaVersionNumber?:int}}, PartitionKeys?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, ViewOriginalText?:string, ViewExpandedText?:string, TableType?:string, Parameters?:array<string, string>, CreatedBy?:string, IsRegisteredWithLakeFormation?:bool, TargetTable?:array{CatalogId?:string, DatabaseName?:string, Name?:string, Region?:string}, CatalogId?:string, VersionId?:string, FederatedTable?:array{Identifier?:string, DatabaseIdentifier?:string, ConnectionName?:string}, ViewDefinition?:array{IsProtected?:bool, Definer?:string, SubObjects?:array<string>, Representations?:array<array{Dialect?:"REDSHIFT"|"ATHENA"|"SPARK", DialectVersion?:string, ViewOriginalText?:string, ViewExpandedText?:string, ValidationConnection?:string, IsStale?:bool}>}, IsMultiDialectView?:bool, Status?:mixed}, ViewValidations?:array<array{Dialect?:"REDSHIFT"|"ATHENA"|"SPARK", DialectVersion?:string, ViewValidationText?:string, UpdateTime?:int|string|\DateTimeInterface, State?:"QUEUED"|"IN_PROGRESS"|"SUCCESS"|"STOPPED"|"FAILED", Error?:array{ErrorCode?:string, ErrorMessage?:string}}>}}}, VersionId?:string}>, NextToken?:string}>
     */
    public function getTableVersions(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, TableName:string, NextToken?:string, MaxResults?:int} $args
     * @return \GuzzleHttp\Promise\Promise<array{TableVersions?:array<array{Table?:array{Name:string, DatabaseName?:string, Description?:string, Owner?:string, CreateTime?:int|string|\DateTimeInterface, UpdateTime?:int|string|\DateTimeInterface, LastAccessTime?:int|string|\DateTimeInterface, LastAnalyzedTime?:int|string|\DateTimeInterface, Retention?:int, StorageDescriptor?:array{Columns?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, Location?:string, AdditionalLocations?:array<string>, InputFormat?:string, OutputFormat?:string, Compressed?:bool, NumberOfBuckets?:int, SerdeInfo?:array{Name?:string, SerializationLibrary?:string, Parameters?:array<string, string>}, BucketColumns?:array<string>, SortColumns?:array<array{Column:string, SortOrder:int}>, Parameters?:array<string, string>, SkewedInfo?:array{SkewedColumnNames?:array<string>, SkewedColumnValues?:array<string>, SkewedColumnValueLocationMaps?:array<string, string>}, StoredAsSubDirectories?:bool, SchemaReference?:array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionId?:string, SchemaVersionNumber?:int}}, PartitionKeys?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, ViewOriginalText?:string, ViewExpandedText?:string, TableType?:string, Parameters?:array<string, string>, CreatedBy?:string, IsRegisteredWithLakeFormation?:bool, TargetTable?:array{CatalogId?:string, DatabaseName?:string, Name?:string, Region?:string}, CatalogId?:string, VersionId?:string, FederatedTable?:array{Identifier?:string, DatabaseIdentifier?:string, ConnectionName?:string}, ViewDefinition?:array{IsProtected?:bool, Definer?:string, SubObjects?:array<string>, Representations?:array<array{Dialect?:"REDSHIFT"|"ATHENA"|"SPARK", DialectVersion?:string, ViewOriginalText?:string, ViewExpandedText?:string, ValidationConnection?:string, IsStale?:bool}>}, IsMultiDialectView?:bool, Status?:array{RequestedBy?:string, UpdatedBy?:string, RequestTime?:int|string|\DateTimeInterface, UpdateTime?:int|string|\DateTimeInterface, Action?:"UPDATE"|"CREATE", State?:"QUEUED"|"IN_PROGRESS"|"SUCCESS"|"STOPPED"|"FAILED", Error?:array{ErrorCode?:string, ErrorMessage?:string}, Details?:array{RequestedChange?:array{Name:string, DatabaseName?:string, Description?:string, Owner?:string, CreateTime?:int|string|\DateTimeInterface, UpdateTime?:int|string|\DateTimeInterface, LastAccessTime?:int|string|\DateTimeInterface, LastAnalyzedTime?:int|string|\DateTimeInterface, Retention?:int, StorageDescriptor?:array{Columns?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, Location?:string, AdditionalLocations?:array<string>, InputFormat?:string, OutputFormat?:string, Compressed?:bool, NumberOfBuckets?:int, SerdeInfo?:array{Name?:string, SerializationLibrary?:string, Parameters?:array<string, string>}, BucketColumns?:array<string>, SortColumns?:array<array{Column:string, SortOrder:int}>, Parameters?:array<string, string>, SkewedInfo?:array{SkewedColumnNames?:array<string>, SkewedColumnValues?:array<string>, SkewedColumnValueLocationMaps?:array<string, string>}, StoredAsSubDirectories?:bool, SchemaReference?:array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionId?:string, SchemaVersionNumber?:int}}, PartitionKeys?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, ViewOriginalText?:string, ViewExpandedText?:string, TableType?:string, Parameters?:array<string, string>, CreatedBy?:string, IsRegisteredWithLakeFormation?:bool, TargetTable?:array{CatalogId?:string, DatabaseName?:string, Name?:string, Region?:string}, CatalogId?:string, VersionId?:string, FederatedTable?:array{Identifier?:string, DatabaseIdentifier?:string, ConnectionName?:string}, ViewDefinition?:array{IsProtected?:bool, Definer?:string, SubObjects?:array<string>, Representations?:array<array{Dialect?:"REDSHIFT"|"ATHENA"|"SPARK", DialectVersion?:string, ViewOriginalText?:string, ViewExpandedText?:string, ValidationConnection?:string, IsStale?:bool}>}, IsMultiDialectView?:bool, Status?:mixed}, ViewValidations?:array<array{Dialect?:"REDSHIFT"|"ATHENA"|"SPARK", DialectVersion?:string, ViewValidationText?:string, UpdateTime?:int|string|\DateTimeInterface, State?:"QUEUED"|"IN_PROGRESS"|"SUCCESS"|"STOPPED"|"FAILED", Error?:array{ErrorCode?:string, ErrorMessage?:string}}>}}}, VersionId?:string}>, NextToken?:string}>
     */
    public function getTableVersionsAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, Expression?:string, NextToken?:string, MaxResults?:int, TransactionId?:string, QueryAsOfTime?:int|string|\DateTimeInterface, IncludeStatusDetails?:bool, AttributesToGet?:array<"NAME"|"TABLE_TYPE">} $args
     * @return \AWS\Result<array{TableList?:array<array{Name:string, DatabaseName?:string, Description?:string, Owner?:string, CreateTime?:int|string|\DateTimeInterface, UpdateTime?:int|string|\DateTimeInterface, LastAccessTime?:int|string|\DateTimeInterface, LastAnalyzedTime?:int|string|\DateTimeInterface, Retention?:int, StorageDescriptor?:array{Columns?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, Location?:string, AdditionalLocations?:array<string>, InputFormat?:string, OutputFormat?:string, Compressed?:bool, NumberOfBuckets?:int, SerdeInfo?:array{Name?:string, SerializationLibrary?:string, Parameters?:array<string, string>}, BucketColumns?:array<string>, SortColumns?:array<array{Column:string, SortOrder:int}>, Parameters?:array<string, string>, SkewedInfo?:array{SkewedColumnNames?:array<string>, SkewedColumnValues?:array<string>, SkewedColumnValueLocationMaps?:array<string, string>}, StoredAsSubDirectories?:bool, SchemaReference?:array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionId?:string, SchemaVersionNumber?:int}}, PartitionKeys?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, ViewOriginalText?:string, ViewExpandedText?:string, TableType?:string, Parameters?:array<string, string>, CreatedBy?:string, IsRegisteredWithLakeFormation?:bool, TargetTable?:array{CatalogId?:string, DatabaseName?:string, Name?:string, Region?:string}, CatalogId?:string, VersionId?:string, FederatedTable?:array{Identifier?:string, DatabaseIdentifier?:string, ConnectionName?:string}, ViewDefinition?:array{IsProtected?:bool, Definer?:string, SubObjects?:array<string>, Representations?:array<array{Dialect?:"REDSHIFT"|"ATHENA"|"SPARK", DialectVersion?:string, ViewOriginalText?:string, ViewExpandedText?:string, ValidationConnection?:string, IsStale?:bool}>}, IsMultiDialectView?:bool, Status?:array{RequestedBy?:string, UpdatedBy?:string, RequestTime?:int|string|\DateTimeInterface, UpdateTime?:int|string|\DateTimeInterface, Action?:"UPDATE"|"CREATE", State?:"QUEUED"|"IN_PROGRESS"|"SUCCESS"|"STOPPED"|"FAILED", Error?:array{ErrorCode?:string, ErrorMessage?:string}, Details?:array{RequestedChange?:array{Name:string, DatabaseName?:string, Description?:string, Owner?:string, CreateTime?:int|string|\DateTimeInterface, UpdateTime?:int|string|\DateTimeInterface, LastAccessTime?:int|string|\DateTimeInterface, LastAnalyzedTime?:int|string|\DateTimeInterface, Retention?:int, StorageDescriptor?:array{Columns?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, Location?:string, AdditionalLocations?:array<string>, InputFormat?:string, OutputFormat?:string, Compressed?:bool, NumberOfBuckets?:int, SerdeInfo?:array{Name?:string, SerializationLibrary?:string, Parameters?:array<string, string>}, BucketColumns?:array<string>, SortColumns?:array<array{Column:string, SortOrder:int}>, Parameters?:array<string, string>, SkewedInfo?:array{SkewedColumnNames?:array<string>, SkewedColumnValues?:array<string>, SkewedColumnValueLocationMaps?:array<string, string>}, StoredAsSubDirectories?:bool, SchemaReference?:array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionId?:string, SchemaVersionNumber?:int}}, PartitionKeys?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, ViewOriginalText?:string, ViewExpandedText?:string, TableType?:string, Parameters?:array<string, string>, CreatedBy?:string, IsRegisteredWithLakeFormation?:bool, TargetTable?:array{CatalogId?:string, DatabaseName?:string, Name?:string, Region?:string}, CatalogId?:string, VersionId?:string, FederatedTable?:array{Identifier?:string, DatabaseIdentifier?:string, ConnectionName?:string}, ViewDefinition?:array{IsProtected?:bool, Definer?:string, SubObjects?:array<string>, Representations?:array<array{Dialect?:"REDSHIFT"|"ATHENA"|"SPARK", DialectVersion?:string, ViewOriginalText?:string, ViewExpandedText?:string, ValidationConnection?:string, IsStale?:bool}>}, IsMultiDialectView?:bool, Status?:mixed}, ViewValidations?:array<array{Dialect?:"REDSHIFT"|"ATHENA"|"SPARK", DialectVersion?:string, ViewValidationText?:string, UpdateTime?:int|string|\DateTimeInterface, State?:"QUEUED"|"IN_PROGRESS"|"SUCCESS"|"STOPPED"|"FAILED", Error?:array{ErrorCode?:string, ErrorMessage?:string}}>}}}>, NextToken?:string}>
     */
    public function getTables(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, Expression?:string, NextToken?:string, MaxResults?:int, TransactionId?:string, QueryAsOfTime?:int|string|\DateTimeInterface, IncludeStatusDetails?:bool, AttributesToGet?:array<"NAME"|"TABLE_TYPE">} $args
     * @return \GuzzleHttp\Promise\Promise<array{TableList?:array<array{Name:string, DatabaseName?:string, Description?:string, Owner?:string, CreateTime?:int|string|\DateTimeInterface, UpdateTime?:int|string|\DateTimeInterface, LastAccessTime?:int|string|\DateTimeInterface, LastAnalyzedTime?:int|string|\DateTimeInterface, Retention?:int, StorageDescriptor?:array{Columns?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, Location?:string, AdditionalLocations?:array<string>, InputFormat?:string, OutputFormat?:string, Compressed?:bool, NumberOfBuckets?:int, SerdeInfo?:array{Name?:string, SerializationLibrary?:string, Parameters?:array<string, string>}, BucketColumns?:array<string>, SortColumns?:array<array{Column:string, SortOrder:int}>, Parameters?:array<string, string>, SkewedInfo?:array{SkewedColumnNames?:array<string>, SkewedColumnValues?:array<string>, SkewedColumnValueLocationMaps?:array<string, string>}, StoredAsSubDirectories?:bool, SchemaReference?:array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionId?:string, SchemaVersionNumber?:int}}, PartitionKeys?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, ViewOriginalText?:string, ViewExpandedText?:string, TableType?:string, Parameters?:array<string, string>, CreatedBy?:string, IsRegisteredWithLakeFormation?:bool, TargetTable?:array{CatalogId?:string, DatabaseName?:string, Name?:string, Region?:string}, CatalogId?:string, VersionId?:string, FederatedTable?:array{Identifier?:string, DatabaseIdentifier?:string, ConnectionName?:string}, ViewDefinition?:array{IsProtected?:bool, Definer?:string, SubObjects?:array<string>, Representations?:array<array{Dialect?:"REDSHIFT"|"ATHENA"|"SPARK", DialectVersion?:string, ViewOriginalText?:string, ViewExpandedText?:string, ValidationConnection?:string, IsStale?:bool}>}, IsMultiDialectView?:bool, Status?:array{RequestedBy?:string, UpdatedBy?:string, RequestTime?:int|string|\DateTimeInterface, UpdateTime?:int|string|\DateTimeInterface, Action?:"UPDATE"|"CREATE", State?:"QUEUED"|"IN_PROGRESS"|"SUCCESS"|"STOPPED"|"FAILED", Error?:array{ErrorCode?:string, ErrorMessage?:string}, Details?:array{RequestedChange?:array{Name:string, DatabaseName?:string, Description?:string, Owner?:string, CreateTime?:int|string|\DateTimeInterface, UpdateTime?:int|string|\DateTimeInterface, LastAccessTime?:int|string|\DateTimeInterface, LastAnalyzedTime?:int|string|\DateTimeInterface, Retention?:int, StorageDescriptor?:array{Columns?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, Location?:string, AdditionalLocations?:array<string>, InputFormat?:string, OutputFormat?:string, Compressed?:bool, NumberOfBuckets?:int, SerdeInfo?:array{Name?:string, SerializationLibrary?:string, Parameters?:array<string, string>}, BucketColumns?:array<string>, SortColumns?:array<array{Column:string, SortOrder:int}>, Parameters?:array<string, string>, SkewedInfo?:array{SkewedColumnNames?:array<string>, SkewedColumnValues?:array<string>, SkewedColumnValueLocationMaps?:array<string, string>}, StoredAsSubDirectories?:bool, SchemaReference?:array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionId?:string, SchemaVersionNumber?:int}}, PartitionKeys?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, ViewOriginalText?:string, ViewExpandedText?:string, TableType?:string, Parameters?:array<string, string>, CreatedBy?:string, IsRegisteredWithLakeFormation?:bool, TargetTable?:array{CatalogId?:string, DatabaseName?:string, Name?:string, Region?:string}, CatalogId?:string, VersionId?:string, FederatedTable?:array{Identifier?:string, DatabaseIdentifier?:string, ConnectionName?:string}, ViewDefinition?:array{IsProtected?:bool, Definer?:string, SubObjects?:array<string>, Representations?:array<array{Dialect?:"REDSHIFT"|"ATHENA"|"SPARK", DialectVersion?:string, ViewOriginalText?:string, ViewExpandedText?:string, ValidationConnection?:string, IsStale?:bool}>}, IsMultiDialectView?:bool, Status?:mixed}, ViewValidations?:array<array{Dialect?:"REDSHIFT"|"ATHENA"|"SPARK", DialectVersion?:string, ViewValidationText?:string, UpdateTime?:int|string|\DateTimeInterface, State?:"QUEUED"|"IN_PROGRESS"|"SUCCESS"|"STOPPED"|"FAILED", Error?:array{ErrorCode?:string, ErrorMessage?:string}}>}}}>, NextToken?:string}>
     */
    public function getTablesAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ResourceArn:string} $args
     * @return \AWS\Result<array{Tags?:array<string, string>}>
     */
    public function getTags(array $args): \AWS\Result { }

    /**
     * @param array{ResourceArn:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Tags?:array<string, string>}>
     */
    public function getTagsAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Name:string} $args
     * @return \AWS\Result<array{Trigger?:array{Name?:string, WorkflowName?:string, Id?:string, Type?:"SCHEDULED"|"CONDITIONAL"|"ON_DEMAND"|"EVENT", State?:"CREATING"|"CREATED"|"ACTIVATING"|"ACTIVATED"|"DEACTIVATING"|"DEACTIVATED"|"DELETING"|"UPDATING", Description?:string, Schedule?:string, Actions?:array<array{JobName?:string, Arguments?:array<string, string>, Timeout?:int, SecurityConfiguration?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, CrawlerName?:string}>, Predicate?:array{Logical?:"AND"|"ANY", Conditions?:array<array{LogicalOperator?:"EQUALS", JobName?:string, State?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED", CrawlerName?:string, CrawlState?:"RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR"}>}, EventBatchingCondition?:array{BatchSize:int, BatchWindow?:int}}}>
     */
    public function getTrigger(array $args): \AWS\Result { }

    /**
     * @param array{Name:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Trigger?:array{Name?:string, WorkflowName?:string, Id?:string, Type?:"SCHEDULED"|"CONDITIONAL"|"ON_DEMAND"|"EVENT", State?:"CREATING"|"CREATED"|"ACTIVATING"|"ACTIVATED"|"DEACTIVATING"|"DEACTIVATED"|"DELETING"|"UPDATING", Description?:string, Schedule?:string, Actions?:array<array{JobName?:string, Arguments?:array<string, string>, Timeout?:int, SecurityConfiguration?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, CrawlerName?:string}>, Predicate?:array{Logical?:"AND"|"ANY", Conditions?:array<array{LogicalOperator?:"EQUALS", JobName?:string, State?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED", CrawlerName?:string, CrawlState?:"RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR"}>}, EventBatchingCondition?:array{BatchSize:int, BatchWindow?:int}}}>
     */
    public function getTriggerAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{NextToken?:string, DependentJobName?:string, MaxResults?:int} $args
     * @return \AWS\Result<array{Triggers?:array<array{Name?:string, WorkflowName?:string, Id?:string, Type?:"SCHEDULED"|"CONDITIONAL"|"ON_DEMAND"|"EVENT", State?:"CREATING"|"CREATED"|"ACTIVATING"|"ACTIVATED"|"DEACTIVATING"|"DEACTIVATED"|"DELETING"|"UPDATING", Description?:string, Schedule?:string, Actions?:array<array{JobName?:string, Arguments?:array<string, string>, Timeout?:int, SecurityConfiguration?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, CrawlerName?:string}>, Predicate?:array{Logical?:"AND"|"ANY", Conditions?:array<array{LogicalOperator?:"EQUALS", JobName?:string, State?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED", CrawlerName?:string, CrawlState?:"RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR"}>}, EventBatchingCondition?:array{BatchSize:int, BatchWindow?:int}}>, NextToken?:string}>
     */
    public function getTriggers(array $args = []): \AWS\Result { }

    /**
     * @param array{NextToken?:string, DependentJobName?:string, MaxResults?:int} $args
     * @return \GuzzleHttp\Promise\Promise<array{Triggers?:array<array{Name?:string, WorkflowName?:string, Id?:string, Type?:"SCHEDULED"|"CONDITIONAL"|"ON_DEMAND"|"EVENT", State?:"CREATING"|"CREATED"|"ACTIVATING"|"ACTIVATED"|"DEACTIVATING"|"DEACTIVATED"|"DELETING"|"UPDATING", Description?:string, Schedule?:string, Actions?:array<array{JobName?:string, Arguments?:array<string, string>, Timeout?:int, SecurityConfiguration?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, CrawlerName?:string}>, Predicate?:array{Logical?:"AND"|"ANY", Conditions?:array<array{LogicalOperator?:"EQUALS", JobName?:string, State?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED", CrawlerName?:string, CrawlState?:"RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR"}>}, EventBatchingCondition?:array{BatchSize:int, BatchWindow?:int}}>, NextToken?:string}>
     */
    public function getTriggersAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Region?:string, CatalogId:string, DatabaseName:string, TableName:string, PartitionValues:array<string>, AuditContext?:array{AdditionalAuditContext?:string, RequestedColumns?:array<string>, AllColumnsRequested?:bool}, SupportedPermissionTypes:array<"COLUMN_PERMISSION"|"CELL_FILTER_PERMISSION"|"NESTED_PERMISSION"|"NESTED_CELL_PERMISSION">, QuerySessionContext?:array{QueryId?:string, QueryStartTime?:int|string|\DateTimeInterface, ClusterId?:string, QueryAuthorizationId?:string, AdditionalContext?:array<string, string>}} $args
     * @return \AWS\Result<array{Partition?:array{Values?:array<string>, DatabaseName?:string, TableName?:string, CreationTime?:int|string|\DateTimeInterface, LastAccessTime?:int|string|\DateTimeInterface, StorageDescriptor?:array{Columns?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, Location?:string, AdditionalLocations?:array<string>, InputFormat?:string, OutputFormat?:string, Compressed?:bool, NumberOfBuckets?:int, SerdeInfo?:array{Name?:string, SerializationLibrary?:string, Parameters?:array<string, string>}, BucketColumns?:array<string>, SortColumns?:array<array{Column:string, SortOrder:int}>, Parameters?:array<string, string>, SkewedInfo?:array{SkewedColumnNames?:array<string>, SkewedColumnValues?:array<string>, SkewedColumnValueLocationMaps?:array<string, string>}, StoredAsSubDirectories?:bool, SchemaReference?:array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionId?:string, SchemaVersionNumber?:int}}, Parameters?:array<string, string>, LastAnalyzedTime?:int|string|\DateTimeInterface, CatalogId?:string}, AuthorizedColumns?:array<string>, IsRegisteredWithLakeFormation?:bool}>
     */
    public function getUnfilteredPartitionMetadata(array $args): \AWS\Result { }

    /**
     * @param array{Region?:string, CatalogId:string, DatabaseName:string, TableName:string, PartitionValues:array<string>, AuditContext?:array{AdditionalAuditContext?:string, RequestedColumns?:array<string>, AllColumnsRequested?:bool}, SupportedPermissionTypes:array<"COLUMN_PERMISSION"|"CELL_FILTER_PERMISSION"|"NESTED_PERMISSION"|"NESTED_CELL_PERMISSION">, QuerySessionContext?:array{QueryId?:string, QueryStartTime?:int|string|\DateTimeInterface, ClusterId?:string, QueryAuthorizationId?:string, AdditionalContext?:array<string, string>}} $args
     * @return \GuzzleHttp\Promise\Promise<array{Partition?:array{Values?:array<string>, DatabaseName?:string, TableName?:string, CreationTime?:int|string|\DateTimeInterface, LastAccessTime?:int|string|\DateTimeInterface, StorageDescriptor?:array{Columns?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, Location?:string, AdditionalLocations?:array<string>, InputFormat?:string, OutputFormat?:string, Compressed?:bool, NumberOfBuckets?:int, SerdeInfo?:array{Name?:string, SerializationLibrary?:string, Parameters?:array<string, string>}, BucketColumns?:array<string>, SortColumns?:array<array{Column:string, SortOrder:int}>, Parameters?:array<string, string>, SkewedInfo?:array{SkewedColumnNames?:array<string>, SkewedColumnValues?:array<string>, SkewedColumnValueLocationMaps?:array<string, string>}, StoredAsSubDirectories?:bool, SchemaReference?:array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionId?:string, SchemaVersionNumber?:int}}, Parameters?:array<string, string>, LastAnalyzedTime?:int|string|\DateTimeInterface, CatalogId?:string}, AuthorizedColumns?:array<string>, IsRegisteredWithLakeFormation?:bool}>
     */
    public function getUnfilteredPartitionMetadataAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Region?:string, CatalogId:string, DatabaseName:string, TableName:string, Expression?:string, AuditContext?:array{AdditionalAuditContext?:string, RequestedColumns?:array<string>, AllColumnsRequested?:bool}, SupportedPermissionTypes:array<"COLUMN_PERMISSION"|"CELL_FILTER_PERMISSION"|"NESTED_PERMISSION"|"NESTED_CELL_PERMISSION">, NextToken?:string, Segment?:array{SegmentNumber:int, TotalSegments:int}, MaxResults?:int, QuerySessionContext?:array{QueryId?:string, QueryStartTime?:int|string|\DateTimeInterface, ClusterId?:string, QueryAuthorizationId?:string, AdditionalContext?:array<string, string>}} $args
     * @return \AWS\Result<array{UnfilteredPartitions?:array<array{Partition?:array{Values?:array<string>, DatabaseName?:string, TableName?:string, CreationTime?:int|string|\DateTimeInterface, LastAccessTime?:int|string|\DateTimeInterface, StorageDescriptor?:array{Columns?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, Location?:string, AdditionalLocations?:array<string>, InputFormat?:string, OutputFormat?:string, Compressed?:bool, NumberOfBuckets?:int, SerdeInfo?:array{Name?:string, SerializationLibrary?:string, Parameters?:array<string, string>}, BucketColumns?:array<string>, SortColumns?:array<array{Column:string, SortOrder:int}>, Parameters?:array<string, string>, SkewedInfo?:array{SkewedColumnNames?:array<string>, SkewedColumnValues?:array<string>, SkewedColumnValueLocationMaps?:array<string, string>}, StoredAsSubDirectories?:bool, SchemaReference?:array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionId?:string, SchemaVersionNumber?:int}}, Parameters?:array<string, string>, LastAnalyzedTime?:int|string|\DateTimeInterface, CatalogId?:string}, AuthorizedColumns?:array<string>, IsRegisteredWithLakeFormation?:bool}>, NextToken?:string}>
     */
    public function getUnfilteredPartitionsMetadata(array $args): \AWS\Result { }

    /**
     * @param array{Region?:string, CatalogId:string, DatabaseName:string, TableName:string, Expression?:string, AuditContext?:array{AdditionalAuditContext?:string, RequestedColumns?:array<string>, AllColumnsRequested?:bool}, SupportedPermissionTypes:array<"COLUMN_PERMISSION"|"CELL_FILTER_PERMISSION"|"NESTED_PERMISSION"|"NESTED_CELL_PERMISSION">, NextToken?:string, Segment?:array{SegmentNumber:int, TotalSegments:int}, MaxResults?:int, QuerySessionContext?:array{QueryId?:string, QueryStartTime?:int|string|\DateTimeInterface, ClusterId?:string, QueryAuthorizationId?:string, AdditionalContext?:array<string, string>}} $args
     * @return \GuzzleHttp\Promise\Promise<array{UnfilteredPartitions?:array<array{Partition?:array{Values?:array<string>, DatabaseName?:string, TableName?:string, CreationTime?:int|string|\DateTimeInterface, LastAccessTime?:int|string|\DateTimeInterface, StorageDescriptor?:array{Columns?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, Location?:string, AdditionalLocations?:array<string>, InputFormat?:string, OutputFormat?:string, Compressed?:bool, NumberOfBuckets?:int, SerdeInfo?:array{Name?:string, SerializationLibrary?:string, Parameters?:array<string, string>}, BucketColumns?:array<string>, SortColumns?:array<array{Column:string, SortOrder:int}>, Parameters?:array<string, string>, SkewedInfo?:array{SkewedColumnNames?:array<string>, SkewedColumnValues?:array<string>, SkewedColumnValueLocationMaps?:array<string, string>}, StoredAsSubDirectories?:bool, SchemaReference?:array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionId?:string, SchemaVersionNumber?:int}}, Parameters?:array<string, string>, LastAnalyzedTime?:int|string|\DateTimeInterface, CatalogId?:string}, AuthorizedColumns?:array<string>, IsRegisteredWithLakeFormation?:bool}>, NextToken?:string}>
     */
    public function getUnfilteredPartitionsMetadataAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Region?:string, CatalogId:string, DatabaseName:string, Name:string, AuditContext?:array{AdditionalAuditContext?:string, RequestedColumns?:array<string>, AllColumnsRequested?:bool}, SupportedPermissionTypes:array<"COLUMN_PERMISSION"|"CELL_FILTER_PERMISSION"|"NESTED_PERMISSION"|"NESTED_CELL_PERMISSION">, ParentResourceArn?:string, RootResourceArn?:string, SupportedDialect?:array{Dialect?:"REDSHIFT"|"ATHENA"|"SPARK", DialectVersion?:string}, Permissions?:array<"ALL"|"SELECT"|"ALTER"|"DROP"|"DELETE"|"INSERT"|"CREATE_DATABASE"|"CREATE_TABLE"|"DATA_LOCATION_ACCESS">, QuerySessionContext?:array{QueryId?:string, QueryStartTime?:int|string|\DateTimeInterface, ClusterId?:string, QueryAuthorizationId?:string, AdditionalContext?:array<string, string>}} $args
     * @return \AWS\Result<array{Table?:array{Name:string, DatabaseName?:string, Description?:string, Owner?:string, CreateTime?:int|string|\DateTimeInterface, UpdateTime?:int|string|\DateTimeInterface, LastAccessTime?:int|string|\DateTimeInterface, LastAnalyzedTime?:int|string|\DateTimeInterface, Retention?:int, StorageDescriptor?:array{Columns?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, Location?:string, AdditionalLocations?:array<string>, InputFormat?:string, OutputFormat?:string, Compressed?:bool, NumberOfBuckets?:int, SerdeInfo?:array{Name?:string, SerializationLibrary?:string, Parameters?:array<string, string>}, BucketColumns?:array<string>, SortColumns?:array<array{Column:string, SortOrder:int}>, Parameters?:array<string, string>, SkewedInfo?:array{SkewedColumnNames?:array<string>, SkewedColumnValues?:array<string>, SkewedColumnValueLocationMaps?:array<string, string>}, StoredAsSubDirectories?:bool, SchemaReference?:array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionId?:string, SchemaVersionNumber?:int}}, PartitionKeys?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, ViewOriginalText?:string, ViewExpandedText?:string, TableType?:string, Parameters?:array<string, string>, CreatedBy?:string, IsRegisteredWithLakeFormation?:bool, TargetTable?:array{CatalogId?:string, DatabaseName?:string, Name?:string, Region?:string}, CatalogId?:string, VersionId?:string, FederatedTable?:array{Identifier?:string, DatabaseIdentifier?:string, ConnectionName?:string}, ViewDefinition?:array{IsProtected?:bool, Definer?:string, SubObjects?:array<string>, Representations?:array<array{Dialect?:"REDSHIFT"|"ATHENA"|"SPARK", DialectVersion?:string, ViewOriginalText?:string, ViewExpandedText?:string, ValidationConnection?:string, IsStale?:bool}>}, IsMultiDialectView?:bool, Status?:array{RequestedBy?:string, UpdatedBy?:string, RequestTime?:int|string|\DateTimeInterface, UpdateTime?:int|string|\DateTimeInterface, Action?:"UPDATE"|"CREATE", State?:"QUEUED"|"IN_PROGRESS"|"SUCCESS"|"STOPPED"|"FAILED", Error?:array{ErrorCode?:string, ErrorMessage?:string}, Details?:array{RequestedChange?:array{Name:string, DatabaseName?:string, Description?:string, Owner?:string, CreateTime?:int|string|\DateTimeInterface, UpdateTime?:int|string|\DateTimeInterface, LastAccessTime?:int|string|\DateTimeInterface, LastAnalyzedTime?:int|string|\DateTimeInterface, Retention?:int, StorageDescriptor?:array{Columns?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, Location?:string, AdditionalLocations?:array<string>, InputFormat?:string, OutputFormat?:string, Compressed?:bool, NumberOfBuckets?:int, SerdeInfo?:array{Name?:string, SerializationLibrary?:string, Parameters?:array<string, string>}, BucketColumns?:array<string>, SortColumns?:array<array{Column:string, SortOrder:int}>, Parameters?:array<string, string>, SkewedInfo?:array{SkewedColumnNames?:array<string>, SkewedColumnValues?:array<string>, SkewedColumnValueLocationMaps?:array<string, string>}, StoredAsSubDirectories?:bool, SchemaReference?:array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionId?:string, SchemaVersionNumber?:int}}, PartitionKeys?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, ViewOriginalText?:string, ViewExpandedText?:string, TableType?:string, Parameters?:array<string, string>, CreatedBy?:string, IsRegisteredWithLakeFormation?:bool, TargetTable?:array{CatalogId?:string, DatabaseName?:string, Name?:string, Region?:string}, CatalogId?:string, VersionId?:string, FederatedTable?:array{Identifier?:string, DatabaseIdentifier?:string, ConnectionName?:string}, ViewDefinition?:array{IsProtected?:bool, Definer?:string, SubObjects?:array<string>, Representations?:array<array{Dialect?:"REDSHIFT"|"ATHENA"|"SPARK", DialectVersion?:string, ViewOriginalText?:string, ViewExpandedText?:string, ValidationConnection?:string, IsStale?:bool}>}, IsMultiDialectView?:bool, Status?:mixed}, ViewValidations?:array<array{Dialect?:"REDSHIFT"|"ATHENA"|"SPARK", DialectVersion?:string, ViewValidationText?:string, UpdateTime?:int|string|\DateTimeInterface, State?:"QUEUED"|"IN_PROGRESS"|"SUCCESS"|"STOPPED"|"FAILED", Error?:array{ErrorCode?:string, ErrorMessage?:string}}>}}}, AuthorizedColumns?:array<string>, IsRegisteredWithLakeFormation?:bool, CellFilters?:array<array{ColumnName?:string, RowFilterExpression?:string}>, QueryAuthorizationId?:string, IsMultiDialectView?:bool, ResourceArn?:string, IsProtected?:bool, Permissions?:array<"ALL"|"SELECT"|"ALTER"|"DROP"|"DELETE"|"INSERT"|"CREATE_DATABASE"|"CREATE_TABLE"|"DATA_LOCATION_ACCESS">, RowFilter?:string}>
     */
    public function getUnfilteredTableMetadata(array $args): \AWS\Result { }

    /**
     * @param array{Region?:string, CatalogId:string, DatabaseName:string, Name:string, AuditContext?:array{AdditionalAuditContext?:string, RequestedColumns?:array<string>, AllColumnsRequested?:bool}, SupportedPermissionTypes:array<"COLUMN_PERMISSION"|"CELL_FILTER_PERMISSION"|"NESTED_PERMISSION"|"NESTED_CELL_PERMISSION">, ParentResourceArn?:string, RootResourceArn?:string, SupportedDialect?:array{Dialect?:"REDSHIFT"|"ATHENA"|"SPARK", DialectVersion?:string}, Permissions?:array<"ALL"|"SELECT"|"ALTER"|"DROP"|"DELETE"|"INSERT"|"CREATE_DATABASE"|"CREATE_TABLE"|"DATA_LOCATION_ACCESS">, QuerySessionContext?:array{QueryId?:string, QueryStartTime?:int|string|\DateTimeInterface, ClusterId?:string, QueryAuthorizationId?:string, AdditionalContext?:array<string, string>}} $args
     * @return \GuzzleHttp\Promise\Promise<array{Table?:array{Name:string, DatabaseName?:string, Description?:string, Owner?:string, CreateTime?:int|string|\DateTimeInterface, UpdateTime?:int|string|\DateTimeInterface, LastAccessTime?:int|string|\DateTimeInterface, LastAnalyzedTime?:int|string|\DateTimeInterface, Retention?:int, StorageDescriptor?:array{Columns?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, Location?:string, AdditionalLocations?:array<string>, InputFormat?:string, OutputFormat?:string, Compressed?:bool, NumberOfBuckets?:int, SerdeInfo?:array{Name?:string, SerializationLibrary?:string, Parameters?:array<string, string>}, BucketColumns?:array<string>, SortColumns?:array<array{Column:string, SortOrder:int}>, Parameters?:array<string, string>, SkewedInfo?:array{SkewedColumnNames?:array<string>, SkewedColumnValues?:array<string>, SkewedColumnValueLocationMaps?:array<string, string>}, StoredAsSubDirectories?:bool, SchemaReference?:array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionId?:string, SchemaVersionNumber?:int}}, PartitionKeys?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, ViewOriginalText?:string, ViewExpandedText?:string, TableType?:string, Parameters?:array<string, string>, CreatedBy?:string, IsRegisteredWithLakeFormation?:bool, TargetTable?:array{CatalogId?:string, DatabaseName?:string, Name?:string, Region?:string}, CatalogId?:string, VersionId?:string, FederatedTable?:array{Identifier?:string, DatabaseIdentifier?:string, ConnectionName?:string}, ViewDefinition?:array{IsProtected?:bool, Definer?:string, SubObjects?:array<string>, Representations?:array<array{Dialect?:"REDSHIFT"|"ATHENA"|"SPARK", DialectVersion?:string, ViewOriginalText?:string, ViewExpandedText?:string, ValidationConnection?:string, IsStale?:bool}>}, IsMultiDialectView?:bool, Status?:array{RequestedBy?:string, UpdatedBy?:string, RequestTime?:int|string|\DateTimeInterface, UpdateTime?:int|string|\DateTimeInterface, Action?:"UPDATE"|"CREATE", State?:"QUEUED"|"IN_PROGRESS"|"SUCCESS"|"STOPPED"|"FAILED", Error?:array{ErrorCode?:string, ErrorMessage?:string}, Details?:array{RequestedChange?:array{Name:string, DatabaseName?:string, Description?:string, Owner?:string, CreateTime?:int|string|\DateTimeInterface, UpdateTime?:int|string|\DateTimeInterface, LastAccessTime?:int|string|\DateTimeInterface, LastAnalyzedTime?:int|string|\DateTimeInterface, Retention?:int, StorageDescriptor?:array{Columns?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, Location?:string, AdditionalLocations?:array<string>, InputFormat?:string, OutputFormat?:string, Compressed?:bool, NumberOfBuckets?:int, SerdeInfo?:array{Name?:string, SerializationLibrary?:string, Parameters?:array<string, string>}, BucketColumns?:array<string>, SortColumns?:array<array{Column:string, SortOrder:int}>, Parameters?:array<string, string>, SkewedInfo?:array{SkewedColumnNames?:array<string>, SkewedColumnValues?:array<string>, SkewedColumnValueLocationMaps?:array<string, string>}, StoredAsSubDirectories?:bool, SchemaReference?:array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionId?:string, SchemaVersionNumber?:int}}, PartitionKeys?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, ViewOriginalText?:string, ViewExpandedText?:string, TableType?:string, Parameters?:array<string, string>, CreatedBy?:string, IsRegisteredWithLakeFormation?:bool, TargetTable?:array{CatalogId?:string, DatabaseName?:string, Name?:string, Region?:string}, CatalogId?:string, VersionId?:string, FederatedTable?:array{Identifier?:string, DatabaseIdentifier?:string, ConnectionName?:string}, ViewDefinition?:array{IsProtected?:bool, Definer?:string, SubObjects?:array<string>, Representations?:array<array{Dialect?:"REDSHIFT"|"ATHENA"|"SPARK", DialectVersion?:string, ViewOriginalText?:string, ViewExpandedText?:string, ValidationConnection?:string, IsStale?:bool}>}, IsMultiDialectView?:bool, Status?:mixed}, ViewValidations?:array<array{Dialect?:"REDSHIFT"|"ATHENA"|"SPARK", DialectVersion?:string, ViewValidationText?:string, UpdateTime?:int|string|\DateTimeInterface, State?:"QUEUED"|"IN_PROGRESS"|"SUCCESS"|"STOPPED"|"FAILED", Error?:array{ErrorCode?:string, ErrorMessage?:string}}>}}}, AuthorizedColumns?:array<string>, IsRegisteredWithLakeFormation?:bool, CellFilters?:array<array{ColumnName?:string, RowFilterExpression?:string}>, QueryAuthorizationId?:string, IsMultiDialectView?:bool, ResourceArn?:string, IsProtected?:bool, Permissions?:array<"ALL"|"SELECT"|"ALTER"|"DROP"|"DELETE"|"INSERT"|"CREATE_DATABASE"|"CREATE_TABLE"|"DATA_LOCATION_ACCESS">, RowFilter?:string}>
     */
    public function getUnfilteredTableMetadataAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Name:string} $args
     * @return \AWS\Result<array{Name?:string, Description?:string, Configuration?:array{SessionConfiguration?:array<string, array{DefaultValue?:string, AllowedValues?:array<string>, MinValue?:string, MaxValue?:string}>, JobConfiguration?:array<string, array{DefaultValue?:string, AllowedValues?:array<string>, MinValue?:string, MaxValue?:string}>}, CreatedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface}>
     */
    public function getUsageProfile(array $args): \AWS\Result { }

    /**
     * @param array{Name:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Name?:string, Description?:string, Configuration?:array{SessionConfiguration?:array<string, array{DefaultValue?:string, AllowedValues?:array<string>, MinValue?:string, MaxValue?:string}>, JobConfiguration?:array<string, array{DefaultValue?:string, AllowedValues?:array<string>, MinValue?:string, MaxValue?:string}>}, CreatedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface}>
     */
    public function getUsageProfileAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, FunctionName:string} $args
     * @return \AWS\Result<array{UserDefinedFunction?:array{FunctionName?:string, DatabaseName?:string, ClassName?:string, OwnerName?:string, OwnerType?:"USER"|"ROLE"|"GROUP", CreateTime?:int|string|\DateTimeInterface, ResourceUris?:array<array{ResourceType?:"JAR"|"FILE"|"ARCHIVE", Uri?:string}>, CatalogId?:string}}>
     */
    public function getUserDefinedFunction(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, FunctionName:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{UserDefinedFunction?:array{FunctionName?:string, DatabaseName?:string, ClassName?:string, OwnerName?:string, OwnerType?:"USER"|"ROLE"|"GROUP", CreateTime?:int|string|\DateTimeInterface, ResourceUris?:array<array{ResourceType?:"JAR"|"FILE"|"ARCHIVE", Uri?:string}>, CatalogId?:string}}>
     */
    public function getUserDefinedFunctionAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId?:string, DatabaseName?:string, Pattern:string, NextToken?:string, MaxResults?:int} $args
     * @return \AWS\Result<array{UserDefinedFunctions?:array<array{FunctionName?:string, DatabaseName?:string, ClassName?:string, OwnerName?:string, OwnerType?:"USER"|"ROLE"|"GROUP", CreateTime?:int|string|\DateTimeInterface, ResourceUris?:array<array{ResourceType?:"JAR"|"FILE"|"ARCHIVE", Uri?:string}>, CatalogId?:string}>, NextToken?:string}>
     */
    public function getUserDefinedFunctions(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId?:string, DatabaseName?:string, Pattern:string, NextToken?:string, MaxResults?:int} $args
     * @return \GuzzleHttp\Promise\Promise<array{UserDefinedFunctions?:array<array{FunctionName?:string, DatabaseName?:string, ClassName?:string, OwnerName?:string, OwnerType?:"USER"|"ROLE"|"GROUP", CreateTime?:int|string|\DateTimeInterface, ResourceUris?:array<array{ResourceType?:"JAR"|"FILE"|"ARCHIVE", Uri?:string}>, CatalogId?:string}>, NextToken?:string}>
     */
    public function getUserDefinedFunctionsAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Name:string, IncludeGraph?:bool} $args
     * @return \AWS\Result<array{Workflow?:array{Name?:string, Description?:string, DefaultRunProperties?:array<string, string>, CreatedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface, LastRun?:array{Name?:string, WorkflowRunId?:string, PreviousRunId?:string, WorkflowRunProperties?:array<string, string>, StartedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, Status?:"RUNNING"|"COMPLETED"|"STOPPING"|"STOPPED"|"ERROR", ErrorMessage?:string, Statistics?:array{TotalActions?:int, TimeoutActions?:int, FailedActions?:int, StoppedActions?:int, SucceededActions?:int, RunningActions?:int, ErroredActions?:int, WaitingActions?:int}, Graph?:array{Nodes?:array<array{Type?:"CRAWLER"|"JOB"|"TRIGGER", Name?:string, UniqueId?:string, TriggerDetails?:array{Trigger?:array{Name?:string, WorkflowName?:string, Id?:string, Type?:"SCHEDULED"|"CONDITIONAL"|"ON_DEMAND"|"EVENT", State?:"CREATING"|"CREATED"|"ACTIVATING"|"ACTIVATED"|"DEACTIVATING"|"DEACTIVATED"|"DELETING"|"UPDATING", Description?:string, Schedule?:string, Actions?:array<array{JobName?:string, Arguments?:array<string, string>, Timeout?:int, SecurityConfiguration?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, CrawlerName?:string}>, Predicate?:array{Logical?:"AND"|"ANY", Conditions?:array<array{LogicalOperator?:"EQUALS", JobName?:string, State?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED", CrawlerName?:string, CrawlState?:"RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR"}>}, EventBatchingCondition?:array{BatchSize:int, BatchWindow?:int}}}, JobDetails?:array{JobRuns?:array<array{Id?:string, Attempt?:int, PreviousRunId?:string, TriggerName?:string, JobName?:string, JobMode?:"SCRIPT"|"VISUAL"|"NOTEBOOK", JobRunQueuingEnabled?:bool, StartedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, JobRunState?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED", Arguments?:array<string, string>, ErrorMessage?:string, PredecessorRuns?:array<array{JobName?:string, RunId?:string}>, AllocatedCapacity?:int, ExecutionTime?:int, Timeout?:int, MaxCapacity?:float, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", NumberOfWorkers?:int, SecurityConfiguration?:string, LogGroupName?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, GlueVersion?:string, DPUSeconds?:float, ExecutionClass?:"FLEX"|"STANDARD", MaintenanceWindow?:string, ProfileName?:string, StateDetail?:string}>}, CrawlerDetails?:array{Crawls?:array<array{State?:"RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR", StartedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, ErrorMessage?:string, LogGroup?:string, LogStream?:string}>}}>, Edges?:array<array{SourceId?:string, DestinationId?:string}>}, StartingEventBatchCondition?:array{BatchSize?:int, BatchWindow?:int}}, Graph?:array{Nodes?:array<array{Type?:"CRAWLER"|"JOB"|"TRIGGER", Name?:string, UniqueId?:string, TriggerDetails?:array{Trigger?:array{Name?:string, WorkflowName?:string, Id?:string, Type?:"SCHEDULED"|"CONDITIONAL"|"ON_DEMAND"|"EVENT", State?:"CREATING"|"CREATED"|"ACTIVATING"|"ACTIVATED"|"DEACTIVATING"|"DEACTIVATED"|"DELETING"|"UPDATING", Description?:string, Schedule?:string, Actions?:array<array{JobName?:string, Arguments?:array<string, string>, Timeout?:int, SecurityConfiguration?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, CrawlerName?:string}>, Predicate?:array{Logical?:"AND"|"ANY", Conditions?:array<array{LogicalOperator?:"EQUALS", JobName?:string, State?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED", CrawlerName?:string, CrawlState?:"RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR"}>}, EventBatchingCondition?:array{BatchSize:int, BatchWindow?:int}}}, JobDetails?:array{JobRuns?:array<array{Id?:string, Attempt?:int, PreviousRunId?:string, TriggerName?:string, JobName?:string, JobMode?:"SCRIPT"|"VISUAL"|"NOTEBOOK", JobRunQueuingEnabled?:bool, StartedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, JobRunState?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED", Arguments?:array<string, string>, ErrorMessage?:string, PredecessorRuns?:array<array{JobName?:string, RunId?:string}>, AllocatedCapacity?:int, ExecutionTime?:int, Timeout?:int, MaxCapacity?:float, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", NumberOfWorkers?:int, SecurityConfiguration?:string, LogGroupName?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, GlueVersion?:string, DPUSeconds?:float, ExecutionClass?:"FLEX"|"STANDARD", MaintenanceWindow?:string, ProfileName?:string, StateDetail?:string}>}, CrawlerDetails?:array{Crawls?:array<array{State?:"RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR", StartedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, ErrorMessage?:string, LogGroup?:string, LogStream?:string}>}}>, Edges?:array<array{SourceId?:string, DestinationId?:string}>}, MaxConcurrentRuns?:int, BlueprintDetails?:array{BlueprintName?:string, RunId?:string}}}>
     */
    public function getWorkflow(array $args): \AWS\Result { }

    /**
     * @param array{Name:string, IncludeGraph?:bool} $args
     * @return \GuzzleHttp\Promise\Promise<array{Workflow?:array{Name?:string, Description?:string, DefaultRunProperties?:array<string, string>, CreatedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface, LastRun?:array{Name?:string, WorkflowRunId?:string, PreviousRunId?:string, WorkflowRunProperties?:array<string, string>, StartedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, Status?:"RUNNING"|"COMPLETED"|"STOPPING"|"STOPPED"|"ERROR", ErrorMessage?:string, Statistics?:array{TotalActions?:int, TimeoutActions?:int, FailedActions?:int, StoppedActions?:int, SucceededActions?:int, RunningActions?:int, ErroredActions?:int, WaitingActions?:int}, Graph?:array{Nodes?:array<array{Type?:"CRAWLER"|"JOB"|"TRIGGER", Name?:string, UniqueId?:string, TriggerDetails?:array{Trigger?:array{Name?:string, WorkflowName?:string, Id?:string, Type?:"SCHEDULED"|"CONDITIONAL"|"ON_DEMAND"|"EVENT", State?:"CREATING"|"CREATED"|"ACTIVATING"|"ACTIVATED"|"DEACTIVATING"|"DEACTIVATED"|"DELETING"|"UPDATING", Description?:string, Schedule?:string, Actions?:array<array{JobName?:string, Arguments?:array<string, string>, Timeout?:int, SecurityConfiguration?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, CrawlerName?:string}>, Predicate?:array{Logical?:"AND"|"ANY", Conditions?:array<array{LogicalOperator?:"EQUALS", JobName?:string, State?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED", CrawlerName?:string, CrawlState?:"RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR"}>}, EventBatchingCondition?:array{BatchSize:int, BatchWindow?:int}}}, JobDetails?:array{JobRuns?:array<array{Id?:string, Attempt?:int, PreviousRunId?:string, TriggerName?:string, JobName?:string, JobMode?:"SCRIPT"|"VISUAL"|"NOTEBOOK", JobRunQueuingEnabled?:bool, StartedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, JobRunState?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED", Arguments?:array<string, string>, ErrorMessage?:string, PredecessorRuns?:array<array{JobName?:string, RunId?:string}>, AllocatedCapacity?:int, ExecutionTime?:int, Timeout?:int, MaxCapacity?:float, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", NumberOfWorkers?:int, SecurityConfiguration?:string, LogGroupName?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, GlueVersion?:string, DPUSeconds?:float, ExecutionClass?:"FLEX"|"STANDARD", MaintenanceWindow?:string, ProfileName?:string, StateDetail?:string}>}, CrawlerDetails?:array{Crawls?:array<array{State?:"RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR", StartedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, ErrorMessage?:string, LogGroup?:string, LogStream?:string}>}}>, Edges?:array<array{SourceId?:string, DestinationId?:string}>}, StartingEventBatchCondition?:array{BatchSize?:int, BatchWindow?:int}}, Graph?:array{Nodes?:array<array{Type?:"CRAWLER"|"JOB"|"TRIGGER", Name?:string, UniqueId?:string, TriggerDetails?:array{Trigger?:array{Name?:string, WorkflowName?:string, Id?:string, Type?:"SCHEDULED"|"CONDITIONAL"|"ON_DEMAND"|"EVENT", State?:"CREATING"|"CREATED"|"ACTIVATING"|"ACTIVATED"|"DEACTIVATING"|"DEACTIVATED"|"DELETING"|"UPDATING", Description?:string, Schedule?:string, Actions?:array<array{JobName?:string, Arguments?:array<string, string>, Timeout?:int, SecurityConfiguration?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, CrawlerName?:string}>, Predicate?:array{Logical?:"AND"|"ANY", Conditions?:array<array{LogicalOperator?:"EQUALS", JobName?:string, State?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED", CrawlerName?:string, CrawlState?:"RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR"}>}, EventBatchingCondition?:array{BatchSize:int, BatchWindow?:int}}}, JobDetails?:array{JobRuns?:array<array{Id?:string, Attempt?:int, PreviousRunId?:string, TriggerName?:string, JobName?:string, JobMode?:"SCRIPT"|"VISUAL"|"NOTEBOOK", JobRunQueuingEnabled?:bool, StartedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, JobRunState?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED", Arguments?:array<string, string>, ErrorMessage?:string, PredecessorRuns?:array<array{JobName?:string, RunId?:string}>, AllocatedCapacity?:int, ExecutionTime?:int, Timeout?:int, MaxCapacity?:float, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", NumberOfWorkers?:int, SecurityConfiguration?:string, LogGroupName?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, GlueVersion?:string, DPUSeconds?:float, ExecutionClass?:"FLEX"|"STANDARD", MaintenanceWindow?:string, ProfileName?:string, StateDetail?:string}>}, CrawlerDetails?:array{Crawls?:array<array{State?:"RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR", StartedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, ErrorMessage?:string, LogGroup?:string, LogStream?:string}>}}>, Edges?:array<array{SourceId?:string, DestinationId?:string}>}, MaxConcurrentRuns?:int, BlueprintDetails?:array{BlueprintName?:string, RunId?:string}}}>
     */
    public function getWorkflowAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Name:string, RunId:string, IncludeGraph?:bool} $args
     * @return \AWS\Result<array{Run?:array{Name?:string, WorkflowRunId?:string, PreviousRunId?:string, WorkflowRunProperties?:array<string, string>, StartedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, Status?:"RUNNING"|"COMPLETED"|"STOPPING"|"STOPPED"|"ERROR", ErrorMessage?:string, Statistics?:array{TotalActions?:int, TimeoutActions?:int, FailedActions?:int, StoppedActions?:int, SucceededActions?:int, RunningActions?:int, ErroredActions?:int, WaitingActions?:int}, Graph?:array{Nodes?:array<array{Type?:"CRAWLER"|"JOB"|"TRIGGER", Name?:string, UniqueId?:string, TriggerDetails?:array{Trigger?:array{Name?:string, WorkflowName?:string, Id?:string, Type?:"SCHEDULED"|"CONDITIONAL"|"ON_DEMAND"|"EVENT", State?:"CREATING"|"CREATED"|"ACTIVATING"|"ACTIVATED"|"DEACTIVATING"|"DEACTIVATED"|"DELETING"|"UPDATING", Description?:string, Schedule?:string, Actions?:array<array{JobName?:string, Arguments?:array<string, string>, Timeout?:int, SecurityConfiguration?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, CrawlerName?:string}>, Predicate?:array{Logical?:"AND"|"ANY", Conditions?:array<array{LogicalOperator?:"EQUALS", JobName?:string, State?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED", CrawlerName?:string, CrawlState?:"RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR"}>}, EventBatchingCondition?:array{BatchSize:int, BatchWindow?:int}}}, JobDetails?:array{JobRuns?:array<array{Id?:string, Attempt?:int, PreviousRunId?:string, TriggerName?:string, JobName?:string, JobMode?:"SCRIPT"|"VISUAL"|"NOTEBOOK", JobRunQueuingEnabled?:bool, StartedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, JobRunState?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED", Arguments?:array<string, string>, ErrorMessage?:string, PredecessorRuns?:array<array{JobName?:string, RunId?:string}>, AllocatedCapacity?:int, ExecutionTime?:int, Timeout?:int, MaxCapacity?:float, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", NumberOfWorkers?:int, SecurityConfiguration?:string, LogGroupName?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, GlueVersion?:string, DPUSeconds?:float, ExecutionClass?:"FLEX"|"STANDARD", MaintenanceWindow?:string, ProfileName?:string, StateDetail?:string}>}, CrawlerDetails?:array{Crawls?:array<array{State?:"RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR", StartedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, ErrorMessage?:string, LogGroup?:string, LogStream?:string}>}}>, Edges?:array<array{SourceId?:string, DestinationId?:string}>}, StartingEventBatchCondition?:array{BatchSize?:int, BatchWindow?:int}}}>
     */
    public function getWorkflowRun(array $args): \AWS\Result { }

    /**
     * @param array{Name:string, RunId:string, IncludeGraph?:bool} $args
     * @return \GuzzleHttp\Promise\Promise<array{Run?:array{Name?:string, WorkflowRunId?:string, PreviousRunId?:string, WorkflowRunProperties?:array<string, string>, StartedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, Status?:"RUNNING"|"COMPLETED"|"STOPPING"|"STOPPED"|"ERROR", ErrorMessage?:string, Statistics?:array{TotalActions?:int, TimeoutActions?:int, FailedActions?:int, StoppedActions?:int, SucceededActions?:int, RunningActions?:int, ErroredActions?:int, WaitingActions?:int}, Graph?:array{Nodes?:array<array{Type?:"CRAWLER"|"JOB"|"TRIGGER", Name?:string, UniqueId?:string, TriggerDetails?:array{Trigger?:array{Name?:string, WorkflowName?:string, Id?:string, Type?:"SCHEDULED"|"CONDITIONAL"|"ON_DEMAND"|"EVENT", State?:"CREATING"|"CREATED"|"ACTIVATING"|"ACTIVATED"|"DEACTIVATING"|"DEACTIVATED"|"DELETING"|"UPDATING", Description?:string, Schedule?:string, Actions?:array<array{JobName?:string, Arguments?:array<string, string>, Timeout?:int, SecurityConfiguration?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, CrawlerName?:string}>, Predicate?:array{Logical?:"AND"|"ANY", Conditions?:array<array{LogicalOperator?:"EQUALS", JobName?:string, State?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED", CrawlerName?:string, CrawlState?:"RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR"}>}, EventBatchingCondition?:array{BatchSize:int, BatchWindow?:int}}}, JobDetails?:array{JobRuns?:array<array{Id?:string, Attempt?:int, PreviousRunId?:string, TriggerName?:string, JobName?:string, JobMode?:"SCRIPT"|"VISUAL"|"NOTEBOOK", JobRunQueuingEnabled?:bool, StartedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, JobRunState?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED", Arguments?:array<string, string>, ErrorMessage?:string, PredecessorRuns?:array<array{JobName?:string, RunId?:string}>, AllocatedCapacity?:int, ExecutionTime?:int, Timeout?:int, MaxCapacity?:float, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", NumberOfWorkers?:int, SecurityConfiguration?:string, LogGroupName?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, GlueVersion?:string, DPUSeconds?:float, ExecutionClass?:"FLEX"|"STANDARD", MaintenanceWindow?:string, ProfileName?:string, StateDetail?:string}>}, CrawlerDetails?:array{Crawls?:array<array{State?:"RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR", StartedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, ErrorMessage?:string, LogGroup?:string, LogStream?:string}>}}>, Edges?:array<array{SourceId?:string, DestinationId?:string}>}, StartingEventBatchCondition?:array{BatchSize?:int, BatchWindow?:int}}}>
     */
    public function getWorkflowRunAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Name:string, RunId:string} $args
     * @return \AWS\Result<array{RunProperties?:array<string, string>}>
     */
    public function getWorkflowRunProperties(array $args): \AWS\Result { }

    /**
     * @param array{Name:string, RunId:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{RunProperties?:array<string, string>}>
     */
    public function getWorkflowRunPropertiesAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Name:string, IncludeGraph?:bool, NextToken?:string, MaxResults?:int} $args
     * @return \AWS\Result<array{Runs?:array<array{Name?:string, WorkflowRunId?:string, PreviousRunId?:string, WorkflowRunProperties?:array<string, string>, StartedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, Status?:"RUNNING"|"COMPLETED"|"STOPPING"|"STOPPED"|"ERROR", ErrorMessage?:string, Statistics?:array{TotalActions?:int, TimeoutActions?:int, FailedActions?:int, StoppedActions?:int, SucceededActions?:int, RunningActions?:int, ErroredActions?:int, WaitingActions?:int}, Graph?:array{Nodes?:array<array{Type?:"CRAWLER"|"JOB"|"TRIGGER", Name?:string, UniqueId?:string, TriggerDetails?:array{Trigger?:array{Name?:string, WorkflowName?:string, Id?:string, Type?:"SCHEDULED"|"CONDITIONAL"|"ON_DEMAND"|"EVENT", State?:"CREATING"|"CREATED"|"ACTIVATING"|"ACTIVATED"|"DEACTIVATING"|"DEACTIVATED"|"DELETING"|"UPDATING", Description?:string, Schedule?:string, Actions?:array<array{JobName?:string, Arguments?:array<string, string>, Timeout?:int, SecurityConfiguration?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, CrawlerName?:string}>, Predicate?:array{Logical?:"AND"|"ANY", Conditions?:array<array{LogicalOperator?:"EQUALS", JobName?:string, State?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED", CrawlerName?:string, CrawlState?:"RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR"}>}, EventBatchingCondition?:array{BatchSize:int, BatchWindow?:int}}}, JobDetails?:array{JobRuns?:array<array{Id?:string, Attempt?:int, PreviousRunId?:string, TriggerName?:string, JobName?:string, JobMode?:"SCRIPT"|"VISUAL"|"NOTEBOOK", JobRunQueuingEnabled?:bool, StartedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, JobRunState?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED", Arguments?:array<string, string>, ErrorMessage?:string, PredecessorRuns?:array<array{JobName?:string, RunId?:string}>, AllocatedCapacity?:int, ExecutionTime?:int, Timeout?:int, MaxCapacity?:float, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", NumberOfWorkers?:int, SecurityConfiguration?:string, LogGroupName?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, GlueVersion?:string, DPUSeconds?:float, ExecutionClass?:"FLEX"|"STANDARD", MaintenanceWindow?:string, ProfileName?:string, StateDetail?:string}>}, CrawlerDetails?:array{Crawls?:array<array{State?:"RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR", StartedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, ErrorMessage?:string, LogGroup?:string, LogStream?:string}>}}>, Edges?:array<array{SourceId?:string, DestinationId?:string}>}, StartingEventBatchCondition?:array{BatchSize?:int, BatchWindow?:int}}>, NextToken?:string}>
     */
    public function getWorkflowRuns(array $args): \AWS\Result { }

    /**
     * @param array{Name:string, IncludeGraph?:bool, NextToken?:string, MaxResults?:int} $args
     * @return \GuzzleHttp\Promise\Promise<array{Runs?:array<array{Name?:string, WorkflowRunId?:string, PreviousRunId?:string, WorkflowRunProperties?:array<string, string>, StartedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, Status?:"RUNNING"|"COMPLETED"|"STOPPING"|"STOPPED"|"ERROR", ErrorMessage?:string, Statistics?:array{TotalActions?:int, TimeoutActions?:int, FailedActions?:int, StoppedActions?:int, SucceededActions?:int, RunningActions?:int, ErroredActions?:int, WaitingActions?:int}, Graph?:array{Nodes?:array<array{Type?:"CRAWLER"|"JOB"|"TRIGGER", Name?:string, UniqueId?:string, TriggerDetails?:array{Trigger?:array{Name?:string, WorkflowName?:string, Id?:string, Type?:"SCHEDULED"|"CONDITIONAL"|"ON_DEMAND"|"EVENT", State?:"CREATING"|"CREATED"|"ACTIVATING"|"ACTIVATED"|"DEACTIVATING"|"DEACTIVATED"|"DELETING"|"UPDATING", Description?:string, Schedule?:string, Actions?:array<array{JobName?:string, Arguments?:array<string, string>, Timeout?:int, SecurityConfiguration?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, CrawlerName?:string}>, Predicate?:array{Logical?:"AND"|"ANY", Conditions?:array<array{LogicalOperator?:"EQUALS", JobName?:string, State?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED", CrawlerName?:string, CrawlState?:"RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR"}>}, EventBatchingCondition?:array{BatchSize:int, BatchWindow?:int}}}, JobDetails?:array{JobRuns?:array<array{Id?:string, Attempt?:int, PreviousRunId?:string, TriggerName?:string, JobName?:string, JobMode?:"SCRIPT"|"VISUAL"|"NOTEBOOK", JobRunQueuingEnabled?:bool, StartedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, JobRunState?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED", Arguments?:array<string, string>, ErrorMessage?:string, PredecessorRuns?:array<array{JobName?:string, RunId?:string}>, AllocatedCapacity?:int, ExecutionTime?:int, Timeout?:int, MaxCapacity?:float, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", NumberOfWorkers?:int, SecurityConfiguration?:string, LogGroupName?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, GlueVersion?:string, DPUSeconds?:float, ExecutionClass?:"FLEX"|"STANDARD", MaintenanceWindow?:string, ProfileName?:string, StateDetail?:string}>}, CrawlerDetails?:array{Crawls?:array<array{State?:"RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR", StartedOn?:int|string|\DateTimeInterface, CompletedOn?:int|string|\DateTimeInterface, ErrorMessage?:string, LogGroup?:string, LogStream?:string}>}}>, Edges?:array<array{SourceId?:string, DestinationId?:string}>}, StartingEventBatchCondition?:array{BatchSize?:int, BatchWindow?:int}}>, NextToken?:string}>
     */
    public function getWorkflowRunsAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId?:string} $args
     * @return \AWS\Result<array{}>
     */
    public function importCatalogToGlue(array $args = []): \AWS\Result { }

    /**
     * @param array{CatalogId?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function importCatalogToGlueAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{NextToken?:string, MaxResults?:int, Tags?:array<string, string>} $args
     * @return \AWS\Result<array{Blueprints?:array<string>, NextToken?:string}>
     */
    public function listBlueprints(array $args = []): \AWS\Result { }

    /**
     * @param array{NextToken?:string, MaxResults?:int, Tags?:array<string, string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{Blueprints?:array<string>, NextToken?:string}>
     */
    public function listBlueprintsAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{MaxResults?:int, NextToken?:string} $args
     * @return \AWS\Result<array{ColumnStatisticsTaskRunIds?:array<string>, NextToken?:string}>
     */
    public function listColumnStatisticsTaskRuns(array $args = []): \AWS\Result { }

    /**
     * @param array{MaxResults?:int, NextToken?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{ColumnStatisticsTaskRunIds?:array<string>, NextToken?:string}>
     */
    public function listColumnStatisticsTaskRunsAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{MaxResults?:int, NextToken?:string} $args
     * @return \AWS\Result<array{ConnectionTypes?:array<array{ConnectionType?:"JDBC"|"SFTP"|"MONGODB"|"KAFKA"|"NETWORK"|"MARKETPLACE"|"CUSTOM"|"SALESFORCE"|"VIEW_VALIDATION_REDSHIFT"|"VIEW_VALIDATION_ATHENA"|"GOOGLEADS"|"GOOGLESHEETS"|"GOOGLEANALYTICS4"|"SERVICENOW"|"MARKETO"|"SAPODATA"|"ZENDESK"|"JIRACLOUD"|"NETSUITEERP"|"HUBSPOT"|"FACEBOOKADS"|"INSTAGRAMADS"|"ZOHOCRM"|"SALESFORCEPARDOT"|"SALESFORCEMARKETINGCLOUD"|"SLACK"|"STRIPE"|"INTERCOM"|"SNAPCHATADS", Description?:string, Capabilities?:array{SupportedAuthenticationTypes:array<"BASIC"|"OAUTH2"|"CUSTOM"|"IAM">, SupportedDataOperations:array<"READ"|"WRITE">, SupportedComputeEnvironments:array<"SPARK"|"ATHENA"|"PYTHON">}}>, NextToken?:string}>
     */
    public function listConnectionTypes(array $args = []): \AWS\Result { }

    /**
     * @param array{MaxResults?:int, NextToken?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{ConnectionTypes?:array<array{ConnectionType?:"JDBC"|"SFTP"|"MONGODB"|"KAFKA"|"NETWORK"|"MARKETPLACE"|"CUSTOM"|"SALESFORCE"|"VIEW_VALIDATION_REDSHIFT"|"VIEW_VALIDATION_ATHENA"|"GOOGLEADS"|"GOOGLESHEETS"|"GOOGLEANALYTICS4"|"SERVICENOW"|"MARKETO"|"SAPODATA"|"ZENDESK"|"JIRACLOUD"|"NETSUITEERP"|"HUBSPOT"|"FACEBOOKADS"|"INSTAGRAMADS"|"ZOHOCRM"|"SALESFORCEPARDOT"|"SALESFORCEMARKETINGCLOUD"|"SLACK"|"STRIPE"|"INTERCOM"|"SNAPCHATADS", Description?:string, Capabilities?:array{SupportedAuthenticationTypes:array<"BASIC"|"OAUTH2"|"CUSTOM"|"IAM">, SupportedDataOperations:array<"READ"|"WRITE">, SupportedComputeEnvironments:array<"SPARK"|"ATHENA"|"PYTHON">}}>, NextToken?:string}>
     */
    public function listConnectionTypesAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{MaxResults?:int, NextToken?:string, Tags?:array<string, string>} $args
     * @return \AWS\Result<array{CrawlerNames?:array<string>, NextToken?:string}>
     */
    public function listCrawlers(array $args = []): \AWS\Result { }

    /**
     * @param array{MaxResults?:int, NextToken?:string, Tags?:array<string, string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{CrawlerNames?:array<string>, NextToken?:string}>
     */
    public function listCrawlersAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CrawlerName:string, MaxResults?:int, Filters?:array<array{FieldName?:"CRAWL_ID"|"STATE"|"START_TIME"|"END_TIME"|"DPU_HOUR", FilterOperator?:"GT"|"GE"|"LT"|"LE"|"EQ"|"NE", FieldValue?:string}>, NextToken?:string} $args
     * @return \AWS\Result<array{Crawls?:array<array{CrawlId?:string, State?:"RUNNING"|"COMPLETED"|"FAILED"|"STOPPED", StartTime?:int|string|\DateTimeInterface, EndTime?:int|string|\DateTimeInterface, Summary?:string, ErrorMessage?:string, LogGroup?:string, LogStream?:string, MessagePrefix?:string, DPUHour?:float}>, NextToken?:string}>
     */
    public function listCrawls(array $args): \AWS\Result { }

    /**
     * @param array{CrawlerName:string, MaxResults?:int, Filters?:array<array{FieldName?:"CRAWL_ID"|"STATE"|"START_TIME"|"END_TIME"|"DPU_HOUR", FilterOperator?:"GT"|"GE"|"LT"|"LE"|"EQ"|"NE", FieldValue?:string}>, NextToken?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Crawls?:array<array{CrawlId?:string, State?:"RUNNING"|"COMPLETED"|"FAILED"|"STOPPED", StartTime?:int|string|\DateTimeInterface, EndTime?:int|string|\DateTimeInterface, Summary?:string, ErrorMessage?:string, LogGroup?:string, LogStream?:string, MessagePrefix?:string, DPUHour?:float}>, NextToken?:string}>
     */
    public function listCrawlsAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{NextToken?:string, MaxResults?:int, Tags?:array<string, string>} $args
     * @return \AWS\Result<array{CustomEntityTypes?:array<array{Name:string, RegexString:string, ContextWords?:array<string>}>, NextToken?:string}>
     */
    public function listCustomEntityTypes(array $args = []): \AWS\Result { }

    /**
     * @param array{NextToken?:string, MaxResults?:int, Tags?:array<string, string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{CustomEntityTypes?:array<array{Name:string, RegexString:string, ContextWords?:array<string>}>, NextToken?:string}>
     */
    public function listCustomEntityTypesAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Filter?:array{DataSource?:array{GlueTable:array{DatabaseName:string, TableName:string, CatalogId?:string, ConnectionName?:string, AdditionalOptions?:array<string, string>}}, JobName?:string, JobRunId?:string, StartedAfter?:int|string|\DateTimeInterface, StartedBefore?:int|string|\DateTimeInterface}, NextToken?:string, MaxResults?:int} $args
     * @return \AWS\Result<array{Results:array<array{ResultId?:string, DataSource?:array{GlueTable:array{DatabaseName:string, TableName:string, CatalogId?:string, ConnectionName?:string, AdditionalOptions?:array<string, string>}}, JobName?:string, JobRunId?:string, StartedOn?:int|string|\DateTimeInterface}>, NextToken?:string}>
     */
    public function listDataQualityResults(array $args = []): \AWS\Result { }

    /**
     * @param array{Filter?:array{DataSource?:array{GlueTable:array{DatabaseName:string, TableName:string, CatalogId?:string, ConnectionName?:string, AdditionalOptions?:array<string, string>}}, JobName?:string, JobRunId?:string, StartedAfter?:int|string|\DateTimeInterface, StartedBefore?:int|string|\DateTimeInterface}, NextToken?:string, MaxResults?:int} $args
     * @return \GuzzleHttp\Promise\Promise<array{Results:array<array{ResultId?:string, DataSource?:array{GlueTable:array{DatabaseName:string, TableName:string, CatalogId?:string, ConnectionName?:string, AdditionalOptions?:array<string, string>}}, JobName?:string, JobRunId?:string, StartedOn?:int|string|\DateTimeInterface}>, NextToken?:string}>
     */
    public function listDataQualityResultsAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Filter?:array{DataSource:array{GlueTable:array{DatabaseName:string, TableName:string, CatalogId?:string, ConnectionName?:string, AdditionalOptions?:array<string, string>}}, StartedBefore?:int|string|\DateTimeInterface, StartedAfter?:int|string|\DateTimeInterface}, NextToken?:string, MaxResults?:int} $args
     * @return \AWS\Result<array{Runs?:array<array{RunId?:string, Status?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT", StartedOn?:int|string|\DateTimeInterface, DataSource?:array{GlueTable:array{DatabaseName:string, TableName:string, CatalogId?:string, ConnectionName?:string, AdditionalOptions?:array<string, string>}}}>, NextToken?:string}>
     */
    public function listDataQualityRuleRecommendationRuns(array $args = []): \AWS\Result { }

    /**
     * @param array{Filter?:array{DataSource:array{GlueTable:array{DatabaseName:string, TableName:string, CatalogId?:string, ConnectionName?:string, AdditionalOptions?:array<string, string>}}, StartedBefore?:int|string|\DateTimeInterface, StartedAfter?:int|string|\DateTimeInterface}, NextToken?:string, MaxResults?:int} $args
     * @return \GuzzleHttp\Promise\Promise<array{Runs?:array<array{RunId?:string, Status?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT", StartedOn?:int|string|\DateTimeInterface, DataSource?:array{GlueTable:array{DatabaseName:string, TableName:string, CatalogId?:string, ConnectionName?:string, AdditionalOptions?:array<string, string>}}}>, NextToken?:string}>
     */
    public function listDataQualityRuleRecommendationRunsAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Filter?:array{DataSource:array{GlueTable:array{DatabaseName:string, TableName:string, CatalogId?:string, ConnectionName?:string, AdditionalOptions?:array<string, string>}}, StartedBefore?:int|string|\DateTimeInterface, StartedAfter?:int|string|\DateTimeInterface}, NextToken?:string, MaxResults?:int} $args
     * @return \AWS\Result<array{Runs?:array<array{RunId?:string, Status?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT", StartedOn?:int|string|\DateTimeInterface, DataSource?:array{GlueTable:array{DatabaseName:string, TableName:string, CatalogId?:string, ConnectionName?:string, AdditionalOptions?:array<string, string>}}}>, NextToken?:string}>
     */
    public function listDataQualityRulesetEvaluationRuns(array $args = []): \AWS\Result { }

    /**
     * @param array{Filter?:array{DataSource:array{GlueTable:array{DatabaseName:string, TableName:string, CatalogId?:string, ConnectionName?:string, AdditionalOptions?:array<string, string>}}, StartedBefore?:int|string|\DateTimeInterface, StartedAfter?:int|string|\DateTimeInterface}, NextToken?:string, MaxResults?:int} $args
     * @return \GuzzleHttp\Promise\Promise<array{Runs?:array<array{RunId?:string, Status?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT", StartedOn?:int|string|\DateTimeInterface, DataSource?:array{GlueTable:array{DatabaseName:string, TableName:string, CatalogId?:string, ConnectionName?:string, AdditionalOptions?:array<string, string>}}}>, NextToken?:string}>
     */
    public function listDataQualityRulesetEvaluationRunsAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{NextToken?:string, MaxResults?:int, Filter?:array{Name?:string, Description?:string, CreatedBefore?:int|string|\DateTimeInterface, CreatedAfter?:int|string|\DateTimeInterface, LastModifiedBefore?:int|string|\DateTimeInterface, LastModifiedAfter?:int|string|\DateTimeInterface, TargetTable?:array{TableName:string, DatabaseName:string, CatalogId?:string}}, Tags?:array<string, string>} $args
     * @return \AWS\Result<array{Rulesets?:array<array{Name?:string, Description?:string, CreatedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface, TargetTable?:array{TableName:string, DatabaseName:string, CatalogId?:string}, RecommendationRunId?:string, RuleCount?:int}>, NextToken?:string}>
     */
    public function listDataQualityRulesets(array $args = []): \AWS\Result { }

    /**
     * @param array{NextToken?:string, MaxResults?:int, Filter?:array{Name?:string, Description?:string, CreatedBefore?:int|string|\DateTimeInterface, CreatedAfter?:int|string|\DateTimeInterface, LastModifiedBefore?:int|string|\DateTimeInterface, LastModifiedAfter?:int|string|\DateTimeInterface, TargetTable?:array{TableName:string, DatabaseName:string, CatalogId?:string}}, Tags?:array<string, string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{Rulesets?:array<array{Name?:string, Description?:string, CreatedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface, TargetTable?:array{TableName:string, DatabaseName:string, CatalogId?:string}, RecommendationRunId?:string, RuleCount?:int}>, NextToken?:string}>
     */
    public function listDataQualityRulesetsAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{StatisticId?:string, ProfileId?:string, TimestampFilter?:array{RecordedBefore?:int|string|\DateTimeInterface, RecordedAfter?:int|string|\DateTimeInterface}, MaxResults?:int, NextToken?:string} $args
     * @return \AWS\Result<array{Annotations?:array<array{ProfileId?:string, StatisticId?:string, StatisticRecordedOn?:int|string|\DateTimeInterface, InclusionAnnotation?:array{Value?:"INCLUDE"|"EXCLUDE", LastModifiedOn?:int|string|\DateTimeInterface}}>, NextToken?:string}>
     */
    public function listDataQualityStatisticAnnotations(array $args = []): \AWS\Result { }

    /**
     * @param array{StatisticId?:string, ProfileId?:string, TimestampFilter?:array{RecordedBefore?:int|string|\DateTimeInterface, RecordedAfter?:int|string|\DateTimeInterface}, MaxResults?:int, NextToken?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Annotations?:array<array{ProfileId?:string, StatisticId?:string, StatisticRecordedOn?:int|string|\DateTimeInterface, InclusionAnnotation?:array{Value?:"INCLUDE"|"EXCLUDE", LastModifiedOn?:int|string|\DateTimeInterface}}>, NextToken?:string}>
     */
    public function listDataQualityStatisticAnnotationsAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{StatisticId?:string, ProfileId?:string, TimestampFilter?:array{RecordedBefore?:int|string|\DateTimeInterface, RecordedAfter?:int|string|\DateTimeInterface}, MaxResults?:int, NextToken?:string} $args
     * @return \AWS\Result<array{Statistics?:array<array{StatisticId?:string, ProfileId?:string, RunIdentifier?:array{RunId?:string, JobRunId?:string}, StatisticName?:string, DoubleValue?:float, EvaluationLevel?:"Dataset"|"Column"|"Multicolumn", ColumnsReferenced?:array<string>, ReferencedDatasets?:array<string>, StatisticProperties?:array<string, string>, RecordedOn?:int|string|\DateTimeInterface, InclusionAnnotation?:array{Value?:"INCLUDE"|"EXCLUDE", LastModifiedOn?:int|string|\DateTimeInterface}}>, NextToken?:string}>
     */
    public function listDataQualityStatistics(array $args = []): \AWS\Result { }

    /**
     * @param array{StatisticId?:string, ProfileId?:string, TimestampFilter?:array{RecordedBefore?:int|string|\DateTimeInterface, RecordedAfter?:int|string|\DateTimeInterface}, MaxResults?:int, NextToken?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Statistics?:array<array{StatisticId?:string, ProfileId?:string, RunIdentifier?:array{RunId?:string, JobRunId?:string}, StatisticName?:string, DoubleValue?:float, EvaluationLevel?:"Dataset"|"Column"|"Multicolumn", ColumnsReferenced?:array<string>, ReferencedDatasets?:array<string>, StatisticProperties?:array<string, string>, RecordedOn?:int|string|\DateTimeInterface, InclusionAnnotation?:array{Value?:"INCLUDE"|"EXCLUDE", LastModifiedOn?:int|string|\DateTimeInterface}}>, NextToken?:string}>
     */
    public function listDataQualityStatisticsAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{NextToken?:string, MaxResults?:int, Tags?:array<string, string>} $args
     * @return \AWS\Result<array{DevEndpointNames?:array<string>, NextToken?:string}>
     */
    public function listDevEndpoints(array $args = []): \AWS\Result { }

    /**
     * @param array{NextToken?:string, MaxResults?:int, Tags?:array<string, string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{DevEndpointNames?:array<string>, NextToken?:string}>
     */
    public function listDevEndpointsAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ConnectionName?:string, CatalogId?:string, ParentEntityName?:string, NextToken?:string, DataStoreApiVersion?:string} $args
     * @return \AWS\Result<array{Entities?:array<array{EntityName?:string, Label?:string, IsParentEntity?:bool, Description?:string, Category?:string, CustomProperties?:array<string, string>}>, NextToken?:string}>
     */
    public function listEntities(array $args = []): \AWS\Result { }

    /**
     * @param array{ConnectionName?:string, CatalogId?:string, ParentEntityName?:string, NextToken?:string, DataStoreApiVersion?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Entities?:array<array{EntityName?:string, Label?:string, IsParentEntity?:bool, Description?:string, Category?:string, CustomProperties?:array<string, string>}>, NextToken?:string}>
     */
    public function listEntitiesAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{NextToken?:string, MaxResults?:int, Tags?:array<string, string>} $args
     * @return \AWS\Result<array{JobNames?:array<string>, NextToken?:string}>
     */
    public function listJobs(array $args = []): \AWS\Result { }

    /**
     * @param array{NextToken?:string, MaxResults?:int, Tags?:array<string, string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{JobNames?:array<string>, NextToken?:string}>
     */
    public function listJobsAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{NextToken?:string, MaxResults?:int, Filter?:array{Name?:string, TransformType?:"FIND_MATCHES", Status?:"NOT_READY"|"READY"|"DELETING", GlueVersion?:string, CreatedBefore?:int|string|\DateTimeInterface, CreatedAfter?:int|string|\DateTimeInterface, LastModifiedBefore?:int|string|\DateTimeInterface, LastModifiedAfter?:int|string|\DateTimeInterface, Schema?:array<array{Name?:string, DataType?:string}>}, Sort?:array{Column:"NAME"|"TRANSFORM_TYPE"|"STATUS"|"CREATED"|"LAST_MODIFIED", SortDirection:"DESCENDING"|"ASCENDING"}, Tags?:array<string, string>} $args
     * @return \AWS\Result<array{TransformIds:array<string>, NextToken?:string}>
     */
    public function listMLTransforms(array $args = []): \AWS\Result { }

    /**
     * @param array{NextToken?:string, MaxResults?:int, Filter?:array{Name?:string, TransformType?:"FIND_MATCHES", Status?:"NOT_READY"|"READY"|"DELETING", GlueVersion?:string, CreatedBefore?:int|string|\DateTimeInterface, CreatedAfter?:int|string|\DateTimeInterface, LastModifiedBefore?:int|string|\DateTimeInterface, LastModifiedAfter?:int|string|\DateTimeInterface, Schema?:array<array{Name?:string, DataType?:string}>}, Sort?:array{Column:"NAME"|"TRANSFORM_TYPE"|"STATUS"|"CREATED"|"LAST_MODIFIED", SortDirection:"DESCENDING"|"ASCENDING"}, Tags?:array<string, string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{TransformIds:array<string>, NextToken?:string}>
     */
    public function listMLTransformsAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{MaxResults?:int, NextToken?:string} $args
     * @return \AWS\Result<array{Registries?:array<array{RegistryName?:string, RegistryArn?:string, Description?:string, Status?:"AVAILABLE"|"DELETING", CreatedTime?:string, UpdatedTime?:string}>, NextToken?:string}>
     */
    public function listRegistries(array $args = []): \AWS\Result { }

    /**
     * @param array{MaxResults?:int, NextToken?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Registries?:array<array{RegistryName?:string, RegistryArn?:string, Description?:string, Status?:"AVAILABLE"|"DELETING", CreatedTime?:string, UpdatedTime?:string}>, NextToken?:string}>
     */
    public function listRegistriesAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{SchemaId:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, MaxResults?:int, NextToken?:string} $args
     * @return \AWS\Result<array{Schemas?:array<array{SchemaArn?:string, SchemaVersionId?:string, VersionNumber?:int, Status?:"AVAILABLE"|"PENDING"|"FAILURE"|"DELETING", CreatedTime?:string}>, NextToken?:string}>
     */
    public function listSchemaVersions(array $args): \AWS\Result { }

    /**
     * @param array{SchemaId:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, MaxResults?:int, NextToken?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Schemas?:array<array{SchemaArn?:string, SchemaVersionId?:string, VersionNumber?:int, Status?:"AVAILABLE"|"PENDING"|"FAILURE"|"DELETING", CreatedTime?:string}>, NextToken?:string}>
     */
    public function listSchemaVersionsAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{RegistryId?:array{RegistryName?:string, RegistryArn?:string}, MaxResults?:int, NextToken?:string} $args
     * @return \AWS\Result<array{Schemas?:array<array{RegistryName?:string, SchemaName?:string, SchemaArn?:string, Description?:string, SchemaStatus?:"AVAILABLE"|"PENDING"|"DELETING", CreatedTime?:string, UpdatedTime?:string}>, NextToken?:string}>
     */
    public function listSchemas(array $args = []): \AWS\Result { }

    /**
     * @param array{RegistryId?:array{RegistryName?:string, RegistryArn?:string}, MaxResults?:int, NextToken?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Schemas?:array<array{RegistryName?:string, SchemaName?:string, SchemaArn?:string, Description?:string, SchemaStatus?:"AVAILABLE"|"PENDING"|"DELETING", CreatedTime?:string, UpdatedTime?:string}>, NextToken?:string}>
     */
    public function listSchemasAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{NextToken?:string, MaxResults?:int, Tags?:array<string, string>, RequestOrigin?:string} $args
     * @return \AWS\Result<array{Ids?:array<string>, Sessions?:array<array{Id?:string, CreatedOn?:int|string|\DateTimeInterface, Status?:"PROVISIONING"|"READY"|"FAILED"|"TIMEOUT"|"STOPPING"|"STOPPED", ErrorMessage?:string, Description?:string, Role?:string, Command?:array{Name?:string, PythonVersion?:string}, DefaultArguments?:array<string, string>, Connections?:array{Connections?:mixed}, Progress?:float, MaxCapacity?:float, SecurityConfiguration?:string, GlueVersion?:string, NumberOfWorkers?:int, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", CompletedOn?:int|string|\DateTimeInterface, ExecutionTime?:float, DPUSeconds?:float, IdleTimeout?:int, ProfileName?:string}>, NextToken?:string}>
     */
    public function listSessions(array $args = []): \AWS\Result { }

    /**
     * @param array{NextToken?:string, MaxResults?:int, Tags?:array<string, string>, RequestOrigin?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Ids?:array<string>, Sessions?:array<array{Id?:string, CreatedOn?:int|string|\DateTimeInterface, Status?:"PROVISIONING"|"READY"|"FAILED"|"TIMEOUT"|"STOPPING"|"STOPPED", ErrorMessage?:string, Description?:string, Role?:string, Command?:array{Name?:string, PythonVersion?:string}, DefaultArguments?:array<string, string>, Connections?:array{Connections?:mixed}, Progress?:float, MaxCapacity?:float, SecurityConfiguration?:string, GlueVersion?:string, NumberOfWorkers?:int, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", CompletedOn?:int|string|\DateTimeInterface, ExecutionTime?:float, DPUSeconds?:float, IdleTimeout?:int, ProfileName?:string}>, NextToken?:string}>
     */
    public function listSessionsAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{SessionId:string, RequestOrigin?:string, NextToken?:string} $args
     * @return \AWS\Result<array{Statements?:array<array{Id?:int, Code?:string, State?:"WAITING"|"RUNNING"|"AVAILABLE"|"CANCELLING"|"CANCELLED"|"ERROR", Output?:array{Data?:array{TextPlain?:string}, ExecutionCount?:int, Status?:"WAITING"|"RUNNING"|"AVAILABLE"|"CANCELLING"|"CANCELLED"|"ERROR", ErrorName?:string, ErrorValue?:string, Traceback?:array<string>}, Progress?:float, StartedOn?:int, CompletedOn?:int}>, NextToken?:string}>
     */
    public function listStatements(array $args): \AWS\Result { }

    /**
     * @param array{SessionId:string, RequestOrigin?:string, NextToken?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Statements?:array<array{Id?:int, Code?:string, State?:"WAITING"|"RUNNING"|"AVAILABLE"|"CANCELLING"|"CANCELLED"|"ERROR", Output?:array{Data?:array{TextPlain?:string}, ExecutionCount?:int, Status?:"WAITING"|"RUNNING"|"AVAILABLE"|"CANCELLING"|"CANCELLED"|"ERROR", ErrorName?:string, ErrorValue?:string, Traceback?:array<string>}, Progress?:float, StartedOn?:int, CompletedOn?:int}>, NextToken?:string}>
     */
    public function listStatementsAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId:string, DatabaseName:string, TableName:string, Type:"compaction"|"retention"|"orphan_file_deletion", MaxResults?:int, NextToken?:string} $args
     * @return \AWS\Result<array{CatalogId?:string, DatabaseName?:string, TableName?:string, NextToken?:string, TableOptimizerRuns?:array<array{eventType?:"starting"|"completed"|"failed"|"in_progress", startTimestamp?:int|string|\DateTimeInterface, endTimestamp?:int|string|\DateTimeInterface, metrics?:array{NumberOfBytesCompacted?:string, NumberOfFilesCompacted?:string, NumberOfDpus?:string, JobDurationInHour?:string}, error?:string, compactionMetrics?:array{IcebergMetrics?:array{NumberOfBytesCompacted?:int, NumberOfFilesCompacted?:int, NumberOfDpus?:int, JobDurationInHour?:float}}, retentionMetrics?:array{IcebergMetrics?:array{NumberOfDataFilesDeleted?:int, NumberOfManifestFilesDeleted?:int, NumberOfManifestListsDeleted?:int, NumberOfDpus?:int, JobDurationInHour?:float}}, orphanFileDeletionMetrics?:array{IcebergMetrics?:array{NumberOfOrphanFilesDeleted?:int, NumberOfDpus?:int, JobDurationInHour?:float}}}>}>
     */
    public function listTableOptimizerRuns(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId:string, DatabaseName:string, TableName:string, Type:"compaction"|"retention"|"orphan_file_deletion", MaxResults?:int, NextToken?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{CatalogId?:string, DatabaseName?:string, TableName?:string, NextToken?:string, TableOptimizerRuns?:array<array{eventType?:"starting"|"completed"|"failed"|"in_progress", startTimestamp?:int|string|\DateTimeInterface, endTimestamp?:int|string|\DateTimeInterface, metrics?:array{NumberOfBytesCompacted?:string, NumberOfFilesCompacted?:string, NumberOfDpus?:string, JobDurationInHour?:string}, error?:string, compactionMetrics?:array{IcebergMetrics?:array{NumberOfBytesCompacted?:int, NumberOfFilesCompacted?:int, NumberOfDpus?:int, JobDurationInHour?:float}}, retentionMetrics?:array{IcebergMetrics?:array{NumberOfDataFilesDeleted?:int, NumberOfManifestFilesDeleted?:int, NumberOfManifestListsDeleted?:int, NumberOfDpus?:int, JobDurationInHour?:float}}, orphanFileDeletionMetrics?:array{IcebergMetrics?:array{NumberOfOrphanFilesDeleted?:int, NumberOfDpus?:int, JobDurationInHour?:float}}}>}>
     */
    public function listTableOptimizerRunsAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{NextToken?:string, DependentJobName?:string, MaxResults?:int, Tags?:array<string, string>} $args
     * @return \AWS\Result<array{TriggerNames?:array<string>, NextToken?:string}>
     */
    public function listTriggers(array $args = []): \AWS\Result { }

    /**
     * @param array{NextToken?:string, DependentJobName?:string, MaxResults?:int, Tags?:array<string, string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{TriggerNames?:array<string>, NextToken?:string}>
     */
    public function listTriggersAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{NextToken?:string, MaxResults?:int} $args
     * @return \AWS\Result<array{Profiles?:array<array{Name?:string, Description?:string, CreatedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface}>, NextToken?:string}>
     */
    public function listUsageProfiles(array $args = []): \AWS\Result { }

    /**
     * @param array{NextToken?:string, MaxResults?:int} $args
     * @return \GuzzleHttp\Promise\Promise<array{Profiles?:array<array{Name?:string, Description?:string, CreatedOn?:int|string|\DateTimeInterface, LastModifiedOn?:int|string|\DateTimeInterface}>, NextToken?:string}>
     */
    public function listUsageProfilesAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{NextToken?:string, MaxResults?:int} $args
     * @return \AWS\Result<array{Workflows?:array<string>, NextToken?:string}>
     */
    public function listWorkflows(array $args = []): \AWS\Result { }

    /**
     * @param array{NextToken?:string, MaxResults?:int} $args
     * @return \GuzzleHttp\Promise\Promise<array{Workflows?:array<string>, NextToken?:string}>
     */
    public function listWorkflowsAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{IntegrationIdentifier:string, Description?:string, DataFilter?:string, IntegrationName?:string} $args
     * @return \AWS\Result<array{SourceArn:string, TargetArn:string, IntegrationName:string, Description?:string, IntegrationArn:string, KmsKeyId?:string, AdditionalEncryptionContext?:array<string, string>, Tags?:array<array{key?:string, value?:string}>, Status:"CREATING"|"ACTIVE"|"MODIFYING"|"FAILED"|"DELETING"|"SYNCING"|"NEEDS_ATTENTION", CreateTime:int|string|\DateTimeInterface, Errors?:array<array{ErrorCode?:string, ErrorMessage?:string}>, DataFilter?:string}>
     */
    public function modifyIntegration(array $args): \AWS\Result { }

    /**
     * @param array{IntegrationIdentifier:string, Description?:string, DataFilter?:string, IntegrationName?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{SourceArn:string, TargetArn:string, IntegrationName:string, Description?:string, IntegrationArn:string, KmsKeyId?:string, AdditionalEncryptionContext?:array<string, string>, Tags?:array<array{key?:string, value?:string}>, Status:"CREATING"|"ACTIVE"|"MODIFYING"|"FAILED"|"DELETING"|"SYNCING"|"NEEDS_ATTENTION", CreateTime:int|string|\DateTimeInterface, Errors?:array<array{ErrorCode?:string, ErrorMessage?:string}>, DataFilter?:string}>
     */
    public function modifyIntegrationAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId?:string, DataCatalogEncryptionSettings:array{EncryptionAtRest?:array{CatalogEncryptionMode:"DISABLED"|"SSE-KMS"|"SSE-KMS-WITH-SERVICE-ROLE", SseAwsKmsKeyId?:string, CatalogEncryptionServiceRole?:string}, ConnectionPasswordEncryption?:array{ReturnConnectionPasswordEncrypted:bool, AwsKmsKeyId?:string}}} $args
     * @return \AWS\Result<array{}>
     */
    public function putDataCatalogEncryptionSettings(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId?:string, DataCatalogEncryptionSettings:array{EncryptionAtRest?:array{CatalogEncryptionMode:"DISABLED"|"SSE-KMS"|"SSE-KMS-WITH-SERVICE-ROLE", SseAwsKmsKeyId?:string, CatalogEncryptionServiceRole?:string}, ConnectionPasswordEncryption?:array{ReturnConnectionPasswordEncrypted:bool, AwsKmsKeyId?:string}}} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function putDataCatalogEncryptionSettingsAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ProfileId:string, InclusionAnnotation:"INCLUDE"|"EXCLUDE"} $args
     * @return \AWS\Result<array{}>
     */
    public function putDataQualityProfileAnnotation(array $args): \AWS\Result { }

    /**
     * @param array{ProfileId:string, InclusionAnnotation:"INCLUDE"|"EXCLUDE"} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function putDataQualityProfileAnnotationAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{PolicyInJson:string, ResourceArn?:string, PolicyHashCondition?:string, PolicyExistsCondition?:"MUST_EXIST"|"NOT_EXIST"|"NONE", EnableHybrid?:"TRUE"|"FALSE"} $args
     * @return \AWS\Result<array{PolicyHash?:string}>
     */
    public function putResourcePolicy(array $args): \AWS\Result { }

    /**
     * @param array{PolicyInJson:string, ResourceArn?:string, PolicyHashCondition?:string, PolicyExistsCondition?:"MUST_EXIST"|"NOT_EXIST"|"NONE", EnableHybrid?:"TRUE"|"FALSE"} $args
     * @return \GuzzleHttp\Promise\Promise<array{PolicyHash?:string}>
     */
    public function putResourcePolicyAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionNumber?:array{LatestVersion?:bool, VersionNumber?:int}, SchemaVersionId?:string, MetadataKeyValue:array{MetadataKey?:string, MetadataValue?:string}} $args
     * @return \AWS\Result<array{SchemaArn?:string, SchemaName?:string, RegistryName?:string, LatestVersion?:bool, VersionNumber?:int, SchemaVersionId?:string, MetadataKey?:string, MetadataValue?:string}>
     */
    public function putSchemaVersionMetadata(array $args): \AWS\Result { }

    /**
     * @param array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionNumber?:array{LatestVersion?:bool, VersionNumber?:int}, SchemaVersionId?:string, MetadataKeyValue:array{MetadataKey?:string, MetadataValue?:string}} $args
     * @return \GuzzleHttp\Promise\Promise<array{SchemaArn?:string, SchemaName?:string, RegistryName?:string, LatestVersion?:bool, VersionNumber?:int, SchemaVersionId?:string, MetadataKey?:string, MetadataValue?:string}>
     */
    public function putSchemaVersionMetadataAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Name:string, RunId:string, RunProperties:array<string, string>} $args
     * @return \AWS\Result<array{}>
     */
    public function putWorkflowRunProperties(array $args): \AWS\Result { }

    /**
     * @param array{Name:string, RunId:string, RunProperties:array<string, string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function putWorkflowRunPropertiesAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionNumber?:array{LatestVersion?:bool, VersionNumber?:int}, SchemaVersionId?:string, MetadataList?:array<array{MetadataKey?:string, MetadataValue?:string}>, MaxResults?:int, NextToken?:string} $args
     * @return \AWS\Result<array{MetadataInfoMap?:array<string, array{MetadataValue?:string, CreatedTime?:string, OtherMetadataValueList?:array<array{MetadataValue?:string, CreatedTime?:string}>}>, SchemaVersionId?:string, NextToken?:string}>
     */
    public function querySchemaVersionMetadata(array $args = []): \AWS\Result { }

    /**
     * @param array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionNumber?:array{LatestVersion?:bool, VersionNumber?:int}, SchemaVersionId?:string, MetadataList?:array<array{MetadataKey?:string, MetadataValue?:string}>, MaxResults?:int, NextToken?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{MetadataInfoMap?:array<string, array{MetadataValue?:string, CreatedTime?:string, OtherMetadataValueList?:array<array{MetadataValue?:string, CreatedTime?:string}>}>, SchemaVersionId?:string, NextToken?:string}>
     */
    public function querySchemaVersionMetadataAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{SchemaId:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaDefinition:string} $args
     * @return \AWS\Result<array{SchemaVersionId?:string, VersionNumber?:int, Status?:"AVAILABLE"|"PENDING"|"FAILURE"|"DELETING"}>
     */
    public function registerSchemaVersion(array $args): \AWS\Result { }

    /**
     * @param array{SchemaId:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaDefinition:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{SchemaVersionId?:string, VersionNumber?:int, Status?:"AVAILABLE"|"PENDING"|"FAILURE"|"DELETING"}>
     */
    public function registerSchemaVersionAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionNumber?:array{LatestVersion?:bool, VersionNumber?:int}, SchemaVersionId?:string, MetadataKeyValue:array{MetadataKey?:string, MetadataValue?:string}} $args
     * @return \AWS\Result<array{SchemaArn?:string, SchemaName?:string, RegistryName?:string, LatestVersion?:bool, VersionNumber?:int, SchemaVersionId?:string, MetadataKey?:string, MetadataValue?:string}>
     */
    public function removeSchemaVersionMetadata(array $args): \AWS\Result { }

    /**
     * @param array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionNumber?:array{LatestVersion?:bool, VersionNumber?:int}, SchemaVersionId?:string, MetadataKeyValue:array{MetadataKey?:string, MetadataValue?:string}} $args
     * @return \GuzzleHttp\Promise\Promise<array{SchemaArn?:string, SchemaName?:string, RegistryName?:string, LatestVersion?:bool, VersionNumber?:int, SchemaVersionId?:string, MetadataKey?:string, MetadataValue?:string}>
     */
    public function removeSchemaVersionMetadataAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{JobName:string, RunId?:string} $args
     * @return \AWS\Result<array{JobBookmarkEntry?:array{JobName?:string, Version?:int, Run?:int, Attempt?:int, PreviousRunId?:string, RunId?:string, JobBookmark?:string}}>
     */
    public function resetJobBookmark(array $args): \AWS\Result { }

    /**
     * @param array{JobName:string, RunId?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{JobBookmarkEntry?:array{JobName?:string, Version?:int, Run?:int, Attempt?:int, PreviousRunId?:string, RunId?:string, JobBookmark?:string}}>
     */
    public function resetJobBookmarkAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Name:string, RunId:string, NodeIds:array<string>} $args
     * @return \AWS\Result<array{RunId?:string, NodeIds?:array<string>}>
     */
    public function resumeWorkflowRun(array $args): \AWS\Result { }

    /**
     * @param array{Name:string, RunId:string, NodeIds:array<string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{RunId?:string, NodeIds?:array<string>}>
     */
    public function resumeWorkflowRunAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{SessionId:string, Code:string, RequestOrigin?:string} $args
     * @return \AWS\Result<array{Id?:int}>
     */
    public function runStatement(array $args): \AWS\Result { }

    /**
     * @param array{SessionId:string, Code:string, RequestOrigin?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Id?:int}>
     */
    public function runStatementAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId?:string, NextToken?:string, Filters?:array<array{Key?:string, Value?:string, Comparator?:"EQUALS"|"GREATER_THAN"|"LESS_THAN"|"GREATER_THAN_EQUALS"|"LESS_THAN_EQUALS"}>, SearchText?:string, SortCriteria?:array<array{FieldName?:string, Sort?:"ASC"|"DESC"}>, MaxResults?:int, ResourceShareType?:"FOREIGN"|"ALL"|"FEDERATED", IncludeStatusDetails?:bool} $args
     * @return \AWS\Result<array{NextToken?:string, TableList?:array<array{Name:string, DatabaseName?:string, Description?:string, Owner?:string, CreateTime?:int|string|\DateTimeInterface, UpdateTime?:int|string|\DateTimeInterface, LastAccessTime?:int|string|\DateTimeInterface, LastAnalyzedTime?:int|string|\DateTimeInterface, Retention?:int, StorageDescriptor?:array{Columns?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, Location?:string, AdditionalLocations?:array<string>, InputFormat?:string, OutputFormat?:string, Compressed?:bool, NumberOfBuckets?:int, SerdeInfo?:array{Name?:string, SerializationLibrary?:string, Parameters?:array<string, string>}, BucketColumns?:array<string>, SortColumns?:array<array{Column:string, SortOrder:int}>, Parameters?:array<string, string>, SkewedInfo?:array{SkewedColumnNames?:array<string>, SkewedColumnValues?:array<string>, SkewedColumnValueLocationMaps?:array<string, string>}, StoredAsSubDirectories?:bool, SchemaReference?:array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionId?:string, SchemaVersionNumber?:int}}, PartitionKeys?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, ViewOriginalText?:string, ViewExpandedText?:string, TableType?:string, Parameters?:array<string, string>, CreatedBy?:string, IsRegisteredWithLakeFormation?:bool, TargetTable?:array{CatalogId?:string, DatabaseName?:string, Name?:string, Region?:string}, CatalogId?:string, VersionId?:string, FederatedTable?:array{Identifier?:string, DatabaseIdentifier?:string, ConnectionName?:string}, ViewDefinition?:array{IsProtected?:bool, Definer?:string, SubObjects?:array<string>, Representations?:array<array{Dialect?:"REDSHIFT"|"ATHENA"|"SPARK", DialectVersion?:string, ViewOriginalText?:string, ViewExpandedText?:string, ValidationConnection?:string, IsStale?:bool}>}, IsMultiDialectView?:bool, Status?:array{RequestedBy?:string, UpdatedBy?:string, RequestTime?:int|string|\DateTimeInterface, UpdateTime?:int|string|\DateTimeInterface, Action?:"UPDATE"|"CREATE", State?:"QUEUED"|"IN_PROGRESS"|"SUCCESS"|"STOPPED"|"FAILED", Error?:array{ErrorCode?:string, ErrorMessage?:string}, Details?:array{RequestedChange?:array{Name:string, DatabaseName?:string, Description?:string, Owner?:string, CreateTime?:int|string|\DateTimeInterface, UpdateTime?:int|string|\DateTimeInterface, LastAccessTime?:int|string|\DateTimeInterface, LastAnalyzedTime?:int|string|\DateTimeInterface, Retention?:int, StorageDescriptor?:array{Columns?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, Location?:string, AdditionalLocations?:array<string>, InputFormat?:string, OutputFormat?:string, Compressed?:bool, NumberOfBuckets?:int, SerdeInfo?:array{Name?:string, SerializationLibrary?:string, Parameters?:array<string, string>}, BucketColumns?:array<string>, SortColumns?:array<array{Column:string, SortOrder:int}>, Parameters?:array<string, string>, SkewedInfo?:array{SkewedColumnNames?:array<string>, SkewedColumnValues?:array<string>, SkewedColumnValueLocationMaps?:array<string, string>}, StoredAsSubDirectories?:bool, SchemaReference?:array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionId?:string, SchemaVersionNumber?:int}}, PartitionKeys?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, ViewOriginalText?:string, ViewExpandedText?:string, TableType?:string, Parameters?:array<string, string>, CreatedBy?:string, IsRegisteredWithLakeFormation?:bool, TargetTable?:array{CatalogId?:string, DatabaseName?:string, Name?:string, Region?:string}, CatalogId?:string, VersionId?:string, FederatedTable?:array{Identifier?:string, DatabaseIdentifier?:string, ConnectionName?:string}, ViewDefinition?:array{IsProtected?:bool, Definer?:string, SubObjects?:array<string>, Representations?:array<array{Dialect?:"REDSHIFT"|"ATHENA"|"SPARK", DialectVersion?:string, ViewOriginalText?:string, ViewExpandedText?:string, ValidationConnection?:string, IsStale?:bool}>}, IsMultiDialectView?:bool, Status?:mixed}, ViewValidations?:array<array{Dialect?:"REDSHIFT"|"ATHENA"|"SPARK", DialectVersion?:string, ViewValidationText?:string, UpdateTime?:int|string|\DateTimeInterface, State?:"QUEUED"|"IN_PROGRESS"|"SUCCESS"|"STOPPED"|"FAILED", Error?:array{ErrorCode?:string, ErrorMessage?:string}}>}}}>}>
     */
    public function searchTables(array $args = []): \AWS\Result { }

    /**
     * @param array{CatalogId?:string, NextToken?:string, Filters?:array<array{Key?:string, Value?:string, Comparator?:"EQUALS"|"GREATER_THAN"|"LESS_THAN"|"GREATER_THAN_EQUALS"|"LESS_THAN_EQUALS"}>, SearchText?:string, SortCriteria?:array<array{FieldName?:string, Sort?:"ASC"|"DESC"}>, MaxResults?:int, ResourceShareType?:"FOREIGN"|"ALL"|"FEDERATED", IncludeStatusDetails?:bool} $args
     * @return \GuzzleHttp\Promise\Promise<array{NextToken?:string, TableList?:array<array{Name:string, DatabaseName?:string, Description?:string, Owner?:string, CreateTime?:int|string|\DateTimeInterface, UpdateTime?:int|string|\DateTimeInterface, LastAccessTime?:int|string|\DateTimeInterface, LastAnalyzedTime?:int|string|\DateTimeInterface, Retention?:int, StorageDescriptor?:array{Columns?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, Location?:string, AdditionalLocations?:array<string>, InputFormat?:string, OutputFormat?:string, Compressed?:bool, NumberOfBuckets?:int, SerdeInfo?:array{Name?:string, SerializationLibrary?:string, Parameters?:array<string, string>}, BucketColumns?:array<string>, SortColumns?:array<array{Column:string, SortOrder:int}>, Parameters?:array<string, string>, SkewedInfo?:array{SkewedColumnNames?:array<string>, SkewedColumnValues?:array<string>, SkewedColumnValueLocationMaps?:array<string, string>}, StoredAsSubDirectories?:bool, SchemaReference?:array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionId?:string, SchemaVersionNumber?:int}}, PartitionKeys?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, ViewOriginalText?:string, ViewExpandedText?:string, TableType?:string, Parameters?:array<string, string>, CreatedBy?:string, IsRegisteredWithLakeFormation?:bool, TargetTable?:array{CatalogId?:string, DatabaseName?:string, Name?:string, Region?:string}, CatalogId?:string, VersionId?:string, FederatedTable?:array{Identifier?:string, DatabaseIdentifier?:string, ConnectionName?:string}, ViewDefinition?:array{IsProtected?:bool, Definer?:string, SubObjects?:array<string>, Representations?:array<array{Dialect?:"REDSHIFT"|"ATHENA"|"SPARK", DialectVersion?:string, ViewOriginalText?:string, ViewExpandedText?:string, ValidationConnection?:string, IsStale?:bool}>}, IsMultiDialectView?:bool, Status?:array{RequestedBy?:string, UpdatedBy?:string, RequestTime?:int|string|\DateTimeInterface, UpdateTime?:int|string|\DateTimeInterface, Action?:"UPDATE"|"CREATE", State?:"QUEUED"|"IN_PROGRESS"|"SUCCESS"|"STOPPED"|"FAILED", Error?:array{ErrorCode?:string, ErrorMessage?:string}, Details?:array{RequestedChange?:array{Name:string, DatabaseName?:string, Description?:string, Owner?:string, CreateTime?:int|string|\DateTimeInterface, UpdateTime?:int|string|\DateTimeInterface, LastAccessTime?:int|string|\DateTimeInterface, LastAnalyzedTime?:int|string|\DateTimeInterface, Retention?:int, StorageDescriptor?:array{Columns?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, Location?:string, AdditionalLocations?:array<string>, InputFormat?:string, OutputFormat?:string, Compressed?:bool, NumberOfBuckets?:int, SerdeInfo?:array{Name?:string, SerializationLibrary?:string, Parameters?:array<string, string>}, BucketColumns?:array<string>, SortColumns?:array<array{Column:string, SortOrder:int}>, Parameters?:array<string, string>, SkewedInfo?:array{SkewedColumnNames?:array<string>, SkewedColumnValues?:array<string>, SkewedColumnValueLocationMaps?:array<string, string>}, StoredAsSubDirectories?:bool, SchemaReference?:array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionId?:string, SchemaVersionNumber?:int}}, PartitionKeys?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, ViewOriginalText?:string, ViewExpandedText?:string, TableType?:string, Parameters?:array<string, string>, CreatedBy?:string, IsRegisteredWithLakeFormation?:bool, TargetTable?:array{CatalogId?:string, DatabaseName?:string, Name?:string, Region?:string}, CatalogId?:string, VersionId?:string, FederatedTable?:array{Identifier?:string, DatabaseIdentifier?:string, ConnectionName?:string}, ViewDefinition?:array{IsProtected?:bool, Definer?:string, SubObjects?:array<string>, Representations?:array<array{Dialect?:"REDSHIFT"|"ATHENA"|"SPARK", DialectVersion?:string, ViewOriginalText?:string, ViewExpandedText?:string, ValidationConnection?:string, IsStale?:bool}>}, IsMultiDialectView?:bool, Status?:mixed}, ViewValidations?:array<array{Dialect?:"REDSHIFT"|"ATHENA"|"SPARK", DialectVersion?:string, ViewValidationText?:string, UpdateTime?:int|string|\DateTimeInterface, State?:"QUEUED"|"IN_PROGRESS"|"SUCCESS"|"STOPPED"|"FAILED", Error?:array{ErrorCode?:string, ErrorMessage?:string}}>}}}>}>
     */
    public function searchTablesAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{BlueprintName:string, Parameters?:string, RoleArn:string} $args
     * @return \AWS\Result<array{RunId?:string}>
     */
    public function startBlueprintRun(array $args): \AWS\Result { }

    /**
     * @param array{BlueprintName:string, Parameters?:string, RoleArn:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{RunId?:string}>
     */
    public function startBlueprintRunAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{DatabaseName:string, TableName:string, ColumnNameList?:array<string>, Role:string, SampleSize?:float, CatalogID?:string, SecurityConfiguration?:string} $args
     * @return \AWS\Result<array{ColumnStatisticsTaskRunId?:string}>
     */
    public function startColumnStatisticsTaskRun(array $args): \AWS\Result { }

    /**
     * @param array{DatabaseName:string, TableName:string, ColumnNameList?:array<string>, Role:string, SampleSize?:float, CatalogID?:string, SecurityConfiguration?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{ColumnStatisticsTaskRunId?:string}>
     */
    public function startColumnStatisticsTaskRunAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{DatabaseName:string, TableName:string} $args
     * @return \AWS\Result<array{}>
     */
    public function startColumnStatisticsTaskRunSchedule(array $args): \AWS\Result { }

    /**
     * @param array{DatabaseName:string, TableName:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function startColumnStatisticsTaskRunScheduleAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Name:string} $args
     * @return \AWS\Result<array{}>
     */
    public function startCrawler(array $args): \AWS\Result { }

    /**
     * @param array{Name:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function startCrawlerAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CrawlerName:string} $args
     * @return \AWS\Result<array{}>
     */
    public function startCrawlerSchedule(array $args): \AWS\Result { }

    /**
     * @param array{CrawlerName:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function startCrawlerScheduleAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{DataSource:array{GlueTable:array{DatabaseName:string, TableName:string, CatalogId?:string, ConnectionName?:string, AdditionalOptions?:array<string, string>}}, Role:string, NumberOfWorkers?:int, Timeout?:int, CreatedRulesetName?:string, DataQualitySecurityConfiguration?:string, ClientToken?:string} $args
     * @return \AWS\Result<array{RunId?:string}>
     */
    public function startDataQualityRuleRecommendationRun(array $args): \AWS\Result { }

    /**
     * @param array{DataSource:array{GlueTable:array{DatabaseName:string, TableName:string, CatalogId?:string, ConnectionName?:string, AdditionalOptions?:array<string, string>}}, Role:string, NumberOfWorkers?:int, Timeout?:int, CreatedRulesetName?:string, DataQualitySecurityConfiguration?:string, ClientToken?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{RunId?:string}>
     */
    public function startDataQualityRuleRecommendationRunAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{DataSource:array{GlueTable:array{DatabaseName:string, TableName:string, CatalogId?:string, ConnectionName?:string, AdditionalOptions?:array<string, string>}}, Role:string, NumberOfWorkers?:int, Timeout?:int, ClientToken?:string, AdditionalRunOptions?:array{CloudWatchMetricsEnabled?:bool, ResultsS3Prefix?:string, CompositeRuleEvaluationMethod?:"COLUMN"|"ROW"}, RulesetNames:array<string>, AdditionalDataSources?:array<string, array{GlueTable:array{DatabaseName:string, TableName:string, CatalogId?:string, ConnectionName?:string, AdditionalOptions?:array<string, string>}}>} $args
     * @return \AWS\Result<array{RunId?:string}>
     */
    public function startDataQualityRulesetEvaluationRun(array $args): \AWS\Result { }

    /**
     * @param array{DataSource:array{GlueTable:array{DatabaseName:string, TableName:string, CatalogId?:string, ConnectionName?:string, AdditionalOptions?:array<string, string>}}, Role:string, NumberOfWorkers?:int, Timeout?:int, ClientToken?:string, AdditionalRunOptions?:array{CloudWatchMetricsEnabled?:bool, ResultsS3Prefix?:string, CompositeRuleEvaluationMethod?:"COLUMN"|"ROW"}, RulesetNames:array<string>, AdditionalDataSources?:array<string, array{GlueTable:array{DatabaseName:string, TableName:string, CatalogId?:string, ConnectionName?:string, AdditionalOptions?:array<string, string>}}>} $args
     * @return \GuzzleHttp\Promise\Promise<array{RunId?:string}>
     */
    public function startDataQualityRulesetEvaluationRunAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{TransformId:string, OutputS3Path:string} $args
     * @return \AWS\Result<array{TaskRunId?:string}>
     */
    public function startExportLabelsTaskRun(array $args): \AWS\Result { }

    /**
     * @param array{TransformId:string, OutputS3Path:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{TaskRunId?:string}>
     */
    public function startExportLabelsTaskRunAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{TransformId:string, InputS3Path:string, ReplaceAllLabels?:bool} $args
     * @return \AWS\Result<array{TaskRunId?:string}>
     */
    public function startImportLabelsTaskRun(array $args): \AWS\Result { }

    /**
     * @param array{TransformId:string, InputS3Path:string, ReplaceAllLabels?:bool} $args
     * @return \GuzzleHttp\Promise\Promise<array{TaskRunId?:string}>
     */
    public function startImportLabelsTaskRunAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{JobName:string, JobRunQueuingEnabled?:bool, JobRunId?:string, Arguments?:array<string, string>, AllocatedCapacity?:int, Timeout?:int, MaxCapacity?:float, SecurityConfiguration?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", NumberOfWorkers?:int, ExecutionClass?:"FLEX"|"STANDARD"} $args
     * @return \AWS\Result<array{JobRunId?:string}>
     */
    public function startJobRun(array $args): \AWS\Result { }

    /**
     * @param array{JobName:string, JobRunQueuingEnabled?:bool, JobRunId?:string, Arguments?:array<string, string>, AllocatedCapacity?:int, Timeout?:int, MaxCapacity?:float, SecurityConfiguration?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", NumberOfWorkers?:int, ExecutionClass?:"FLEX"|"STANDARD"} $args
     * @return \GuzzleHttp\Promise\Promise<array{JobRunId?:string}>
     */
    public function startJobRunAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{TransformId:string} $args
     * @return \AWS\Result<array{TaskRunId?:string}>
     */
    public function startMLEvaluationTaskRun(array $args): \AWS\Result { }

    /**
     * @param array{TransformId:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{TaskRunId?:string}>
     */
    public function startMLEvaluationTaskRunAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{TransformId:string, OutputS3Path:string} $args
     * @return \AWS\Result<array{TaskRunId?:string}>
     */
    public function startMLLabelingSetGenerationTaskRun(array $args): \AWS\Result { }

    /**
     * @param array{TransformId:string, OutputS3Path:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{TaskRunId?:string}>
     */
    public function startMLLabelingSetGenerationTaskRunAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Name:string} $args
     * @return \AWS\Result<array{Name?:string}>
     */
    public function startTrigger(array $args): \AWS\Result { }

    /**
     * @param array{Name:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Name?:string}>
     */
    public function startTriggerAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Name:string, RunProperties?:array<string, string>} $args
     * @return \AWS\Result<array{RunId?:string}>
     */
    public function startWorkflowRun(array $args): \AWS\Result { }

    /**
     * @param array{Name:string, RunProperties?:array<string, string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{RunId?:string}>
     */
    public function startWorkflowRunAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{DatabaseName:string, TableName:string} $args
     * @return \AWS\Result<array{}>
     */
    public function stopColumnStatisticsTaskRun(array $args): \AWS\Result { }

    /**
     * @param array{DatabaseName:string, TableName:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function stopColumnStatisticsTaskRunAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{DatabaseName:string, TableName:string} $args
     * @return \AWS\Result<array{}>
     */
    public function stopColumnStatisticsTaskRunSchedule(array $args): \AWS\Result { }

    /**
     * @param array{DatabaseName:string, TableName:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function stopColumnStatisticsTaskRunScheduleAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Name:string} $args
     * @return \AWS\Result<array{}>
     */
    public function stopCrawler(array $args): \AWS\Result { }

    /**
     * @param array{Name:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function stopCrawlerAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CrawlerName:string} $args
     * @return \AWS\Result<array{}>
     */
    public function stopCrawlerSchedule(array $args): \AWS\Result { }

    /**
     * @param array{CrawlerName:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function stopCrawlerScheduleAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Id:string, RequestOrigin?:string} $args
     * @return \AWS\Result<array{Id?:string}>
     */
    public function stopSession(array $args): \AWS\Result { }

    /**
     * @param array{Id:string, RequestOrigin?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Id?:string}>
     */
    public function stopSessionAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Name:string} $args
     * @return \AWS\Result<array{Name?:string}>
     */
    public function stopTrigger(array $args): \AWS\Result { }

    /**
     * @param array{Name:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Name?:string}>
     */
    public function stopTriggerAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Name:string, RunId:string} $args
     * @return \AWS\Result<array{}>
     */
    public function stopWorkflowRun(array $args): \AWS\Result { }

    /**
     * @param array{Name:string, RunId:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function stopWorkflowRunAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ResourceArn:string, TagsToAdd:array<string, string>} $args
     * @return \AWS\Result<array{}>
     */
    public function tagResource(array $args): \AWS\Result { }

    /**
     * @param array{ResourceArn:string, TagsToAdd:array<string, string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function tagResourceAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ConnectionName?:string, CatalogId?:string, TestConnectionInput?:array{ConnectionType:"JDBC"|"SFTP"|"MONGODB"|"KAFKA"|"NETWORK"|"MARKETPLACE"|"CUSTOM"|"SALESFORCE"|"VIEW_VALIDATION_REDSHIFT"|"VIEW_VALIDATION_ATHENA"|"GOOGLEADS"|"GOOGLESHEETS"|"GOOGLEANALYTICS4"|"SERVICENOW"|"MARKETO"|"SAPODATA"|"ZENDESK"|"JIRACLOUD"|"NETSUITEERP"|"HUBSPOT"|"FACEBOOKADS"|"INSTAGRAMADS"|"ZOHOCRM"|"SALESFORCEPARDOT"|"SALESFORCEMARKETINGCLOUD"|"SLACK"|"STRIPE"|"INTERCOM"|"SNAPCHATADS", ConnectionProperties:array<"HOST"|"PORT"|"USERNAME"|"PASSWORD"|"ENCRYPTED_PASSWORD"|"JDBC_DRIVER_JAR_URI"|"JDBC_DRIVER_CLASS_NAME"|"JDBC_ENGINE"|"JDBC_ENGINE_VERSION"|"CONFIG_FILES"|"INSTANCE_ID"|"JDBC_CONNECTION_URL"|"JDBC_ENFORCE_SSL"|"CUSTOM_JDBC_CERT"|"SKIP_CUSTOM_JDBC_CERT_VALIDATION"|"CUSTOM_JDBC_CERT_STRING"|"CONNECTION_URL"|"KAFKA_BOOTSTRAP_SERVERS"|"KAFKA_SSL_ENABLED"|"KAFKA_CUSTOM_CERT"|"KAFKA_SKIP_CUSTOM_CERT_VALIDATION"|"KAFKA_CLIENT_KEYSTORE"|"KAFKA_CLIENT_KEYSTORE_PASSWORD"|"KAFKA_CLIENT_KEY_PASSWORD"|"ENCRYPTED_KAFKA_CLIENT_KEYSTORE_PASSWORD"|"ENCRYPTED_KAFKA_CLIENT_KEY_PASSWORD"|"KAFKA_SASL_MECHANISM"|"KAFKA_SASL_PLAIN_USERNAME"|"KAFKA_SASL_PLAIN_PASSWORD"|"ENCRYPTED_KAFKA_SASL_PLAIN_PASSWORD"|"KAFKA_SASL_SCRAM_USERNAME"|"KAFKA_SASL_SCRAM_PASSWORD"|"KAFKA_SASL_SCRAM_SECRETS_ARN"|"ENCRYPTED_KAFKA_SASL_SCRAM_PASSWORD"|"KAFKA_SASL_GSSAPI_KEYTAB"|"KAFKA_SASL_GSSAPI_KRB5_CONF"|"KAFKA_SASL_GSSAPI_SERVICE"|"KAFKA_SASL_GSSAPI_PRINCIPAL"|"SECRET_ID"|"CONNECTOR_URL"|"CONNECTOR_TYPE"|"CONNECTOR_CLASS_NAME"|"ENDPOINT"|"ENDPOINT_TYPE"|"ROLE_ARN"|"REGION"|"WORKGROUP_NAME"|"CLUSTER_IDENTIFIER"|"DATABASE", string>, AuthenticationConfiguration?:array{AuthenticationType?:"BASIC"|"OAUTH2"|"CUSTOM"|"IAM", OAuth2Properties?:array{OAuth2GrantType?:"AUTHORIZATION_CODE"|"CLIENT_CREDENTIALS"|"JWT_BEARER", OAuth2ClientApplication?:array{UserManagedClientApplicationClientId?:string, AWSManagedClientApplicationReference?:string}, TokenUrl?:string, TokenUrlParametersMap?:array<string, string>, AuthorizationCodeProperties?:array{AuthorizationCode?:string, RedirectUri?:string}, OAuth2Credentials?:array{UserManagedClientApplicationClientSecret?:string, AccessToken?:string, RefreshToken?:string, JwtToken?:string}}, SecretArn?:string, KmsKeyArn?:string, BasicAuthenticationCredentials?:array{Username?:string, Password?:string}, CustomAuthenticationCredentials?:array<string, string>}}} $args
     * @return \AWS\Result<array{}>
     */
    public function testConnection(array $args = []): \AWS\Result { }

    /**
     * @param array{ConnectionName?:string, CatalogId?:string, TestConnectionInput?:array{ConnectionType:"JDBC"|"SFTP"|"MONGODB"|"KAFKA"|"NETWORK"|"MARKETPLACE"|"CUSTOM"|"SALESFORCE"|"VIEW_VALIDATION_REDSHIFT"|"VIEW_VALIDATION_ATHENA"|"GOOGLEADS"|"GOOGLESHEETS"|"GOOGLEANALYTICS4"|"SERVICENOW"|"MARKETO"|"SAPODATA"|"ZENDESK"|"JIRACLOUD"|"NETSUITEERP"|"HUBSPOT"|"FACEBOOKADS"|"INSTAGRAMADS"|"ZOHOCRM"|"SALESFORCEPARDOT"|"SALESFORCEMARKETINGCLOUD"|"SLACK"|"STRIPE"|"INTERCOM"|"SNAPCHATADS", ConnectionProperties:array<"HOST"|"PORT"|"USERNAME"|"PASSWORD"|"ENCRYPTED_PASSWORD"|"JDBC_DRIVER_JAR_URI"|"JDBC_DRIVER_CLASS_NAME"|"JDBC_ENGINE"|"JDBC_ENGINE_VERSION"|"CONFIG_FILES"|"INSTANCE_ID"|"JDBC_CONNECTION_URL"|"JDBC_ENFORCE_SSL"|"CUSTOM_JDBC_CERT"|"SKIP_CUSTOM_JDBC_CERT_VALIDATION"|"CUSTOM_JDBC_CERT_STRING"|"CONNECTION_URL"|"KAFKA_BOOTSTRAP_SERVERS"|"KAFKA_SSL_ENABLED"|"KAFKA_CUSTOM_CERT"|"KAFKA_SKIP_CUSTOM_CERT_VALIDATION"|"KAFKA_CLIENT_KEYSTORE"|"KAFKA_CLIENT_KEYSTORE_PASSWORD"|"KAFKA_CLIENT_KEY_PASSWORD"|"ENCRYPTED_KAFKA_CLIENT_KEYSTORE_PASSWORD"|"ENCRYPTED_KAFKA_CLIENT_KEY_PASSWORD"|"KAFKA_SASL_MECHANISM"|"KAFKA_SASL_PLAIN_USERNAME"|"KAFKA_SASL_PLAIN_PASSWORD"|"ENCRYPTED_KAFKA_SASL_PLAIN_PASSWORD"|"KAFKA_SASL_SCRAM_USERNAME"|"KAFKA_SASL_SCRAM_PASSWORD"|"KAFKA_SASL_SCRAM_SECRETS_ARN"|"ENCRYPTED_KAFKA_SASL_SCRAM_PASSWORD"|"KAFKA_SASL_GSSAPI_KEYTAB"|"KAFKA_SASL_GSSAPI_KRB5_CONF"|"KAFKA_SASL_GSSAPI_SERVICE"|"KAFKA_SASL_GSSAPI_PRINCIPAL"|"SECRET_ID"|"CONNECTOR_URL"|"CONNECTOR_TYPE"|"CONNECTOR_CLASS_NAME"|"ENDPOINT"|"ENDPOINT_TYPE"|"ROLE_ARN"|"REGION"|"WORKGROUP_NAME"|"CLUSTER_IDENTIFIER"|"DATABASE", string>, AuthenticationConfiguration?:array{AuthenticationType?:"BASIC"|"OAUTH2"|"CUSTOM"|"IAM", OAuth2Properties?:array{OAuth2GrantType?:"AUTHORIZATION_CODE"|"CLIENT_CREDENTIALS"|"JWT_BEARER", OAuth2ClientApplication?:array{UserManagedClientApplicationClientId?:string, AWSManagedClientApplicationReference?:string}, TokenUrl?:string, TokenUrlParametersMap?:array<string, string>, AuthorizationCodeProperties?:array{AuthorizationCode?:string, RedirectUri?:string}, OAuth2Credentials?:array{UserManagedClientApplicationClientSecret?:string, AccessToken?:string, RefreshToken?:string, JwtToken?:string}}, SecretArn?:string, KmsKeyArn?:string, BasicAuthenticationCredentials?:array{Username?:string, Password?:string}, CustomAuthenticationCredentials?:array<string, string>}}} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function testConnectionAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ResourceArn:string, TagsToRemove:array<string>} $args
     * @return \AWS\Result<array{}>
     */
    public function untagResource(array $args): \AWS\Result { }

    /**
     * @param array{ResourceArn:string, TagsToRemove:array<string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function untagResourceAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Name:string, Description?:string, BlueprintLocation:string} $args
     * @return \AWS\Result<array{Name?:string}>
     */
    public function updateBlueprint(array $args): \AWS\Result { }

    /**
     * @param array{Name:string, Description?:string, BlueprintLocation:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Name?:string}>
     */
    public function updateBlueprintAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId:string, CatalogInput:array{Description?:string, FederatedCatalog?:array{Identifier?:string, ConnectionName?:string}, Parameters?:array<string, string>, TargetRedshiftCatalog?:array{CatalogArn:string}, CatalogProperties?:array{DataLakeAccessProperties?:array{DataLakeAccess?:bool, DataTransferRole?:string, KmsKey?:string, CatalogType?:string}, CustomProperties?:array<string, string>}, CreateTableDefaultPermissions?:array<array{Principal?:array{DataLakePrincipalIdentifier?:string}, Permissions?:array<"ALL"|"SELECT"|"ALTER"|"DROP"|"DELETE"|"INSERT"|"CREATE_DATABASE"|"CREATE_TABLE"|"DATA_LOCATION_ACCESS">}>, CreateDatabaseDefaultPermissions?:array<array{Principal?:array{DataLakePrincipalIdentifier?:string}, Permissions?:array<"ALL"|"SELECT"|"ALTER"|"DROP"|"DELETE"|"INSERT"|"CREATE_DATABASE"|"CREATE_TABLE"|"DATA_LOCATION_ACCESS">}>}} $args
     * @return \AWS\Result<array{}>
     */
    public function updateCatalog(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId:string, CatalogInput:array{Description?:string, FederatedCatalog?:array{Identifier?:string, ConnectionName?:string}, Parameters?:array<string, string>, TargetRedshiftCatalog?:array{CatalogArn:string}, CatalogProperties?:array{DataLakeAccessProperties?:array{DataLakeAccess?:bool, DataTransferRole?:string, KmsKey?:string, CatalogType?:string}, CustomProperties?:array<string, string>}, CreateTableDefaultPermissions?:array<array{Principal?:array{DataLakePrincipalIdentifier?:string}, Permissions?:array<"ALL"|"SELECT"|"ALTER"|"DROP"|"DELETE"|"INSERT"|"CREATE_DATABASE"|"CREATE_TABLE"|"DATA_LOCATION_ACCESS">}>, CreateDatabaseDefaultPermissions?:array<array{Principal?:array{DataLakePrincipalIdentifier?:string}, Permissions?:array<"ALL"|"SELECT"|"ALTER"|"DROP"|"DELETE"|"INSERT"|"CREATE_DATABASE"|"CREATE_TABLE"|"DATA_LOCATION_ACCESS">}>}} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function updateCatalogAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{GrokClassifier?:array{Name:string, Classification?:string, GrokPattern?:string, CustomPatterns?:string}, XMLClassifier?:array{Name:string, Classification?:string, RowTag?:string}, JsonClassifier?:array{Name:string, JsonPath?:string}, CsvClassifier?:array{Name:string, Delimiter?:string, QuoteSymbol?:string, ContainsHeader?:"UNKNOWN"|"PRESENT"|"ABSENT", Header?:array<string>, DisableValueTrimming?:bool, AllowSingleColumn?:bool, CustomDatatypeConfigured?:bool, CustomDatatypes?:array<string>, Serde?:"OpenCSVSerDe"|"LazySimpleSerDe"|"None"}} $args
     * @return \AWS\Result<array{}>
     */
    public function updateClassifier(array $args = []): \AWS\Result { }

    /**
     * @param array{GrokClassifier?:array{Name:string, Classification?:string, GrokPattern?:string, CustomPatterns?:string}, XMLClassifier?:array{Name:string, Classification?:string, RowTag?:string}, JsonClassifier?:array{Name:string, JsonPath?:string}, CsvClassifier?:array{Name:string, Delimiter?:string, QuoteSymbol?:string, ContainsHeader?:"UNKNOWN"|"PRESENT"|"ABSENT", Header?:array<string>, DisableValueTrimming?:bool, AllowSingleColumn?:bool, CustomDatatypeConfigured?:bool, CustomDatatypes?:array<string>, Serde?:"OpenCSVSerDe"|"LazySimpleSerDe"|"None"}} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function updateClassifierAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, TableName:string, PartitionValues:array<string>, ColumnStatisticsList:array<array{ColumnName:string, ColumnType:string, AnalyzedTime:int|string|\DateTimeInterface, StatisticsData:array{Type:"BOOLEAN"|"DATE"|"DECIMAL"|"DOUBLE"|"LONG"|"STRING"|"BINARY", BooleanColumnStatisticsData?:array{NumberOfTrues:int, NumberOfFalses:int, NumberOfNulls:int}, DateColumnStatisticsData?:array{MinimumValue?:int|string|\DateTimeInterface, MaximumValue?:int|string|\DateTimeInterface, NumberOfNulls:int, NumberOfDistinctValues:int}, DecimalColumnStatisticsData?:array{MinimumValue?:array{UnscaledValue:string|resource|\Psr\Http\Message\StreamInterface, Scale:int}, MaximumValue?:array{UnscaledValue:string|resource|\Psr\Http\Message\StreamInterface, Scale:int}, NumberOfNulls:int, NumberOfDistinctValues:int}, DoubleColumnStatisticsData?:array{MinimumValue?:float, MaximumValue?:float, NumberOfNulls:int, NumberOfDistinctValues:int}, LongColumnStatisticsData?:array{MinimumValue?:int, MaximumValue?:int, NumberOfNulls:int, NumberOfDistinctValues:int}, StringColumnStatisticsData?:array{MaximumLength:int, AverageLength:float, NumberOfNulls:int, NumberOfDistinctValues:int}, BinaryColumnStatisticsData?:array{MaximumLength:int, AverageLength:float, NumberOfNulls:int}}}>} $args
     * @return \AWS\Result<array{Errors?:array<array{ColumnStatistics?:array{ColumnName:string, ColumnType:string, AnalyzedTime:int|string|\DateTimeInterface, StatisticsData:array{Type:"BOOLEAN"|"DATE"|"DECIMAL"|"DOUBLE"|"LONG"|"STRING"|"BINARY", BooleanColumnStatisticsData?:array{NumberOfTrues:int, NumberOfFalses:int, NumberOfNulls:int}, DateColumnStatisticsData?:array{MinimumValue?:int|string|\DateTimeInterface, MaximumValue?:int|string|\DateTimeInterface, NumberOfNulls:int, NumberOfDistinctValues:int}, DecimalColumnStatisticsData?:array{MinimumValue?:array{UnscaledValue:string|resource|\Psr\Http\Message\StreamInterface, Scale:int}, MaximumValue?:array{UnscaledValue:string|resource|\Psr\Http\Message\StreamInterface, Scale:int}, NumberOfNulls:int, NumberOfDistinctValues:int}, DoubleColumnStatisticsData?:array{MinimumValue?:float, MaximumValue?:float, NumberOfNulls:int, NumberOfDistinctValues:int}, LongColumnStatisticsData?:array{MinimumValue?:int, MaximumValue?:int, NumberOfNulls:int, NumberOfDistinctValues:int}, StringColumnStatisticsData?:array{MaximumLength:int, AverageLength:float, NumberOfNulls:int, NumberOfDistinctValues:int}, BinaryColumnStatisticsData?:array{MaximumLength:int, AverageLength:float, NumberOfNulls:int}}}, Error?:array{ErrorCode?:string, ErrorMessage?:string}}>}>
     */
    public function updateColumnStatisticsForPartition(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, TableName:string, PartitionValues:array<string>, ColumnStatisticsList:array<array{ColumnName:string, ColumnType:string, AnalyzedTime:int|string|\DateTimeInterface, StatisticsData:array{Type:"BOOLEAN"|"DATE"|"DECIMAL"|"DOUBLE"|"LONG"|"STRING"|"BINARY", BooleanColumnStatisticsData?:array{NumberOfTrues:int, NumberOfFalses:int, NumberOfNulls:int}, DateColumnStatisticsData?:array{MinimumValue?:int|string|\DateTimeInterface, MaximumValue?:int|string|\DateTimeInterface, NumberOfNulls:int, NumberOfDistinctValues:int}, DecimalColumnStatisticsData?:array{MinimumValue?:array{UnscaledValue:string|resource|\Psr\Http\Message\StreamInterface, Scale:int}, MaximumValue?:array{UnscaledValue:string|resource|\Psr\Http\Message\StreamInterface, Scale:int}, NumberOfNulls:int, NumberOfDistinctValues:int}, DoubleColumnStatisticsData?:array{MinimumValue?:float, MaximumValue?:float, NumberOfNulls:int, NumberOfDistinctValues:int}, LongColumnStatisticsData?:array{MinimumValue?:int, MaximumValue?:int, NumberOfNulls:int, NumberOfDistinctValues:int}, StringColumnStatisticsData?:array{MaximumLength:int, AverageLength:float, NumberOfNulls:int, NumberOfDistinctValues:int}, BinaryColumnStatisticsData?:array{MaximumLength:int, AverageLength:float, NumberOfNulls:int}}}>} $args
     * @return \GuzzleHttp\Promise\Promise<array{Errors?:array<array{ColumnStatistics?:array{ColumnName:string, ColumnType:string, AnalyzedTime:int|string|\DateTimeInterface, StatisticsData:array{Type:"BOOLEAN"|"DATE"|"DECIMAL"|"DOUBLE"|"LONG"|"STRING"|"BINARY", BooleanColumnStatisticsData?:array{NumberOfTrues:int, NumberOfFalses:int, NumberOfNulls:int}, DateColumnStatisticsData?:array{MinimumValue?:int|string|\DateTimeInterface, MaximumValue?:int|string|\DateTimeInterface, NumberOfNulls:int, NumberOfDistinctValues:int}, DecimalColumnStatisticsData?:array{MinimumValue?:array{UnscaledValue:string|resource|\Psr\Http\Message\StreamInterface, Scale:int}, MaximumValue?:array{UnscaledValue:string|resource|\Psr\Http\Message\StreamInterface, Scale:int}, NumberOfNulls:int, NumberOfDistinctValues:int}, DoubleColumnStatisticsData?:array{MinimumValue?:float, MaximumValue?:float, NumberOfNulls:int, NumberOfDistinctValues:int}, LongColumnStatisticsData?:array{MinimumValue?:int, MaximumValue?:int, NumberOfNulls:int, NumberOfDistinctValues:int}, StringColumnStatisticsData?:array{MaximumLength:int, AverageLength:float, NumberOfNulls:int, NumberOfDistinctValues:int}, BinaryColumnStatisticsData?:array{MaximumLength:int, AverageLength:float, NumberOfNulls:int}}}, Error?:array{ErrorCode?:string, ErrorMessage?:string}}>}>
     */
    public function updateColumnStatisticsForPartitionAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, TableName:string, ColumnStatisticsList:array<array{ColumnName:string, ColumnType:string, AnalyzedTime:int|string|\DateTimeInterface, StatisticsData:array{Type:"BOOLEAN"|"DATE"|"DECIMAL"|"DOUBLE"|"LONG"|"STRING"|"BINARY", BooleanColumnStatisticsData?:array{NumberOfTrues:int, NumberOfFalses:int, NumberOfNulls:int}, DateColumnStatisticsData?:array{MinimumValue?:int|string|\DateTimeInterface, MaximumValue?:int|string|\DateTimeInterface, NumberOfNulls:int, NumberOfDistinctValues:int}, DecimalColumnStatisticsData?:array{MinimumValue?:array{UnscaledValue:string|resource|\Psr\Http\Message\StreamInterface, Scale:int}, MaximumValue?:array{UnscaledValue:string|resource|\Psr\Http\Message\StreamInterface, Scale:int}, NumberOfNulls:int, NumberOfDistinctValues:int}, DoubleColumnStatisticsData?:array{MinimumValue?:float, MaximumValue?:float, NumberOfNulls:int, NumberOfDistinctValues:int}, LongColumnStatisticsData?:array{MinimumValue?:int, MaximumValue?:int, NumberOfNulls:int, NumberOfDistinctValues:int}, StringColumnStatisticsData?:array{MaximumLength:int, AverageLength:float, NumberOfNulls:int, NumberOfDistinctValues:int}, BinaryColumnStatisticsData?:array{MaximumLength:int, AverageLength:float, NumberOfNulls:int}}}>} $args
     * @return \AWS\Result<array{Errors?:array<array{ColumnStatistics?:array{ColumnName:string, ColumnType:string, AnalyzedTime:int|string|\DateTimeInterface, StatisticsData:array{Type:"BOOLEAN"|"DATE"|"DECIMAL"|"DOUBLE"|"LONG"|"STRING"|"BINARY", BooleanColumnStatisticsData?:array{NumberOfTrues:int, NumberOfFalses:int, NumberOfNulls:int}, DateColumnStatisticsData?:array{MinimumValue?:int|string|\DateTimeInterface, MaximumValue?:int|string|\DateTimeInterface, NumberOfNulls:int, NumberOfDistinctValues:int}, DecimalColumnStatisticsData?:array{MinimumValue?:array{UnscaledValue:string|resource|\Psr\Http\Message\StreamInterface, Scale:int}, MaximumValue?:array{UnscaledValue:string|resource|\Psr\Http\Message\StreamInterface, Scale:int}, NumberOfNulls:int, NumberOfDistinctValues:int}, DoubleColumnStatisticsData?:array{MinimumValue?:float, MaximumValue?:float, NumberOfNulls:int, NumberOfDistinctValues:int}, LongColumnStatisticsData?:array{MinimumValue?:int, MaximumValue?:int, NumberOfNulls:int, NumberOfDistinctValues:int}, StringColumnStatisticsData?:array{MaximumLength:int, AverageLength:float, NumberOfNulls:int, NumberOfDistinctValues:int}, BinaryColumnStatisticsData?:array{MaximumLength:int, AverageLength:float, NumberOfNulls:int}}}, Error?:array{ErrorCode?:string, ErrorMessage?:string}}>}>
     */
    public function updateColumnStatisticsForTable(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, TableName:string, ColumnStatisticsList:array<array{ColumnName:string, ColumnType:string, AnalyzedTime:int|string|\DateTimeInterface, StatisticsData:array{Type:"BOOLEAN"|"DATE"|"DECIMAL"|"DOUBLE"|"LONG"|"STRING"|"BINARY", BooleanColumnStatisticsData?:array{NumberOfTrues:int, NumberOfFalses:int, NumberOfNulls:int}, DateColumnStatisticsData?:array{MinimumValue?:int|string|\DateTimeInterface, MaximumValue?:int|string|\DateTimeInterface, NumberOfNulls:int, NumberOfDistinctValues:int}, DecimalColumnStatisticsData?:array{MinimumValue?:array{UnscaledValue:string|resource|\Psr\Http\Message\StreamInterface, Scale:int}, MaximumValue?:array{UnscaledValue:string|resource|\Psr\Http\Message\StreamInterface, Scale:int}, NumberOfNulls:int, NumberOfDistinctValues:int}, DoubleColumnStatisticsData?:array{MinimumValue?:float, MaximumValue?:float, NumberOfNulls:int, NumberOfDistinctValues:int}, LongColumnStatisticsData?:array{MinimumValue?:int, MaximumValue?:int, NumberOfNulls:int, NumberOfDistinctValues:int}, StringColumnStatisticsData?:array{MaximumLength:int, AverageLength:float, NumberOfNulls:int, NumberOfDistinctValues:int}, BinaryColumnStatisticsData?:array{MaximumLength:int, AverageLength:float, NumberOfNulls:int}}}>} $args
     * @return \GuzzleHttp\Promise\Promise<array{Errors?:array<array{ColumnStatistics?:array{ColumnName:string, ColumnType:string, AnalyzedTime:int|string|\DateTimeInterface, StatisticsData:array{Type:"BOOLEAN"|"DATE"|"DECIMAL"|"DOUBLE"|"LONG"|"STRING"|"BINARY", BooleanColumnStatisticsData?:array{NumberOfTrues:int, NumberOfFalses:int, NumberOfNulls:int}, DateColumnStatisticsData?:array{MinimumValue?:int|string|\DateTimeInterface, MaximumValue?:int|string|\DateTimeInterface, NumberOfNulls:int, NumberOfDistinctValues:int}, DecimalColumnStatisticsData?:array{MinimumValue?:array{UnscaledValue:string|resource|\Psr\Http\Message\StreamInterface, Scale:int}, MaximumValue?:array{UnscaledValue:string|resource|\Psr\Http\Message\StreamInterface, Scale:int}, NumberOfNulls:int, NumberOfDistinctValues:int}, DoubleColumnStatisticsData?:array{MinimumValue?:float, MaximumValue?:float, NumberOfNulls:int, NumberOfDistinctValues:int}, LongColumnStatisticsData?:array{MinimumValue?:int, MaximumValue?:int, NumberOfNulls:int, NumberOfDistinctValues:int}, StringColumnStatisticsData?:array{MaximumLength:int, AverageLength:float, NumberOfNulls:int, NumberOfDistinctValues:int}, BinaryColumnStatisticsData?:array{MaximumLength:int, AverageLength:float, NumberOfNulls:int}}}, Error?:array{ErrorCode?:string, ErrorMessage?:string}}>}>
     */
    public function updateColumnStatisticsForTableAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{DatabaseName:string, TableName:string, Role?:string, Schedule?:string, ColumnNameList?:array<string>, SampleSize?:float, CatalogID?:string, SecurityConfiguration?:string} $args
     * @return \AWS\Result<array{}>
     */
    public function updateColumnStatisticsTaskSettings(array $args): \AWS\Result { }

    /**
     * @param array{DatabaseName:string, TableName:string, Role?:string, Schedule?:string, ColumnNameList?:array<string>, SampleSize?:float, CatalogID?:string, SecurityConfiguration?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function updateColumnStatisticsTaskSettingsAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId?:string, Name:string, ConnectionInput:array{Name:string, Description?:string, ConnectionType:"JDBC"|"SFTP"|"MONGODB"|"KAFKA"|"NETWORK"|"MARKETPLACE"|"CUSTOM"|"SALESFORCE"|"VIEW_VALIDATION_REDSHIFT"|"VIEW_VALIDATION_ATHENA"|"GOOGLEADS"|"GOOGLESHEETS"|"GOOGLEANALYTICS4"|"SERVICENOW"|"MARKETO"|"SAPODATA"|"ZENDESK"|"JIRACLOUD"|"NETSUITEERP"|"HUBSPOT"|"FACEBOOKADS"|"INSTAGRAMADS"|"ZOHOCRM"|"SALESFORCEPARDOT"|"SALESFORCEMARKETINGCLOUD"|"SLACK"|"STRIPE"|"INTERCOM"|"SNAPCHATADS", MatchCriteria?:array<string>, ConnectionProperties:array<"HOST"|"PORT"|"USERNAME"|"PASSWORD"|"ENCRYPTED_PASSWORD"|"JDBC_DRIVER_JAR_URI"|"JDBC_DRIVER_CLASS_NAME"|"JDBC_ENGINE"|"JDBC_ENGINE_VERSION"|"CONFIG_FILES"|"INSTANCE_ID"|"JDBC_CONNECTION_URL"|"JDBC_ENFORCE_SSL"|"CUSTOM_JDBC_CERT"|"SKIP_CUSTOM_JDBC_CERT_VALIDATION"|"CUSTOM_JDBC_CERT_STRING"|"CONNECTION_URL"|"KAFKA_BOOTSTRAP_SERVERS"|"KAFKA_SSL_ENABLED"|"KAFKA_CUSTOM_CERT"|"KAFKA_SKIP_CUSTOM_CERT_VALIDATION"|"KAFKA_CLIENT_KEYSTORE"|"KAFKA_CLIENT_KEYSTORE_PASSWORD"|"KAFKA_CLIENT_KEY_PASSWORD"|"ENCRYPTED_KAFKA_CLIENT_KEYSTORE_PASSWORD"|"ENCRYPTED_KAFKA_CLIENT_KEY_PASSWORD"|"KAFKA_SASL_MECHANISM"|"KAFKA_SASL_PLAIN_USERNAME"|"KAFKA_SASL_PLAIN_PASSWORD"|"ENCRYPTED_KAFKA_SASL_PLAIN_PASSWORD"|"KAFKA_SASL_SCRAM_USERNAME"|"KAFKA_SASL_SCRAM_PASSWORD"|"KAFKA_SASL_SCRAM_SECRETS_ARN"|"ENCRYPTED_KAFKA_SASL_SCRAM_PASSWORD"|"KAFKA_SASL_GSSAPI_KEYTAB"|"KAFKA_SASL_GSSAPI_KRB5_CONF"|"KAFKA_SASL_GSSAPI_SERVICE"|"KAFKA_SASL_GSSAPI_PRINCIPAL"|"SECRET_ID"|"CONNECTOR_URL"|"CONNECTOR_TYPE"|"CONNECTOR_CLASS_NAME"|"ENDPOINT"|"ENDPOINT_TYPE"|"ROLE_ARN"|"REGION"|"WORKGROUP_NAME"|"CLUSTER_IDENTIFIER"|"DATABASE", string>, SparkProperties?:array<string, string>, AthenaProperties?:array<string, string>, PythonProperties?:array<string, string>, PhysicalConnectionRequirements?:array{SubnetId?:string, SecurityGroupIdList?:array<string>, AvailabilityZone?:string}, AuthenticationConfiguration?:array{AuthenticationType?:"BASIC"|"OAUTH2"|"CUSTOM"|"IAM", OAuth2Properties?:array{OAuth2GrantType?:"AUTHORIZATION_CODE"|"CLIENT_CREDENTIALS"|"JWT_BEARER", OAuth2ClientApplication?:array{UserManagedClientApplicationClientId?:string, AWSManagedClientApplicationReference?:string}, TokenUrl?:string, TokenUrlParametersMap?:array<string, string>, AuthorizationCodeProperties?:array{AuthorizationCode?:string, RedirectUri?:string}, OAuth2Credentials?:array{UserManagedClientApplicationClientSecret?:string, AccessToken?:string, RefreshToken?:string, JwtToken?:string}}, SecretArn?:string, KmsKeyArn?:string, BasicAuthenticationCredentials?:array{Username?:string, Password?:string}, CustomAuthenticationCredentials?:array<string, string>}, ValidateCredentials?:bool, ValidateForComputeEnvironments?:array<"SPARK"|"ATHENA"|"PYTHON">}} $args
     * @return \AWS\Result<array{}>
     */
    public function updateConnection(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId?:string, Name:string, ConnectionInput:array{Name:string, Description?:string, ConnectionType:"JDBC"|"SFTP"|"MONGODB"|"KAFKA"|"NETWORK"|"MARKETPLACE"|"CUSTOM"|"SALESFORCE"|"VIEW_VALIDATION_REDSHIFT"|"VIEW_VALIDATION_ATHENA"|"GOOGLEADS"|"GOOGLESHEETS"|"GOOGLEANALYTICS4"|"SERVICENOW"|"MARKETO"|"SAPODATA"|"ZENDESK"|"JIRACLOUD"|"NETSUITEERP"|"HUBSPOT"|"FACEBOOKADS"|"INSTAGRAMADS"|"ZOHOCRM"|"SALESFORCEPARDOT"|"SALESFORCEMARKETINGCLOUD"|"SLACK"|"STRIPE"|"INTERCOM"|"SNAPCHATADS", MatchCriteria?:array<string>, ConnectionProperties:array<"HOST"|"PORT"|"USERNAME"|"PASSWORD"|"ENCRYPTED_PASSWORD"|"JDBC_DRIVER_JAR_URI"|"JDBC_DRIVER_CLASS_NAME"|"JDBC_ENGINE"|"JDBC_ENGINE_VERSION"|"CONFIG_FILES"|"INSTANCE_ID"|"JDBC_CONNECTION_URL"|"JDBC_ENFORCE_SSL"|"CUSTOM_JDBC_CERT"|"SKIP_CUSTOM_JDBC_CERT_VALIDATION"|"CUSTOM_JDBC_CERT_STRING"|"CONNECTION_URL"|"KAFKA_BOOTSTRAP_SERVERS"|"KAFKA_SSL_ENABLED"|"KAFKA_CUSTOM_CERT"|"KAFKA_SKIP_CUSTOM_CERT_VALIDATION"|"KAFKA_CLIENT_KEYSTORE"|"KAFKA_CLIENT_KEYSTORE_PASSWORD"|"KAFKA_CLIENT_KEY_PASSWORD"|"ENCRYPTED_KAFKA_CLIENT_KEYSTORE_PASSWORD"|"ENCRYPTED_KAFKA_CLIENT_KEY_PASSWORD"|"KAFKA_SASL_MECHANISM"|"KAFKA_SASL_PLAIN_USERNAME"|"KAFKA_SASL_PLAIN_PASSWORD"|"ENCRYPTED_KAFKA_SASL_PLAIN_PASSWORD"|"KAFKA_SASL_SCRAM_USERNAME"|"KAFKA_SASL_SCRAM_PASSWORD"|"KAFKA_SASL_SCRAM_SECRETS_ARN"|"ENCRYPTED_KAFKA_SASL_SCRAM_PASSWORD"|"KAFKA_SASL_GSSAPI_KEYTAB"|"KAFKA_SASL_GSSAPI_KRB5_CONF"|"KAFKA_SASL_GSSAPI_SERVICE"|"KAFKA_SASL_GSSAPI_PRINCIPAL"|"SECRET_ID"|"CONNECTOR_URL"|"CONNECTOR_TYPE"|"CONNECTOR_CLASS_NAME"|"ENDPOINT"|"ENDPOINT_TYPE"|"ROLE_ARN"|"REGION"|"WORKGROUP_NAME"|"CLUSTER_IDENTIFIER"|"DATABASE", string>, SparkProperties?:array<string, string>, AthenaProperties?:array<string, string>, PythonProperties?:array<string, string>, PhysicalConnectionRequirements?:array{SubnetId?:string, SecurityGroupIdList?:array<string>, AvailabilityZone?:string}, AuthenticationConfiguration?:array{AuthenticationType?:"BASIC"|"OAUTH2"|"CUSTOM"|"IAM", OAuth2Properties?:array{OAuth2GrantType?:"AUTHORIZATION_CODE"|"CLIENT_CREDENTIALS"|"JWT_BEARER", OAuth2ClientApplication?:array{UserManagedClientApplicationClientId?:string, AWSManagedClientApplicationReference?:string}, TokenUrl?:string, TokenUrlParametersMap?:array<string, string>, AuthorizationCodeProperties?:array{AuthorizationCode?:string, RedirectUri?:string}, OAuth2Credentials?:array{UserManagedClientApplicationClientSecret?:string, AccessToken?:string, RefreshToken?:string, JwtToken?:string}}, SecretArn?:string, KmsKeyArn?:string, BasicAuthenticationCredentials?:array{Username?:string, Password?:string}, CustomAuthenticationCredentials?:array<string, string>}, ValidateCredentials?:bool, ValidateForComputeEnvironments?:array<"SPARK"|"ATHENA"|"PYTHON">}} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function updateConnectionAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Name:string, Role?:string, DatabaseName?:string, Description?:string, Targets?:array{S3Targets?:array<array{Path?:string, Exclusions?:array<string>, ConnectionName?:string, SampleSize?:int, EventQueueArn?:string, DlqEventQueueArn?:string}>, JdbcTargets?:array<array{ConnectionName?:string, Path?:string, Exclusions?:array<string>, EnableAdditionalMetadata?:array<"COMMENTS"|"RAWTYPES">}>, MongoDBTargets?:array<array{ConnectionName?:string, Path?:string, ScanAll?:bool}>, DynamoDBTargets?:array<array{Path?:string, scanAll?:bool, scanRate?:float}>, CatalogTargets?:array<array{DatabaseName:string, Tables:array<string>, ConnectionName?:string, EventQueueArn?:string, DlqEventQueueArn?:string}>, DeltaTargets?:array<array{DeltaTables?:array<string>, ConnectionName?:string, WriteManifest?:bool, CreateNativeDeltaTable?:bool}>, IcebergTargets?:array<array{Paths?:array<string>, ConnectionName?:string, Exclusions?:array<string>, MaximumTraversalDepth?:int}>, HudiTargets?:array<array{Paths?:array<string>, ConnectionName?:string, Exclusions?:array<string>, MaximumTraversalDepth?:int}>}, Schedule?:string, Classifiers?:array<string>, TablePrefix?:string, SchemaChangePolicy?:array{UpdateBehavior?:"LOG"|"UPDATE_IN_DATABASE", DeleteBehavior?:"LOG"|"DELETE_FROM_DATABASE"|"DEPRECATE_IN_DATABASE"}, RecrawlPolicy?:array{RecrawlBehavior?:"CRAWL_EVERYTHING"|"CRAWL_NEW_FOLDERS_ONLY"|"CRAWL_EVENT_MODE"}, LineageConfiguration?:array{CrawlerLineageSettings?:"ENABLE"|"DISABLE"}, LakeFormationConfiguration?:array{UseLakeFormationCredentials?:bool, AccountId?:string}, Configuration?:string, CrawlerSecurityConfiguration?:string} $args
     * @return \AWS\Result<array{}>
     */
    public function updateCrawler(array $args): \AWS\Result { }

    /**
     * @param array{Name:string, Role?:string, DatabaseName?:string, Description?:string, Targets?:array{S3Targets?:array<array{Path?:string, Exclusions?:array<string>, ConnectionName?:string, SampleSize?:int, EventQueueArn?:string, DlqEventQueueArn?:string}>, JdbcTargets?:array<array{ConnectionName?:string, Path?:string, Exclusions?:array<string>, EnableAdditionalMetadata?:array<"COMMENTS"|"RAWTYPES">}>, MongoDBTargets?:array<array{ConnectionName?:string, Path?:string, ScanAll?:bool}>, DynamoDBTargets?:array<array{Path?:string, scanAll?:bool, scanRate?:float}>, CatalogTargets?:array<array{DatabaseName:string, Tables:array<string>, ConnectionName?:string, EventQueueArn?:string, DlqEventQueueArn?:string}>, DeltaTargets?:array<array{DeltaTables?:array<string>, ConnectionName?:string, WriteManifest?:bool, CreateNativeDeltaTable?:bool}>, IcebergTargets?:array<array{Paths?:array<string>, ConnectionName?:string, Exclusions?:array<string>, MaximumTraversalDepth?:int}>, HudiTargets?:array<array{Paths?:array<string>, ConnectionName?:string, Exclusions?:array<string>, MaximumTraversalDepth?:int}>}, Schedule?:string, Classifiers?:array<string>, TablePrefix?:string, SchemaChangePolicy?:array{UpdateBehavior?:"LOG"|"UPDATE_IN_DATABASE", DeleteBehavior?:"LOG"|"DELETE_FROM_DATABASE"|"DEPRECATE_IN_DATABASE"}, RecrawlPolicy?:array{RecrawlBehavior?:"CRAWL_EVERYTHING"|"CRAWL_NEW_FOLDERS_ONLY"|"CRAWL_EVENT_MODE"}, LineageConfiguration?:array{CrawlerLineageSettings?:"ENABLE"|"DISABLE"}, LakeFormationConfiguration?:array{UseLakeFormationCredentials?:bool, AccountId?:string}, Configuration?:string, CrawlerSecurityConfiguration?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function updateCrawlerAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CrawlerName:string, Schedule?:string} $args
     * @return \AWS\Result<array{}>
     */
    public function updateCrawlerSchedule(array $args): \AWS\Result { }

    /**
     * @param array{CrawlerName:string, Schedule?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function updateCrawlerScheduleAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Name:string, Description?:string, Ruleset?:string} $args
     * @return \AWS\Result<array{Name?:string, Description?:string, Ruleset?:string}>
     */
    public function updateDataQualityRuleset(array $args): \AWS\Result { }

    /**
     * @param array{Name:string, Description?:string, Ruleset?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Name?:string, Description?:string, Ruleset?:string}>
     */
    public function updateDataQualityRulesetAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId?:string, Name:string, DatabaseInput:array{Name:string, Description?:string, LocationUri?:string, Parameters?:array<string, string>, CreateTableDefaultPermissions?:array<array{Principal?:array{DataLakePrincipalIdentifier?:string}, Permissions?:array<"ALL"|"SELECT"|"ALTER"|"DROP"|"DELETE"|"INSERT"|"CREATE_DATABASE"|"CREATE_TABLE"|"DATA_LOCATION_ACCESS">}>, TargetDatabase?:array{CatalogId?:string, DatabaseName?:string, Region?:string}, FederatedDatabase?:array{Identifier?:string, ConnectionName?:string}}} $args
     * @return \AWS\Result<array{}>
     */
    public function updateDatabase(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId?:string, Name:string, DatabaseInput:array{Name:string, Description?:string, LocationUri?:string, Parameters?:array<string, string>, CreateTableDefaultPermissions?:array<array{Principal?:array{DataLakePrincipalIdentifier?:string}, Permissions?:array<"ALL"|"SELECT"|"ALTER"|"DROP"|"DELETE"|"INSERT"|"CREATE_DATABASE"|"CREATE_TABLE"|"DATA_LOCATION_ACCESS">}>, TargetDatabase?:array{CatalogId?:string, DatabaseName?:string, Region?:string}, FederatedDatabase?:array{Identifier?:string, ConnectionName?:string}}} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function updateDatabaseAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{EndpointName:string, PublicKey?:string, AddPublicKeys?:array<string>, DeletePublicKeys?:array<string>, CustomLibraries?:array{ExtraPythonLibsS3Path?:string, ExtraJarsS3Path?:string}, UpdateEtlLibraries?:bool, DeleteArguments?:array<string>, AddArguments?:array<string, string>} $args
     * @return \AWS\Result<array{}>
     */
    public function updateDevEndpoint(array $args): \AWS\Result { }

    /**
     * @param array{EndpointName:string, PublicKey?:string, AddPublicKeys?:array<string>, DeletePublicKeys?:array<string>, CustomLibraries?:array{ExtraPythonLibsS3Path?:string, ExtraJarsS3Path?:string}, UpdateEtlLibraries?:bool, DeleteArguments?:array<string>, AddArguments?:array<string, string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function updateDevEndpointAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ResourceArn:string, SourceProcessingProperties?:array{RoleArn?:string}, TargetProcessingProperties?:array{RoleArn?:string, KmsArn?:string, ConnectionName?:string, EventBusArn?:string}} $args
     * @return \AWS\Result<array{ResourceArn?:string, SourceProcessingProperties?:array{RoleArn?:string}, TargetProcessingProperties?:array{RoleArn?:string, KmsArn?:string, ConnectionName?:string, EventBusArn?:string}}>
     */
    public function updateIntegrationResourceProperty(array $args): \AWS\Result { }

    /**
     * @param array{ResourceArn:string, SourceProcessingProperties?:array{RoleArn?:string}, TargetProcessingProperties?:array{RoleArn?:string, KmsArn?:string, ConnectionName?:string, EventBusArn?:string}} $args
     * @return \GuzzleHttp\Promise\Promise<array{ResourceArn?:string, SourceProcessingProperties?:array{RoleArn?:string}, TargetProcessingProperties?:array{RoleArn?:string, KmsArn?:string, ConnectionName?:string, EventBusArn?:string}}>
     */
    public function updateIntegrationResourcePropertyAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ResourceArn:string, TableName:string, SourceTableConfig?:array{Fields?:array<string>, FilterPredicate?:string, PrimaryKey?:array<string>, RecordUpdateField?:string}, TargetTableConfig?:array{UnnestSpec?:"TOPLEVEL"|"FULL"|"NOUNNEST", PartitionSpec?:array<array{FieldName?:string, FunctionSpec?:string}>, TargetTableName?:string}} $args
     * @return \AWS\Result<array{}>
     */
    public function updateIntegrationTableProperties(array $args): \AWS\Result { }

    /**
     * @param array{ResourceArn:string, TableName:string, SourceTableConfig?:array{Fields?:array<string>, FilterPredicate?:string, PrimaryKey?:array<string>, RecordUpdateField?:string}, TargetTableConfig?:array{UnnestSpec?:"TOPLEVEL"|"FULL"|"NOUNNEST", PartitionSpec?:array<array{FieldName?:string, FunctionSpec?:string}>, TargetTableName?:string}} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function updateIntegrationTablePropertiesAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{JobName:string, JobUpdate:array{JobMode?:"SCRIPT"|"VISUAL"|"NOTEBOOK", JobRunQueuingEnabled?:bool, Description?:string, LogUri?:string, Role?:string, ExecutionProperty?:array{MaxConcurrentRuns?:int}, Command?:array{Name?:string, ScriptLocation?:string, PythonVersion?:string, Runtime?:string}, DefaultArguments?:array<string, string>, NonOverridableArguments?:array<string, string>, Connections?:array{Connections?:mixed}, MaxRetries?:int, AllocatedCapacity?:int, Timeout?:int, MaxCapacity?:float, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", NumberOfWorkers?:int, SecurityConfiguration?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, GlueVersion?:string, CodeGenConfigurationNodes?:array<string, array{AthenaConnectorSource?:array{Name:string, ConnectionName:string, ConnectorName:string, ConnectionType:string, ConnectionTable?:string, SchemaName:string, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, JDBCConnectorSource?:array{Name:string, ConnectionName:string, ConnectorName:string, ConnectionType:string, AdditionalOptions?:array{FilterPredicate?:string, PartitionColumn?:string, LowerBound?:int, UpperBound?:int, NumPartitions?:int, JobBookmarkKeys?:array<string>, JobBookmarkKeysSortOrder?:string, DataTypeMapping?:array<"ARRAY"|"BIGINT"|"BINARY"|"BIT"|"BLOB"|"BOOLEAN"|"CHAR"|"CLOB"|"DATALINK"|"DATE"|"DECIMAL"|"DISTINCT"|"DOUBLE"|"FLOAT"|"INTEGER"|"JAVA_OBJECT"|"LONGNVARCHAR"|"LONGVARBINARY"|"LONGVARCHAR"|"NCHAR"|"NCLOB"|"NULL"|"NUMERIC"|"NVARCHAR"|"OTHER"|"REAL"|"REF"|"REF_CURSOR"|"ROWID"|"SMALLINT"|"SQLXML"|"STRUCT"|"TIME"|"TIME_WITH_TIMEZONE"|"TIMESTAMP"|"TIMESTAMP_WITH_TIMEZONE"|"TINYINT"|"VARBINARY"|"VARCHAR", "DATE"|"STRING"|"TIMESTAMP"|"INT"|"FLOAT"|"LONG"|"BIGDECIMAL"|"BYTE"|"SHORT"|"DOUBLE">}, ConnectionTable?:string, Query?:string, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, SparkConnectorSource?:array{Name:string, ConnectionName:string, ConnectorName:string, ConnectionType:string, AdditionalOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, CatalogSource?:array{Name:string, Database:string, Table:string}, RedshiftSource?:array{Name:string, Database:string, Table:string, RedshiftTmpDir?:string, TmpDirIAMRole?:string}, S3CatalogSource?:array{Name:string, Database:string, Table:string, PartitionPredicate?:string, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int}}, S3CsvSource?:array{Name:string, Paths:array<string>, CompressionType?:"gzip"|"bzip2", Exclusions?:array<string>, GroupSize?:string, GroupFiles?:string, Recurse?:bool, MaxBand?:int, MaxFilesInBand?:int, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, Separator:"comma"|"ctrla"|"pipe"|"semicolon"|"tab", Escaper?:string, QuoteChar:"quote"|"quillemet"|"single_quote"|"disabled", Multiline?:bool, WithHeader?:bool, WriteHeader?:bool, SkipFirst?:bool, OptimizePerformance?:bool, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3JsonSource?:array{Name:string, Paths:array<string>, CompressionType?:"gzip"|"bzip2", Exclusions?:array<string>, GroupSize?:string, GroupFiles?:string, Recurse?:bool, MaxBand?:int, MaxFilesInBand?:int, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, JsonPath?:string, Multiline?:bool, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3ParquetSource?:array{Name:string, Paths:array<string>, CompressionType?:"snappy"|"lzo"|"gzip"|"uncompressed"|"none", Exclusions?:array<string>, GroupSize?:string, GroupFiles?:string, Recurse?:bool, MaxBand?:int, MaxFilesInBand?:int, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, RelationalCatalogSource?:array{Name:string, Database:string, Table:string}, DynamoDBCatalogSource?:array{Name:string, Database:string, Table:string}, JDBCConnectorTarget?:array{Name:string, Inputs:array<string>, ConnectionName:string, ConnectionTable:string, ConnectorName:string, ConnectionType:string, AdditionalOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, SparkConnectorTarget?:array{Name:string, Inputs:array<string>, ConnectionName:string, ConnectorName:string, ConnectionType:string, AdditionalOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, CatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Database:string, Table:string}, RedshiftTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string, RedshiftTmpDir?:string, TmpDirIAMRole?:string, UpsertRedshiftOptions?:array{TableLocation?:string, ConnectionName?:string, UpsertKeys?:array<string>}}, S3CatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Table:string, Database:string, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG"}}, S3GlueParquetTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Path:string, Compression?:"snappy"|"lzo"|"gzip"|"uncompressed"|"none", SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG", Table?:string, Database?:string}}, S3DirectTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Path:string, Compression?:string, Format:"json"|"csv"|"avro"|"orc"|"parquet"|"hudi"|"delta", SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG", Table?:string, Database?:string}}, ApplyMapping?:array{Name:string, Inputs:array<string>, Mapping:array<array{ToKey?:string, FromPath?:array<string>, FromType?:string, ToType?:string, Dropped?:bool, Children?:array<array{ToKey?:string, FromPath?:array<string>, FromType?:string, ToType?:string, Dropped?:bool, Children?:mixed}>}>}, SelectFields?:array{Name:string, Inputs:array<string>, Paths:array<array<string>>}, DropFields?:array{Name:string, Inputs:array<string>, Paths:array<array<string>>}, RenameField?:array{Name:string, Inputs:array<string>, SourcePath:array<string>, TargetPath:array<string>}, Spigot?:array{Name:string, Inputs:array<string>, Path:string, Topk?:int, Prob?:float}, Join?:array{Name:string, Inputs:array<string>, JoinType:"equijoin"|"left"|"right"|"outer"|"leftsemi"|"leftanti", Columns:array<array{From:string, Keys:array<array<string>>}>}, SplitFields?:array{Name:string, Inputs:array<string>, Paths:array<array<string>>}, SelectFromCollection?:array{Name:string, Inputs:array<string>, Index:int}, FillMissingValues?:array{Name:string, Inputs:array<string>, ImputedPath:string, FilledPath?:string}, Filter?:array{Name:string, Inputs:array<string>, LogicalOperator:"AND"|"OR", Filters:array<array{Operation:"EQ"|"LT"|"GT"|"LTE"|"GTE"|"REGEX"|"ISNULL", Negated?:bool, Values:array<array{Type:"COLUMNEXTRACTED"|"CONSTANT", Value:array<string>}>}>}, CustomCode?:array{Name:string, Inputs:array<string>, Code:string, ClassName:string, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, SparkSQL?:array{Name:string, Inputs:array<string>, SqlQuery:string, SqlAliases:array<array{From:string, Alias:string}>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, DirectKinesisSource?:array{Name:string, WindowSize?:int, DetectSchema?:bool, StreamingOptions?:array{EndpointUrl?:string, StreamName?:string, Classification?:string, Delimiter?:string, StartingPosition?:"latest"|"trim_horizon"|"earliest"|"timestamp", MaxFetchTimeInMs?:int, MaxFetchRecordsPerShard?:int, MaxRecordPerRead?:int, AddIdleTimeBetweenReads?:bool, IdleTimeBetweenReadsInMs?:int, DescribeShardInterval?:int, NumRetries?:int, RetryIntervalMs?:int, MaxRetryIntervalMs?:int, AvoidEmptyBatches?:bool, StreamArn?:string, RoleArn?:string, RoleSessionName?:string, AddRecordTimestamp?:string, EmitConsumerLagMetrics?:string, StartingTimestamp?:int|string|\DateTimeInterface}, DataPreviewOptions?:array{PollingTime?:int, RecordPollingLimit?:int}}, DirectKafkaSource?:array{Name:string, StreamingOptions?:array{BootstrapServers?:string, SecurityProtocol?:string, ConnectionName?:string, TopicName?:string, Assign?:string, SubscribePattern?:string, Classification?:string, Delimiter?:string, StartingOffsets?:string, EndingOffsets?:string, PollTimeoutMs?:int, NumRetries?:int, RetryIntervalMs?:int, MaxOffsetsPerTrigger?:int, MinPartitions?:int, IncludeHeaders?:bool, AddRecordTimestamp?:string, EmitConsumerLagMetrics?:string, StartingTimestamp?:int|string|\DateTimeInterface}, WindowSize?:int, DetectSchema?:bool, DataPreviewOptions?:array{PollingTime?:int, RecordPollingLimit?:int}}, CatalogKinesisSource?:array{Name:string, WindowSize?:int, DetectSchema?:bool, Table:string, Database:string, StreamingOptions?:array{EndpointUrl?:string, StreamName?:string, Classification?:string, Delimiter?:string, StartingPosition?:"latest"|"trim_horizon"|"earliest"|"timestamp", MaxFetchTimeInMs?:int, MaxFetchRecordsPerShard?:int, MaxRecordPerRead?:int, AddIdleTimeBetweenReads?:bool, IdleTimeBetweenReadsInMs?:int, DescribeShardInterval?:int, NumRetries?:int, RetryIntervalMs?:int, MaxRetryIntervalMs?:int, AvoidEmptyBatches?:bool, StreamArn?:string, RoleArn?:string, RoleSessionName?:string, AddRecordTimestamp?:string, EmitConsumerLagMetrics?:string, StartingTimestamp?:int|string|\DateTimeInterface}, DataPreviewOptions?:array{PollingTime?:int, RecordPollingLimit?:int}}, CatalogKafkaSource?:array{Name:string, WindowSize?:int, DetectSchema?:bool, Table:string, Database:string, StreamingOptions?:array{BootstrapServers?:string, SecurityProtocol?:string, ConnectionName?:string, TopicName?:string, Assign?:string, SubscribePattern?:string, Classification?:string, Delimiter?:string, StartingOffsets?:string, EndingOffsets?:string, PollTimeoutMs?:int, NumRetries?:int, RetryIntervalMs?:int, MaxOffsetsPerTrigger?:int, MinPartitions?:int, IncludeHeaders?:bool, AddRecordTimestamp?:string, EmitConsumerLagMetrics?:string, StartingTimestamp?:int|string|\DateTimeInterface}, DataPreviewOptions?:array{PollingTime?:int, RecordPollingLimit?:int}}, DropNullFields?:array{Name:string, Inputs:array<string>, NullCheckBoxList?:array{IsEmpty?:bool, IsNullString?:bool, IsNegOne?:bool}, NullTextList?:array<array{Value:string, Datatype:array{Id:string, Label:string}}>}, Merge?:array{Name:string, Inputs:array<string>, Source:string, PrimaryKeys:array<array<string>>}, Union?:array{Name:string, Inputs:array<string>, UnionType:"ALL"|"DISTINCT"}, PIIDetection?:array{Name:string, Inputs:array<string>, PiiType:"RowAudit"|"RowMasking"|"ColumnAudit"|"ColumnMasking", EntityTypesToDetect:array<string>, OutputColumnName?:string, SampleFraction?:float, ThresholdFraction?:float, MaskValue?:string}, Aggregate?:array{Name:string, Inputs:array<string>, Groups:array<array<string>>, Aggs:array<array{Column:array<string>, AggFunc:"avg"|"countDistinct"|"count"|"first"|"last"|"kurtosis"|"max"|"min"|"skewness"|"stddev_samp"|"stddev_pop"|"sum"|"sumDistinct"|"var_samp"|"var_pop"}>}, DropDuplicates?:array{Name:string, Inputs:array<string>, Columns?:array<array<string>>}, GovernedCatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Table:string, Database:string, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG"}}, GovernedCatalogSource?:array{Name:string, Database:string, Table:string, PartitionPredicate?:string, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int}}, MicrosoftSQLServerCatalogSource?:array{Name:string, Database:string, Table:string}, MySQLCatalogSource?:array{Name:string, Database:string, Table:string}, OracleSQLCatalogSource?:array{Name:string, Database:string, Table:string}, PostgreSQLCatalogSource?:array{Name:string, Database:string, Table:string}, MicrosoftSQLServerCatalogTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string}, MySQLCatalogTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string}, OracleSQLCatalogTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string}, PostgreSQLCatalogTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string}, DynamicTransform?:array{Name:string, TransformName:string, Inputs:array<string>, Parameters?:array<array{Name:string, Type:"str"|"int"|"float"|"complex"|"bool"|"list"|"null", ValidationRule?:string, ValidationMessage?:string, Value?:array<string>, ListType?:"str"|"int"|"float"|"complex"|"bool"|"list"|"null", IsOptional?:bool}>, FunctionName:string, Path:string, Version?:string, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, EvaluateDataQuality?:array{Name:string, Inputs:array<string>, Ruleset:string, Output?:"PrimaryInput"|"EvaluationResults", PublishingOptions?:array{EvaluationContext?:string, ResultsS3Prefix?:string, CloudWatchMetricsEnabled?:bool, ResultsPublishingEnabled?:bool}, StopJobOnFailureOptions?:array{StopJobOnFailureTiming?:"Immediate"|"AfterDataLoad"}}, S3CatalogHudiSource?:array{Name:string, Database:string, Table:string, AdditionalHudiOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, CatalogHudiSource?:array{Name:string, Database:string, Table:string, AdditionalHudiOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3HudiSource?:array{Name:string, Paths:array<string>, AdditionalHudiOptions?:array<string, string>, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3HudiCatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Table:string, Database:string, AdditionalOptions:array<string, string>, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG"}}, S3HudiDirectTarget?:array{Name:string, Inputs:array<string>, Path:string, Compression:"gzip"|"lzo"|"uncompressed"|"snappy", PartitionKeys?:array<array<string>>, Format:"json"|"csv"|"avro"|"orc"|"parquet"|"hudi"|"delta", AdditionalOptions:array<string, string>, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG", Table?:string, Database?:string}}, DirectJDBCSource?:array{Name:string, Database:string, Table:string, ConnectionName:string, ConnectionType:"sqlserver"|"mysql"|"oracle"|"postgresql"|"redshift", RedshiftTmpDir?:string}, S3CatalogDeltaSource?:array{Name:string, Database:string, Table:string, AdditionalDeltaOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, CatalogDeltaSource?:array{Name:string, Database:string, Table:string, AdditionalDeltaOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3DeltaSource?:array{Name:string, Paths:array<string>, AdditionalDeltaOptions?:array<string, string>, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3DeltaCatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Table:string, Database:string, AdditionalOptions?:array<string, string>, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG"}}, S3DeltaDirectTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Path:string, Compression:"uncompressed"|"snappy", Format:"json"|"csv"|"avro"|"orc"|"parquet"|"hudi"|"delta", AdditionalOptions?:array<string, string>, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG", Table?:string, Database?:string}}, AmazonRedshiftSource?:array{Name?:string, Data?:array{AccessType?:string, SourceType?:string, Connection?:array{Value?:string, Label?:string, Description?:string}, Schema?:array{Value?:string, Label?:string, Description?:string}, Table?:array{Value?:string, Label?:string, Description?:string}, CatalogDatabase?:array{Value?:string, Label?:string, Description?:string}, CatalogTable?:array{Value?:string, Label?:string, Description?:string}, CatalogRedshiftSchema?:string, CatalogRedshiftTable?:string, TempDir?:string, IamRole?:array{Value?:string, Label?:string, Description?:string}, AdvancedOptions?:array<array{Key?:string, Value?:string}>, SampleQuery?:string, PreAction?:string, PostAction?:string, Action?:string, TablePrefix?:string, Upsert?:bool, MergeAction?:string, MergeWhenMatched?:string, MergeWhenNotMatched?:string, MergeClause?:string, CrawlerConnection?:string, TableSchema?:array<array{Value?:string, Label?:string, Description?:string}>, StagingTable?:string, SelectedColumns?:array<array{Value?:string, Label?:string, Description?:string}>}}, AmazonRedshiftTarget?:array{Name?:string, Data?:array{AccessType?:string, SourceType?:string, Connection?:array{Value?:string, Label?:string, Description?:string}, Schema?:array{Value?:string, Label?:string, Description?:string}, Table?:array{Value?:string, Label?:string, Description?:string}, CatalogDatabase?:array{Value?:string, Label?:string, Description?:string}, CatalogTable?:array{Value?:string, Label?:string, Description?:string}, CatalogRedshiftSchema?:string, CatalogRedshiftTable?:string, TempDir?:string, IamRole?:array{Value?:string, Label?:string, Description?:string}, AdvancedOptions?:array<array{Key?:string, Value?:string}>, SampleQuery?:string, PreAction?:string, PostAction?:string, Action?:string, TablePrefix?:string, Upsert?:bool, MergeAction?:string, MergeWhenMatched?:string, MergeWhenNotMatched?:string, MergeClause?:string, CrawlerConnection?:string, TableSchema?:array<array{Value?:string, Label?:string, Description?:string}>, StagingTable?:string, SelectedColumns?:array<array{Value?:string, Label?:string, Description?:string}>}, Inputs?:array<string>}, EvaluateDataQualityMultiFrame?:array{Name:string, Inputs:array<string>, AdditionalDataSources?:array<string, string>, Ruleset:string, PublishingOptions?:array{EvaluationContext?:string, ResultsS3Prefix?:string, CloudWatchMetricsEnabled?:bool, ResultsPublishingEnabled?:bool}, AdditionalOptions?:array<"performanceTuning.caching"|"observations.scope", string>, StopJobOnFailureOptions?:array{StopJobOnFailureTiming?:"Immediate"|"AfterDataLoad"}}, Recipe?:array{Name:string, Inputs:array<string>, RecipeReference?:array{RecipeArn:string, RecipeVersion:string}, RecipeSteps?:array<array{Action:array{Operation:string, Parameters?:array<string, string>}, ConditionExpressions?:array<array{Condition:string, Value?:string, TargetColumn:string}>}>}, SnowflakeSource?:array{Name:string, Data:array{SourceType?:string, Connection?:array{Value?:string, Label?:string, Description?:string}, Schema?:string, Table?:string, Database?:string, TempDir?:string, IamRole?:array{Value?:string, Label?:string, Description?:string}, AdditionalOptions?:array<string, string>, SampleQuery?:string, PreAction?:string, PostAction?:string, Action?:string, Upsert?:bool, MergeAction?:string, MergeWhenMatched?:string, MergeWhenNotMatched?:string, MergeClause?:string, StagingTable?:string, SelectedColumns?:array<array{Value?:string, Label?:string, Description?:string}>, AutoPushdown?:bool, TableSchema?:array<array{Value?:string, Label?:string, Description?:string}>}, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, SnowflakeTarget?:array{Name:string, Data:array{SourceType?:string, Connection?:array{Value?:string, Label?:string, Description?:string}, Schema?:string, Table?:string, Database?:string, TempDir?:string, IamRole?:array{Value?:string, Label?:string, Description?:string}, AdditionalOptions?:array<string, string>, SampleQuery?:string, PreAction?:string, PostAction?:string, Action?:string, Upsert?:bool, MergeAction?:string, MergeWhenMatched?:string, MergeWhenNotMatched?:string, MergeClause?:string, StagingTable?:string, SelectedColumns?:array<array{Value?:string, Label?:string, Description?:string}>, AutoPushdown?:bool, TableSchema?:array<array{Value?:string, Label?:string, Description?:string}>}, Inputs?:array<string>}, ConnectorDataSource?:array{Name:string, ConnectionType:string, Data:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, ConnectorDataTarget?:array{Name:string, ConnectionType:string, Data:array<string, string>, Inputs?:array<string>}}>, ExecutionClass?:"FLEX"|"STANDARD", SourceControlDetails?:array{Provider?:"GITHUB"|"GITLAB"|"BITBUCKET"|"AWS_CODE_COMMIT", Repository?:string, Owner?:string, Branch?:string, Folder?:string, LastCommitId?:string, AuthStrategy?:"PERSONAL_ACCESS_TOKEN"|"AWS_SECRETS_MANAGER", AuthToken?:string}, MaintenanceWindow?:string}} $args
     * @return \AWS\Result<array{JobName?:string}>
     */
    public function updateJob(array $args): \AWS\Result { }

    /**
     * @param array{JobName:string, JobUpdate:array{JobMode?:"SCRIPT"|"VISUAL"|"NOTEBOOK", JobRunQueuingEnabled?:bool, Description?:string, LogUri?:string, Role?:string, ExecutionProperty?:array{MaxConcurrentRuns?:int}, Command?:array{Name?:string, ScriptLocation?:string, PythonVersion?:string, Runtime?:string}, DefaultArguments?:array<string, string>, NonOverridableArguments?:array<string, string>, Connections?:array{Connections?:mixed}, MaxRetries?:int, AllocatedCapacity?:int, Timeout?:int, MaxCapacity?:float, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", NumberOfWorkers?:int, SecurityConfiguration?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, GlueVersion?:string, CodeGenConfigurationNodes?:array<string, array{AthenaConnectorSource?:array{Name:string, ConnectionName:string, ConnectorName:string, ConnectionType:string, ConnectionTable?:string, SchemaName:string, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, JDBCConnectorSource?:array{Name:string, ConnectionName:string, ConnectorName:string, ConnectionType:string, AdditionalOptions?:array{FilterPredicate?:string, PartitionColumn?:string, LowerBound?:int, UpperBound?:int, NumPartitions?:int, JobBookmarkKeys?:array<string>, JobBookmarkKeysSortOrder?:string, DataTypeMapping?:array<"ARRAY"|"BIGINT"|"BINARY"|"BIT"|"BLOB"|"BOOLEAN"|"CHAR"|"CLOB"|"DATALINK"|"DATE"|"DECIMAL"|"DISTINCT"|"DOUBLE"|"FLOAT"|"INTEGER"|"JAVA_OBJECT"|"LONGNVARCHAR"|"LONGVARBINARY"|"LONGVARCHAR"|"NCHAR"|"NCLOB"|"NULL"|"NUMERIC"|"NVARCHAR"|"OTHER"|"REAL"|"REF"|"REF_CURSOR"|"ROWID"|"SMALLINT"|"SQLXML"|"STRUCT"|"TIME"|"TIME_WITH_TIMEZONE"|"TIMESTAMP"|"TIMESTAMP_WITH_TIMEZONE"|"TINYINT"|"VARBINARY"|"VARCHAR", "DATE"|"STRING"|"TIMESTAMP"|"INT"|"FLOAT"|"LONG"|"BIGDECIMAL"|"BYTE"|"SHORT"|"DOUBLE">}, ConnectionTable?:string, Query?:string, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, SparkConnectorSource?:array{Name:string, ConnectionName:string, ConnectorName:string, ConnectionType:string, AdditionalOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, CatalogSource?:array{Name:string, Database:string, Table:string}, RedshiftSource?:array{Name:string, Database:string, Table:string, RedshiftTmpDir?:string, TmpDirIAMRole?:string}, S3CatalogSource?:array{Name:string, Database:string, Table:string, PartitionPredicate?:string, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int}}, S3CsvSource?:array{Name:string, Paths:array<string>, CompressionType?:"gzip"|"bzip2", Exclusions?:array<string>, GroupSize?:string, GroupFiles?:string, Recurse?:bool, MaxBand?:int, MaxFilesInBand?:int, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, Separator:"comma"|"ctrla"|"pipe"|"semicolon"|"tab", Escaper?:string, QuoteChar:"quote"|"quillemet"|"single_quote"|"disabled", Multiline?:bool, WithHeader?:bool, WriteHeader?:bool, SkipFirst?:bool, OptimizePerformance?:bool, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3JsonSource?:array{Name:string, Paths:array<string>, CompressionType?:"gzip"|"bzip2", Exclusions?:array<string>, GroupSize?:string, GroupFiles?:string, Recurse?:bool, MaxBand?:int, MaxFilesInBand?:int, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, JsonPath?:string, Multiline?:bool, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3ParquetSource?:array{Name:string, Paths:array<string>, CompressionType?:"snappy"|"lzo"|"gzip"|"uncompressed"|"none", Exclusions?:array<string>, GroupSize?:string, GroupFiles?:string, Recurse?:bool, MaxBand?:int, MaxFilesInBand?:int, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, RelationalCatalogSource?:array{Name:string, Database:string, Table:string}, DynamoDBCatalogSource?:array{Name:string, Database:string, Table:string}, JDBCConnectorTarget?:array{Name:string, Inputs:array<string>, ConnectionName:string, ConnectionTable:string, ConnectorName:string, ConnectionType:string, AdditionalOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, SparkConnectorTarget?:array{Name:string, Inputs:array<string>, ConnectionName:string, ConnectorName:string, ConnectionType:string, AdditionalOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, CatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Database:string, Table:string}, RedshiftTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string, RedshiftTmpDir?:string, TmpDirIAMRole?:string, UpsertRedshiftOptions?:array{TableLocation?:string, ConnectionName?:string, UpsertKeys?:array<string>}}, S3CatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Table:string, Database:string, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG"}}, S3GlueParquetTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Path:string, Compression?:"snappy"|"lzo"|"gzip"|"uncompressed"|"none", SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG", Table?:string, Database?:string}}, S3DirectTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Path:string, Compression?:string, Format:"json"|"csv"|"avro"|"orc"|"parquet"|"hudi"|"delta", SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG", Table?:string, Database?:string}}, ApplyMapping?:array{Name:string, Inputs:array<string>, Mapping:array<array{ToKey?:string, FromPath?:array<string>, FromType?:string, ToType?:string, Dropped?:bool, Children?:array<array{ToKey?:string, FromPath?:array<string>, FromType?:string, ToType?:string, Dropped?:bool, Children?:mixed}>}>}, SelectFields?:array{Name:string, Inputs:array<string>, Paths:array<array<string>>}, DropFields?:array{Name:string, Inputs:array<string>, Paths:array<array<string>>}, RenameField?:array{Name:string, Inputs:array<string>, SourcePath:array<string>, TargetPath:array<string>}, Spigot?:array{Name:string, Inputs:array<string>, Path:string, Topk?:int, Prob?:float}, Join?:array{Name:string, Inputs:array<string>, JoinType:"equijoin"|"left"|"right"|"outer"|"leftsemi"|"leftanti", Columns:array<array{From:string, Keys:array<array<string>>}>}, SplitFields?:array{Name:string, Inputs:array<string>, Paths:array<array<string>>}, SelectFromCollection?:array{Name:string, Inputs:array<string>, Index:int}, FillMissingValues?:array{Name:string, Inputs:array<string>, ImputedPath:string, FilledPath?:string}, Filter?:array{Name:string, Inputs:array<string>, LogicalOperator:"AND"|"OR", Filters:array<array{Operation:"EQ"|"LT"|"GT"|"LTE"|"GTE"|"REGEX"|"ISNULL", Negated?:bool, Values:array<array{Type:"COLUMNEXTRACTED"|"CONSTANT", Value:array<string>}>}>}, CustomCode?:array{Name:string, Inputs:array<string>, Code:string, ClassName:string, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, SparkSQL?:array{Name:string, Inputs:array<string>, SqlQuery:string, SqlAliases:array<array{From:string, Alias:string}>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, DirectKinesisSource?:array{Name:string, WindowSize?:int, DetectSchema?:bool, StreamingOptions?:array{EndpointUrl?:string, StreamName?:string, Classification?:string, Delimiter?:string, StartingPosition?:"latest"|"trim_horizon"|"earliest"|"timestamp", MaxFetchTimeInMs?:int, MaxFetchRecordsPerShard?:int, MaxRecordPerRead?:int, AddIdleTimeBetweenReads?:bool, IdleTimeBetweenReadsInMs?:int, DescribeShardInterval?:int, NumRetries?:int, RetryIntervalMs?:int, MaxRetryIntervalMs?:int, AvoidEmptyBatches?:bool, StreamArn?:string, RoleArn?:string, RoleSessionName?:string, AddRecordTimestamp?:string, EmitConsumerLagMetrics?:string, StartingTimestamp?:int|string|\DateTimeInterface}, DataPreviewOptions?:array{PollingTime?:int, RecordPollingLimit?:int}}, DirectKafkaSource?:array{Name:string, StreamingOptions?:array{BootstrapServers?:string, SecurityProtocol?:string, ConnectionName?:string, TopicName?:string, Assign?:string, SubscribePattern?:string, Classification?:string, Delimiter?:string, StartingOffsets?:string, EndingOffsets?:string, PollTimeoutMs?:int, NumRetries?:int, RetryIntervalMs?:int, MaxOffsetsPerTrigger?:int, MinPartitions?:int, IncludeHeaders?:bool, AddRecordTimestamp?:string, EmitConsumerLagMetrics?:string, StartingTimestamp?:int|string|\DateTimeInterface}, WindowSize?:int, DetectSchema?:bool, DataPreviewOptions?:array{PollingTime?:int, RecordPollingLimit?:int}}, CatalogKinesisSource?:array{Name:string, WindowSize?:int, DetectSchema?:bool, Table:string, Database:string, StreamingOptions?:array{EndpointUrl?:string, StreamName?:string, Classification?:string, Delimiter?:string, StartingPosition?:"latest"|"trim_horizon"|"earliest"|"timestamp", MaxFetchTimeInMs?:int, MaxFetchRecordsPerShard?:int, MaxRecordPerRead?:int, AddIdleTimeBetweenReads?:bool, IdleTimeBetweenReadsInMs?:int, DescribeShardInterval?:int, NumRetries?:int, RetryIntervalMs?:int, MaxRetryIntervalMs?:int, AvoidEmptyBatches?:bool, StreamArn?:string, RoleArn?:string, RoleSessionName?:string, AddRecordTimestamp?:string, EmitConsumerLagMetrics?:string, StartingTimestamp?:int|string|\DateTimeInterface}, DataPreviewOptions?:array{PollingTime?:int, RecordPollingLimit?:int}}, CatalogKafkaSource?:array{Name:string, WindowSize?:int, DetectSchema?:bool, Table:string, Database:string, StreamingOptions?:array{BootstrapServers?:string, SecurityProtocol?:string, ConnectionName?:string, TopicName?:string, Assign?:string, SubscribePattern?:string, Classification?:string, Delimiter?:string, StartingOffsets?:string, EndingOffsets?:string, PollTimeoutMs?:int, NumRetries?:int, RetryIntervalMs?:int, MaxOffsetsPerTrigger?:int, MinPartitions?:int, IncludeHeaders?:bool, AddRecordTimestamp?:string, EmitConsumerLagMetrics?:string, StartingTimestamp?:int|string|\DateTimeInterface}, DataPreviewOptions?:array{PollingTime?:int, RecordPollingLimit?:int}}, DropNullFields?:array{Name:string, Inputs:array<string>, NullCheckBoxList?:array{IsEmpty?:bool, IsNullString?:bool, IsNegOne?:bool}, NullTextList?:array<array{Value:string, Datatype:array{Id:string, Label:string}}>}, Merge?:array{Name:string, Inputs:array<string>, Source:string, PrimaryKeys:array<array<string>>}, Union?:array{Name:string, Inputs:array<string>, UnionType:"ALL"|"DISTINCT"}, PIIDetection?:array{Name:string, Inputs:array<string>, PiiType:"RowAudit"|"RowMasking"|"ColumnAudit"|"ColumnMasking", EntityTypesToDetect:array<string>, OutputColumnName?:string, SampleFraction?:float, ThresholdFraction?:float, MaskValue?:string}, Aggregate?:array{Name:string, Inputs:array<string>, Groups:array<array<string>>, Aggs:array<array{Column:array<string>, AggFunc:"avg"|"countDistinct"|"count"|"first"|"last"|"kurtosis"|"max"|"min"|"skewness"|"stddev_samp"|"stddev_pop"|"sum"|"sumDistinct"|"var_samp"|"var_pop"}>}, DropDuplicates?:array{Name:string, Inputs:array<string>, Columns?:array<array<string>>}, GovernedCatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Table:string, Database:string, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG"}}, GovernedCatalogSource?:array{Name:string, Database:string, Table:string, PartitionPredicate?:string, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int}}, MicrosoftSQLServerCatalogSource?:array{Name:string, Database:string, Table:string}, MySQLCatalogSource?:array{Name:string, Database:string, Table:string}, OracleSQLCatalogSource?:array{Name:string, Database:string, Table:string}, PostgreSQLCatalogSource?:array{Name:string, Database:string, Table:string}, MicrosoftSQLServerCatalogTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string}, MySQLCatalogTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string}, OracleSQLCatalogTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string}, PostgreSQLCatalogTarget?:array{Name:string, Inputs:array<string>, Database:string, Table:string}, DynamicTransform?:array{Name:string, TransformName:string, Inputs:array<string>, Parameters?:array<array{Name:string, Type:"str"|"int"|"float"|"complex"|"bool"|"list"|"null", ValidationRule?:string, ValidationMessage?:string, Value?:array<string>, ListType?:"str"|"int"|"float"|"complex"|"bool"|"list"|"null", IsOptional?:bool}>, FunctionName:string, Path:string, Version?:string, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, EvaluateDataQuality?:array{Name:string, Inputs:array<string>, Ruleset:string, Output?:"PrimaryInput"|"EvaluationResults", PublishingOptions?:array{EvaluationContext?:string, ResultsS3Prefix?:string, CloudWatchMetricsEnabled?:bool, ResultsPublishingEnabled?:bool}, StopJobOnFailureOptions?:array{StopJobOnFailureTiming?:"Immediate"|"AfterDataLoad"}}, S3CatalogHudiSource?:array{Name:string, Database:string, Table:string, AdditionalHudiOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, CatalogHudiSource?:array{Name:string, Database:string, Table:string, AdditionalHudiOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3HudiSource?:array{Name:string, Paths:array<string>, AdditionalHudiOptions?:array<string, string>, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3HudiCatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Table:string, Database:string, AdditionalOptions:array<string, string>, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG"}}, S3HudiDirectTarget?:array{Name:string, Inputs:array<string>, Path:string, Compression:"gzip"|"lzo"|"uncompressed"|"snappy", PartitionKeys?:array<array<string>>, Format:"json"|"csv"|"avro"|"orc"|"parquet"|"hudi"|"delta", AdditionalOptions:array<string, string>, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG", Table?:string, Database?:string}}, DirectJDBCSource?:array{Name:string, Database:string, Table:string, ConnectionName:string, ConnectionType:"sqlserver"|"mysql"|"oracle"|"postgresql"|"redshift", RedshiftTmpDir?:string}, S3CatalogDeltaSource?:array{Name:string, Database:string, Table:string, AdditionalDeltaOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, CatalogDeltaSource?:array{Name:string, Database:string, Table:string, AdditionalDeltaOptions?:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3DeltaSource?:array{Name:string, Paths:array<string>, AdditionalDeltaOptions?:array<string, string>, AdditionalOptions?:array{BoundedSize?:int, BoundedFiles?:int, EnableSamplePath?:bool, SamplePath?:string}, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, S3DeltaCatalogTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Table:string, Database:string, AdditionalOptions?:array<string, string>, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG"}}, S3DeltaDirectTarget?:array{Name:string, Inputs:array<string>, PartitionKeys?:array<array<string>>, Path:string, Compression:"uncompressed"|"snappy", Format:"json"|"csv"|"avro"|"orc"|"parquet"|"hudi"|"delta", AdditionalOptions?:array<string, string>, SchemaChangePolicy?:array{EnableUpdateCatalog?:bool, UpdateBehavior?:"UPDATE_IN_DATABASE"|"LOG", Table?:string, Database?:string}}, AmazonRedshiftSource?:array{Name?:string, Data?:array{AccessType?:string, SourceType?:string, Connection?:array{Value?:string, Label?:string, Description?:string}, Schema?:array{Value?:string, Label?:string, Description?:string}, Table?:array{Value?:string, Label?:string, Description?:string}, CatalogDatabase?:array{Value?:string, Label?:string, Description?:string}, CatalogTable?:array{Value?:string, Label?:string, Description?:string}, CatalogRedshiftSchema?:string, CatalogRedshiftTable?:string, TempDir?:string, IamRole?:array{Value?:string, Label?:string, Description?:string}, AdvancedOptions?:array<array{Key?:string, Value?:string}>, SampleQuery?:string, PreAction?:string, PostAction?:string, Action?:string, TablePrefix?:string, Upsert?:bool, MergeAction?:string, MergeWhenMatched?:string, MergeWhenNotMatched?:string, MergeClause?:string, CrawlerConnection?:string, TableSchema?:array<array{Value?:string, Label?:string, Description?:string}>, StagingTable?:string, SelectedColumns?:array<array{Value?:string, Label?:string, Description?:string}>}}, AmazonRedshiftTarget?:array{Name?:string, Data?:array{AccessType?:string, SourceType?:string, Connection?:array{Value?:string, Label?:string, Description?:string}, Schema?:array{Value?:string, Label?:string, Description?:string}, Table?:array{Value?:string, Label?:string, Description?:string}, CatalogDatabase?:array{Value?:string, Label?:string, Description?:string}, CatalogTable?:array{Value?:string, Label?:string, Description?:string}, CatalogRedshiftSchema?:string, CatalogRedshiftTable?:string, TempDir?:string, IamRole?:array{Value?:string, Label?:string, Description?:string}, AdvancedOptions?:array<array{Key?:string, Value?:string}>, SampleQuery?:string, PreAction?:string, PostAction?:string, Action?:string, TablePrefix?:string, Upsert?:bool, MergeAction?:string, MergeWhenMatched?:string, MergeWhenNotMatched?:string, MergeClause?:string, CrawlerConnection?:string, TableSchema?:array<array{Value?:string, Label?:string, Description?:string}>, StagingTable?:string, SelectedColumns?:array<array{Value?:string, Label?:string, Description?:string}>}, Inputs?:array<string>}, EvaluateDataQualityMultiFrame?:array{Name:string, Inputs:array<string>, AdditionalDataSources?:array<string, string>, Ruleset:string, PublishingOptions?:array{EvaluationContext?:string, ResultsS3Prefix?:string, CloudWatchMetricsEnabled?:bool, ResultsPublishingEnabled?:bool}, AdditionalOptions?:array<"performanceTuning.caching"|"observations.scope", string>, StopJobOnFailureOptions?:array{StopJobOnFailureTiming?:"Immediate"|"AfterDataLoad"}}, Recipe?:array{Name:string, Inputs:array<string>, RecipeReference?:array{RecipeArn:string, RecipeVersion:string}, RecipeSteps?:array<array{Action:array{Operation:string, Parameters?:array<string, string>}, ConditionExpressions?:array<array{Condition:string, Value?:string, TargetColumn:string}>}>}, SnowflakeSource?:array{Name:string, Data:array{SourceType?:string, Connection?:array{Value?:string, Label?:string, Description?:string}, Schema?:string, Table?:string, Database?:string, TempDir?:string, IamRole?:array{Value?:string, Label?:string, Description?:string}, AdditionalOptions?:array<string, string>, SampleQuery?:string, PreAction?:string, PostAction?:string, Action?:string, Upsert?:bool, MergeAction?:string, MergeWhenMatched?:string, MergeWhenNotMatched?:string, MergeClause?:string, StagingTable?:string, SelectedColumns?:array<array{Value?:string, Label?:string, Description?:string}>, AutoPushdown?:bool, TableSchema?:array<array{Value?:string, Label?:string, Description?:string}>}, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, SnowflakeTarget?:array{Name:string, Data:array{SourceType?:string, Connection?:array{Value?:string, Label?:string, Description?:string}, Schema?:string, Table?:string, Database?:string, TempDir?:string, IamRole?:array{Value?:string, Label?:string, Description?:string}, AdditionalOptions?:array<string, string>, SampleQuery?:string, PreAction?:string, PostAction?:string, Action?:string, Upsert?:bool, MergeAction?:string, MergeWhenMatched?:string, MergeWhenNotMatched?:string, MergeClause?:string, StagingTable?:string, SelectedColumns?:array<array{Value?:string, Label?:string, Description?:string}>, AutoPushdown?:bool, TableSchema?:array<array{Value?:string, Label?:string, Description?:string}>}, Inputs?:array<string>}, ConnectorDataSource?:array{Name:string, ConnectionType:string, Data:array<string, string>, OutputSchemas?:array<array{Columns?:array<array{Name:string, Type?:string}>}>}, ConnectorDataTarget?:array{Name:string, ConnectionType:string, Data:array<string, string>, Inputs?:array<string>}}>, ExecutionClass?:"FLEX"|"STANDARD", SourceControlDetails?:array{Provider?:"GITHUB"|"GITLAB"|"BITBUCKET"|"AWS_CODE_COMMIT", Repository?:string, Owner?:string, Branch?:string, Folder?:string, LastCommitId?:string, AuthStrategy?:"PERSONAL_ACCESS_TOKEN"|"AWS_SECRETS_MANAGER", AuthToken?:string}, MaintenanceWindow?:string}} $args
     * @return \GuzzleHttp\Promise\Promise<array{JobName?:string}>
     */
    public function updateJobAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{JobName?:string, Provider?:"GITHUB"|"GITLAB"|"BITBUCKET"|"AWS_CODE_COMMIT", RepositoryName?:string, RepositoryOwner?:string, BranchName?:string, Folder?:string, CommitId?:string, AuthStrategy?:"PERSONAL_ACCESS_TOKEN"|"AWS_SECRETS_MANAGER", AuthToken?:string} $args
     * @return \AWS\Result<array{JobName?:string}>
     */
    public function updateJobFromSourceControl(array $args = []): \AWS\Result { }

    /**
     * @param array{JobName?:string, Provider?:"GITHUB"|"GITLAB"|"BITBUCKET"|"AWS_CODE_COMMIT", RepositoryName?:string, RepositoryOwner?:string, BranchName?:string, Folder?:string, CommitId?:string, AuthStrategy?:"PERSONAL_ACCESS_TOKEN"|"AWS_SECRETS_MANAGER", AuthToken?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{JobName?:string}>
     */
    public function updateJobFromSourceControlAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{TransformId:string, Name?:string, Description?:string, Parameters?:array{TransformType:"FIND_MATCHES", FindMatchesParameters?:array{PrimaryKeyColumnName?:string, PrecisionRecallTradeoff?:float, AccuracyCostTradeoff?:float, EnforceProvidedLabels?:bool}}, Role?:string, GlueVersion?:string, MaxCapacity?:float, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", NumberOfWorkers?:int, Timeout?:int, MaxRetries?:int} $args
     * @return \AWS\Result<array{TransformId?:string}>
     */
    public function updateMLTransform(array $args): \AWS\Result { }

    /**
     * @param array{TransformId:string, Name?:string, Description?:string, Parameters?:array{TransformType:"FIND_MATCHES", FindMatchesParameters?:array{PrimaryKeyColumnName?:string, PrecisionRecallTradeoff?:float, AccuracyCostTradeoff?:float, EnforceProvidedLabels?:bool}}, Role?:string, GlueVersion?:string, MaxCapacity?:float, WorkerType?:"Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X", NumberOfWorkers?:int, Timeout?:int, MaxRetries?:int} $args
     * @return \GuzzleHttp\Promise\Promise<array{TransformId?:string}>
     */
    public function updateMLTransformAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, TableName:string, PartitionValueList:array<string>, PartitionInput:array{Values?:array<string>, LastAccessTime?:int|string|\DateTimeInterface, StorageDescriptor?:array{Columns?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, Location?:string, AdditionalLocations?:array<string>, InputFormat?:string, OutputFormat?:string, Compressed?:bool, NumberOfBuckets?:int, SerdeInfo?:array{Name?:string, SerializationLibrary?:string, Parameters?:array<string, string>}, BucketColumns?:array<string>, SortColumns?:array<array{Column:string, SortOrder:int}>, Parameters?:array<string, string>, SkewedInfo?:array{SkewedColumnNames?:array<string>, SkewedColumnValues?:array<string>, SkewedColumnValueLocationMaps?:array<string, string>}, StoredAsSubDirectories?:bool, SchemaReference?:array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionId?:string, SchemaVersionNumber?:int}}, Parameters?:array<string, string>, LastAnalyzedTime?:int|string|\DateTimeInterface}} $args
     * @return \AWS\Result<array{}>
     */
    public function updatePartition(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, TableName:string, PartitionValueList:array<string>, PartitionInput:array{Values?:array<string>, LastAccessTime?:int|string|\DateTimeInterface, StorageDescriptor?:array{Columns?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, Location?:string, AdditionalLocations?:array<string>, InputFormat?:string, OutputFormat?:string, Compressed?:bool, NumberOfBuckets?:int, SerdeInfo?:array{Name?:string, SerializationLibrary?:string, Parameters?:array<string, string>}, BucketColumns?:array<string>, SortColumns?:array<array{Column:string, SortOrder:int}>, Parameters?:array<string, string>, SkewedInfo?:array{SkewedColumnNames?:array<string>, SkewedColumnValues?:array<string>, SkewedColumnValueLocationMaps?:array<string, string>}, StoredAsSubDirectories?:bool, SchemaReference?:array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionId?:string, SchemaVersionNumber?:int}}, Parameters?:array<string, string>, LastAnalyzedTime?:int|string|\DateTimeInterface}} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function updatePartitionAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{RegistryId:array{RegistryName?:string, RegistryArn?:string}, Description:string} $args
     * @return \AWS\Result<array{RegistryName?:string, RegistryArn?:string}>
     */
    public function updateRegistry(array $args): \AWS\Result { }

    /**
     * @param array{RegistryId:array{RegistryName?:string, RegistryArn?:string}, Description:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{RegistryName?:string, RegistryArn?:string}>
     */
    public function updateRegistryAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{SchemaId:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionNumber?:array{LatestVersion?:bool, VersionNumber?:int}, Compatibility?:"NONE"|"DISABLED"|"BACKWARD"|"BACKWARD_ALL"|"FORWARD"|"FORWARD_ALL"|"FULL"|"FULL_ALL", Description?:string} $args
     * @return \AWS\Result<array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}>
     */
    public function updateSchema(array $args): \AWS\Result { }

    /**
     * @param array{SchemaId:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionNumber?:array{LatestVersion?:bool, VersionNumber?:int}, Compatibility?:"NONE"|"DISABLED"|"BACKWARD"|"BACKWARD_ALL"|"FORWARD"|"FORWARD_ALL"|"FULL"|"FULL_ALL", Description?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}>
     */
    public function updateSchemaAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{JobName?:string, Provider?:"GITHUB"|"GITLAB"|"BITBUCKET"|"AWS_CODE_COMMIT", RepositoryName?:string, RepositoryOwner?:string, BranchName?:string, Folder?:string, CommitId?:string, AuthStrategy?:"PERSONAL_ACCESS_TOKEN"|"AWS_SECRETS_MANAGER", AuthToken?:string} $args
     * @return \AWS\Result<array{JobName?:string}>
     */
    public function updateSourceControlFromJob(array $args = []): \AWS\Result { }

    /**
     * @param array{JobName?:string, Provider?:"GITHUB"|"GITLAB"|"BITBUCKET"|"AWS_CODE_COMMIT", RepositoryName?:string, RepositoryOwner?:string, BranchName?:string, Folder?:string, CommitId?:string, AuthStrategy?:"PERSONAL_ACCESS_TOKEN"|"AWS_SECRETS_MANAGER", AuthToken?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{JobName?:string}>
     */
    public function updateSourceControlFromJobAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, TableInput:array{Name:string, Description?:string, Owner?:string, LastAccessTime?:int|string|\DateTimeInterface, LastAnalyzedTime?:int|string|\DateTimeInterface, Retention?:int, StorageDescriptor?:array{Columns?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, Location?:string, AdditionalLocations?:array<string>, InputFormat?:string, OutputFormat?:string, Compressed?:bool, NumberOfBuckets?:int, SerdeInfo?:array{Name?:string, SerializationLibrary?:string, Parameters?:array<string, string>}, BucketColumns?:array<string>, SortColumns?:array<array{Column:string, SortOrder:int}>, Parameters?:array<string, string>, SkewedInfo?:array{SkewedColumnNames?:array<string>, SkewedColumnValues?:array<string>, SkewedColumnValueLocationMaps?:array<string, string>}, StoredAsSubDirectories?:bool, SchemaReference?:array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionId?:string, SchemaVersionNumber?:int}}, PartitionKeys?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, ViewOriginalText?:string, ViewExpandedText?:string, TableType?:string, Parameters?:array<string, string>, TargetTable?:array{CatalogId?:string, DatabaseName?:string, Name?:string, Region?:string}, ViewDefinition?:array{IsProtected?:bool, Definer?:string, Representations?:array<array{Dialect?:"REDSHIFT"|"ATHENA"|"SPARK", DialectVersion?:string, ViewOriginalText?:string, ValidationConnection?:string, ViewExpandedText?:string}>, SubObjects?:array<string>}}, SkipArchive?:bool, TransactionId?:string, VersionId?:string, ViewUpdateAction?:"ADD"|"REPLACE"|"ADD_OR_REPLACE"|"DROP", Force?:bool} $args
     * @return \AWS\Result<array{}>
     */
    public function updateTable(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, TableInput:array{Name:string, Description?:string, Owner?:string, LastAccessTime?:int|string|\DateTimeInterface, LastAnalyzedTime?:int|string|\DateTimeInterface, Retention?:int, StorageDescriptor?:array{Columns?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, Location?:string, AdditionalLocations?:array<string>, InputFormat?:string, OutputFormat?:string, Compressed?:bool, NumberOfBuckets?:int, SerdeInfo?:array{Name?:string, SerializationLibrary?:string, Parameters?:array<string, string>}, BucketColumns?:array<string>, SortColumns?:array<array{Column:string, SortOrder:int}>, Parameters?:array<string, string>, SkewedInfo?:array{SkewedColumnNames?:array<string>, SkewedColumnValues?:array<string>, SkewedColumnValueLocationMaps?:array<string, string>}, StoredAsSubDirectories?:bool, SchemaReference?:array{SchemaId?:array{SchemaArn?:string, SchemaName?:string, RegistryName?:string}, SchemaVersionId?:string, SchemaVersionNumber?:int}}, PartitionKeys?:array<array{Name:string, Type?:string, Comment?:string, Parameters?:array<string, string>}>, ViewOriginalText?:string, ViewExpandedText?:string, TableType?:string, Parameters?:array<string, string>, TargetTable?:array{CatalogId?:string, DatabaseName?:string, Name?:string, Region?:string}, ViewDefinition?:array{IsProtected?:bool, Definer?:string, Representations?:array<array{Dialect?:"REDSHIFT"|"ATHENA"|"SPARK", DialectVersion?:string, ViewOriginalText?:string, ValidationConnection?:string, ViewExpandedText?:string}>, SubObjects?:array<string>}}, SkipArchive?:bool, TransactionId?:string, VersionId?:string, ViewUpdateAction?:"ADD"|"REPLACE"|"ADD_OR_REPLACE"|"DROP", Force?:bool} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function updateTableAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId:string, DatabaseName:string, TableName:string, Type:"compaction"|"retention"|"orphan_file_deletion", TableOptimizerConfiguration:array{roleArn?:string, enabled?:bool, vpcConfiguration?:array{glueConnectionName?:string}, retentionConfiguration?:array{icebergConfiguration?:array{snapshotRetentionPeriodInDays?:int, numberOfSnapshotsToRetain?:int, cleanExpiredFiles?:bool}}, orphanFileDeletionConfiguration?:array{icebergConfiguration?:array{orphanFileRetentionPeriodInDays?:int, location?:string}}}} $args
     * @return \AWS\Result<array{}>
     */
    public function updateTableOptimizer(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId:string, DatabaseName:string, TableName:string, Type:"compaction"|"retention"|"orphan_file_deletion", TableOptimizerConfiguration:array{roleArn?:string, enabled?:bool, vpcConfiguration?:array{glueConnectionName?:string}, retentionConfiguration?:array{icebergConfiguration?:array{snapshotRetentionPeriodInDays?:int, numberOfSnapshotsToRetain?:int, cleanExpiredFiles?:bool}}, orphanFileDeletionConfiguration?:array{icebergConfiguration?:array{orphanFileRetentionPeriodInDays?:int, location?:string}}}} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function updateTableOptimizerAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Name:string, TriggerUpdate:array{Name?:string, Description?:string, Schedule?:string, Actions?:array<array{JobName?:string, Arguments?:array<string, string>, Timeout?:int, SecurityConfiguration?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, CrawlerName?:string}>, Predicate?:array{Logical?:"AND"|"ANY", Conditions?:array<array{LogicalOperator?:"EQUALS", JobName?:string, State?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED", CrawlerName?:string, CrawlState?:"RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR"}>}, EventBatchingCondition?:array{BatchSize:int, BatchWindow?:int}}} $args
     * @return \AWS\Result<array{Trigger?:array{Name?:string, WorkflowName?:string, Id?:string, Type?:"SCHEDULED"|"CONDITIONAL"|"ON_DEMAND"|"EVENT", State?:"CREATING"|"CREATED"|"ACTIVATING"|"ACTIVATED"|"DEACTIVATING"|"DEACTIVATED"|"DELETING"|"UPDATING", Description?:string, Schedule?:string, Actions?:array<array{JobName?:string, Arguments?:array<string, string>, Timeout?:int, SecurityConfiguration?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, CrawlerName?:string}>, Predicate?:array{Logical?:"AND"|"ANY", Conditions?:array<array{LogicalOperator?:"EQUALS", JobName?:string, State?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED", CrawlerName?:string, CrawlState?:"RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR"}>}, EventBatchingCondition?:array{BatchSize:int, BatchWindow?:int}}}>
     */
    public function updateTrigger(array $args): \AWS\Result { }

    /**
     * @param array{Name:string, TriggerUpdate:array{Name?:string, Description?:string, Schedule?:string, Actions?:array<array{JobName?:string, Arguments?:array<string, string>, Timeout?:int, SecurityConfiguration?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, CrawlerName?:string}>, Predicate?:array{Logical?:"AND"|"ANY", Conditions?:array<array{LogicalOperator?:"EQUALS", JobName?:string, State?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED", CrawlerName?:string, CrawlState?:"RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR"}>}, EventBatchingCondition?:array{BatchSize:int, BatchWindow?:int}}} $args
     * @return \GuzzleHttp\Promise\Promise<array{Trigger?:array{Name?:string, WorkflowName?:string, Id?:string, Type?:"SCHEDULED"|"CONDITIONAL"|"ON_DEMAND"|"EVENT", State?:"CREATING"|"CREATED"|"ACTIVATING"|"ACTIVATED"|"DEACTIVATING"|"DEACTIVATED"|"DELETING"|"UPDATING", Description?:string, Schedule?:string, Actions?:array<array{JobName?:string, Arguments?:array<string, string>, Timeout?:int, SecurityConfiguration?:string, NotificationProperty?:array{NotifyDelayAfter?:int}, CrawlerName?:string}>, Predicate?:array{Logical?:"AND"|"ANY", Conditions?:array<array{LogicalOperator?:"EQUALS", JobName?:string, State?:"STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED", CrawlerName?:string, CrawlState?:"RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR"}>}, EventBatchingCondition?:array{BatchSize:int, BatchWindow?:int}}}>
     */
    public function updateTriggerAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Name:string, Description?:string, Configuration:array{SessionConfiguration?:array<string, array{DefaultValue?:string, AllowedValues?:array<string>, MinValue?:string, MaxValue?:string}>, JobConfiguration?:array<string, array{DefaultValue?:string, AllowedValues?:array<string>, MinValue?:string, MaxValue?:string}>}} $args
     * @return \AWS\Result<array{Name?:string}>
     */
    public function updateUsageProfile(array $args): \AWS\Result { }

    /**
     * @param array{Name:string, Description?:string, Configuration:array{SessionConfiguration?:array<string, array{DefaultValue?:string, AllowedValues?:array<string>, MinValue?:string, MaxValue?:string}>, JobConfiguration?:array<string, array{DefaultValue?:string, AllowedValues?:array<string>, MinValue?:string, MaxValue?:string}>}} $args
     * @return \GuzzleHttp\Promise\Promise<array{Name?:string}>
     */
    public function updateUsageProfileAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, FunctionName:string, FunctionInput:array{FunctionName?:string, ClassName?:string, OwnerName?:string, OwnerType?:"USER"|"ROLE"|"GROUP", ResourceUris?:array<array{ResourceType?:"JAR"|"FILE"|"ARCHIVE", Uri?:string}>}} $args
     * @return \AWS\Result<array{}>
     */
    public function updateUserDefinedFunction(array $args): \AWS\Result { }

    /**
     * @param array{CatalogId?:string, DatabaseName:string, FunctionName:string, FunctionInput:array{FunctionName?:string, ClassName?:string, OwnerName?:string, OwnerType?:"USER"|"ROLE"|"GROUP", ResourceUris?:array<array{ResourceType?:"JAR"|"FILE"|"ARCHIVE", Uri?:string}>}} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function updateUserDefinedFunctionAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Name:string, Description?:string, DefaultRunProperties?:array<string, string>, MaxConcurrentRuns?:int} $args
     * @return \AWS\Result<array{Name?:string}>
     */
    public function updateWorkflow(array $args): \AWS\Result { }

    /**
     * @param array{Name:string, Description?:string, DefaultRunProperties?:array<string, string>, MaxConcurrentRuns?:int} $args
     * @return \GuzzleHttp\Promise\Promise<array{Name?:string}>
     */
    public function updateWorkflowAsync(array $args): \GuzzleHttp\Promise\Promise { }
}
