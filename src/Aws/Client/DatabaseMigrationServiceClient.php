<?php
namespace AWS\DatabaseMigrationService;

class DatabaseMigrationServiceClient
{
    /**
     * @param array{ResourceArn:string, Tags:array<array{Key?:string, Value?:string, ResourceArn?:string}>} $args
     * @return \AWS\Result<array{}>
     */
    public function addTagsToResource(array $args): \AWS\Result { }

    /**
     * @param array{ResourceArn:string, Tags:array<array{Key?:string, Value?:string, ResourceArn?:string}>} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function addTagsToResourceAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ReplicationInstanceArn:string, ApplyAction:string, OptInType:string} $args
     * @return \AWS\Result<array{ResourcePendingMaintenanceActions?:array{ResourceIdentifier?:string, PendingMaintenanceActionDetails?:array<array{Action?:string, AutoAppliedAfterDate?:int|string|\DateTimeInterface, ForcedApplyDate?:int|string|\DateTimeInterface, OptInStatus?:string, CurrentApplyDate?:int|string|\DateTimeInterface, Description?:string}>}}>
     */
    public function applyPendingMaintenanceAction(array $args): \AWS\Result { }

    /**
     * @param array{ReplicationInstanceArn:string, ApplyAction:string, OptInType:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{ResourcePendingMaintenanceActions?:array{ResourceIdentifier?:string, PendingMaintenanceActionDetails?:array<array{Action?:string, AutoAppliedAfterDate?:int|string|\DateTimeInterface, ForcedApplyDate?:int|string|\DateTimeInterface, OptInStatus?:string, CurrentApplyDate?:int|string|\DateTimeInterface, Description?:string}>}}>
     */
    public function applyPendingMaintenanceActionAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Data?:array<array{DatabaseId:string, Settings:array{InstanceSizingType:string, WorkloadType:string}}>} $args
     * @return \AWS\Result<array{ErrorEntries?:array<array{DatabaseId?:string, Message?:string, Code?:string}>}>
     */
    public function batchStartRecommendations(array $args = []): \AWS\Result { }

    /**
     * @param array{Data?:array<array{DatabaseId:string, Settings:array{InstanceSizingType:string, WorkloadType:string}}>} $args
     * @return \GuzzleHttp\Promise\Promise<array{ErrorEntries?:array<array{DatabaseId?:string, Message?:string, Code?:string}>}>
     */
    public function batchStartRecommendationsAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ReplicationTaskAssessmentRunArn:string} $args
     * @return \AWS\Result<array{ReplicationTaskAssessmentRun?:array{ReplicationTaskAssessmentRunArn?:string, ReplicationTaskArn?:string, Status?:string, ReplicationTaskAssessmentRunCreationDate?:int|string|\DateTimeInterface, AssessmentProgress?:array{IndividualAssessmentCount?:int, IndividualAssessmentCompletedCount?:int}, LastFailureMessage?:string, ServiceAccessRoleArn?:string, ResultLocationBucket?:string, ResultLocationFolder?:string, ResultEncryptionMode?:string, ResultKmsKeyArn?:string, AssessmentRunName?:string, IsLatestTaskAssessmentRun?:bool, ResultStatistic?:array{Passed?:int, Failed?:int, Error?:int, Warning?:int, Cancelled?:int}}}>
     */
    public function cancelReplicationTaskAssessmentRun(array $args): \AWS\Result { }

    /**
     * @param array{ReplicationTaskAssessmentRunArn:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{ReplicationTaskAssessmentRun?:array{ReplicationTaskAssessmentRunArn?:string, ReplicationTaskArn?:string, Status?:string, ReplicationTaskAssessmentRunCreationDate?:int|string|\DateTimeInterface, AssessmentProgress?:array{IndividualAssessmentCount?:int, IndividualAssessmentCompletedCount?:int}, LastFailureMessage?:string, ServiceAccessRoleArn?:string, ResultLocationBucket?:string, ResultLocationFolder?:string, ResultEncryptionMode?:string, ResultKmsKeyArn?:string, AssessmentRunName?:string, IsLatestTaskAssessmentRun?:bool, ResultStatistic?:array{Passed?:int, Failed?:int, Error?:int, Warning?:int, Cancelled?:int}}}>
     */
    public function cancelReplicationTaskAssessmentRunAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{DataMigrationName?:string, MigrationProjectIdentifier:string, DataMigrationType:"full-load"|"cdc"|"full-load-and-cdc", ServiceAccessRoleArn:string, EnableCloudwatchLogs?:bool, SourceDataSettings?:array<array{CDCStartPosition?:string, CDCStartTime?:int|string|\DateTimeInterface, CDCStopTime?:int|string|\DateTimeInterface, SlotName?:string}>, NumberOfJobs?:int, Tags?:array<array{Key?:string, Value?:string, ResourceArn?:string}>, SelectionRules?:string} $args
     * @return \AWS\Result<array{DataMigration?:array{DataMigrationName?:string, DataMigrationArn?:string, DataMigrationCreateTime?:int|string|\DateTimeInterface, DataMigrationStartTime?:int|string|\DateTimeInterface, DataMigrationEndTime?:int|string|\DateTimeInterface, ServiceAccessRoleArn?:string, MigrationProjectArn?:string, DataMigrationType?:"full-load"|"cdc"|"full-load-and-cdc", DataMigrationSettings?:array{NumberOfJobs?:int, CloudwatchLogsEnabled?:bool, SelectionRules?:string}, SourceDataSettings?:array<array{CDCStartPosition?:string, CDCStartTime?:int|string|\DateTimeInterface, CDCStopTime?:int|string|\DateTimeInterface, SlotName?:string}>, DataMigrationStatistics?:array{TablesLoaded?:int, ElapsedTimeMillis?:int, TablesLoading?:int, FullLoadPercentage?:int, CDCLatency?:int, TablesQueued?:int, TablesErrored?:int, StartTime?:int|string|\DateTimeInterface, StopTime?:int|string|\DateTimeInterface}, DataMigrationStatus?:string, PublicIpAddresses?:array<string>, DataMigrationCidrBlocks?:array<string>, LastFailureMessage?:string, StopReason?:string}}>
     */
    public function createDataMigration(array $args): \AWS\Result { }

    /**
     * @param array{DataMigrationName?:string, MigrationProjectIdentifier:string, DataMigrationType:"full-load"|"cdc"|"full-load-and-cdc", ServiceAccessRoleArn:string, EnableCloudwatchLogs?:bool, SourceDataSettings?:array<array{CDCStartPosition?:string, CDCStartTime?:int|string|\DateTimeInterface, CDCStopTime?:int|string|\DateTimeInterface, SlotName?:string}>, NumberOfJobs?:int, Tags?:array<array{Key?:string, Value?:string, ResourceArn?:string}>, SelectionRules?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{DataMigration?:array{DataMigrationName?:string, DataMigrationArn?:string, DataMigrationCreateTime?:int|string|\DateTimeInterface, DataMigrationStartTime?:int|string|\DateTimeInterface, DataMigrationEndTime?:int|string|\DateTimeInterface, ServiceAccessRoleArn?:string, MigrationProjectArn?:string, DataMigrationType?:"full-load"|"cdc"|"full-load-and-cdc", DataMigrationSettings?:array{NumberOfJobs?:int, CloudwatchLogsEnabled?:bool, SelectionRules?:string}, SourceDataSettings?:array<array{CDCStartPosition?:string, CDCStartTime?:int|string|\DateTimeInterface, CDCStopTime?:int|string|\DateTimeInterface, SlotName?:string}>, DataMigrationStatistics?:array{TablesLoaded?:int, ElapsedTimeMillis?:int, TablesLoading?:int, FullLoadPercentage?:int, CDCLatency?:int, TablesQueued?:int, TablesErrored?:int, StartTime?:int|string|\DateTimeInterface, StopTime?:int|string|\DateTimeInterface}, DataMigrationStatus?:string, PublicIpAddresses?:array<string>, DataMigrationCidrBlocks?:array<string>, LastFailureMessage?:string, StopReason?:string}}>
     */
    public function createDataMigrationAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{DataProviderName?:string, Description?:string, Engine:string, Settings:array{RedshiftSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string}, PostgreSqlSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, MySqlSettings?:array{ServerName?:string, Port?:int, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, OracleSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string, AsmServer?:string, SecretsManagerOracleAsmSecretId?:string, SecretsManagerOracleAsmAccessRoleArn?:string, SecretsManagerSecurityDbEncryptionSecretId?:string, SecretsManagerSecurityDbEncryptionAccessRoleArn?:string}, MicrosoftSqlServerSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, DocDbSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, MariaDbSettings?:array{ServerName?:string, Port?:int, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, MongoDbSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string, AuthType?:"no"|"password", AuthSource?:string, AuthMechanism?:"default"|"mongodb_cr"|"scram_sha_1"}}, Tags?:array<array{Key?:string, Value?:string, ResourceArn?:string}>} $args
     * @return \AWS\Result<array{DataProvider?:array{DataProviderName?:string, DataProviderArn?:string, DataProviderCreationTime?:int|string|\DateTimeInterface, Description?:string, Engine?:string, Settings?:array{RedshiftSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string}, PostgreSqlSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, MySqlSettings?:array{ServerName?:string, Port?:int, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, OracleSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string, AsmServer?:string, SecretsManagerOracleAsmSecretId?:string, SecretsManagerOracleAsmAccessRoleArn?:string, SecretsManagerSecurityDbEncryptionSecretId?:string, SecretsManagerSecurityDbEncryptionAccessRoleArn?:string}, MicrosoftSqlServerSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, DocDbSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, MariaDbSettings?:array{ServerName?:string, Port?:int, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, MongoDbSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string, AuthType?:"no"|"password", AuthSource?:string, AuthMechanism?:"default"|"mongodb_cr"|"scram_sha_1"}}}}>
     */
    public function createDataProvider(array $args): \AWS\Result { }

    /**
     * @param array{DataProviderName?:string, Description?:string, Engine:string, Settings:array{RedshiftSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string}, PostgreSqlSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, MySqlSettings?:array{ServerName?:string, Port?:int, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, OracleSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string, AsmServer?:string, SecretsManagerOracleAsmSecretId?:string, SecretsManagerOracleAsmAccessRoleArn?:string, SecretsManagerSecurityDbEncryptionSecretId?:string, SecretsManagerSecurityDbEncryptionAccessRoleArn?:string}, MicrosoftSqlServerSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, DocDbSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, MariaDbSettings?:array{ServerName?:string, Port?:int, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, MongoDbSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string, AuthType?:"no"|"password", AuthSource?:string, AuthMechanism?:"default"|"mongodb_cr"|"scram_sha_1"}}, Tags?:array<array{Key?:string, Value?:string, ResourceArn?:string}>} $args
     * @return \GuzzleHttp\Promise\Promise<array{DataProvider?:array{DataProviderName?:string, DataProviderArn?:string, DataProviderCreationTime?:int|string|\DateTimeInterface, Description?:string, Engine?:string, Settings?:array{RedshiftSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string}, PostgreSqlSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, MySqlSettings?:array{ServerName?:string, Port?:int, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, OracleSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string, AsmServer?:string, SecretsManagerOracleAsmSecretId?:string, SecretsManagerOracleAsmAccessRoleArn?:string, SecretsManagerSecurityDbEncryptionSecretId?:string, SecretsManagerSecurityDbEncryptionAccessRoleArn?:string}, MicrosoftSqlServerSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, DocDbSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, MariaDbSettings?:array{ServerName?:string, Port?:int, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, MongoDbSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string, AuthType?:"no"|"password", AuthSource?:string, AuthMechanism?:"default"|"mongodb_cr"|"scram_sha_1"}}}}>
     */
    public function createDataProviderAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{EndpointIdentifier:string, EndpointType:"source"|"target", EngineName:string, Username?:string, Password?:string, ServerName?:string, Port?:int, DatabaseName?:string, ExtraConnectionAttributes?:string, KmsKeyId?:string, Tags?:array<array{Key?:string, Value?:string, ResourceArn?:string}>, CertificateArn?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", ServiceAccessRoleArn?:string, ExternalTableDefinition?:string, DynamoDbSettings?:array{ServiceAccessRoleArn:string}, S3Settings?:array{ServiceAccessRoleArn?:string, ExternalTableDefinition?:string, CsvRowDelimiter?:string, CsvDelimiter?:string, BucketFolder?:string, BucketName?:string, CompressionType?:"none"|"gzip", EncryptionMode?:"sse-s3"|"sse-kms", ServerSideEncryptionKmsKeyId?:string, DataFormat?:"csv"|"parquet", EncodingType?:"plain"|"plain-dictionary"|"rle-dictionary", DictPageSizeLimit?:int, RowGroupLength?:int, DataPageSize?:int, ParquetVersion?:"parquet-1-0"|"parquet-2-0", EnableStatistics?:bool, IncludeOpForFullLoad?:bool, CdcInsertsOnly?:bool, TimestampColumnName?:string, ParquetTimestampInMillisecond?:bool, CdcInsertsAndUpdates?:bool, DatePartitionEnabled?:bool, DatePartitionSequence?:"YYYYMMDD"|"YYYYMMDDHH"|"YYYYMM"|"MMYYYYDD"|"DDMMYYYY", DatePartitionDelimiter?:"SLASH"|"UNDERSCORE"|"DASH"|"NONE", UseCsvNoSupValue?:bool, CsvNoSupValue?:string, PreserveTransactions?:bool, CdcPath?:string, UseTaskStartTimeForFullLoadTimestamp?:bool, CannedAclForObjects?:"none"|"private"|"public-read"|"public-read-write"|"authenticated-read"|"aws-exec-read"|"bucket-owner-read"|"bucket-owner-full-control", AddColumnName?:bool, CdcMaxBatchInterval?:int, CdcMinFileSize?:int, CsvNullValue?:string, IgnoreHeaderRows?:int, MaxFileSize?:int, Rfc4180?:bool, DatePartitionTimezone?:string, AddTrailingPaddingCharacter?:bool, ExpectedBucketOwner?:string, GlueCatalogGeneration?:bool}, DmsTransferSettings?:array{ServiceAccessRoleArn?:string, BucketName?:string}, MongoDbSettings?:array{Username?:string, Password?:string, ServerName?:string, Port?:int, DatabaseName?:string, AuthType?:"no"|"password", AuthMechanism?:"default"|"mongodb_cr"|"scram_sha_1", NestingLevel?:"none"|"one", ExtractDocId?:string, DocsToInvestigate?:string, AuthSource?:string, KmsKeyId?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, UseUpdateLookUp?:bool, ReplicateShardCollections?:bool}, KinesisSettings?:array{StreamArn?:string, MessageFormat?:"json"|"json-unformatted", ServiceAccessRoleArn?:string, IncludeTransactionDetails?:bool, IncludePartitionValue?:bool, PartitionIncludeSchemaTable?:bool, IncludeTableAlterOperations?:bool, IncludeControlDetails?:bool, IncludeNullAndEmpty?:bool, NoHexPrefix?:bool, UseLargeIntegerValue?:bool}, KafkaSettings?:array{Broker?:string, Topic?:string, MessageFormat?:"json"|"json-unformatted", IncludeTransactionDetails?:bool, IncludePartitionValue?:bool, PartitionIncludeSchemaTable?:bool, IncludeTableAlterOperations?:bool, IncludeControlDetails?:bool, MessageMaxBytes?:int, IncludeNullAndEmpty?:bool, SecurityProtocol?:"plaintext"|"ssl-authentication"|"ssl-encryption"|"sasl-ssl", SslClientCertificateArn?:string, SslClientKeyArn?:string, SslClientKeyPassword?:string, SslCaCertificateArn?:string, SaslUsername?:string, SaslPassword?:string, NoHexPrefix?:bool, SaslMechanism?:"scram-sha-512"|"plain", SslEndpointIdentificationAlgorithm?:"none"|"https", UseLargeIntegerValue?:bool}, ElasticsearchSettings?:array{ServiceAccessRoleArn:string, EndpointUri:string, FullLoadErrorPercentage?:int, ErrorRetryDuration?:int, UseNewMappingType?:bool}, NeptuneSettings?:array{ServiceAccessRoleArn?:string, S3BucketName:string, S3BucketFolder:string, ErrorRetryDuration?:int, MaxFileSize?:int, MaxRetryCount?:int, IamAuthEnabled?:bool}, RedshiftSettings?:array{AcceptAnyDate?:bool, AfterConnectScript?:string, BucketFolder?:string, BucketName?:string, CaseSensitiveNames?:bool, CompUpdate?:bool, ConnectionTimeout?:int, DatabaseName?:string, DateFormat?:string, EmptyAsNull?:bool, EncryptionMode?:"sse-s3"|"sse-kms", ExplicitIds?:bool, FileTransferUploadStreams?:int, LoadTimeout?:int, MaxFileSize?:int, Password?:string, Port?:int, RemoveQuotes?:bool, ReplaceInvalidChars?:string, ReplaceChars?:string, ServerName?:string, ServiceAccessRoleArn?:string, ServerSideEncryptionKmsKeyId?:string, TimeFormat?:string, TrimBlanks?:bool, TruncateColumns?:bool, Username?:string, WriteBufferSize?:int, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, MapBooleanAsBoolean?:bool}, PostgreSQLSettings?:array{AfterConnectScript?:string, CaptureDdls?:bool, MaxFileSize?:int, DatabaseName?:string, DdlArtifactsSchema?:string, ExecuteTimeout?:int, FailTasksOnLobTruncation?:bool, HeartbeatEnable?:bool, HeartbeatSchema?:string, HeartbeatFrequency?:int, Password?:string, Port?:int, ServerName?:string, Username?:string, SlotName?:string, PluginName?:"no-preference"|"test-decoding"|"pglogical", SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, TrimSpaceInChar?:bool, MapBooleanAsBoolean?:bool, MapJsonbAsClob?:bool, MapLongVarcharAs?:"wstring"|"clob"|"nclob", DatabaseMode?:"default"|"babelfish", BabelfishDatabaseName?:string, DisableUnicodeSourceFilter?:bool}, MySQLSettings?:array{AfterConnectScript?:string, CleanSourceMetadataOnMismatch?:bool, DatabaseName?:string, EventsPollInterval?:int, TargetDbType?:"specific-database"|"multiple-databases", MaxFileSize?:int, ParallelLoadThreads?:int, Password?:string, Port?:int, ServerName?:string, ServerTimezone?:string, Username?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, ExecuteTimeout?:int}, OracleSettings?:array{AddSupplementalLogging?:bool, ArchivedLogDestId?:int, AdditionalArchivedLogDestId?:int, ExtraArchivedLogDestIds?:array<int>, AllowSelectNestedTables?:bool, ParallelAsmReadThreads?:int, ReadAheadBlocks?:int, AccessAlternateDirectly?:bool, UseAlternateFolderForOnline?:bool, OraclePathPrefix?:string, UsePathPrefix?:string, ReplacePathPrefix?:bool, EnableHomogenousTablespace?:bool, DirectPathNoLog?:bool, ArchivedLogsOnly?:bool, AsmPassword?:string, AsmServer?:string, AsmUser?:string, CharLengthSemantics?:"default"|"char"|"byte", DatabaseName?:string, DirectPathParallelLoad?:bool, FailTasksOnLobTruncation?:bool, NumberDatatypeScale?:int, Password?:string, Port?:int, ReadTableSpaceName?:bool, RetryInterval?:int, SecurityDbEncryption?:string, SecurityDbEncryptionName?:string, ServerName?:string, SpatialDataOptionToGeoJsonFunctionName?:string, StandbyDelayTime?:int, Username?:string, UseBFile?:bool, UseDirectPathFullLoad?:bool, UseLogminerReader?:bool, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, SecretsManagerOracleAsmAccessRoleArn?:string, SecretsManagerOracleAsmSecretId?:string, TrimSpaceInChar?:bool, ConvertTimestampWithZoneToUTC?:bool, OpenTransactionWindow?:int, AuthenticationMethod?:"password"|"kerberos"}, SybaseSettings?:array{DatabaseName?:string, Password?:string, Port?:int, ServerName?:string, Username?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string}, MicrosoftSQLServerSettings?:array{Port?:int, BcpPacketSize?:int, DatabaseName?:string, ControlTablesFileGroup?:string, Password?:string, QuerySingleAlwaysOnNode?:bool, ReadBackupOnly?:bool, SafeguardPolicy?:"rely-on-sql-server-replication-agent"|"exclusive-automatic-truncation"|"shared-automatic-truncation", ServerName?:string, Username?:string, UseBcpFullLoad?:bool, UseThirdPartyBackupDevice?:bool, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, TrimSpaceInChar?:bool, TlogAccessMode?:"BackupOnly"|"PreferBackup"|"PreferTlog"|"TlogOnly", ForceLobLookup?:bool, AuthenticationMethod?:"password"|"kerberos"}, IBMDb2Settings?:array{DatabaseName?:string, Password?:string, Port?:int, ServerName?:string, SetDataCaptureChanges?:bool, CurrentLsn?:string, MaxKBytesPerRead?:int, Username?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, LoadTimeout?:int, WriteBufferSize?:int, MaxFileSize?:int, KeepCsvFiles?:bool}, ResourceIdentifier?:string, DocDbSettings?:array{Username?:string, Password?:string, ServerName?:string, Port?:int, DatabaseName?:string, NestingLevel?:"none"|"one", ExtractDocId?:bool, DocsToInvestigate?:int, KmsKeyId?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, UseUpdateLookUp?:bool, ReplicateShardCollections?:bool}, RedisSettings?:array{ServerName:string, Port:int, SslSecurityProtocol?:"plaintext"|"ssl-encryption", AuthType?:"none"|"auth-role"|"auth-token", AuthUserName?:string, AuthPassword?:string, SslCaCertificateArn?:string}, GcpMySQLSettings?:array{AfterConnectScript?:string, CleanSourceMetadataOnMismatch?:bool, DatabaseName?:string, EventsPollInterval?:int, TargetDbType?:"specific-database"|"multiple-databases", MaxFileSize?:int, ParallelLoadThreads?:int, Password?:string, Port?:int, ServerName?:string, ServerTimezone?:string, Username?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string}, TimestreamSettings?:array{DatabaseName:string, MemoryDuration:int, MagneticDuration:int, CdcInsertsAndUpdates?:bool, EnableMagneticStoreWrites?:bool}} $args
     * @return \AWS\Result<array{Endpoint?:array{EndpointIdentifier?:string, EndpointType?:"source"|"target", EngineName?:string, EngineDisplayName?:string, Username?:string, ServerName?:string, Port?:int, DatabaseName?:string, ExtraConnectionAttributes?:string, Status?:string, KmsKeyId?:string, EndpointArn?:string, CertificateArn?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", ServiceAccessRoleArn?:string, ExternalTableDefinition?:string, ExternalId?:string, DynamoDbSettings?:array{ServiceAccessRoleArn:string}, S3Settings?:array{ServiceAccessRoleArn?:string, ExternalTableDefinition?:string, CsvRowDelimiter?:string, CsvDelimiter?:string, BucketFolder?:string, BucketName?:string, CompressionType?:"none"|"gzip", EncryptionMode?:"sse-s3"|"sse-kms", ServerSideEncryptionKmsKeyId?:string, DataFormat?:"csv"|"parquet", EncodingType?:"plain"|"plain-dictionary"|"rle-dictionary", DictPageSizeLimit?:int, RowGroupLength?:int, DataPageSize?:int, ParquetVersion?:"parquet-1-0"|"parquet-2-0", EnableStatistics?:bool, IncludeOpForFullLoad?:bool, CdcInsertsOnly?:bool, TimestampColumnName?:string, ParquetTimestampInMillisecond?:bool, CdcInsertsAndUpdates?:bool, DatePartitionEnabled?:bool, DatePartitionSequence?:"YYYYMMDD"|"YYYYMMDDHH"|"YYYYMM"|"MMYYYYDD"|"DDMMYYYY", DatePartitionDelimiter?:"SLASH"|"UNDERSCORE"|"DASH"|"NONE", UseCsvNoSupValue?:bool, CsvNoSupValue?:string, PreserveTransactions?:bool, CdcPath?:string, UseTaskStartTimeForFullLoadTimestamp?:bool, CannedAclForObjects?:"none"|"private"|"public-read"|"public-read-write"|"authenticated-read"|"aws-exec-read"|"bucket-owner-read"|"bucket-owner-full-control", AddColumnName?:bool, CdcMaxBatchInterval?:int, CdcMinFileSize?:int, CsvNullValue?:string, IgnoreHeaderRows?:int, MaxFileSize?:int, Rfc4180?:bool, DatePartitionTimezone?:string, AddTrailingPaddingCharacter?:bool, ExpectedBucketOwner?:string, GlueCatalogGeneration?:bool}, DmsTransferSettings?:array{ServiceAccessRoleArn?:string, BucketName?:string}, MongoDbSettings?:array{Username?:string, Password?:string, ServerName?:string, Port?:int, DatabaseName?:string, AuthType?:"no"|"password", AuthMechanism?:"default"|"mongodb_cr"|"scram_sha_1", NestingLevel?:"none"|"one", ExtractDocId?:string, DocsToInvestigate?:string, AuthSource?:string, KmsKeyId?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, UseUpdateLookUp?:bool, ReplicateShardCollections?:bool}, KinesisSettings?:array{StreamArn?:string, MessageFormat?:"json"|"json-unformatted", ServiceAccessRoleArn?:string, IncludeTransactionDetails?:bool, IncludePartitionValue?:bool, PartitionIncludeSchemaTable?:bool, IncludeTableAlterOperations?:bool, IncludeControlDetails?:bool, IncludeNullAndEmpty?:bool, NoHexPrefix?:bool, UseLargeIntegerValue?:bool}, KafkaSettings?:array{Broker?:string, Topic?:string, MessageFormat?:"json"|"json-unformatted", IncludeTransactionDetails?:bool, IncludePartitionValue?:bool, PartitionIncludeSchemaTable?:bool, IncludeTableAlterOperations?:bool, IncludeControlDetails?:bool, MessageMaxBytes?:int, IncludeNullAndEmpty?:bool, SecurityProtocol?:"plaintext"|"ssl-authentication"|"ssl-encryption"|"sasl-ssl", SslClientCertificateArn?:string, SslClientKeyArn?:string, SslClientKeyPassword?:string, SslCaCertificateArn?:string, SaslUsername?:string, SaslPassword?:string, NoHexPrefix?:bool, SaslMechanism?:"scram-sha-512"|"plain", SslEndpointIdentificationAlgorithm?:"none"|"https", UseLargeIntegerValue?:bool}, ElasticsearchSettings?:array{ServiceAccessRoleArn:string, EndpointUri:string, FullLoadErrorPercentage?:int, ErrorRetryDuration?:int, UseNewMappingType?:bool}, NeptuneSettings?:array{ServiceAccessRoleArn?:string, S3BucketName:string, S3BucketFolder:string, ErrorRetryDuration?:int, MaxFileSize?:int, MaxRetryCount?:int, IamAuthEnabled?:bool}, RedshiftSettings?:array{AcceptAnyDate?:bool, AfterConnectScript?:string, BucketFolder?:string, BucketName?:string, CaseSensitiveNames?:bool, CompUpdate?:bool, ConnectionTimeout?:int, DatabaseName?:string, DateFormat?:string, EmptyAsNull?:bool, EncryptionMode?:"sse-s3"|"sse-kms", ExplicitIds?:bool, FileTransferUploadStreams?:int, LoadTimeout?:int, MaxFileSize?:int, Password?:string, Port?:int, RemoveQuotes?:bool, ReplaceInvalidChars?:string, ReplaceChars?:string, ServerName?:string, ServiceAccessRoleArn?:string, ServerSideEncryptionKmsKeyId?:string, TimeFormat?:string, TrimBlanks?:bool, TruncateColumns?:bool, Username?:string, WriteBufferSize?:int, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, MapBooleanAsBoolean?:bool}, PostgreSQLSettings?:array{AfterConnectScript?:string, CaptureDdls?:bool, MaxFileSize?:int, DatabaseName?:string, DdlArtifactsSchema?:string, ExecuteTimeout?:int, FailTasksOnLobTruncation?:bool, HeartbeatEnable?:bool, HeartbeatSchema?:string, HeartbeatFrequency?:int, Password?:string, Port?:int, ServerName?:string, Username?:string, SlotName?:string, PluginName?:"no-preference"|"test-decoding"|"pglogical", SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, TrimSpaceInChar?:bool, MapBooleanAsBoolean?:bool, MapJsonbAsClob?:bool, MapLongVarcharAs?:"wstring"|"clob"|"nclob", DatabaseMode?:"default"|"babelfish", BabelfishDatabaseName?:string, DisableUnicodeSourceFilter?:bool}, MySQLSettings?:array{AfterConnectScript?:string, CleanSourceMetadataOnMismatch?:bool, DatabaseName?:string, EventsPollInterval?:int, TargetDbType?:"specific-database"|"multiple-databases", MaxFileSize?:int, ParallelLoadThreads?:int, Password?:string, Port?:int, ServerName?:string, ServerTimezone?:string, Username?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, ExecuteTimeout?:int}, OracleSettings?:array{AddSupplementalLogging?:bool, ArchivedLogDestId?:int, AdditionalArchivedLogDestId?:int, ExtraArchivedLogDestIds?:array<int>, AllowSelectNestedTables?:bool, ParallelAsmReadThreads?:int, ReadAheadBlocks?:int, AccessAlternateDirectly?:bool, UseAlternateFolderForOnline?:bool, OraclePathPrefix?:string, UsePathPrefix?:string, ReplacePathPrefix?:bool, EnableHomogenousTablespace?:bool, DirectPathNoLog?:bool, ArchivedLogsOnly?:bool, AsmPassword?:string, AsmServer?:string, AsmUser?:string, CharLengthSemantics?:"default"|"char"|"byte", DatabaseName?:string, DirectPathParallelLoad?:bool, FailTasksOnLobTruncation?:bool, NumberDatatypeScale?:int, Password?:string, Port?:int, ReadTableSpaceName?:bool, RetryInterval?:int, SecurityDbEncryption?:string, SecurityDbEncryptionName?:string, ServerName?:string, SpatialDataOptionToGeoJsonFunctionName?:string, StandbyDelayTime?:int, Username?:string, UseBFile?:bool, UseDirectPathFullLoad?:bool, UseLogminerReader?:bool, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, SecretsManagerOracleAsmAccessRoleArn?:string, SecretsManagerOracleAsmSecretId?:string, TrimSpaceInChar?:bool, ConvertTimestampWithZoneToUTC?:bool, OpenTransactionWindow?:int, AuthenticationMethod?:"password"|"kerberos"}, SybaseSettings?:array{DatabaseName?:string, Password?:string, Port?:int, ServerName?:string, Username?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string}, MicrosoftSQLServerSettings?:array{Port?:int, BcpPacketSize?:int, DatabaseName?:string, ControlTablesFileGroup?:string, Password?:string, QuerySingleAlwaysOnNode?:bool, ReadBackupOnly?:bool, SafeguardPolicy?:"rely-on-sql-server-replication-agent"|"exclusive-automatic-truncation"|"shared-automatic-truncation", ServerName?:string, Username?:string, UseBcpFullLoad?:bool, UseThirdPartyBackupDevice?:bool, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, TrimSpaceInChar?:bool, TlogAccessMode?:"BackupOnly"|"PreferBackup"|"PreferTlog"|"TlogOnly", ForceLobLookup?:bool, AuthenticationMethod?:"password"|"kerberos"}, IBMDb2Settings?:array{DatabaseName?:string, Password?:string, Port?:int, ServerName?:string, SetDataCaptureChanges?:bool, CurrentLsn?:string, MaxKBytesPerRead?:int, Username?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, LoadTimeout?:int, WriteBufferSize?:int, MaxFileSize?:int, KeepCsvFiles?:bool}, DocDbSettings?:array{Username?:string, Password?:string, ServerName?:string, Port?:int, DatabaseName?:string, NestingLevel?:"none"|"one", ExtractDocId?:bool, DocsToInvestigate?:int, KmsKeyId?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, UseUpdateLookUp?:bool, ReplicateShardCollections?:bool}, RedisSettings?:array{ServerName:string, Port:int, SslSecurityProtocol?:"plaintext"|"ssl-encryption", AuthType?:"none"|"auth-role"|"auth-token", AuthUserName?:string, AuthPassword?:string, SslCaCertificateArn?:string}, GcpMySQLSettings?:array{AfterConnectScript?:string, CleanSourceMetadataOnMismatch?:bool, DatabaseName?:string, EventsPollInterval?:int, TargetDbType?:"specific-database"|"multiple-databases", MaxFileSize?:int, ParallelLoadThreads?:int, Password?:string, Port?:int, ServerName?:string, ServerTimezone?:string, Username?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string}, TimestreamSettings?:array{DatabaseName:string, MemoryDuration:int, MagneticDuration:int, CdcInsertsAndUpdates?:bool, EnableMagneticStoreWrites?:bool}}}>
     */
    public function createEndpoint(array $args): \AWS\Result { }

    /**
     * @param array{EndpointIdentifier:string, EndpointType:"source"|"target", EngineName:string, Username?:string, Password?:string, ServerName?:string, Port?:int, DatabaseName?:string, ExtraConnectionAttributes?:string, KmsKeyId?:string, Tags?:array<array{Key?:string, Value?:string, ResourceArn?:string}>, CertificateArn?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", ServiceAccessRoleArn?:string, ExternalTableDefinition?:string, DynamoDbSettings?:array{ServiceAccessRoleArn:string}, S3Settings?:array{ServiceAccessRoleArn?:string, ExternalTableDefinition?:string, CsvRowDelimiter?:string, CsvDelimiter?:string, BucketFolder?:string, BucketName?:string, CompressionType?:"none"|"gzip", EncryptionMode?:"sse-s3"|"sse-kms", ServerSideEncryptionKmsKeyId?:string, DataFormat?:"csv"|"parquet", EncodingType?:"plain"|"plain-dictionary"|"rle-dictionary", DictPageSizeLimit?:int, RowGroupLength?:int, DataPageSize?:int, ParquetVersion?:"parquet-1-0"|"parquet-2-0", EnableStatistics?:bool, IncludeOpForFullLoad?:bool, CdcInsertsOnly?:bool, TimestampColumnName?:string, ParquetTimestampInMillisecond?:bool, CdcInsertsAndUpdates?:bool, DatePartitionEnabled?:bool, DatePartitionSequence?:"YYYYMMDD"|"YYYYMMDDHH"|"YYYYMM"|"MMYYYYDD"|"DDMMYYYY", DatePartitionDelimiter?:"SLASH"|"UNDERSCORE"|"DASH"|"NONE", UseCsvNoSupValue?:bool, CsvNoSupValue?:string, PreserveTransactions?:bool, CdcPath?:string, UseTaskStartTimeForFullLoadTimestamp?:bool, CannedAclForObjects?:"none"|"private"|"public-read"|"public-read-write"|"authenticated-read"|"aws-exec-read"|"bucket-owner-read"|"bucket-owner-full-control", AddColumnName?:bool, CdcMaxBatchInterval?:int, CdcMinFileSize?:int, CsvNullValue?:string, IgnoreHeaderRows?:int, MaxFileSize?:int, Rfc4180?:bool, DatePartitionTimezone?:string, AddTrailingPaddingCharacter?:bool, ExpectedBucketOwner?:string, GlueCatalogGeneration?:bool}, DmsTransferSettings?:array{ServiceAccessRoleArn?:string, BucketName?:string}, MongoDbSettings?:array{Username?:string, Password?:string, ServerName?:string, Port?:int, DatabaseName?:string, AuthType?:"no"|"password", AuthMechanism?:"default"|"mongodb_cr"|"scram_sha_1", NestingLevel?:"none"|"one", ExtractDocId?:string, DocsToInvestigate?:string, AuthSource?:string, KmsKeyId?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, UseUpdateLookUp?:bool, ReplicateShardCollections?:bool}, KinesisSettings?:array{StreamArn?:string, MessageFormat?:"json"|"json-unformatted", ServiceAccessRoleArn?:string, IncludeTransactionDetails?:bool, IncludePartitionValue?:bool, PartitionIncludeSchemaTable?:bool, IncludeTableAlterOperations?:bool, IncludeControlDetails?:bool, IncludeNullAndEmpty?:bool, NoHexPrefix?:bool, UseLargeIntegerValue?:bool}, KafkaSettings?:array{Broker?:string, Topic?:string, MessageFormat?:"json"|"json-unformatted", IncludeTransactionDetails?:bool, IncludePartitionValue?:bool, PartitionIncludeSchemaTable?:bool, IncludeTableAlterOperations?:bool, IncludeControlDetails?:bool, MessageMaxBytes?:int, IncludeNullAndEmpty?:bool, SecurityProtocol?:"plaintext"|"ssl-authentication"|"ssl-encryption"|"sasl-ssl", SslClientCertificateArn?:string, SslClientKeyArn?:string, SslClientKeyPassword?:string, SslCaCertificateArn?:string, SaslUsername?:string, SaslPassword?:string, NoHexPrefix?:bool, SaslMechanism?:"scram-sha-512"|"plain", SslEndpointIdentificationAlgorithm?:"none"|"https", UseLargeIntegerValue?:bool}, ElasticsearchSettings?:array{ServiceAccessRoleArn:string, EndpointUri:string, FullLoadErrorPercentage?:int, ErrorRetryDuration?:int, UseNewMappingType?:bool}, NeptuneSettings?:array{ServiceAccessRoleArn?:string, S3BucketName:string, S3BucketFolder:string, ErrorRetryDuration?:int, MaxFileSize?:int, MaxRetryCount?:int, IamAuthEnabled?:bool}, RedshiftSettings?:array{AcceptAnyDate?:bool, AfterConnectScript?:string, BucketFolder?:string, BucketName?:string, CaseSensitiveNames?:bool, CompUpdate?:bool, ConnectionTimeout?:int, DatabaseName?:string, DateFormat?:string, EmptyAsNull?:bool, EncryptionMode?:"sse-s3"|"sse-kms", ExplicitIds?:bool, FileTransferUploadStreams?:int, LoadTimeout?:int, MaxFileSize?:int, Password?:string, Port?:int, RemoveQuotes?:bool, ReplaceInvalidChars?:string, ReplaceChars?:string, ServerName?:string, ServiceAccessRoleArn?:string, ServerSideEncryptionKmsKeyId?:string, TimeFormat?:string, TrimBlanks?:bool, TruncateColumns?:bool, Username?:string, WriteBufferSize?:int, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, MapBooleanAsBoolean?:bool}, PostgreSQLSettings?:array{AfterConnectScript?:string, CaptureDdls?:bool, MaxFileSize?:int, DatabaseName?:string, DdlArtifactsSchema?:string, ExecuteTimeout?:int, FailTasksOnLobTruncation?:bool, HeartbeatEnable?:bool, HeartbeatSchema?:string, HeartbeatFrequency?:int, Password?:string, Port?:int, ServerName?:string, Username?:string, SlotName?:string, PluginName?:"no-preference"|"test-decoding"|"pglogical", SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, TrimSpaceInChar?:bool, MapBooleanAsBoolean?:bool, MapJsonbAsClob?:bool, MapLongVarcharAs?:"wstring"|"clob"|"nclob", DatabaseMode?:"default"|"babelfish", BabelfishDatabaseName?:string, DisableUnicodeSourceFilter?:bool}, MySQLSettings?:array{AfterConnectScript?:string, CleanSourceMetadataOnMismatch?:bool, DatabaseName?:string, EventsPollInterval?:int, TargetDbType?:"specific-database"|"multiple-databases", MaxFileSize?:int, ParallelLoadThreads?:int, Password?:string, Port?:int, ServerName?:string, ServerTimezone?:string, Username?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, ExecuteTimeout?:int}, OracleSettings?:array{AddSupplementalLogging?:bool, ArchivedLogDestId?:int, AdditionalArchivedLogDestId?:int, ExtraArchivedLogDestIds?:array<int>, AllowSelectNestedTables?:bool, ParallelAsmReadThreads?:int, ReadAheadBlocks?:int, AccessAlternateDirectly?:bool, UseAlternateFolderForOnline?:bool, OraclePathPrefix?:string, UsePathPrefix?:string, ReplacePathPrefix?:bool, EnableHomogenousTablespace?:bool, DirectPathNoLog?:bool, ArchivedLogsOnly?:bool, AsmPassword?:string, AsmServer?:string, AsmUser?:string, CharLengthSemantics?:"default"|"char"|"byte", DatabaseName?:string, DirectPathParallelLoad?:bool, FailTasksOnLobTruncation?:bool, NumberDatatypeScale?:int, Password?:string, Port?:int, ReadTableSpaceName?:bool, RetryInterval?:int, SecurityDbEncryption?:string, SecurityDbEncryptionName?:string, ServerName?:string, SpatialDataOptionToGeoJsonFunctionName?:string, StandbyDelayTime?:int, Username?:string, UseBFile?:bool, UseDirectPathFullLoad?:bool, UseLogminerReader?:bool, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, SecretsManagerOracleAsmAccessRoleArn?:string, SecretsManagerOracleAsmSecretId?:string, TrimSpaceInChar?:bool, ConvertTimestampWithZoneToUTC?:bool, OpenTransactionWindow?:int, AuthenticationMethod?:"password"|"kerberos"}, SybaseSettings?:array{DatabaseName?:string, Password?:string, Port?:int, ServerName?:string, Username?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string}, MicrosoftSQLServerSettings?:array{Port?:int, BcpPacketSize?:int, DatabaseName?:string, ControlTablesFileGroup?:string, Password?:string, QuerySingleAlwaysOnNode?:bool, ReadBackupOnly?:bool, SafeguardPolicy?:"rely-on-sql-server-replication-agent"|"exclusive-automatic-truncation"|"shared-automatic-truncation", ServerName?:string, Username?:string, UseBcpFullLoad?:bool, UseThirdPartyBackupDevice?:bool, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, TrimSpaceInChar?:bool, TlogAccessMode?:"BackupOnly"|"PreferBackup"|"PreferTlog"|"TlogOnly", ForceLobLookup?:bool, AuthenticationMethod?:"password"|"kerberos"}, IBMDb2Settings?:array{DatabaseName?:string, Password?:string, Port?:int, ServerName?:string, SetDataCaptureChanges?:bool, CurrentLsn?:string, MaxKBytesPerRead?:int, Username?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, LoadTimeout?:int, WriteBufferSize?:int, MaxFileSize?:int, KeepCsvFiles?:bool}, ResourceIdentifier?:string, DocDbSettings?:array{Username?:string, Password?:string, ServerName?:string, Port?:int, DatabaseName?:string, NestingLevel?:"none"|"one", ExtractDocId?:bool, DocsToInvestigate?:int, KmsKeyId?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, UseUpdateLookUp?:bool, ReplicateShardCollections?:bool}, RedisSettings?:array{ServerName:string, Port:int, SslSecurityProtocol?:"plaintext"|"ssl-encryption", AuthType?:"none"|"auth-role"|"auth-token", AuthUserName?:string, AuthPassword?:string, SslCaCertificateArn?:string}, GcpMySQLSettings?:array{AfterConnectScript?:string, CleanSourceMetadataOnMismatch?:bool, DatabaseName?:string, EventsPollInterval?:int, TargetDbType?:"specific-database"|"multiple-databases", MaxFileSize?:int, ParallelLoadThreads?:int, Password?:string, Port?:int, ServerName?:string, ServerTimezone?:string, Username?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string}, TimestreamSettings?:array{DatabaseName:string, MemoryDuration:int, MagneticDuration:int, CdcInsertsAndUpdates?:bool, EnableMagneticStoreWrites?:bool}} $args
     * @return \GuzzleHttp\Promise\Promise<array{Endpoint?:array{EndpointIdentifier?:string, EndpointType?:"source"|"target", EngineName?:string, EngineDisplayName?:string, Username?:string, ServerName?:string, Port?:int, DatabaseName?:string, ExtraConnectionAttributes?:string, Status?:string, KmsKeyId?:string, EndpointArn?:string, CertificateArn?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", ServiceAccessRoleArn?:string, ExternalTableDefinition?:string, ExternalId?:string, DynamoDbSettings?:array{ServiceAccessRoleArn:string}, S3Settings?:array{ServiceAccessRoleArn?:string, ExternalTableDefinition?:string, CsvRowDelimiter?:string, CsvDelimiter?:string, BucketFolder?:string, BucketName?:string, CompressionType?:"none"|"gzip", EncryptionMode?:"sse-s3"|"sse-kms", ServerSideEncryptionKmsKeyId?:string, DataFormat?:"csv"|"parquet", EncodingType?:"plain"|"plain-dictionary"|"rle-dictionary", DictPageSizeLimit?:int, RowGroupLength?:int, DataPageSize?:int, ParquetVersion?:"parquet-1-0"|"parquet-2-0", EnableStatistics?:bool, IncludeOpForFullLoad?:bool, CdcInsertsOnly?:bool, TimestampColumnName?:string, ParquetTimestampInMillisecond?:bool, CdcInsertsAndUpdates?:bool, DatePartitionEnabled?:bool, DatePartitionSequence?:"YYYYMMDD"|"YYYYMMDDHH"|"YYYYMM"|"MMYYYYDD"|"DDMMYYYY", DatePartitionDelimiter?:"SLASH"|"UNDERSCORE"|"DASH"|"NONE", UseCsvNoSupValue?:bool, CsvNoSupValue?:string, PreserveTransactions?:bool, CdcPath?:string, UseTaskStartTimeForFullLoadTimestamp?:bool, CannedAclForObjects?:"none"|"private"|"public-read"|"public-read-write"|"authenticated-read"|"aws-exec-read"|"bucket-owner-read"|"bucket-owner-full-control", AddColumnName?:bool, CdcMaxBatchInterval?:int, CdcMinFileSize?:int, CsvNullValue?:string, IgnoreHeaderRows?:int, MaxFileSize?:int, Rfc4180?:bool, DatePartitionTimezone?:string, AddTrailingPaddingCharacter?:bool, ExpectedBucketOwner?:string, GlueCatalogGeneration?:bool}, DmsTransferSettings?:array{ServiceAccessRoleArn?:string, BucketName?:string}, MongoDbSettings?:array{Username?:string, Password?:string, ServerName?:string, Port?:int, DatabaseName?:string, AuthType?:"no"|"password", AuthMechanism?:"default"|"mongodb_cr"|"scram_sha_1", NestingLevel?:"none"|"one", ExtractDocId?:string, DocsToInvestigate?:string, AuthSource?:string, KmsKeyId?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, UseUpdateLookUp?:bool, ReplicateShardCollections?:bool}, KinesisSettings?:array{StreamArn?:string, MessageFormat?:"json"|"json-unformatted", ServiceAccessRoleArn?:string, IncludeTransactionDetails?:bool, IncludePartitionValue?:bool, PartitionIncludeSchemaTable?:bool, IncludeTableAlterOperations?:bool, IncludeControlDetails?:bool, IncludeNullAndEmpty?:bool, NoHexPrefix?:bool, UseLargeIntegerValue?:bool}, KafkaSettings?:array{Broker?:string, Topic?:string, MessageFormat?:"json"|"json-unformatted", IncludeTransactionDetails?:bool, IncludePartitionValue?:bool, PartitionIncludeSchemaTable?:bool, IncludeTableAlterOperations?:bool, IncludeControlDetails?:bool, MessageMaxBytes?:int, IncludeNullAndEmpty?:bool, SecurityProtocol?:"plaintext"|"ssl-authentication"|"ssl-encryption"|"sasl-ssl", SslClientCertificateArn?:string, SslClientKeyArn?:string, SslClientKeyPassword?:string, SslCaCertificateArn?:string, SaslUsername?:string, SaslPassword?:string, NoHexPrefix?:bool, SaslMechanism?:"scram-sha-512"|"plain", SslEndpointIdentificationAlgorithm?:"none"|"https", UseLargeIntegerValue?:bool}, ElasticsearchSettings?:array{ServiceAccessRoleArn:string, EndpointUri:string, FullLoadErrorPercentage?:int, ErrorRetryDuration?:int, UseNewMappingType?:bool}, NeptuneSettings?:array{ServiceAccessRoleArn?:string, S3BucketName:string, S3BucketFolder:string, ErrorRetryDuration?:int, MaxFileSize?:int, MaxRetryCount?:int, IamAuthEnabled?:bool}, RedshiftSettings?:array{AcceptAnyDate?:bool, AfterConnectScript?:string, BucketFolder?:string, BucketName?:string, CaseSensitiveNames?:bool, CompUpdate?:bool, ConnectionTimeout?:int, DatabaseName?:string, DateFormat?:string, EmptyAsNull?:bool, EncryptionMode?:"sse-s3"|"sse-kms", ExplicitIds?:bool, FileTransferUploadStreams?:int, LoadTimeout?:int, MaxFileSize?:int, Password?:string, Port?:int, RemoveQuotes?:bool, ReplaceInvalidChars?:string, ReplaceChars?:string, ServerName?:string, ServiceAccessRoleArn?:string, ServerSideEncryptionKmsKeyId?:string, TimeFormat?:string, TrimBlanks?:bool, TruncateColumns?:bool, Username?:string, WriteBufferSize?:int, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, MapBooleanAsBoolean?:bool}, PostgreSQLSettings?:array{AfterConnectScript?:string, CaptureDdls?:bool, MaxFileSize?:int, DatabaseName?:string, DdlArtifactsSchema?:string, ExecuteTimeout?:int, FailTasksOnLobTruncation?:bool, HeartbeatEnable?:bool, HeartbeatSchema?:string, HeartbeatFrequency?:int, Password?:string, Port?:int, ServerName?:string, Username?:string, SlotName?:string, PluginName?:"no-preference"|"test-decoding"|"pglogical", SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, TrimSpaceInChar?:bool, MapBooleanAsBoolean?:bool, MapJsonbAsClob?:bool, MapLongVarcharAs?:"wstring"|"clob"|"nclob", DatabaseMode?:"default"|"babelfish", BabelfishDatabaseName?:string, DisableUnicodeSourceFilter?:bool}, MySQLSettings?:array{AfterConnectScript?:string, CleanSourceMetadataOnMismatch?:bool, DatabaseName?:string, EventsPollInterval?:int, TargetDbType?:"specific-database"|"multiple-databases", MaxFileSize?:int, ParallelLoadThreads?:int, Password?:string, Port?:int, ServerName?:string, ServerTimezone?:string, Username?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, ExecuteTimeout?:int}, OracleSettings?:array{AddSupplementalLogging?:bool, ArchivedLogDestId?:int, AdditionalArchivedLogDestId?:int, ExtraArchivedLogDestIds?:array<int>, AllowSelectNestedTables?:bool, ParallelAsmReadThreads?:int, ReadAheadBlocks?:int, AccessAlternateDirectly?:bool, UseAlternateFolderForOnline?:bool, OraclePathPrefix?:string, UsePathPrefix?:string, ReplacePathPrefix?:bool, EnableHomogenousTablespace?:bool, DirectPathNoLog?:bool, ArchivedLogsOnly?:bool, AsmPassword?:string, AsmServer?:string, AsmUser?:string, CharLengthSemantics?:"default"|"char"|"byte", DatabaseName?:string, DirectPathParallelLoad?:bool, FailTasksOnLobTruncation?:bool, NumberDatatypeScale?:int, Password?:string, Port?:int, ReadTableSpaceName?:bool, RetryInterval?:int, SecurityDbEncryption?:string, SecurityDbEncryptionName?:string, ServerName?:string, SpatialDataOptionToGeoJsonFunctionName?:string, StandbyDelayTime?:int, Username?:string, UseBFile?:bool, UseDirectPathFullLoad?:bool, UseLogminerReader?:bool, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, SecretsManagerOracleAsmAccessRoleArn?:string, SecretsManagerOracleAsmSecretId?:string, TrimSpaceInChar?:bool, ConvertTimestampWithZoneToUTC?:bool, OpenTransactionWindow?:int, AuthenticationMethod?:"password"|"kerberos"}, SybaseSettings?:array{DatabaseName?:string, Password?:string, Port?:int, ServerName?:string, Username?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string}, MicrosoftSQLServerSettings?:array{Port?:int, BcpPacketSize?:int, DatabaseName?:string, ControlTablesFileGroup?:string, Password?:string, QuerySingleAlwaysOnNode?:bool, ReadBackupOnly?:bool, SafeguardPolicy?:"rely-on-sql-server-replication-agent"|"exclusive-automatic-truncation"|"shared-automatic-truncation", ServerName?:string, Username?:string, UseBcpFullLoad?:bool, UseThirdPartyBackupDevice?:bool, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, TrimSpaceInChar?:bool, TlogAccessMode?:"BackupOnly"|"PreferBackup"|"PreferTlog"|"TlogOnly", ForceLobLookup?:bool, AuthenticationMethod?:"password"|"kerberos"}, IBMDb2Settings?:array{DatabaseName?:string, Password?:string, Port?:int, ServerName?:string, SetDataCaptureChanges?:bool, CurrentLsn?:string, MaxKBytesPerRead?:int, Username?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, LoadTimeout?:int, WriteBufferSize?:int, MaxFileSize?:int, KeepCsvFiles?:bool}, DocDbSettings?:array{Username?:string, Password?:string, ServerName?:string, Port?:int, DatabaseName?:string, NestingLevel?:"none"|"one", ExtractDocId?:bool, DocsToInvestigate?:int, KmsKeyId?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, UseUpdateLookUp?:bool, ReplicateShardCollections?:bool}, RedisSettings?:array{ServerName:string, Port:int, SslSecurityProtocol?:"plaintext"|"ssl-encryption", AuthType?:"none"|"auth-role"|"auth-token", AuthUserName?:string, AuthPassword?:string, SslCaCertificateArn?:string}, GcpMySQLSettings?:array{AfterConnectScript?:string, CleanSourceMetadataOnMismatch?:bool, DatabaseName?:string, EventsPollInterval?:int, TargetDbType?:"specific-database"|"multiple-databases", MaxFileSize?:int, ParallelLoadThreads?:int, Password?:string, Port?:int, ServerName?:string, ServerTimezone?:string, Username?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string}, TimestreamSettings?:array{DatabaseName:string, MemoryDuration:int, MagneticDuration:int, CdcInsertsAndUpdates?:bool, EnableMagneticStoreWrites?:bool}}}>
     */
    public function createEndpointAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{SubscriptionName:string, SnsTopicArn:string, SourceType?:string, EventCategories?:array<string>, SourceIds?:array<string>, Enabled?:bool, Tags?:array<array{Key?:string, Value?:string, ResourceArn?:string}>} $args
     * @return \AWS\Result<array{EventSubscription?:array{CustomerAwsId?:string, CustSubscriptionId?:string, SnsTopicArn?:string, Status?:string, SubscriptionCreationTime?:string, SourceType?:string, SourceIdsList?:array<string>, EventCategoriesList?:array<string>, Enabled?:bool}}>
     */
    public function createEventSubscription(array $args): \AWS\Result { }

    /**
     * @param array{SubscriptionName:string, SnsTopicArn:string, SourceType?:string, EventCategories?:array<string>, SourceIds?:array<string>, Enabled?:bool, Tags?:array<array{Key?:string, Value?:string, ResourceArn?:string}>} $args
     * @return \GuzzleHttp\Promise\Promise<array{EventSubscription?:array{CustomerAwsId?:string, CustSubscriptionId?:string, SnsTopicArn?:string, Status?:string, SubscriptionCreationTime?:string, SourceType?:string, SourceIdsList?:array<string>, EventCategoriesList?:array<string>, Enabled?:bool}}>
     */
    public function createEventSubscriptionAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CollectorName:string, Description?:string, ServiceAccessRoleArn:string, S3BucketName:string} $args
     * @return \AWS\Result<array{CollectorReferencedId?:string, CollectorName?:string, Description?:string, ServiceAccessRoleArn?:string, S3BucketName?:string}>
     */
    public function createFleetAdvisorCollector(array $args): \AWS\Result { }

    /**
     * @param array{CollectorName:string, Description?:string, ServiceAccessRoleArn:string, S3BucketName:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{CollectorReferencedId?:string, CollectorName?:string, Description?:string, ServiceAccessRoleArn?:string, S3BucketName?:string}>
     */
    public function createFleetAdvisorCollectorAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{AvailabilityZone?:string, KmsKeyArn?:string, PubliclyAccessible?:bool, Tags?:array<array{Key?:string, Value?:string, ResourceArn?:string}>, NetworkType?:string, InstanceProfileName?:string, Description?:string, SubnetGroupIdentifier?:string, VpcSecurityGroups?:array<string>} $args
     * @return \AWS\Result<array{InstanceProfile?:array{InstanceProfileArn?:string, AvailabilityZone?:string, KmsKeyArn?:string, PubliclyAccessible?:bool, NetworkType?:string, InstanceProfileName?:string, Description?:string, InstanceProfileCreationTime?:int|string|\DateTimeInterface, SubnetGroupIdentifier?:string, VpcSecurityGroups?:array<string>}}>
     */
    public function createInstanceProfile(array $args = []): \AWS\Result { }

    /**
     * @param array{AvailabilityZone?:string, KmsKeyArn?:string, PubliclyAccessible?:bool, Tags?:array<array{Key?:string, Value?:string, ResourceArn?:string}>, NetworkType?:string, InstanceProfileName?:string, Description?:string, SubnetGroupIdentifier?:string, VpcSecurityGroups?:array<string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{InstanceProfile?:array{InstanceProfileArn?:string, AvailabilityZone?:string, KmsKeyArn?:string, PubliclyAccessible?:bool, NetworkType?:string, InstanceProfileName?:string, Description?:string, InstanceProfileCreationTime?:int|string|\DateTimeInterface, SubnetGroupIdentifier?:string, VpcSecurityGroups?:array<string>}}>
     */
    public function createInstanceProfileAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{MigrationProjectName?:string, SourceDataProviderDescriptors:array<array{DataProviderIdentifier:string, SecretsManagerSecretId?:string, SecretsManagerAccessRoleArn?:string}>, TargetDataProviderDescriptors:array<array{DataProviderIdentifier:string, SecretsManagerSecretId?:string, SecretsManagerAccessRoleArn?:string}>, InstanceProfileIdentifier:string, TransformationRules?:string, Description?:string, Tags?:array<array{Key?:string, Value?:string, ResourceArn?:string}>, SchemaConversionApplicationAttributes?:array{S3BucketPath?:string, S3BucketRoleArn?:string}} $args
     * @return \AWS\Result<array{MigrationProject?:array{MigrationProjectName?:string, MigrationProjectArn?:string, MigrationProjectCreationTime?:int|string|\DateTimeInterface, SourceDataProviderDescriptors?:array<array{SecretsManagerSecretId?:string, SecretsManagerAccessRoleArn?:string, DataProviderName?:string, DataProviderArn?:string}>, TargetDataProviderDescriptors?:array<array{SecretsManagerSecretId?:string, SecretsManagerAccessRoleArn?:string, DataProviderName?:string, DataProviderArn?:string}>, InstanceProfileArn?:string, InstanceProfileName?:string, TransformationRules?:string, Description?:string, SchemaConversionApplicationAttributes?:array{S3BucketPath?:string, S3BucketRoleArn?:string}}}>
     */
    public function createMigrationProject(array $args): \AWS\Result { }

    /**
     * @param array{MigrationProjectName?:string, SourceDataProviderDescriptors:array<array{DataProviderIdentifier:string, SecretsManagerSecretId?:string, SecretsManagerAccessRoleArn?:string}>, TargetDataProviderDescriptors:array<array{DataProviderIdentifier:string, SecretsManagerSecretId?:string, SecretsManagerAccessRoleArn?:string}>, InstanceProfileIdentifier:string, TransformationRules?:string, Description?:string, Tags?:array<array{Key?:string, Value?:string, ResourceArn?:string}>, SchemaConversionApplicationAttributes?:array{S3BucketPath?:string, S3BucketRoleArn?:string}} $args
     * @return \GuzzleHttp\Promise\Promise<array{MigrationProject?:array{MigrationProjectName?:string, MigrationProjectArn?:string, MigrationProjectCreationTime?:int|string|\DateTimeInterface, SourceDataProviderDescriptors?:array<array{SecretsManagerSecretId?:string, SecretsManagerAccessRoleArn?:string, DataProviderName?:string, DataProviderArn?:string}>, TargetDataProviderDescriptors?:array<array{SecretsManagerSecretId?:string, SecretsManagerAccessRoleArn?:string, DataProviderName?:string, DataProviderArn?:string}>, InstanceProfileArn?:string, InstanceProfileName?:string, TransformationRules?:string, Description?:string, SchemaConversionApplicationAttributes?:array{S3BucketPath?:string, S3BucketRoleArn?:string}}}>
     */
    public function createMigrationProjectAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ReplicationConfigIdentifier:string, SourceEndpointArn:string, TargetEndpointArn:string, ComputeConfig:array{AvailabilityZone?:string, DnsNameServers?:string, KmsKeyId?:string, MaxCapacityUnits?:int, MinCapacityUnits?:int, MultiAZ?:bool, PreferredMaintenanceWindow?:string, ReplicationSubnetGroupId?:string, VpcSecurityGroupIds?:array<string>}, ReplicationType:"full-load"|"cdc"|"full-load-and-cdc", TableMappings:string, ReplicationSettings?:string, SupplementalSettings?:string, ResourceIdentifier?:string, Tags?:array<array{Key?:string, Value?:string, ResourceArn?:string}>} $args
     * @return \AWS\Result<array{ReplicationConfig?:array{ReplicationConfigIdentifier?:string, ReplicationConfigArn?:string, SourceEndpointArn?:string, TargetEndpointArn?:string, ReplicationType?:"full-load"|"cdc"|"full-load-and-cdc", ComputeConfig?:array{AvailabilityZone?:string, DnsNameServers?:string, KmsKeyId?:string, MaxCapacityUnits?:int, MinCapacityUnits?:int, MultiAZ?:bool, PreferredMaintenanceWindow?:string, ReplicationSubnetGroupId?:string, VpcSecurityGroupIds?:array<string>}, ReplicationSettings?:string, SupplementalSettings?:string, TableMappings?:string, ReplicationConfigCreateTime?:int|string|\DateTimeInterface, ReplicationConfigUpdateTime?:int|string|\DateTimeInterface}}>
     */
    public function createReplicationConfig(array $args): \AWS\Result { }

    /**
     * @param array{ReplicationConfigIdentifier:string, SourceEndpointArn:string, TargetEndpointArn:string, ComputeConfig:array{AvailabilityZone?:string, DnsNameServers?:string, KmsKeyId?:string, MaxCapacityUnits?:int, MinCapacityUnits?:int, MultiAZ?:bool, PreferredMaintenanceWindow?:string, ReplicationSubnetGroupId?:string, VpcSecurityGroupIds?:array<string>}, ReplicationType:"full-load"|"cdc"|"full-load-and-cdc", TableMappings:string, ReplicationSettings?:string, SupplementalSettings?:string, ResourceIdentifier?:string, Tags?:array<array{Key?:string, Value?:string, ResourceArn?:string}>} $args
     * @return \GuzzleHttp\Promise\Promise<array{ReplicationConfig?:array{ReplicationConfigIdentifier?:string, ReplicationConfigArn?:string, SourceEndpointArn?:string, TargetEndpointArn?:string, ReplicationType?:"full-load"|"cdc"|"full-load-and-cdc", ComputeConfig?:array{AvailabilityZone?:string, DnsNameServers?:string, KmsKeyId?:string, MaxCapacityUnits?:int, MinCapacityUnits?:int, MultiAZ?:bool, PreferredMaintenanceWindow?:string, ReplicationSubnetGroupId?:string, VpcSecurityGroupIds?:array<string>}, ReplicationSettings?:string, SupplementalSettings?:string, TableMappings?:string, ReplicationConfigCreateTime?:int|string|\DateTimeInterface, ReplicationConfigUpdateTime?:int|string|\DateTimeInterface}}>
     */
    public function createReplicationConfigAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ReplicationInstanceIdentifier:string, AllocatedStorage?:int, ReplicationInstanceClass:string, VpcSecurityGroupIds?:array<string>, AvailabilityZone?:string, ReplicationSubnetGroupIdentifier?:string, PreferredMaintenanceWindow?:string, MultiAZ?:bool, EngineVersion?:string, AutoMinorVersionUpgrade?:bool, Tags?:array<array{Key?:string, Value?:string, ResourceArn?:string}>, KmsKeyId?:string, PubliclyAccessible?:bool, DnsNameServers?:string, ResourceIdentifier?:string, NetworkType?:string, KerberosAuthenticationSettings?:array{KeyCacheSecretId?:string, KeyCacheSecretIamArn?:string, Krb5FileContents?:string}} $args
     * @return \AWS\Result<array{ReplicationInstance?:array{ReplicationInstanceIdentifier?:string, ReplicationInstanceClass?:string, ReplicationInstanceStatus?:string, AllocatedStorage?:int, InstanceCreateTime?:int|string|\DateTimeInterface, VpcSecurityGroups?:array<array{VpcSecurityGroupId?:string, Status?:string}>, AvailabilityZone?:string, ReplicationSubnetGroup?:array{ReplicationSubnetGroupIdentifier?:string, ReplicationSubnetGroupDescription?:string, VpcId?:string, SubnetGroupStatus?:string, Subnets?:array<array{SubnetIdentifier?:string, SubnetAvailabilityZone?:array{Name?:string}, SubnetStatus?:string}>, SupportedNetworkTypes?:array<string>}, PreferredMaintenanceWindow?:string, PendingModifiedValues?:array{ReplicationInstanceClass?:string, AllocatedStorage?:int, MultiAZ?:bool, EngineVersion?:string, NetworkType?:string}, MultiAZ?:bool, EngineVersion?:string, AutoMinorVersionUpgrade?:bool, KmsKeyId?:string, ReplicationInstanceArn?:string, ReplicationInstancePublicIpAddress?:string, ReplicationInstancePrivateIpAddress?:string, ReplicationInstancePublicIpAddresses?:array<string>, ReplicationInstancePrivateIpAddresses?:array<string>, ReplicationInstanceIpv6Addresses?:array<string>, PubliclyAccessible?:bool, SecondaryAvailabilityZone?:string, FreeUntil?:int|string|\DateTimeInterface, DnsNameServers?:string, NetworkType?:string, KerberosAuthenticationSettings?:array{KeyCacheSecretId?:string, KeyCacheSecretIamArn?:string, Krb5FileContents?:string}}}>
     */
    public function createReplicationInstance(array $args): \AWS\Result { }

    /**
     * @param array{ReplicationInstanceIdentifier:string, AllocatedStorage?:int, ReplicationInstanceClass:string, VpcSecurityGroupIds?:array<string>, AvailabilityZone?:string, ReplicationSubnetGroupIdentifier?:string, PreferredMaintenanceWindow?:string, MultiAZ?:bool, EngineVersion?:string, AutoMinorVersionUpgrade?:bool, Tags?:array<array{Key?:string, Value?:string, ResourceArn?:string}>, KmsKeyId?:string, PubliclyAccessible?:bool, DnsNameServers?:string, ResourceIdentifier?:string, NetworkType?:string, KerberosAuthenticationSettings?:array{KeyCacheSecretId?:string, KeyCacheSecretIamArn?:string, Krb5FileContents?:string}} $args
     * @return \GuzzleHttp\Promise\Promise<array{ReplicationInstance?:array{ReplicationInstanceIdentifier?:string, ReplicationInstanceClass?:string, ReplicationInstanceStatus?:string, AllocatedStorage?:int, InstanceCreateTime?:int|string|\DateTimeInterface, VpcSecurityGroups?:array<array{VpcSecurityGroupId?:string, Status?:string}>, AvailabilityZone?:string, ReplicationSubnetGroup?:array{ReplicationSubnetGroupIdentifier?:string, ReplicationSubnetGroupDescription?:string, VpcId?:string, SubnetGroupStatus?:string, Subnets?:array<array{SubnetIdentifier?:string, SubnetAvailabilityZone?:array{Name?:string}, SubnetStatus?:string}>, SupportedNetworkTypes?:array<string>}, PreferredMaintenanceWindow?:string, PendingModifiedValues?:array{ReplicationInstanceClass?:string, AllocatedStorage?:int, MultiAZ?:bool, EngineVersion?:string, NetworkType?:string}, MultiAZ?:bool, EngineVersion?:string, AutoMinorVersionUpgrade?:bool, KmsKeyId?:string, ReplicationInstanceArn?:string, ReplicationInstancePublicIpAddress?:string, ReplicationInstancePrivateIpAddress?:string, ReplicationInstancePublicIpAddresses?:array<string>, ReplicationInstancePrivateIpAddresses?:array<string>, ReplicationInstanceIpv6Addresses?:array<string>, PubliclyAccessible?:bool, SecondaryAvailabilityZone?:string, FreeUntil?:int|string|\DateTimeInterface, DnsNameServers?:string, NetworkType?:string, KerberosAuthenticationSettings?:array{KeyCacheSecretId?:string, KeyCacheSecretIamArn?:string, Krb5FileContents?:string}}}>
     */
    public function createReplicationInstanceAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ReplicationSubnetGroupIdentifier:string, ReplicationSubnetGroupDescription:string, SubnetIds:array<string>, Tags?:array<array{Key?:string, Value?:string, ResourceArn?:string}>} $args
     * @return \AWS\Result<array{ReplicationSubnetGroup?:array{ReplicationSubnetGroupIdentifier?:string, ReplicationSubnetGroupDescription?:string, VpcId?:string, SubnetGroupStatus?:string, Subnets?:array<array{SubnetIdentifier?:string, SubnetAvailabilityZone?:array{Name?:string}, SubnetStatus?:string}>, SupportedNetworkTypes?:array<string>}}>
     */
    public function createReplicationSubnetGroup(array $args): \AWS\Result { }

    /**
     * @param array{ReplicationSubnetGroupIdentifier:string, ReplicationSubnetGroupDescription:string, SubnetIds:array<string>, Tags?:array<array{Key?:string, Value?:string, ResourceArn?:string}>} $args
     * @return \GuzzleHttp\Promise\Promise<array{ReplicationSubnetGroup?:array{ReplicationSubnetGroupIdentifier?:string, ReplicationSubnetGroupDescription?:string, VpcId?:string, SubnetGroupStatus?:string, Subnets?:array<array{SubnetIdentifier?:string, SubnetAvailabilityZone?:array{Name?:string}, SubnetStatus?:string}>, SupportedNetworkTypes?:array<string>}}>
     */
    public function createReplicationSubnetGroupAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ReplicationTaskIdentifier:string, SourceEndpointArn:string, TargetEndpointArn:string, ReplicationInstanceArn:string, MigrationType:"full-load"|"cdc"|"full-load-and-cdc", TableMappings:string, ReplicationTaskSettings?:string, CdcStartTime?:int|string|\DateTimeInterface, CdcStartPosition?:string, CdcStopPosition?:string, Tags?:array<array{Key?:string, Value?:string, ResourceArn?:string}>, TaskData?:string, ResourceIdentifier?:string} $args
     * @return \AWS\Result<array{ReplicationTask?:array{ReplicationTaskIdentifier?:string, SourceEndpointArn?:string, TargetEndpointArn?:string, ReplicationInstanceArn?:string, MigrationType?:"full-load"|"cdc"|"full-load-and-cdc", TableMappings?:string, ReplicationTaskSettings?:string, Status?:string, LastFailureMessage?:string, StopReason?:string, ReplicationTaskCreationDate?:int|string|\DateTimeInterface, ReplicationTaskStartDate?:int|string|\DateTimeInterface, CdcStartPosition?:string, CdcStopPosition?:string, RecoveryCheckpoint?:string, ReplicationTaskArn?:string, ReplicationTaskStats?:array{FullLoadProgressPercent?:int, ElapsedTimeMillis?:int, TablesLoaded?:int, TablesLoading?:int, TablesQueued?:int, TablesErrored?:int, FreshStartDate?:int|string|\DateTimeInterface, StartDate?:int|string|\DateTimeInterface, StopDate?:int|string|\DateTimeInterface, FullLoadStartDate?:int|string|\DateTimeInterface, FullLoadFinishDate?:int|string|\DateTimeInterface}, TaskData?:string, TargetReplicationInstanceArn?:string}}>
     */
    public function createReplicationTask(array $args): \AWS\Result { }

    /**
     * @param array{ReplicationTaskIdentifier:string, SourceEndpointArn:string, TargetEndpointArn:string, ReplicationInstanceArn:string, MigrationType:"full-load"|"cdc"|"full-load-and-cdc", TableMappings:string, ReplicationTaskSettings?:string, CdcStartTime?:int|string|\DateTimeInterface, CdcStartPosition?:string, CdcStopPosition?:string, Tags?:array<array{Key?:string, Value?:string, ResourceArn?:string}>, TaskData?:string, ResourceIdentifier?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{ReplicationTask?:array{ReplicationTaskIdentifier?:string, SourceEndpointArn?:string, TargetEndpointArn?:string, ReplicationInstanceArn?:string, MigrationType?:"full-load"|"cdc"|"full-load-and-cdc", TableMappings?:string, ReplicationTaskSettings?:string, Status?:string, LastFailureMessage?:string, StopReason?:string, ReplicationTaskCreationDate?:int|string|\DateTimeInterface, ReplicationTaskStartDate?:int|string|\DateTimeInterface, CdcStartPosition?:string, CdcStopPosition?:string, RecoveryCheckpoint?:string, ReplicationTaskArn?:string, ReplicationTaskStats?:array{FullLoadProgressPercent?:int, ElapsedTimeMillis?:int, TablesLoaded?:int, TablesLoading?:int, TablesQueued?:int, TablesErrored?:int, FreshStartDate?:int|string|\DateTimeInterface, StartDate?:int|string|\DateTimeInterface, StopDate?:int|string|\DateTimeInterface, FullLoadStartDate?:int|string|\DateTimeInterface, FullLoadFinishDate?:int|string|\DateTimeInterface}, TaskData?:string, TargetReplicationInstanceArn?:string}}>
     */
    public function createReplicationTaskAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CertificateArn:string} $args
     * @return \AWS\Result<array{Certificate?:array{CertificateIdentifier?:string, CertificateCreationDate?:int|string|\DateTimeInterface, CertificatePem?:string, CertificateWallet?:string|resource|\Psr\Http\Message\StreamInterface, CertificateArn?:string, CertificateOwner?:string, ValidFromDate?:int|string|\DateTimeInterface, ValidToDate?:int|string|\DateTimeInterface, SigningAlgorithm?:string, KeyLength?:int}}>
     */
    public function deleteCertificate(array $args): \AWS\Result { }

    /**
     * @param array{CertificateArn:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Certificate?:array{CertificateIdentifier?:string, CertificateCreationDate?:int|string|\DateTimeInterface, CertificatePem?:string, CertificateWallet?:string|resource|\Psr\Http\Message\StreamInterface, CertificateArn?:string, CertificateOwner?:string, ValidFromDate?:int|string|\DateTimeInterface, ValidToDate?:int|string|\DateTimeInterface, SigningAlgorithm?:string, KeyLength?:int}}>
     */
    public function deleteCertificateAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{EndpointArn:string, ReplicationInstanceArn:string} $args
     * @return \AWS\Result<array{Connection?:array{ReplicationInstanceArn?:string, EndpointArn?:string, Status?:string, LastFailureMessage?:string, EndpointIdentifier?:string, ReplicationInstanceIdentifier?:string}}>
     */
    public function deleteConnection(array $args): \AWS\Result { }

    /**
     * @param array{EndpointArn:string, ReplicationInstanceArn:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Connection?:array{ReplicationInstanceArn?:string, EndpointArn?:string, Status?:string, LastFailureMessage?:string, EndpointIdentifier?:string, ReplicationInstanceIdentifier?:string}}>
     */
    public function deleteConnectionAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{DataMigrationIdentifier:string} $args
     * @return \AWS\Result<array{DataMigration?:array{DataMigrationName?:string, DataMigrationArn?:string, DataMigrationCreateTime?:int|string|\DateTimeInterface, DataMigrationStartTime?:int|string|\DateTimeInterface, DataMigrationEndTime?:int|string|\DateTimeInterface, ServiceAccessRoleArn?:string, MigrationProjectArn?:string, DataMigrationType?:"full-load"|"cdc"|"full-load-and-cdc", DataMigrationSettings?:array{NumberOfJobs?:int, CloudwatchLogsEnabled?:bool, SelectionRules?:string}, SourceDataSettings?:array<array{CDCStartPosition?:string, CDCStartTime?:int|string|\DateTimeInterface, CDCStopTime?:int|string|\DateTimeInterface, SlotName?:string}>, DataMigrationStatistics?:array{TablesLoaded?:int, ElapsedTimeMillis?:int, TablesLoading?:int, FullLoadPercentage?:int, CDCLatency?:int, TablesQueued?:int, TablesErrored?:int, StartTime?:int|string|\DateTimeInterface, StopTime?:int|string|\DateTimeInterface}, DataMigrationStatus?:string, PublicIpAddresses?:array<string>, DataMigrationCidrBlocks?:array<string>, LastFailureMessage?:string, StopReason?:string}}>
     */
    public function deleteDataMigration(array $args): \AWS\Result { }

    /**
     * @param array{DataMigrationIdentifier:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{DataMigration?:array{DataMigrationName?:string, DataMigrationArn?:string, DataMigrationCreateTime?:int|string|\DateTimeInterface, DataMigrationStartTime?:int|string|\DateTimeInterface, DataMigrationEndTime?:int|string|\DateTimeInterface, ServiceAccessRoleArn?:string, MigrationProjectArn?:string, DataMigrationType?:"full-load"|"cdc"|"full-load-and-cdc", DataMigrationSettings?:array{NumberOfJobs?:int, CloudwatchLogsEnabled?:bool, SelectionRules?:string}, SourceDataSettings?:array<array{CDCStartPosition?:string, CDCStartTime?:int|string|\DateTimeInterface, CDCStopTime?:int|string|\DateTimeInterface, SlotName?:string}>, DataMigrationStatistics?:array{TablesLoaded?:int, ElapsedTimeMillis?:int, TablesLoading?:int, FullLoadPercentage?:int, CDCLatency?:int, TablesQueued?:int, TablesErrored?:int, StartTime?:int|string|\DateTimeInterface, StopTime?:int|string|\DateTimeInterface}, DataMigrationStatus?:string, PublicIpAddresses?:array<string>, DataMigrationCidrBlocks?:array<string>, LastFailureMessage?:string, StopReason?:string}}>
     */
    public function deleteDataMigrationAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{DataProviderIdentifier:string} $args
     * @return \AWS\Result<array{DataProvider?:array{DataProviderName?:string, DataProviderArn?:string, DataProviderCreationTime?:int|string|\DateTimeInterface, Description?:string, Engine?:string, Settings?:array{RedshiftSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string}, PostgreSqlSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, MySqlSettings?:array{ServerName?:string, Port?:int, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, OracleSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string, AsmServer?:string, SecretsManagerOracleAsmSecretId?:string, SecretsManagerOracleAsmAccessRoleArn?:string, SecretsManagerSecurityDbEncryptionSecretId?:string, SecretsManagerSecurityDbEncryptionAccessRoleArn?:string}, MicrosoftSqlServerSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, DocDbSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, MariaDbSettings?:array{ServerName?:string, Port?:int, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, MongoDbSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string, AuthType?:"no"|"password", AuthSource?:string, AuthMechanism?:"default"|"mongodb_cr"|"scram_sha_1"}}}}>
     */
    public function deleteDataProvider(array $args): \AWS\Result { }

    /**
     * @param array{DataProviderIdentifier:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{DataProvider?:array{DataProviderName?:string, DataProviderArn?:string, DataProviderCreationTime?:int|string|\DateTimeInterface, Description?:string, Engine?:string, Settings?:array{RedshiftSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string}, PostgreSqlSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, MySqlSettings?:array{ServerName?:string, Port?:int, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, OracleSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string, AsmServer?:string, SecretsManagerOracleAsmSecretId?:string, SecretsManagerOracleAsmAccessRoleArn?:string, SecretsManagerSecurityDbEncryptionSecretId?:string, SecretsManagerSecurityDbEncryptionAccessRoleArn?:string}, MicrosoftSqlServerSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, DocDbSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, MariaDbSettings?:array{ServerName?:string, Port?:int, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, MongoDbSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string, AuthType?:"no"|"password", AuthSource?:string, AuthMechanism?:"default"|"mongodb_cr"|"scram_sha_1"}}}}>
     */
    public function deleteDataProviderAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{EndpointArn:string} $args
     * @return \AWS\Result<array{Endpoint?:array{EndpointIdentifier?:string, EndpointType?:"source"|"target", EngineName?:string, EngineDisplayName?:string, Username?:string, ServerName?:string, Port?:int, DatabaseName?:string, ExtraConnectionAttributes?:string, Status?:string, KmsKeyId?:string, EndpointArn?:string, CertificateArn?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", ServiceAccessRoleArn?:string, ExternalTableDefinition?:string, ExternalId?:string, DynamoDbSettings?:array{ServiceAccessRoleArn:string}, S3Settings?:array{ServiceAccessRoleArn?:string, ExternalTableDefinition?:string, CsvRowDelimiter?:string, CsvDelimiter?:string, BucketFolder?:string, BucketName?:string, CompressionType?:"none"|"gzip", EncryptionMode?:"sse-s3"|"sse-kms", ServerSideEncryptionKmsKeyId?:string, DataFormat?:"csv"|"parquet", EncodingType?:"plain"|"plain-dictionary"|"rle-dictionary", DictPageSizeLimit?:int, RowGroupLength?:int, DataPageSize?:int, ParquetVersion?:"parquet-1-0"|"parquet-2-0", EnableStatistics?:bool, IncludeOpForFullLoad?:bool, CdcInsertsOnly?:bool, TimestampColumnName?:string, ParquetTimestampInMillisecond?:bool, CdcInsertsAndUpdates?:bool, DatePartitionEnabled?:bool, DatePartitionSequence?:"YYYYMMDD"|"YYYYMMDDHH"|"YYYYMM"|"MMYYYYDD"|"DDMMYYYY", DatePartitionDelimiter?:"SLASH"|"UNDERSCORE"|"DASH"|"NONE", UseCsvNoSupValue?:bool, CsvNoSupValue?:string, PreserveTransactions?:bool, CdcPath?:string, UseTaskStartTimeForFullLoadTimestamp?:bool, CannedAclForObjects?:"none"|"private"|"public-read"|"public-read-write"|"authenticated-read"|"aws-exec-read"|"bucket-owner-read"|"bucket-owner-full-control", AddColumnName?:bool, CdcMaxBatchInterval?:int, CdcMinFileSize?:int, CsvNullValue?:string, IgnoreHeaderRows?:int, MaxFileSize?:int, Rfc4180?:bool, DatePartitionTimezone?:string, AddTrailingPaddingCharacter?:bool, ExpectedBucketOwner?:string, GlueCatalogGeneration?:bool}, DmsTransferSettings?:array{ServiceAccessRoleArn?:string, BucketName?:string}, MongoDbSettings?:array{Username?:string, Password?:string, ServerName?:string, Port?:int, DatabaseName?:string, AuthType?:"no"|"password", AuthMechanism?:"default"|"mongodb_cr"|"scram_sha_1", NestingLevel?:"none"|"one", ExtractDocId?:string, DocsToInvestigate?:string, AuthSource?:string, KmsKeyId?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, UseUpdateLookUp?:bool, ReplicateShardCollections?:bool}, KinesisSettings?:array{StreamArn?:string, MessageFormat?:"json"|"json-unformatted", ServiceAccessRoleArn?:string, IncludeTransactionDetails?:bool, IncludePartitionValue?:bool, PartitionIncludeSchemaTable?:bool, IncludeTableAlterOperations?:bool, IncludeControlDetails?:bool, IncludeNullAndEmpty?:bool, NoHexPrefix?:bool, UseLargeIntegerValue?:bool}, KafkaSettings?:array{Broker?:string, Topic?:string, MessageFormat?:"json"|"json-unformatted", IncludeTransactionDetails?:bool, IncludePartitionValue?:bool, PartitionIncludeSchemaTable?:bool, IncludeTableAlterOperations?:bool, IncludeControlDetails?:bool, MessageMaxBytes?:int, IncludeNullAndEmpty?:bool, SecurityProtocol?:"plaintext"|"ssl-authentication"|"ssl-encryption"|"sasl-ssl", SslClientCertificateArn?:string, SslClientKeyArn?:string, SslClientKeyPassword?:string, SslCaCertificateArn?:string, SaslUsername?:string, SaslPassword?:string, NoHexPrefix?:bool, SaslMechanism?:"scram-sha-512"|"plain", SslEndpointIdentificationAlgorithm?:"none"|"https", UseLargeIntegerValue?:bool}, ElasticsearchSettings?:array{ServiceAccessRoleArn:string, EndpointUri:string, FullLoadErrorPercentage?:int, ErrorRetryDuration?:int, UseNewMappingType?:bool}, NeptuneSettings?:array{ServiceAccessRoleArn?:string, S3BucketName:string, S3BucketFolder:string, ErrorRetryDuration?:int, MaxFileSize?:int, MaxRetryCount?:int, IamAuthEnabled?:bool}, RedshiftSettings?:array{AcceptAnyDate?:bool, AfterConnectScript?:string, BucketFolder?:string, BucketName?:string, CaseSensitiveNames?:bool, CompUpdate?:bool, ConnectionTimeout?:int, DatabaseName?:string, DateFormat?:string, EmptyAsNull?:bool, EncryptionMode?:"sse-s3"|"sse-kms", ExplicitIds?:bool, FileTransferUploadStreams?:int, LoadTimeout?:int, MaxFileSize?:int, Password?:string, Port?:int, RemoveQuotes?:bool, ReplaceInvalidChars?:string, ReplaceChars?:string, ServerName?:string, ServiceAccessRoleArn?:string, ServerSideEncryptionKmsKeyId?:string, TimeFormat?:string, TrimBlanks?:bool, TruncateColumns?:bool, Username?:string, WriteBufferSize?:int, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, MapBooleanAsBoolean?:bool}, PostgreSQLSettings?:array{AfterConnectScript?:string, CaptureDdls?:bool, MaxFileSize?:int, DatabaseName?:string, DdlArtifactsSchema?:string, ExecuteTimeout?:int, FailTasksOnLobTruncation?:bool, HeartbeatEnable?:bool, HeartbeatSchema?:string, HeartbeatFrequency?:int, Password?:string, Port?:int, ServerName?:string, Username?:string, SlotName?:string, PluginName?:"no-preference"|"test-decoding"|"pglogical", SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, TrimSpaceInChar?:bool, MapBooleanAsBoolean?:bool, MapJsonbAsClob?:bool, MapLongVarcharAs?:"wstring"|"clob"|"nclob", DatabaseMode?:"default"|"babelfish", BabelfishDatabaseName?:string, DisableUnicodeSourceFilter?:bool}, MySQLSettings?:array{AfterConnectScript?:string, CleanSourceMetadataOnMismatch?:bool, DatabaseName?:string, EventsPollInterval?:int, TargetDbType?:"specific-database"|"multiple-databases", MaxFileSize?:int, ParallelLoadThreads?:int, Password?:string, Port?:int, ServerName?:string, ServerTimezone?:string, Username?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, ExecuteTimeout?:int}, OracleSettings?:array{AddSupplementalLogging?:bool, ArchivedLogDestId?:int, AdditionalArchivedLogDestId?:int, ExtraArchivedLogDestIds?:array<int>, AllowSelectNestedTables?:bool, ParallelAsmReadThreads?:int, ReadAheadBlocks?:int, AccessAlternateDirectly?:bool, UseAlternateFolderForOnline?:bool, OraclePathPrefix?:string, UsePathPrefix?:string, ReplacePathPrefix?:bool, EnableHomogenousTablespace?:bool, DirectPathNoLog?:bool, ArchivedLogsOnly?:bool, AsmPassword?:string, AsmServer?:string, AsmUser?:string, CharLengthSemantics?:"default"|"char"|"byte", DatabaseName?:string, DirectPathParallelLoad?:bool, FailTasksOnLobTruncation?:bool, NumberDatatypeScale?:int, Password?:string, Port?:int, ReadTableSpaceName?:bool, RetryInterval?:int, SecurityDbEncryption?:string, SecurityDbEncryptionName?:string, ServerName?:string, SpatialDataOptionToGeoJsonFunctionName?:string, StandbyDelayTime?:int, Username?:string, UseBFile?:bool, UseDirectPathFullLoad?:bool, UseLogminerReader?:bool, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, SecretsManagerOracleAsmAccessRoleArn?:string, SecretsManagerOracleAsmSecretId?:string, TrimSpaceInChar?:bool, ConvertTimestampWithZoneToUTC?:bool, OpenTransactionWindow?:int, AuthenticationMethod?:"password"|"kerberos"}, SybaseSettings?:array{DatabaseName?:string, Password?:string, Port?:int, ServerName?:string, Username?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string}, MicrosoftSQLServerSettings?:array{Port?:int, BcpPacketSize?:int, DatabaseName?:string, ControlTablesFileGroup?:string, Password?:string, QuerySingleAlwaysOnNode?:bool, ReadBackupOnly?:bool, SafeguardPolicy?:"rely-on-sql-server-replication-agent"|"exclusive-automatic-truncation"|"shared-automatic-truncation", ServerName?:string, Username?:string, UseBcpFullLoad?:bool, UseThirdPartyBackupDevice?:bool, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, TrimSpaceInChar?:bool, TlogAccessMode?:"BackupOnly"|"PreferBackup"|"PreferTlog"|"TlogOnly", ForceLobLookup?:bool, AuthenticationMethod?:"password"|"kerberos"}, IBMDb2Settings?:array{DatabaseName?:string, Password?:string, Port?:int, ServerName?:string, SetDataCaptureChanges?:bool, CurrentLsn?:string, MaxKBytesPerRead?:int, Username?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, LoadTimeout?:int, WriteBufferSize?:int, MaxFileSize?:int, KeepCsvFiles?:bool}, DocDbSettings?:array{Username?:string, Password?:string, ServerName?:string, Port?:int, DatabaseName?:string, NestingLevel?:"none"|"one", ExtractDocId?:bool, DocsToInvestigate?:int, KmsKeyId?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, UseUpdateLookUp?:bool, ReplicateShardCollections?:bool}, RedisSettings?:array{ServerName:string, Port:int, SslSecurityProtocol?:"plaintext"|"ssl-encryption", AuthType?:"none"|"auth-role"|"auth-token", AuthUserName?:string, AuthPassword?:string, SslCaCertificateArn?:string}, GcpMySQLSettings?:array{AfterConnectScript?:string, CleanSourceMetadataOnMismatch?:bool, DatabaseName?:string, EventsPollInterval?:int, TargetDbType?:"specific-database"|"multiple-databases", MaxFileSize?:int, ParallelLoadThreads?:int, Password?:string, Port?:int, ServerName?:string, ServerTimezone?:string, Username?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string}, TimestreamSettings?:array{DatabaseName:string, MemoryDuration:int, MagneticDuration:int, CdcInsertsAndUpdates?:bool, EnableMagneticStoreWrites?:bool}}}>
     */
    public function deleteEndpoint(array $args): \AWS\Result { }

    /**
     * @param array{EndpointArn:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Endpoint?:array{EndpointIdentifier?:string, EndpointType?:"source"|"target", EngineName?:string, EngineDisplayName?:string, Username?:string, ServerName?:string, Port?:int, DatabaseName?:string, ExtraConnectionAttributes?:string, Status?:string, KmsKeyId?:string, EndpointArn?:string, CertificateArn?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", ServiceAccessRoleArn?:string, ExternalTableDefinition?:string, ExternalId?:string, DynamoDbSettings?:array{ServiceAccessRoleArn:string}, S3Settings?:array{ServiceAccessRoleArn?:string, ExternalTableDefinition?:string, CsvRowDelimiter?:string, CsvDelimiter?:string, BucketFolder?:string, BucketName?:string, CompressionType?:"none"|"gzip", EncryptionMode?:"sse-s3"|"sse-kms", ServerSideEncryptionKmsKeyId?:string, DataFormat?:"csv"|"parquet", EncodingType?:"plain"|"plain-dictionary"|"rle-dictionary", DictPageSizeLimit?:int, RowGroupLength?:int, DataPageSize?:int, ParquetVersion?:"parquet-1-0"|"parquet-2-0", EnableStatistics?:bool, IncludeOpForFullLoad?:bool, CdcInsertsOnly?:bool, TimestampColumnName?:string, ParquetTimestampInMillisecond?:bool, CdcInsertsAndUpdates?:bool, DatePartitionEnabled?:bool, DatePartitionSequence?:"YYYYMMDD"|"YYYYMMDDHH"|"YYYYMM"|"MMYYYYDD"|"DDMMYYYY", DatePartitionDelimiter?:"SLASH"|"UNDERSCORE"|"DASH"|"NONE", UseCsvNoSupValue?:bool, CsvNoSupValue?:string, PreserveTransactions?:bool, CdcPath?:string, UseTaskStartTimeForFullLoadTimestamp?:bool, CannedAclForObjects?:"none"|"private"|"public-read"|"public-read-write"|"authenticated-read"|"aws-exec-read"|"bucket-owner-read"|"bucket-owner-full-control", AddColumnName?:bool, CdcMaxBatchInterval?:int, CdcMinFileSize?:int, CsvNullValue?:string, IgnoreHeaderRows?:int, MaxFileSize?:int, Rfc4180?:bool, DatePartitionTimezone?:string, AddTrailingPaddingCharacter?:bool, ExpectedBucketOwner?:string, GlueCatalogGeneration?:bool}, DmsTransferSettings?:array{ServiceAccessRoleArn?:string, BucketName?:string}, MongoDbSettings?:array{Username?:string, Password?:string, ServerName?:string, Port?:int, DatabaseName?:string, AuthType?:"no"|"password", AuthMechanism?:"default"|"mongodb_cr"|"scram_sha_1", NestingLevel?:"none"|"one", ExtractDocId?:string, DocsToInvestigate?:string, AuthSource?:string, KmsKeyId?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, UseUpdateLookUp?:bool, ReplicateShardCollections?:bool}, KinesisSettings?:array{StreamArn?:string, MessageFormat?:"json"|"json-unformatted", ServiceAccessRoleArn?:string, IncludeTransactionDetails?:bool, IncludePartitionValue?:bool, PartitionIncludeSchemaTable?:bool, IncludeTableAlterOperations?:bool, IncludeControlDetails?:bool, IncludeNullAndEmpty?:bool, NoHexPrefix?:bool, UseLargeIntegerValue?:bool}, KafkaSettings?:array{Broker?:string, Topic?:string, MessageFormat?:"json"|"json-unformatted", IncludeTransactionDetails?:bool, IncludePartitionValue?:bool, PartitionIncludeSchemaTable?:bool, IncludeTableAlterOperations?:bool, IncludeControlDetails?:bool, MessageMaxBytes?:int, IncludeNullAndEmpty?:bool, SecurityProtocol?:"plaintext"|"ssl-authentication"|"ssl-encryption"|"sasl-ssl", SslClientCertificateArn?:string, SslClientKeyArn?:string, SslClientKeyPassword?:string, SslCaCertificateArn?:string, SaslUsername?:string, SaslPassword?:string, NoHexPrefix?:bool, SaslMechanism?:"scram-sha-512"|"plain", SslEndpointIdentificationAlgorithm?:"none"|"https", UseLargeIntegerValue?:bool}, ElasticsearchSettings?:array{ServiceAccessRoleArn:string, EndpointUri:string, FullLoadErrorPercentage?:int, ErrorRetryDuration?:int, UseNewMappingType?:bool}, NeptuneSettings?:array{ServiceAccessRoleArn?:string, S3BucketName:string, S3BucketFolder:string, ErrorRetryDuration?:int, MaxFileSize?:int, MaxRetryCount?:int, IamAuthEnabled?:bool}, RedshiftSettings?:array{AcceptAnyDate?:bool, AfterConnectScript?:string, BucketFolder?:string, BucketName?:string, CaseSensitiveNames?:bool, CompUpdate?:bool, ConnectionTimeout?:int, DatabaseName?:string, DateFormat?:string, EmptyAsNull?:bool, EncryptionMode?:"sse-s3"|"sse-kms", ExplicitIds?:bool, FileTransferUploadStreams?:int, LoadTimeout?:int, MaxFileSize?:int, Password?:string, Port?:int, RemoveQuotes?:bool, ReplaceInvalidChars?:string, ReplaceChars?:string, ServerName?:string, ServiceAccessRoleArn?:string, ServerSideEncryptionKmsKeyId?:string, TimeFormat?:string, TrimBlanks?:bool, TruncateColumns?:bool, Username?:string, WriteBufferSize?:int, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, MapBooleanAsBoolean?:bool}, PostgreSQLSettings?:array{AfterConnectScript?:string, CaptureDdls?:bool, MaxFileSize?:int, DatabaseName?:string, DdlArtifactsSchema?:string, ExecuteTimeout?:int, FailTasksOnLobTruncation?:bool, HeartbeatEnable?:bool, HeartbeatSchema?:string, HeartbeatFrequency?:int, Password?:string, Port?:int, ServerName?:string, Username?:string, SlotName?:string, PluginName?:"no-preference"|"test-decoding"|"pglogical", SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, TrimSpaceInChar?:bool, MapBooleanAsBoolean?:bool, MapJsonbAsClob?:bool, MapLongVarcharAs?:"wstring"|"clob"|"nclob", DatabaseMode?:"default"|"babelfish", BabelfishDatabaseName?:string, DisableUnicodeSourceFilter?:bool}, MySQLSettings?:array{AfterConnectScript?:string, CleanSourceMetadataOnMismatch?:bool, DatabaseName?:string, EventsPollInterval?:int, TargetDbType?:"specific-database"|"multiple-databases", MaxFileSize?:int, ParallelLoadThreads?:int, Password?:string, Port?:int, ServerName?:string, ServerTimezone?:string, Username?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, ExecuteTimeout?:int}, OracleSettings?:array{AddSupplementalLogging?:bool, ArchivedLogDestId?:int, AdditionalArchivedLogDestId?:int, ExtraArchivedLogDestIds?:array<int>, AllowSelectNestedTables?:bool, ParallelAsmReadThreads?:int, ReadAheadBlocks?:int, AccessAlternateDirectly?:bool, UseAlternateFolderForOnline?:bool, OraclePathPrefix?:string, UsePathPrefix?:string, ReplacePathPrefix?:bool, EnableHomogenousTablespace?:bool, DirectPathNoLog?:bool, ArchivedLogsOnly?:bool, AsmPassword?:string, AsmServer?:string, AsmUser?:string, CharLengthSemantics?:"default"|"char"|"byte", DatabaseName?:string, DirectPathParallelLoad?:bool, FailTasksOnLobTruncation?:bool, NumberDatatypeScale?:int, Password?:string, Port?:int, ReadTableSpaceName?:bool, RetryInterval?:int, SecurityDbEncryption?:string, SecurityDbEncryptionName?:string, ServerName?:string, SpatialDataOptionToGeoJsonFunctionName?:string, StandbyDelayTime?:int, Username?:string, UseBFile?:bool, UseDirectPathFullLoad?:bool, UseLogminerReader?:bool, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, SecretsManagerOracleAsmAccessRoleArn?:string, SecretsManagerOracleAsmSecretId?:string, TrimSpaceInChar?:bool, ConvertTimestampWithZoneToUTC?:bool, OpenTransactionWindow?:int, AuthenticationMethod?:"password"|"kerberos"}, SybaseSettings?:array{DatabaseName?:string, Password?:string, Port?:int, ServerName?:string, Username?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string}, MicrosoftSQLServerSettings?:array{Port?:int, BcpPacketSize?:int, DatabaseName?:string, ControlTablesFileGroup?:string, Password?:string, QuerySingleAlwaysOnNode?:bool, ReadBackupOnly?:bool, SafeguardPolicy?:"rely-on-sql-server-replication-agent"|"exclusive-automatic-truncation"|"shared-automatic-truncation", ServerName?:string, Username?:string, UseBcpFullLoad?:bool, UseThirdPartyBackupDevice?:bool, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, TrimSpaceInChar?:bool, TlogAccessMode?:"BackupOnly"|"PreferBackup"|"PreferTlog"|"TlogOnly", ForceLobLookup?:bool, AuthenticationMethod?:"password"|"kerberos"}, IBMDb2Settings?:array{DatabaseName?:string, Password?:string, Port?:int, ServerName?:string, SetDataCaptureChanges?:bool, CurrentLsn?:string, MaxKBytesPerRead?:int, Username?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, LoadTimeout?:int, WriteBufferSize?:int, MaxFileSize?:int, KeepCsvFiles?:bool}, DocDbSettings?:array{Username?:string, Password?:string, ServerName?:string, Port?:int, DatabaseName?:string, NestingLevel?:"none"|"one", ExtractDocId?:bool, DocsToInvestigate?:int, KmsKeyId?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, UseUpdateLookUp?:bool, ReplicateShardCollections?:bool}, RedisSettings?:array{ServerName:string, Port:int, SslSecurityProtocol?:"plaintext"|"ssl-encryption", AuthType?:"none"|"auth-role"|"auth-token", AuthUserName?:string, AuthPassword?:string, SslCaCertificateArn?:string}, GcpMySQLSettings?:array{AfterConnectScript?:string, CleanSourceMetadataOnMismatch?:bool, DatabaseName?:string, EventsPollInterval?:int, TargetDbType?:"specific-database"|"multiple-databases", MaxFileSize?:int, ParallelLoadThreads?:int, Password?:string, Port?:int, ServerName?:string, ServerTimezone?:string, Username?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string}, TimestreamSettings?:array{DatabaseName:string, MemoryDuration:int, MagneticDuration:int, CdcInsertsAndUpdates?:bool, EnableMagneticStoreWrites?:bool}}}>
     */
    public function deleteEndpointAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{SubscriptionName:string} $args
     * @return \AWS\Result<array{EventSubscription?:array{CustomerAwsId?:string, CustSubscriptionId?:string, SnsTopicArn?:string, Status?:string, SubscriptionCreationTime?:string, SourceType?:string, SourceIdsList?:array<string>, EventCategoriesList?:array<string>, Enabled?:bool}}>
     */
    public function deleteEventSubscription(array $args): \AWS\Result { }

    /**
     * @param array{SubscriptionName:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{EventSubscription?:array{CustomerAwsId?:string, CustSubscriptionId?:string, SnsTopicArn?:string, Status?:string, SubscriptionCreationTime?:string, SourceType?:string, SourceIdsList?:array<string>, EventCategoriesList?:array<string>, Enabled?:bool}}>
     */
    public function deleteEventSubscriptionAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CollectorReferencedId:string} $args
     * @return \AWS\Result<void>
     */
    public function deleteFleetAdvisorCollector(array $args): \AWS\Result { }

    /**
     * @param array{CollectorReferencedId:string} $args
     * @return \GuzzleHttp\Promise\Promise<void>
     */
    public function deleteFleetAdvisorCollectorAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{DatabaseIds:array<string>} $args
     * @return \AWS\Result<array{DatabaseIds?:array<string>}>
     */
    public function deleteFleetAdvisorDatabases(array $args): \AWS\Result { }

    /**
     * @param array{DatabaseIds:array<string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{DatabaseIds?:array<string>}>
     */
    public function deleteFleetAdvisorDatabasesAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{InstanceProfileIdentifier:string} $args
     * @return \AWS\Result<array{InstanceProfile?:array{InstanceProfileArn?:string, AvailabilityZone?:string, KmsKeyArn?:string, PubliclyAccessible?:bool, NetworkType?:string, InstanceProfileName?:string, Description?:string, InstanceProfileCreationTime?:int|string|\DateTimeInterface, SubnetGroupIdentifier?:string, VpcSecurityGroups?:array<string>}}>
     */
    public function deleteInstanceProfile(array $args): \AWS\Result { }

    /**
     * @param array{InstanceProfileIdentifier:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{InstanceProfile?:array{InstanceProfileArn?:string, AvailabilityZone?:string, KmsKeyArn?:string, PubliclyAccessible?:bool, NetworkType?:string, InstanceProfileName?:string, Description?:string, InstanceProfileCreationTime?:int|string|\DateTimeInterface, SubnetGroupIdentifier?:string, VpcSecurityGroups?:array<string>}}>
     */
    public function deleteInstanceProfileAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{MigrationProjectIdentifier:string} $args
     * @return \AWS\Result<array{MigrationProject?:array{MigrationProjectName?:string, MigrationProjectArn?:string, MigrationProjectCreationTime?:int|string|\DateTimeInterface, SourceDataProviderDescriptors?:array<array{SecretsManagerSecretId?:string, SecretsManagerAccessRoleArn?:string, DataProviderName?:string, DataProviderArn?:string}>, TargetDataProviderDescriptors?:array<array{SecretsManagerSecretId?:string, SecretsManagerAccessRoleArn?:string, DataProviderName?:string, DataProviderArn?:string}>, InstanceProfileArn?:string, InstanceProfileName?:string, TransformationRules?:string, Description?:string, SchemaConversionApplicationAttributes?:array{S3BucketPath?:string, S3BucketRoleArn?:string}}}>
     */
    public function deleteMigrationProject(array $args): \AWS\Result { }

    /**
     * @param array{MigrationProjectIdentifier:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{MigrationProject?:array{MigrationProjectName?:string, MigrationProjectArn?:string, MigrationProjectCreationTime?:int|string|\DateTimeInterface, SourceDataProviderDescriptors?:array<array{SecretsManagerSecretId?:string, SecretsManagerAccessRoleArn?:string, DataProviderName?:string, DataProviderArn?:string}>, TargetDataProviderDescriptors?:array<array{SecretsManagerSecretId?:string, SecretsManagerAccessRoleArn?:string, DataProviderName?:string, DataProviderArn?:string}>, InstanceProfileArn?:string, InstanceProfileName?:string, TransformationRules?:string, Description?:string, SchemaConversionApplicationAttributes?:array{S3BucketPath?:string, S3BucketRoleArn?:string}}}>
     */
    public function deleteMigrationProjectAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ReplicationConfigArn:string} $args
     * @return \AWS\Result<array{ReplicationConfig?:array{ReplicationConfigIdentifier?:string, ReplicationConfigArn?:string, SourceEndpointArn?:string, TargetEndpointArn?:string, ReplicationType?:"full-load"|"cdc"|"full-load-and-cdc", ComputeConfig?:array{AvailabilityZone?:string, DnsNameServers?:string, KmsKeyId?:string, MaxCapacityUnits?:int, MinCapacityUnits?:int, MultiAZ?:bool, PreferredMaintenanceWindow?:string, ReplicationSubnetGroupId?:string, VpcSecurityGroupIds?:array<string>}, ReplicationSettings?:string, SupplementalSettings?:string, TableMappings?:string, ReplicationConfigCreateTime?:int|string|\DateTimeInterface, ReplicationConfigUpdateTime?:int|string|\DateTimeInterface}}>
     */
    public function deleteReplicationConfig(array $args): \AWS\Result { }

    /**
     * @param array{ReplicationConfigArn:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{ReplicationConfig?:array{ReplicationConfigIdentifier?:string, ReplicationConfigArn?:string, SourceEndpointArn?:string, TargetEndpointArn?:string, ReplicationType?:"full-load"|"cdc"|"full-load-and-cdc", ComputeConfig?:array{AvailabilityZone?:string, DnsNameServers?:string, KmsKeyId?:string, MaxCapacityUnits?:int, MinCapacityUnits?:int, MultiAZ?:bool, PreferredMaintenanceWindow?:string, ReplicationSubnetGroupId?:string, VpcSecurityGroupIds?:array<string>}, ReplicationSettings?:string, SupplementalSettings?:string, TableMappings?:string, ReplicationConfigCreateTime?:int|string|\DateTimeInterface, ReplicationConfigUpdateTime?:int|string|\DateTimeInterface}}>
     */
    public function deleteReplicationConfigAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ReplicationInstanceArn:string} $args
     * @return \AWS\Result<array{ReplicationInstance?:array{ReplicationInstanceIdentifier?:string, ReplicationInstanceClass?:string, ReplicationInstanceStatus?:string, AllocatedStorage?:int, InstanceCreateTime?:int|string|\DateTimeInterface, VpcSecurityGroups?:array<array{VpcSecurityGroupId?:string, Status?:string}>, AvailabilityZone?:string, ReplicationSubnetGroup?:array{ReplicationSubnetGroupIdentifier?:string, ReplicationSubnetGroupDescription?:string, VpcId?:string, SubnetGroupStatus?:string, Subnets?:array<array{SubnetIdentifier?:string, SubnetAvailabilityZone?:array{Name?:string}, SubnetStatus?:string}>, SupportedNetworkTypes?:array<string>}, PreferredMaintenanceWindow?:string, PendingModifiedValues?:array{ReplicationInstanceClass?:string, AllocatedStorage?:int, MultiAZ?:bool, EngineVersion?:string, NetworkType?:string}, MultiAZ?:bool, EngineVersion?:string, AutoMinorVersionUpgrade?:bool, KmsKeyId?:string, ReplicationInstanceArn?:string, ReplicationInstancePublicIpAddress?:string, ReplicationInstancePrivateIpAddress?:string, ReplicationInstancePublicIpAddresses?:array<string>, ReplicationInstancePrivateIpAddresses?:array<string>, ReplicationInstanceIpv6Addresses?:array<string>, PubliclyAccessible?:bool, SecondaryAvailabilityZone?:string, FreeUntil?:int|string|\DateTimeInterface, DnsNameServers?:string, NetworkType?:string, KerberosAuthenticationSettings?:array{KeyCacheSecretId?:string, KeyCacheSecretIamArn?:string, Krb5FileContents?:string}}}>
     */
    public function deleteReplicationInstance(array $args): \AWS\Result { }

    /**
     * @param array{ReplicationInstanceArn:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{ReplicationInstance?:array{ReplicationInstanceIdentifier?:string, ReplicationInstanceClass?:string, ReplicationInstanceStatus?:string, AllocatedStorage?:int, InstanceCreateTime?:int|string|\DateTimeInterface, VpcSecurityGroups?:array<array{VpcSecurityGroupId?:string, Status?:string}>, AvailabilityZone?:string, ReplicationSubnetGroup?:array{ReplicationSubnetGroupIdentifier?:string, ReplicationSubnetGroupDescription?:string, VpcId?:string, SubnetGroupStatus?:string, Subnets?:array<array{SubnetIdentifier?:string, SubnetAvailabilityZone?:array{Name?:string}, SubnetStatus?:string}>, SupportedNetworkTypes?:array<string>}, PreferredMaintenanceWindow?:string, PendingModifiedValues?:array{ReplicationInstanceClass?:string, AllocatedStorage?:int, MultiAZ?:bool, EngineVersion?:string, NetworkType?:string}, MultiAZ?:bool, EngineVersion?:string, AutoMinorVersionUpgrade?:bool, KmsKeyId?:string, ReplicationInstanceArn?:string, ReplicationInstancePublicIpAddress?:string, ReplicationInstancePrivateIpAddress?:string, ReplicationInstancePublicIpAddresses?:array<string>, ReplicationInstancePrivateIpAddresses?:array<string>, ReplicationInstanceIpv6Addresses?:array<string>, PubliclyAccessible?:bool, SecondaryAvailabilityZone?:string, FreeUntil?:int|string|\DateTimeInterface, DnsNameServers?:string, NetworkType?:string, KerberosAuthenticationSettings?:array{KeyCacheSecretId?:string, KeyCacheSecretIamArn?:string, Krb5FileContents?:string}}}>
     */
    public function deleteReplicationInstanceAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ReplicationSubnetGroupIdentifier:string} $args
     * @return \AWS\Result<array{}>
     */
    public function deleteReplicationSubnetGroup(array $args): \AWS\Result { }

    /**
     * @param array{ReplicationSubnetGroupIdentifier:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function deleteReplicationSubnetGroupAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ReplicationTaskArn:string} $args
     * @return \AWS\Result<array{ReplicationTask?:array{ReplicationTaskIdentifier?:string, SourceEndpointArn?:string, TargetEndpointArn?:string, ReplicationInstanceArn?:string, MigrationType?:"full-load"|"cdc"|"full-load-and-cdc", TableMappings?:string, ReplicationTaskSettings?:string, Status?:string, LastFailureMessage?:string, StopReason?:string, ReplicationTaskCreationDate?:int|string|\DateTimeInterface, ReplicationTaskStartDate?:int|string|\DateTimeInterface, CdcStartPosition?:string, CdcStopPosition?:string, RecoveryCheckpoint?:string, ReplicationTaskArn?:string, ReplicationTaskStats?:array{FullLoadProgressPercent?:int, ElapsedTimeMillis?:int, TablesLoaded?:int, TablesLoading?:int, TablesQueued?:int, TablesErrored?:int, FreshStartDate?:int|string|\DateTimeInterface, StartDate?:int|string|\DateTimeInterface, StopDate?:int|string|\DateTimeInterface, FullLoadStartDate?:int|string|\DateTimeInterface, FullLoadFinishDate?:int|string|\DateTimeInterface}, TaskData?:string, TargetReplicationInstanceArn?:string}}>
     */
    public function deleteReplicationTask(array $args): \AWS\Result { }

    /**
     * @param array{ReplicationTaskArn:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{ReplicationTask?:array{ReplicationTaskIdentifier?:string, SourceEndpointArn?:string, TargetEndpointArn?:string, ReplicationInstanceArn?:string, MigrationType?:"full-load"|"cdc"|"full-load-and-cdc", TableMappings?:string, ReplicationTaskSettings?:string, Status?:string, LastFailureMessage?:string, StopReason?:string, ReplicationTaskCreationDate?:int|string|\DateTimeInterface, ReplicationTaskStartDate?:int|string|\DateTimeInterface, CdcStartPosition?:string, CdcStopPosition?:string, RecoveryCheckpoint?:string, ReplicationTaskArn?:string, ReplicationTaskStats?:array{FullLoadProgressPercent?:int, ElapsedTimeMillis?:int, TablesLoaded?:int, TablesLoading?:int, TablesQueued?:int, TablesErrored?:int, FreshStartDate?:int|string|\DateTimeInterface, StartDate?:int|string|\DateTimeInterface, StopDate?:int|string|\DateTimeInterface, FullLoadStartDate?:int|string|\DateTimeInterface, FullLoadFinishDate?:int|string|\DateTimeInterface}, TaskData?:string, TargetReplicationInstanceArn?:string}}>
     */
    public function deleteReplicationTaskAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ReplicationTaskAssessmentRunArn:string} $args
     * @return \AWS\Result<array{ReplicationTaskAssessmentRun?:array{ReplicationTaskAssessmentRunArn?:string, ReplicationTaskArn?:string, Status?:string, ReplicationTaskAssessmentRunCreationDate?:int|string|\DateTimeInterface, AssessmentProgress?:array{IndividualAssessmentCount?:int, IndividualAssessmentCompletedCount?:int}, LastFailureMessage?:string, ServiceAccessRoleArn?:string, ResultLocationBucket?:string, ResultLocationFolder?:string, ResultEncryptionMode?:string, ResultKmsKeyArn?:string, AssessmentRunName?:string, IsLatestTaskAssessmentRun?:bool, ResultStatistic?:array{Passed?:int, Failed?:int, Error?:int, Warning?:int, Cancelled?:int}}}>
     */
    public function deleteReplicationTaskAssessmentRun(array $args): \AWS\Result { }

    /**
     * @param array{ReplicationTaskAssessmentRunArn:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{ReplicationTaskAssessmentRun?:array{ReplicationTaskAssessmentRunArn?:string, ReplicationTaskArn?:string, Status?:string, ReplicationTaskAssessmentRunCreationDate?:int|string|\DateTimeInterface, AssessmentProgress?:array{IndividualAssessmentCount?:int, IndividualAssessmentCompletedCount?:int}, LastFailureMessage?:string, ServiceAccessRoleArn?:string, ResultLocationBucket?:string, ResultLocationFolder?:string, ResultEncryptionMode?:string, ResultKmsKeyArn?:string, AssessmentRunName?:string, IsLatestTaskAssessmentRun?:bool, ResultStatistic?:array{Passed?:int, Failed?:int, Error?:int, Warning?:int, Cancelled?:int}}}>
     */
    public function deleteReplicationTaskAssessmentRunAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{} $args
     * @return \AWS\Result<array{AccountQuotas?:array<array{AccountQuotaName?:string, Used?:int, Max?:int}>, UniqueAccountIdentifier?:string}>
     */
    public function describeAccountAttributes(array $args = []): \AWS\Result { }

    /**
     * @param array{} $args
     * @return \GuzzleHttp\Promise\Promise<array{AccountQuotas?:array<array{AccountQuotaName?:string, Used?:int, Max?:int}>, UniqueAccountIdentifier?:string}>
     */
    public function describeAccountAttributesAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ReplicationTaskArn?:string, ReplicationInstanceArn?:string, SourceEngineName?:string, TargetEngineName?:string, MigrationType?:"full-load"|"cdc"|"full-load-and-cdc", MaxRecords?:int, Marker?:string} $args
     * @return \AWS\Result<array{IndividualAssessmentNames?:array<string>, Marker?:string}>
     */
    public function describeApplicableIndividualAssessments(array $args = []): \AWS\Result { }

    /**
     * @param array{ReplicationTaskArn?:string, ReplicationInstanceArn?:string, SourceEngineName?:string, TargetEngineName?:string, MigrationType?:"full-load"|"cdc"|"full-load-and-cdc", MaxRecords?:int, Marker?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{IndividualAssessmentNames?:array<string>, Marker?:string}>
     */
    public function describeApplicableIndividualAssessmentsAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Filters?:array<array{Name:string, Values:array<string>}>, MaxRecords?:int, Marker?:string} $args
     * @return \AWS\Result<array{Marker?:string, Certificates?:array<array{CertificateIdentifier?:string, CertificateCreationDate?:int|string|\DateTimeInterface, CertificatePem?:string, CertificateWallet?:string|resource|\Psr\Http\Message\StreamInterface, CertificateArn?:string, CertificateOwner?:string, ValidFromDate?:int|string|\DateTimeInterface, ValidToDate?:int|string|\DateTimeInterface, SigningAlgorithm?:string, KeyLength?:int}>}>
     */
    public function describeCertificates(array $args = []): \AWS\Result { }

    /**
     * @param array{Filters?:array<array{Name:string, Values:array<string>}>, MaxRecords?:int, Marker?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Marker?:string, Certificates?:array<array{CertificateIdentifier?:string, CertificateCreationDate?:int|string|\DateTimeInterface, CertificatePem?:string, CertificateWallet?:string|resource|\Psr\Http\Message\StreamInterface, CertificateArn?:string, CertificateOwner?:string, ValidFromDate?:int|string|\DateTimeInterface, ValidToDate?:int|string|\DateTimeInterface, SigningAlgorithm?:string, KeyLength?:int}>}>
     */
    public function describeCertificatesAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Filters?:array<array{Name:string, Values:array<string>}>, MaxRecords?:int, Marker?:string} $args
     * @return \AWS\Result<array{Marker?:string, Connections?:array<array{ReplicationInstanceArn?:string, EndpointArn?:string, Status?:string, LastFailureMessage?:string, EndpointIdentifier?:string, ReplicationInstanceIdentifier?:string}>}>
     */
    public function describeConnections(array $args = []): \AWS\Result { }

    /**
     * @param array{Filters?:array<array{Name:string, Values:array<string>}>, MaxRecords?:int, Marker?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Marker?:string, Connections?:array<array{ReplicationInstanceArn?:string, EndpointArn?:string, Status?:string, LastFailureMessage?:string, EndpointIdentifier?:string, ReplicationInstanceIdentifier?:string}>}>
     */
    public function describeConnectionsAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{MigrationProjectIdentifier:string} $args
     * @return \AWS\Result<array{MigrationProjectIdentifier?:string, ConversionConfiguration?:string}>
     */
    public function describeConversionConfiguration(array $args): \AWS\Result { }

    /**
     * @param array{MigrationProjectIdentifier:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{MigrationProjectIdentifier?:string, ConversionConfiguration?:string}>
     */
    public function describeConversionConfigurationAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Filters?:array<array{Name:string, Values:array<string>}>, MaxRecords?:int, Marker?:string, WithoutSettings?:bool, WithoutStatistics?:bool} $args
     * @return \AWS\Result<array{DataMigrations?:array<array{DataMigrationName?:string, DataMigrationArn?:string, DataMigrationCreateTime?:int|string|\DateTimeInterface, DataMigrationStartTime?:int|string|\DateTimeInterface, DataMigrationEndTime?:int|string|\DateTimeInterface, ServiceAccessRoleArn?:string, MigrationProjectArn?:string, DataMigrationType?:"full-load"|"cdc"|"full-load-and-cdc", DataMigrationSettings?:array{NumberOfJobs?:int, CloudwatchLogsEnabled?:bool, SelectionRules?:string}, SourceDataSettings?:array<array{CDCStartPosition?:string, CDCStartTime?:int|string|\DateTimeInterface, CDCStopTime?:int|string|\DateTimeInterface, SlotName?:string}>, DataMigrationStatistics?:array{TablesLoaded?:int, ElapsedTimeMillis?:int, TablesLoading?:int, FullLoadPercentage?:int, CDCLatency?:int, TablesQueued?:int, TablesErrored?:int, StartTime?:int|string|\DateTimeInterface, StopTime?:int|string|\DateTimeInterface}, DataMigrationStatus?:string, PublicIpAddresses?:array<string>, DataMigrationCidrBlocks?:array<string>, LastFailureMessage?:string, StopReason?:string}>, Marker?:string}>
     */
    public function describeDataMigrations(array $args = []): \AWS\Result { }

    /**
     * @param array{Filters?:array<array{Name:string, Values:array<string>}>, MaxRecords?:int, Marker?:string, WithoutSettings?:bool, WithoutStatistics?:bool} $args
     * @return \GuzzleHttp\Promise\Promise<array{DataMigrations?:array<array{DataMigrationName?:string, DataMigrationArn?:string, DataMigrationCreateTime?:int|string|\DateTimeInterface, DataMigrationStartTime?:int|string|\DateTimeInterface, DataMigrationEndTime?:int|string|\DateTimeInterface, ServiceAccessRoleArn?:string, MigrationProjectArn?:string, DataMigrationType?:"full-load"|"cdc"|"full-load-and-cdc", DataMigrationSettings?:array{NumberOfJobs?:int, CloudwatchLogsEnabled?:bool, SelectionRules?:string}, SourceDataSettings?:array<array{CDCStartPosition?:string, CDCStartTime?:int|string|\DateTimeInterface, CDCStopTime?:int|string|\DateTimeInterface, SlotName?:string}>, DataMigrationStatistics?:array{TablesLoaded?:int, ElapsedTimeMillis?:int, TablesLoading?:int, FullLoadPercentage?:int, CDCLatency?:int, TablesQueued?:int, TablesErrored?:int, StartTime?:int|string|\DateTimeInterface, StopTime?:int|string|\DateTimeInterface}, DataMigrationStatus?:string, PublicIpAddresses?:array<string>, DataMigrationCidrBlocks?:array<string>, LastFailureMessage?:string, StopReason?:string}>, Marker?:string}>
     */
    public function describeDataMigrationsAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Filters?:array<array{Name:string, Values:array<string>}>, MaxRecords?:int, Marker?:string} $args
     * @return \AWS\Result<array{Marker?:string, DataProviders?:array<array{DataProviderName?:string, DataProviderArn?:string, DataProviderCreationTime?:int|string|\DateTimeInterface, Description?:string, Engine?:string, Settings?:array{RedshiftSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string}, PostgreSqlSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, MySqlSettings?:array{ServerName?:string, Port?:int, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, OracleSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string, AsmServer?:string, SecretsManagerOracleAsmSecretId?:string, SecretsManagerOracleAsmAccessRoleArn?:string, SecretsManagerSecurityDbEncryptionSecretId?:string, SecretsManagerSecurityDbEncryptionAccessRoleArn?:string}, MicrosoftSqlServerSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, DocDbSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, MariaDbSettings?:array{ServerName?:string, Port?:int, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, MongoDbSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string, AuthType?:"no"|"password", AuthSource?:string, AuthMechanism?:"default"|"mongodb_cr"|"scram_sha_1"}}}>}>
     */
    public function describeDataProviders(array $args = []): \AWS\Result { }

    /**
     * @param array{Filters?:array<array{Name:string, Values:array<string>}>, MaxRecords?:int, Marker?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Marker?:string, DataProviders?:array<array{DataProviderName?:string, DataProviderArn?:string, DataProviderCreationTime?:int|string|\DateTimeInterface, Description?:string, Engine?:string, Settings?:array{RedshiftSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string}, PostgreSqlSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, MySqlSettings?:array{ServerName?:string, Port?:int, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, OracleSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string, AsmServer?:string, SecretsManagerOracleAsmSecretId?:string, SecretsManagerOracleAsmAccessRoleArn?:string, SecretsManagerSecurityDbEncryptionSecretId?:string, SecretsManagerSecurityDbEncryptionAccessRoleArn?:string}, MicrosoftSqlServerSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, DocDbSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, MariaDbSettings?:array{ServerName?:string, Port?:int, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, MongoDbSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string, AuthType?:"no"|"password", AuthSource?:string, AuthMechanism?:"default"|"mongodb_cr"|"scram_sha_1"}}}>}>
     */
    public function describeDataProvidersAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{EngineName:string, MaxRecords?:int, Marker?:string} $args
     * @return \AWS\Result<array{Marker?:string, EndpointSettings?:array<array{Name?:string, Type?:"string"|"boolean"|"integer"|"enum", EnumValues?:array<string>, Sensitive?:bool, Units?:string, Applicability?:string, IntValueMin?:int, IntValueMax?:int, DefaultValue?:string}>}>
     */
    public function describeEndpointSettings(array $args): \AWS\Result { }

    /**
     * @param array{EngineName:string, MaxRecords?:int, Marker?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Marker?:string, EndpointSettings?:array<array{Name?:string, Type?:"string"|"boolean"|"integer"|"enum", EnumValues?:array<string>, Sensitive?:bool, Units?:string, Applicability?:string, IntValueMin?:int, IntValueMax?:int, DefaultValue?:string}>}>
     */
    public function describeEndpointSettingsAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Filters?:array<array{Name:string, Values:array<string>}>, MaxRecords?:int, Marker?:string} $args
     * @return \AWS\Result<array{Marker?:string, SupportedEndpointTypes?:array<array{EngineName?:string, SupportsCDC?:bool, EndpointType?:"source"|"target", ReplicationInstanceEngineMinimumVersion?:string, EngineDisplayName?:string}>}>
     */
    public function describeEndpointTypes(array $args = []): \AWS\Result { }

    /**
     * @param array{Filters?:array<array{Name:string, Values:array<string>}>, MaxRecords?:int, Marker?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Marker?:string, SupportedEndpointTypes?:array<array{EngineName?:string, SupportsCDC?:bool, EndpointType?:"source"|"target", ReplicationInstanceEngineMinimumVersion?:string, EngineDisplayName?:string}>}>
     */
    public function describeEndpointTypesAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Filters?:array<array{Name:string, Values:array<string>}>, MaxRecords?:int, Marker?:string} $args
     * @return \AWS\Result<array{Marker?:string, Endpoints?:array<array{EndpointIdentifier?:string, EndpointType?:"source"|"target", EngineName?:string, EngineDisplayName?:string, Username?:string, ServerName?:string, Port?:int, DatabaseName?:string, ExtraConnectionAttributes?:string, Status?:string, KmsKeyId?:string, EndpointArn?:string, CertificateArn?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", ServiceAccessRoleArn?:string, ExternalTableDefinition?:string, ExternalId?:string, DynamoDbSettings?:array{ServiceAccessRoleArn:string}, S3Settings?:array{ServiceAccessRoleArn?:string, ExternalTableDefinition?:string, CsvRowDelimiter?:string, CsvDelimiter?:string, BucketFolder?:string, BucketName?:string, CompressionType?:"none"|"gzip", EncryptionMode?:"sse-s3"|"sse-kms", ServerSideEncryptionKmsKeyId?:string, DataFormat?:"csv"|"parquet", EncodingType?:"plain"|"plain-dictionary"|"rle-dictionary", DictPageSizeLimit?:int, RowGroupLength?:int, DataPageSize?:int, ParquetVersion?:"parquet-1-0"|"parquet-2-0", EnableStatistics?:bool, IncludeOpForFullLoad?:bool, CdcInsertsOnly?:bool, TimestampColumnName?:string, ParquetTimestampInMillisecond?:bool, CdcInsertsAndUpdates?:bool, DatePartitionEnabled?:bool, DatePartitionSequence?:"YYYYMMDD"|"YYYYMMDDHH"|"YYYYMM"|"MMYYYYDD"|"DDMMYYYY", DatePartitionDelimiter?:"SLASH"|"UNDERSCORE"|"DASH"|"NONE", UseCsvNoSupValue?:bool, CsvNoSupValue?:string, PreserveTransactions?:bool, CdcPath?:string, UseTaskStartTimeForFullLoadTimestamp?:bool, CannedAclForObjects?:"none"|"private"|"public-read"|"public-read-write"|"authenticated-read"|"aws-exec-read"|"bucket-owner-read"|"bucket-owner-full-control", AddColumnName?:bool, CdcMaxBatchInterval?:int, CdcMinFileSize?:int, CsvNullValue?:string, IgnoreHeaderRows?:int, MaxFileSize?:int, Rfc4180?:bool, DatePartitionTimezone?:string, AddTrailingPaddingCharacter?:bool, ExpectedBucketOwner?:string, GlueCatalogGeneration?:bool}, DmsTransferSettings?:array{ServiceAccessRoleArn?:string, BucketName?:string}, MongoDbSettings?:array{Username?:string, Password?:string, ServerName?:string, Port?:int, DatabaseName?:string, AuthType?:"no"|"password", AuthMechanism?:"default"|"mongodb_cr"|"scram_sha_1", NestingLevel?:"none"|"one", ExtractDocId?:string, DocsToInvestigate?:string, AuthSource?:string, KmsKeyId?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, UseUpdateLookUp?:bool, ReplicateShardCollections?:bool}, KinesisSettings?:array{StreamArn?:string, MessageFormat?:"json"|"json-unformatted", ServiceAccessRoleArn?:string, IncludeTransactionDetails?:bool, IncludePartitionValue?:bool, PartitionIncludeSchemaTable?:bool, IncludeTableAlterOperations?:bool, IncludeControlDetails?:bool, IncludeNullAndEmpty?:bool, NoHexPrefix?:bool, UseLargeIntegerValue?:bool}, KafkaSettings?:array{Broker?:string, Topic?:string, MessageFormat?:"json"|"json-unformatted", IncludeTransactionDetails?:bool, IncludePartitionValue?:bool, PartitionIncludeSchemaTable?:bool, IncludeTableAlterOperations?:bool, IncludeControlDetails?:bool, MessageMaxBytes?:int, IncludeNullAndEmpty?:bool, SecurityProtocol?:"plaintext"|"ssl-authentication"|"ssl-encryption"|"sasl-ssl", SslClientCertificateArn?:string, SslClientKeyArn?:string, SslClientKeyPassword?:string, SslCaCertificateArn?:string, SaslUsername?:string, SaslPassword?:string, NoHexPrefix?:bool, SaslMechanism?:"scram-sha-512"|"plain", SslEndpointIdentificationAlgorithm?:"none"|"https", UseLargeIntegerValue?:bool}, ElasticsearchSettings?:array{ServiceAccessRoleArn:string, EndpointUri:string, FullLoadErrorPercentage?:int, ErrorRetryDuration?:int, UseNewMappingType?:bool}, NeptuneSettings?:array{ServiceAccessRoleArn?:string, S3BucketName:string, S3BucketFolder:string, ErrorRetryDuration?:int, MaxFileSize?:int, MaxRetryCount?:int, IamAuthEnabled?:bool}, RedshiftSettings?:array{AcceptAnyDate?:bool, AfterConnectScript?:string, BucketFolder?:string, BucketName?:string, CaseSensitiveNames?:bool, CompUpdate?:bool, ConnectionTimeout?:int, DatabaseName?:string, DateFormat?:string, EmptyAsNull?:bool, EncryptionMode?:"sse-s3"|"sse-kms", ExplicitIds?:bool, FileTransferUploadStreams?:int, LoadTimeout?:int, MaxFileSize?:int, Password?:string, Port?:int, RemoveQuotes?:bool, ReplaceInvalidChars?:string, ReplaceChars?:string, ServerName?:string, ServiceAccessRoleArn?:string, ServerSideEncryptionKmsKeyId?:string, TimeFormat?:string, TrimBlanks?:bool, TruncateColumns?:bool, Username?:string, WriteBufferSize?:int, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, MapBooleanAsBoolean?:bool}, PostgreSQLSettings?:array{AfterConnectScript?:string, CaptureDdls?:bool, MaxFileSize?:int, DatabaseName?:string, DdlArtifactsSchema?:string, ExecuteTimeout?:int, FailTasksOnLobTruncation?:bool, HeartbeatEnable?:bool, HeartbeatSchema?:string, HeartbeatFrequency?:int, Password?:string, Port?:int, ServerName?:string, Username?:string, SlotName?:string, PluginName?:"no-preference"|"test-decoding"|"pglogical", SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, TrimSpaceInChar?:bool, MapBooleanAsBoolean?:bool, MapJsonbAsClob?:bool, MapLongVarcharAs?:"wstring"|"clob"|"nclob", DatabaseMode?:"default"|"babelfish", BabelfishDatabaseName?:string, DisableUnicodeSourceFilter?:bool}, MySQLSettings?:array{AfterConnectScript?:string, CleanSourceMetadataOnMismatch?:bool, DatabaseName?:string, EventsPollInterval?:int, TargetDbType?:"specific-database"|"multiple-databases", MaxFileSize?:int, ParallelLoadThreads?:int, Password?:string, Port?:int, ServerName?:string, ServerTimezone?:string, Username?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, ExecuteTimeout?:int}, OracleSettings?:array{AddSupplementalLogging?:bool, ArchivedLogDestId?:int, AdditionalArchivedLogDestId?:int, ExtraArchivedLogDestIds?:array<int>, AllowSelectNestedTables?:bool, ParallelAsmReadThreads?:int, ReadAheadBlocks?:int, AccessAlternateDirectly?:bool, UseAlternateFolderForOnline?:bool, OraclePathPrefix?:string, UsePathPrefix?:string, ReplacePathPrefix?:bool, EnableHomogenousTablespace?:bool, DirectPathNoLog?:bool, ArchivedLogsOnly?:bool, AsmPassword?:string, AsmServer?:string, AsmUser?:string, CharLengthSemantics?:"default"|"char"|"byte", DatabaseName?:string, DirectPathParallelLoad?:bool, FailTasksOnLobTruncation?:bool, NumberDatatypeScale?:int, Password?:string, Port?:int, ReadTableSpaceName?:bool, RetryInterval?:int, SecurityDbEncryption?:string, SecurityDbEncryptionName?:string, ServerName?:string, SpatialDataOptionToGeoJsonFunctionName?:string, StandbyDelayTime?:int, Username?:string, UseBFile?:bool, UseDirectPathFullLoad?:bool, UseLogminerReader?:bool, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, SecretsManagerOracleAsmAccessRoleArn?:string, SecretsManagerOracleAsmSecretId?:string, TrimSpaceInChar?:bool, ConvertTimestampWithZoneToUTC?:bool, OpenTransactionWindow?:int, AuthenticationMethod?:"password"|"kerberos"}, SybaseSettings?:array{DatabaseName?:string, Password?:string, Port?:int, ServerName?:string, Username?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string}, MicrosoftSQLServerSettings?:array{Port?:int, BcpPacketSize?:int, DatabaseName?:string, ControlTablesFileGroup?:string, Password?:string, QuerySingleAlwaysOnNode?:bool, ReadBackupOnly?:bool, SafeguardPolicy?:"rely-on-sql-server-replication-agent"|"exclusive-automatic-truncation"|"shared-automatic-truncation", ServerName?:string, Username?:string, UseBcpFullLoad?:bool, UseThirdPartyBackupDevice?:bool, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, TrimSpaceInChar?:bool, TlogAccessMode?:"BackupOnly"|"PreferBackup"|"PreferTlog"|"TlogOnly", ForceLobLookup?:bool, AuthenticationMethod?:"password"|"kerberos"}, IBMDb2Settings?:array{DatabaseName?:string, Password?:string, Port?:int, ServerName?:string, SetDataCaptureChanges?:bool, CurrentLsn?:string, MaxKBytesPerRead?:int, Username?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, LoadTimeout?:int, WriteBufferSize?:int, MaxFileSize?:int, KeepCsvFiles?:bool}, DocDbSettings?:array{Username?:string, Password?:string, ServerName?:string, Port?:int, DatabaseName?:string, NestingLevel?:"none"|"one", ExtractDocId?:bool, DocsToInvestigate?:int, KmsKeyId?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, UseUpdateLookUp?:bool, ReplicateShardCollections?:bool}, RedisSettings?:array{ServerName:string, Port:int, SslSecurityProtocol?:"plaintext"|"ssl-encryption", AuthType?:"none"|"auth-role"|"auth-token", AuthUserName?:string, AuthPassword?:string, SslCaCertificateArn?:string}, GcpMySQLSettings?:array{AfterConnectScript?:string, CleanSourceMetadataOnMismatch?:bool, DatabaseName?:string, EventsPollInterval?:int, TargetDbType?:"specific-database"|"multiple-databases", MaxFileSize?:int, ParallelLoadThreads?:int, Password?:string, Port?:int, ServerName?:string, ServerTimezone?:string, Username?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string}, TimestreamSettings?:array{DatabaseName:string, MemoryDuration:int, MagneticDuration:int, CdcInsertsAndUpdates?:bool, EnableMagneticStoreWrites?:bool}}>}>
     */
    public function describeEndpoints(array $args = []): \AWS\Result { }

    /**
     * @param array{Filters?:array<array{Name:string, Values:array<string>}>, MaxRecords?:int, Marker?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Marker?:string, Endpoints?:array<array{EndpointIdentifier?:string, EndpointType?:"source"|"target", EngineName?:string, EngineDisplayName?:string, Username?:string, ServerName?:string, Port?:int, DatabaseName?:string, ExtraConnectionAttributes?:string, Status?:string, KmsKeyId?:string, EndpointArn?:string, CertificateArn?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", ServiceAccessRoleArn?:string, ExternalTableDefinition?:string, ExternalId?:string, DynamoDbSettings?:array{ServiceAccessRoleArn:string}, S3Settings?:array{ServiceAccessRoleArn?:string, ExternalTableDefinition?:string, CsvRowDelimiter?:string, CsvDelimiter?:string, BucketFolder?:string, BucketName?:string, CompressionType?:"none"|"gzip", EncryptionMode?:"sse-s3"|"sse-kms", ServerSideEncryptionKmsKeyId?:string, DataFormat?:"csv"|"parquet", EncodingType?:"plain"|"plain-dictionary"|"rle-dictionary", DictPageSizeLimit?:int, RowGroupLength?:int, DataPageSize?:int, ParquetVersion?:"parquet-1-0"|"parquet-2-0", EnableStatistics?:bool, IncludeOpForFullLoad?:bool, CdcInsertsOnly?:bool, TimestampColumnName?:string, ParquetTimestampInMillisecond?:bool, CdcInsertsAndUpdates?:bool, DatePartitionEnabled?:bool, DatePartitionSequence?:"YYYYMMDD"|"YYYYMMDDHH"|"YYYYMM"|"MMYYYYDD"|"DDMMYYYY", DatePartitionDelimiter?:"SLASH"|"UNDERSCORE"|"DASH"|"NONE", UseCsvNoSupValue?:bool, CsvNoSupValue?:string, PreserveTransactions?:bool, CdcPath?:string, UseTaskStartTimeForFullLoadTimestamp?:bool, CannedAclForObjects?:"none"|"private"|"public-read"|"public-read-write"|"authenticated-read"|"aws-exec-read"|"bucket-owner-read"|"bucket-owner-full-control", AddColumnName?:bool, CdcMaxBatchInterval?:int, CdcMinFileSize?:int, CsvNullValue?:string, IgnoreHeaderRows?:int, MaxFileSize?:int, Rfc4180?:bool, DatePartitionTimezone?:string, AddTrailingPaddingCharacter?:bool, ExpectedBucketOwner?:string, GlueCatalogGeneration?:bool}, DmsTransferSettings?:array{ServiceAccessRoleArn?:string, BucketName?:string}, MongoDbSettings?:array{Username?:string, Password?:string, ServerName?:string, Port?:int, DatabaseName?:string, AuthType?:"no"|"password", AuthMechanism?:"default"|"mongodb_cr"|"scram_sha_1", NestingLevel?:"none"|"one", ExtractDocId?:string, DocsToInvestigate?:string, AuthSource?:string, KmsKeyId?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, UseUpdateLookUp?:bool, ReplicateShardCollections?:bool}, KinesisSettings?:array{StreamArn?:string, MessageFormat?:"json"|"json-unformatted", ServiceAccessRoleArn?:string, IncludeTransactionDetails?:bool, IncludePartitionValue?:bool, PartitionIncludeSchemaTable?:bool, IncludeTableAlterOperations?:bool, IncludeControlDetails?:bool, IncludeNullAndEmpty?:bool, NoHexPrefix?:bool, UseLargeIntegerValue?:bool}, KafkaSettings?:array{Broker?:string, Topic?:string, MessageFormat?:"json"|"json-unformatted", IncludeTransactionDetails?:bool, IncludePartitionValue?:bool, PartitionIncludeSchemaTable?:bool, IncludeTableAlterOperations?:bool, IncludeControlDetails?:bool, MessageMaxBytes?:int, IncludeNullAndEmpty?:bool, SecurityProtocol?:"plaintext"|"ssl-authentication"|"ssl-encryption"|"sasl-ssl", SslClientCertificateArn?:string, SslClientKeyArn?:string, SslClientKeyPassword?:string, SslCaCertificateArn?:string, SaslUsername?:string, SaslPassword?:string, NoHexPrefix?:bool, SaslMechanism?:"scram-sha-512"|"plain", SslEndpointIdentificationAlgorithm?:"none"|"https", UseLargeIntegerValue?:bool}, ElasticsearchSettings?:array{ServiceAccessRoleArn:string, EndpointUri:string, FullLoadErrorPercentage?:int, ErrorRetryDuration?:int, UseNewMappingType?:bool}, NeptuneSettings?:array{ServiceAccessRoleArn?:string, S3BucketName:string, S3BucketFolder:string, ErrorRetryDuration?:int, MaxFileSize?:int, MaxRetryCount?:int, IamAuthEnabled?:bool}, RedshiftSettings?:array{AcceptAnyDate?:bool, AfterConnectScript?:string, BucketFolder?:string, BucketName?:string, CaseSensitiveNames?:bool, CompUpdate?:bool, ConnectionTimeout?:int, DatabaseName?:string, DateFormat?:string, EmptyAsNull?:bool, EncryptionMode?:"sse-s3"|"sse-kms", ExplicitIds?:bool, FileTransferUploadStreams?:int, LoadTimeout?:int, MaxFileSize?:int, Password?:string, Port?:int, RemoveQuotes?:bool, ReplaceInvalidChars?:string, ReplaceChars?:string, ServerName?:string, ServiceAccessRoleArn?:string, ServerSideEncryptionKmsKeyId?:string, TimeFormat?:string, TrimBlanks?:bool, TruncateColumns?:bool, Username?:string, WriteBufferSize?:int, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, MapBooleanAsBoolean?:bool}, PostgreSQLSettings?:array{AfterConnectScript?:string, CaptureDdls?:bool, MaxFileSize?:int, DatabaseName?:string, DdlArtifactsSchema?:string, ExecuteTimeout?:int, FailTasksOnLobTruncation?:bool, HeartbeatEnable?:bool, HeartbeatSchema?:string, HeartbeatFrequency?:int, Password?:string, Port?:int, ServerName?:string, Username?:string, SlotName?:string, PluginName?:"no-preference"|"test-decoding"|"pglogical", SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, TrimSpaceInChar?:bool, MapBooleanAsBoolean?:bool, MapJsonbAsClob?:bool, MapLongVarcharAs?:"wstring"|"clob"|"nclob", DatabaseMode?:"default"|"babelfish", BabelfishDatabaseName?:string, DisableUnicodeSourceFilter?:bool}, MySQLSettings?:array{AfterConnectScript?:string, CleanSourceMetadataOnMismatch?:bool, DatabaseName?:string, EventsPollInterval?:int, TargetDbType?:"specific-database"|"multiple-databases", MaxFileSize?:int, ParallelLoadThreads?:int, Password?:string, Port?:int, ServerName?:string, ServerTimezone?:string, Username?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, ExecuteTimeout?:int}, OracleSettings?:array{AddSupplementalLogging?:bool, ArchivedLogDestId?:int, AdditionalArchivedLogDestId?:int, ExtraArchivedLogDestIds?:array<int>, AllowSelectNestedTables?:bool, ParallelAsmReadThreads?:int, ReadAheadBlocks?:int, AccessAlternateDirectly?:bool, UseAlternateFolderForOnline?:bool, OraclePathPrefix?:string, UsePathPrefix?:string, ReplacePathPrefix?:bool, EnableHomogenousTablespace?:bool, DirectPathNoLog?:bool, ArchivedLogsOnly?:bool, AsmPassword?:string, AsmServer?:string, AsmUser?:string, CharLengthSemantics?:"default"|"char"|"byte", DatabaseName?:string, DirectPathParallelLoad?:bool, FailTasksOnLobTruncation?:bool, NumberDatatypeScale?:int, Password?:string, Port?:int, ReadTableSpaceName?:bool, RetryInterval?:int, SecurityDbEncryption?:string, SecurityDbEncryptionName?:string, ServerName?:string, SpatialDataOptionToGeoJsonFunctionName?:string, StandbyDelayTime?:int, Username?:string, UseBFile?:bool, UseDirectPathFullLoad?:bool, UseLogminerReader?:bool, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, SecretsManagerOracleAsmAccessRoleArn?:string, SecretsManagerOracleAsmSecretId?:string, TrimSpaceInChar?:bool, ConvertTimestampWithZoneToUTC?:bool, OpenTransactionWindow?:int, AuthenticationMethod?:"password"|"kerberos"}, SybaseSettings?:array{DatabaseName?:string, Password?:string, Port?:int, ServerName?:string, Username?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string}, MicrosoftSQLServerSettings?:array{Port?:int, BcpPacketSize?:int, DatabaseName?:string, ControlTablesFileGroup?:string, Password?:string, QuerySingleAlwaysOnNode?:bool, ReadBackupOnly?:bool, SafeguardPolicy?:"rely-on-sql-server-replication-agent"|"exclusive-automatic-truncation"|"shared-automatic-truncation", ServerName?:string, Username?:string, UseBcpFullLoad?:bool, UseThirdPartyBackupDevice?:bool, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, TrimSpaceInChar?:bool, TlogAccessMode?:"BackupOnly"|"PreferBackup"|"PreferTlog"|"TlogOnly", ForceLobLookup?:bool, AuthenticationMethod?:"password"|"kerberos"}, IBMDb2Settings?:array{DatabaseName?:string, Password?:string, Port?:int, ServerName?:string, SetDataCaptureChanges?:bool, CurrentLsn?:string, MaxKBytesPerRead?:int, Username?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, LoadTimeout?:int, WriteBufferSize?:int, MaxFileSize?:int, KeepCsvFiles?:bool}, DocDbSettings?:array{Username?:string, Password?:string, ServerName?:string, Port?:int, DatabaseName?:string, NestingLevel?:"none"|"one", ExtractDocId?:bool, DocsToInvestigate?:int, KmsKeyId?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, UseUpdateLookUp?:bool, ReplicateShardCollections?:bool}, RedisSettings?:array{ServerName:string, Port:int, SslSecurityProtocol?:"plaintext"|"ssl-encryption", AuthType?:"none"|"auth-role"|"auth-token", AuthUserName?:string, AuthPassword?:string, SslCaCertificateArn?:string}, GcpMySQLSettings?:array{AfterConnectScript?:string, CleanSourceMetadataOnMismatch?:bool, DatabaseName?:string, EventsPollInterval?:int, TargetDbType?:"specific-database"|"multiple-databases", MaxFileSize?:int, ParallelLoadThreads?:int, Password?:string, Port?:int, ServerName?:string, ServerTimezone?:string, Username?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string}, TimestreamSettings?:array{DatabaseName:string, MemoryDuration:int, MagneticDuration:int, CdcInsertsAndUpdates?:bool, EnableMagneticStoreWrites?:bool}}>}>
     */
    public function describeEndpointsAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{MaxRecords?:int, Marker?:string} $args
     * @return \AWS\Result<array{EngineVersions?:array<array{Version?:string, Lifecycle?:string, ReleaseStatus?:"beta"|"prod", LaunchDate?:int|string|\DateTimeInterface, AutoUpgradeDate?:int|string|\DateTimeInterface, DeprecationDate?:int|string|\DateTimeInterface, ForceUpgradeDate?:int|string|\DateTimeInterface, AvailableUpgrades?:array<string>}>, Marker?:string}>
     */
    public function describeEngineVersions(array $args = []): \AWS\Result { }

    /**
     * @param array{MaxRecords?:int, Marker?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{EngineVersions?:array<array{Version?:string, Lifecycle?:string, ReleaseStatus?:"beta"|"prod", LaunchDate?:int|string|\DateTimeInterface, AutoUpgradeDate?:int|string|\DateTimeInterface, DeprecationDate?:int|string|\DateTimeInterface, ForceUpgradeDate?:int|string|\DateTimeInterface, AvailableUpgrades?:array<string>}>, Marker?:string}>
     */
    public function describeEngineVersionsAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{SourceType?:string, Filters?:array<array{Name:string, Values:array<string>}>} $args
     * @return \AWS\Result<array{EventCategoryGroupList?:array<array{SourceType?:string, EventCategories?:array<string>}>}>
     */
    public function describeEventCategories(array $args = []): \AWS\Result { }

    /**
     * @param array{SourceType?:string, Filters?:array<array{Name:string, Values:array<string>}>} $args
     * @return \GuzzleHttp\Promise\Promise<array{EventCategoryGroupList?:array<array{SourceType?:string, EventCategories?:array<string>}>}>
     */
    public function describeEventCategoriesAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{SubscriptionName?:string, Filters?:array<array{Name:string, Values:array<string>}>, MaxRecords?:int, Marker?:string} $args
     * @return \AWS\Result<array{Marker?:string, EventSubscriptionsList?:array<array{CustomerAwsId?:string, CustSubscriptionId?:string, SnsTopicArn?:string, Status?:string, SubscriptionCreationTime?:string, SourceType?:string, SourceIdsList?:array<string>, EventCategoriesList?:array<string>, Enabled?:bool}>}>
     */
    public function describeEventSubscriptions(array $args = []): \AWS\Result { }

    /**
     * @param array{SubscriptionName?:string, Filters?:array<array{Name:string, Values:array<string>}>, MaxRecords?:int, Marker?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Marker?:string, EventSubscriptionsList?:array<array{CustomerAwsId?:string, CustSubscriptionId?:string, SnsTopicArn?:string, Status?:string, SubscriptionCreationTime?:string, SourceType?:string, SourceIdsList?:array<string>, EventCategoriesList?:array<string>, Enabled?:bool}>}>
     */
    public function describeEventSubscriptionsAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{SourceIdentifier?:string, SourceType?:"replication-instance", StartTime?:int|string|\DateTimeInterface, EndTime?:int|string|\DateTimeInterface, Duration?:int, EventCategories?:array<string>, Filters?:array<array{Name:string, Values:array<string>}>, MaxRecords?:int, Marker?:string} $args
     * @return \AWS\Result<array{Marker?:string, Events?:array<array{SourceIdentifier?:string, SourceType?:"replication-instance", Message?:string, EventCategories?:array<string>, Date?:int|string|\DateTimeInterface}>}>
     */
    public function describeEvents(array $args = []): \AWS\Result { }

    /**
     * @param array{SourceIdentifier?:string, SourceType?:"replication-instance", StartTime?:int|string|\DateTimeInterface, EndTime?:int|string|\DateTimeInterface, Duration?:int, EventCategories?:array<string>, Filters?:array<array{Name:string, Values:array<string>}>, MaxRecords?:int, Marker?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Marker?:string, Events?:array<array{SourceIdentifier?:string, SourceType?:"replication-instance", Message?:string, EventCategories?:array<string>, Date?:int|string|\DateTimeInterface}>}>
     */
    public function describeEventsAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{MigrationProjectIdentifier:string, Filters?:array<array{Name:string, Values:array<string>}>, Marker?:string, MaxRecords?:int} $args
     * @return \AWS\Result<array{Marker?:string, Requests?:array<array{Status?:string, RequestIdentifier?:string, MigrationProjectArn?:string, Error?:array{defaultErrorDetails?:array{Message?:string}}, ExportSqlDetails?:array{S3ObjectKey?:string, ObjectURL?:string}}>}>
     */
    public function describeExtensionPackAssociations(array $args): \AWS\Result { }

    /**
     * @param array{MigrationProjectIdentifier:string, Filters?:array<array{Name:string, Values:array<string>}>, Marker?:string, MaxRecords?:int} $args
     * @return \GuzzleHttp\Promise\Promise<array{Marker?:string, Requests?:array<array{Status?:string, RequestIdentifier?:string, MigrationProjectArn?:string, Error?:array{defaultErrorDetails?:array{Message?:string}}, ExportSqlDetails?:array{S3ObjectKey?:string, ObjectURL?:string}}>}>
     */
    public function describeExtensionPackAssociationsAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Filters?:array<array{Name:string, Values:array<string>}>, MaxRecords?:int, NextToken?:string} $args
     * @return \AWS\Result<array{Collectors?:array<array{CollectorReferencedId?:string, CollectorName?:string, CollectorVersion?:string, VersionStatus?:"UP_TO_DATE"|"OUTDATED"|"UNSUPPORTED", Description?:string, S3BucketName?:string, ServiceAccessRoleArn?:string, CollectorHealthCheck?:array{CollectorStatus?:"UNREGISTERED"|"ACTIVE", LocalCollectorS3Access?:bool, WebCollectorS3Access?:bool, WebCollectorGrantedRoleBasedAccess?:bool}, LastDataReceived?:string, RegisteredDate?:string, CreatedDate?:string, ModifiedDate?:string, InventoryData?:array{NumberOfDatabases?:int, NumberOfSchemas?:int}}>, NextToken?:string}>
     */
    public function describeFleetAdvisorCollectors(array $args = []): \AWS\Result { }

    /**
     * @param array{Filters?:array<array{Name:string, Values:array<string>}>, MaxRecords?:int, NextToken?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Collectors?:array<array{CollectorReferencedId?:string, CollectorName?:string, CollectorVersion?:string, VersionStatus?:"UP_TO_DATE"|"OUTDATED"|"UNSUPPORTED", Description?:string, S3BucketName?:string, ServiceAccessRoleArn?:string, CollectorHealthCheck?:array{CollectorStatus?:"UNREGISTERED"|"ACTIVE", LocalCollectorS3Access?:bool, WebCollectorS3Access?:bool, WebCollectorGrantedRoleBasedAccess?:bool}, LastDataReceived?:string, RegisteredDate?:string, CreatedDate?:string, ModifiedDate?:string, InventoryData?:array{NumberOfDatabases?:int, NumberOfSchemas?:int}}>, NextToken?:string}>
     */
    public function describeFleetAdvisorCollectorsAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Filters?:array<array{Name:string, Values:array<string>}>, MaxRecords?:int, NextToken?:string} $args
     * @return \AWS\Result<array{Databases?:array<array{DatabaseId?:string, DatabaseName?:string, IpAddress?:string, NumberOfSchemas?:int, Server?:array{ServerId?:string, IpAddress?:string, ServerName?:string}, SoftwareDetails?:array{Engine?:string, EngineVersion?:string, EngineEdition?:string, ServicePack?:string, SupportLevel?:string, OsArchitecture?:int, Tooltip?:string}, Collectors?:array<array{CollectorReferencedId?:string, CollectorName?:string}>}>, NextToken?:string}>
     */
    public function describeFleetAdvisorDatabases(array $args = []): \AWS\Result { }

    /**
     * @param array{Filters?:array<array{Name:string, Values:array<string>}>, MaxRecords?:int, NextToken?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Databases?:array<array{DatabaseId?:string, DatabaseName?:string, IpAddress?:string, NumberOfSchemas?:int, Server?:array{ServerId?:string, IpAddress?:string, ServerName?:string}, SoftwareDetails?:array{Engine?:string, EngineVersion?:string, EngineEdition?:string, ServicePack?:string, SupportLevel?:string, OsArchitecture?:int, Tooltip?:string}, Collectors?:array<array{CollectorReferencedId?:string, CollectorName?:string}>}>, NextToken?:string}>
     */
    public function describeFleetAdvisorDatabasesAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{MaxRecords?:int, NextToken?:string} $args
     * @return \AWS\Result<array{Analysis?:array<array{LsaAnalysisId?:string, Status?:string}>, NextToken?:string}>
     */
    public function describeFleetAdvisorLsaAnalysis(array $args = []): \AWS\Result { }

    /**
     * @param array{MaxRecords?:int, NextToken?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Analysis?:array<array{LsaAnalysisId?:string, Status?:string}>, NextToken?:string}>
     */
    public function describeFleetAdvisorLsaAnalysisAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Filters?:array<array{Name:string, Values:array<string>}>, MaxRecords?:int, NextToken?:string} $args
     * @return \AWS\Result<array{FleetAdvisorSchemaObjects?:array<array{SchemaId?:string, ObjectType?:string, NumberOfObjects?:int, CodeLineCount?:int, CodeSize?:int}>, NextToken?:string}>
     */
    public function describeFleetAdvisorSchemaObjectSummary(array $args = []): \AWS\Result { }

    /**
     * @param array{Filters?:array<array{Name:string, Values:array<string>}>, MaxRecords?:int, NextToken?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{FleetAdvisorSchemaObjects?:array<array{SchemaId?:string, ObjectType?:string, NumberOfObjects?:int, CodeLineCount?:int, CodeSize?:int}>, NextToken?:string}>
     */
    public function describeFleetAdvisorSchemaObjectSummaryAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Filters?:array<array{Name:string, Values:array<string>}>, MaxRecords?:int, NextToken?:string} $args
     * @return \AWS\Result<array{FleetAdvisorSchemas?:array<array{CodeLineCount?:int, CodeSize?:int, Complexity?:string, Server?:array{ServerId?:string, IpAddress?:string, ServerName?:string}, DatabaseInstance?:array{DatabaseId?:string, DatabaseName?:string, DatabaseIpAddress?:string, DatabaseEngine?:string}, SchemaId?:string, SchemaName?:string, OriginalSchema?:array{SchemaId?:string, SchemaName?:string, DatabaseId?:string, DatabaseName?:string, DatabaseIpAddress?:string}, Similarity?:float}>, NextToken?:string}>
     */
    public function describeFleetAdvisorSchemas(array $args = []): \AWS\Result { }

    /**
     * @param array{Filters?:array<array{Name:string, Values:array<string>}>, MaxRecords?:int, NextToken?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{FleetAdvisorSchemas?:array<array{CodeLineCount?:int, CodeSize?:int, Complexity?:string, Server?:array{ServerId?:string, IpAddress?:string, ServerName?:string}, DatabaseInstance?:array{DatabaseId?:string, DatabaseName?:string, DatabaseIpAddress?:string, DatabaseEngine?:string}, SchemaId?:string, SchemaName?:string, OriginalSchema?:array{SchemaId?:string, SchemaName?:string, DatabaseId?:string, DatabaseName?:string, DatabaseIpAddress?:string}, Similarity?:float}>, NextToken?:string}>
     */
    public function describeFleetAdvisorSchemasAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Filters?:array<array{Name:string, Values:array<string>}>, MaxRecords?:int, Marker?:string} $args
     * @return \AWS\Result<array{Marker?:string, InstanceProfiles?:array<array{InstanceProfileArn?:string, AvailabilityZone?:string, KmsKeyArn?:string, PubliclyAccessible?:bool, NetworkType?:string, InstanceProfileName?:string, Description?:string, InstanceProfileCreationTime?:int|string|\DateTimeInterface, SubnetGroupIdentifier?:string, VpcSecurityGroups?:array<string>}>}>
     */
    public function describeInstanceProfiles(array $args = []): \AWS\Result { }

    /**
     * @param array{Filters?:array<array{Name:string, Values:array<string>}>, MaxRecords?:int, Marker?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Marker?:string, InstanceProfiles?:array<array{InstanceProfileArn?:string, AvailabilityZone?:string, KmsKeyArn?:string, PubliclyAccessible?:bool, NetworkType?:string, InstanceProfileName?:string, Description?:string, InstanceProfileCreationTime?:int|string|\DateTimeInterface, SubnetGroupIdentifier?:string, VpcSecurityGroups?:array<string>}>}>
     */
    public function describeInstanceProfilesAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{MigrationProjectIdentifier:string, Filters?:array<array{Name:string, Values:array<string>}>, Marker?:string, MaxRecords?:int} $args
     * @return \AWS\Result<array{Marker?:string, Requests?:array<array{Status?:string, RequestIdentifier?:string, MigrationProjectArn?:string, Error?:array{defaultErrorDetails?:array{Message?:string}}, ExportSqlDetails?:array{S3ObjectKey?:string, ObjectURL?:string}}>}>
     */
    public function describeMetadataModelAssessments(array $args): \AWS\Result { }

    /**
     * @param array{MigrationProjectIdentifier:string, Filters?:array<array{Name:string, Values:array<string>}>, Marker?:string, MaxRecords?:int} $args
     * @return \GuzzleHttp\Promise\Promise<array{Marker?:string, Requests?:array<array{Status?:string, RequestIdentifier?:string, MigrationProjectArn?:string, Error?:array{defaultErrorDetails?:array{Message?:string}}, ExportSqlDetails?:array{S3ObjectKey?:string, ObjectURL?:string}}>}>
     */
    public function describeMetadataModelAssessmentsAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{MigrationProjectIdentifier:string, Filters?:array<array{Name:string, Values:array<string>}>, Marker?:string, MaxRecords?:int} $args
     * @return \AWS\Result<array{Marker?:string, Requests?:array<array{Status?:string, RequestIdentifier?:string, MigrationProjectArn?:string, Error?:array{defaultErrorDetails?:array{Message?:string}}, ExportSqlDetails?:array{S3ObjectKey?:string, ObjectURL?:string}}>}>
     */
    public function describeMetadataModelConversions(array $args): \AWS\Result { }

    /**
     * @param array{MigrationProjectIdentifier:string, Filters?:array<array{Name:string, Values:array<string>}>, Marker?:string, MaxRecords?:int} $args
     * @return \GuzzleHttp\Promise\Promise<array{Marker?:string, Requests?:array<array{Status?:string, RequestIdentifier?:string, MigrationProjectArn?:string, Error?:array{defaultErrorDetails?:array{Message?:string}}, ExportSqlDetails?:array{S3ObjectKey?:string, ObjectURL?:string}}>}>
     */
    public function describeMetadataModelConversionsAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{MigrationProjectIdentifier:string, Filters?:array<array{Name:string, Values:array<string>}>, Marker?:string, MaxRecords?:int} $args
     * @return \AWS\Result<array{Marker?:string, Requests?:array<array{Status?:string, RequestIdentifier?:string, MigrationProjectArn?:string, Error?:array{defaultErrorDetails?:array{Message?:string}}, ExportSqlDetails?:array{S3ObjectKey?:string, ObjectURL?:string}}>}>
     */
    public function describeMetadataModelExportsAsScript(array $args): \AWS\Result { }

    /**
     * @param array{MigrationProjectIdentifier:string, Filters?:array<array{Name:string, Values:array<string>}>, Marker?:string, MaxRecords?:int} $args
     * @return \GuzzleHttp\Promise\Promise<array{Marker?:string, Requests?:array<array{Status?:string, RequestIdentifier?:string, MigrationProjectArn?:string, Error?:array{defaultErrorDetails?:array{Message?:string}}, ExportSqlDetails?:array{S3ObjectKey?:string, ObjectURL?:string}}>}>
     */
    public function describeMetadataModelExportsAsScriptAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{MigrationProjectIdentifier:string, Filters?:array<array{Name:string, Values:array<string>}>, Marker?:string, MaxRecords?:int} $args
     * @return \AWS\Result<array{Marker?:string, Requests?:array<array{Status?:string, RequestIdentifier?:string, MigrationProjectArn?:string, Error?:array{defaultErrorDetails?:array{Message?:string}}, ExportSqlDetails?:array{S3ObjectKey?:string, ObjectURL?:string}}>}>
     */
    public function describeMetadataModelExportsToTarget(array $args): \AWS\Result { }

    /**
     * @param array{MigrationProjectIdentifier:string, Filters?:array<array{Name:string, Values:array<string>}>, Marker?:string, MaxRecords?:int} $args
     * @return \GuzzleHttp\Promise\Promise<array{Marker?:string, Requests?:array<array{Status?:string, RequestIdentifier?:string, MigrationProjectArn?:string, Error?:array{defaultErrorDetails?:array{Message?:string}}, ExportSqlDetails?:array{S3ObjectKey?:string, ObjectURL?:string}}>}>
     */
    public function describeMetadataModelExportsToTargetAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{MigrationProjectIdentifier:string, Filters?:array<array{Name:string, Values:array<string>}>, Marker?:string, MaxRecords?:int} $args
     * @return \AWS\Result<array{Marker?:string, Requests?:array<array{Status?:string, RequestIdentifier?:string, MigrationProjectArn?:string, Error?:array{defaultErrorDetails?:array{Message?:string}}, ExportSqlDetails?:array{S3ObjectKey?:string, ObjectURL?:string}}>}>
     */
    public function describeMetadataModelImports(array $args): \AWS\Result { }

    /**
     * @param array{MigrationProjectIdentifier:string, Filters?:array<array{Name:string, Values:array<string>}>, Marker?:string, MaxRecords?:int} $args
     * @return \GuzzleHttp\Promise\Promise<array{Marker?:string, Requests?:array<array{Status?:string, RequestIdentifier?:string, MigrationProjectArn?:string, Error?:array{defaultErrorDetails?:array{Message?:string}}, ExportSqlDetails?:array{S3ObjectKey?:string, ObjectURL?:string}}>}>
     */
    public function describeMetadataModelImportsAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Filters?:array<array{Name:string, Values:array<string>}>, MaxRecords?:int, Marker?:string} $args
     * @return \AWS\Result<array{Marker?:string, MigrationProjects?:array<array{MigrationProjectName?:string, MigrationProjectArn?:string, MigrationProjectCreationTime?:int|string|\DateTimeInterface, SourceDataProviderDescriptors?:array<array{SecretsManagerSecretId?:string, SecretsManagerAccessRoleArn?:string, DataProviderName?:string, DataProviderArn?:string}>, TargetDataProviderDescriptors?:array<array{SecretsManagerSecretId?:string, SecretsManagerAccessRoleArn?:string, DataProviderName?:string, DataProviderArn?:string}>, InstanceProfileArn?:string, InstanceProfileName?:string, TransformationRules?:string, Description?:string, SchemaConversionApplicationAttributes?:array{S3BucketPath?:string, S3BucketRoleArn?:string}}>}>
     */
    public function describeMigrationProjects(array $args = []): \AWS\Result { }

    /**
     * @param array{Filters?:array<array{Name:string, Values:array<string>}>, MaxRecords?:int, Marker?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Marker?:string, MigrationProjects?:array<array{MigrationProjectName?:string, MigrationProjectArn?:string, MigrationProjectCreationTime?:int|string|\DateTimeInterface, SourceDataProviderDescriptors?:array<array{SecretsManagerSecretId?:string, SecretsManagerAccessRoleArn?:string, DataProviderName?:string, DataProviderArn?:string}>, TargetDataProviderDescriptors?:array<array{SecretsManagerSecretId?:string, SecretsManagerAccessRoleArn?:string, DataProviderName?:string, DataProviderArn?:string}>, InstanceProfileArn?:string, InstanceProfileName?:string, TransformationRules?:string, Description?:string, SchemaConversionApplicationAttributes?:array{S3BucketPath?:string, S3BucketRoleArn?:string}}>}>
     */
    public function describeMigrationProjectsAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{MaxRecords?:int, Marker?:string} $args
     * @return \AWS\Result<array{OrderableReplicationInstances?:array<array{EngineVersion?:string, ReplicationInstanceClass?:string, StorageType?:string, MinAllocatedStorage?:int, MaxAllocatedStorage?:int, DefaultAllocatedStorage?:int, IncludedAllocatedStorage?:int, AvailabilityZones?:array<string>, ReleaseStatus?:"beta"|"prod"}>, Marker?:string}>
     */
    public function describeOrderableReplicationInstances(array $args = []): \AWS\Result { }

    /**
     * @param array{MaxRecords?:int, Marker?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{OrderableReplicationInstances?:array<array{EngineVersion?:string, ReplicationInstanceClass?:string, StorageType?:string, MinAllocatedStorage?:int, MaxAllocatedStorage?:int, DefaultAllocatedStorage?:int, IncludedAllocatedStorage?:int, AvailabilityZones?:array<string>, ReleaseStatus?:"beta"|"prod"}>, Marker?:string}>
     */
    public function describeOrderableReplicationInstancesAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ReplicationInstanceArn?:string, Filters?:array<array{Name:string, Values:array<string>}>, Marker?:string, MaxRecords?:int} $args
     * @return \AWS\Result<array{PendingMaintenanceActions?:array<array{ResourceIdentifier?:string, PendingMaintenanceActionDetails?:array<array{Action?:string, AutoAppliedAfterDate?:int|string|\DateTimeInterface, ForcedApplyDate?:int|string|\DateTimeInterface, OptInStatus?:string, CurrentApplyDate?:int|string|\DateTimeInterface, Description?:string}>}>, Marker?:string}>
     */
    public function describePendingMaintenanceActions(array $args = []): \AWS\Result { }

    /**
     * @param array{ReplicationInstanceArn?:string, Filters?:array<array{Name:string, Values:array<string>}>, Marker?:string, MaxRecords?:int} $args
     * @return \GuzzleHttp\Promise\Promise<array{PendingMaintenanceActions?:array<array{ResourceIdentifier?:string, PendingMaintenanceActionDetails?:array<array{Action?:string, AutoAppliedAfterDate?:int|string|\DateTimeInterface, ForcedApplyDate?:int|string|\DateTimeInterface, OptInStatus?:string, CurrentApplyDate?:int|string|\DateTimeInterface, Description?:string}>}>, Marker?:string}>
     */
    public function describePendingMaintenanceActionsAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Filters?:array<array{Name:string, Values:array<string>}>, MaxRecords?:int, NextToken?:string} $args
     * @return \AWS\Result<array{NextToken?:string, Limitations?:array<array{DatabaseId?:string, EngineName?:string, Name?:string, Description?:string, Impact?:string, Type?:string}>}>
     */
    public function describeRecommendationLimitations(array $args = []): \AWS\Result { }

    /**
     * @param array{Filters?:array<array{Name:string, Values:array<string>}>, MaxRecords?:int, NextToken?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{NextToken?:string, Limitations?:array<array{DatabaseId?:string, EngineName?:string, Name?:string, Description?:string, Impact?:string, Type?:string}>}>
     */
    public function describeRecommendationLimitationsAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Filters?:array<array{Name:string, Values:array<string>}>, MaxRecords?:int, NextToken?:string} $args
     * @return \AWS\Result<array{NextToken?:string, Recommendations?:array<array{DatabaseId?:string, EngineName?:string, CreatedDate?:string, Status?:string, Preferred?:bool, Settings?:array{InstanceSizingType:string, WorkloadType:string}, Data?:array{RdsEngine?:array{RequirementsToTarget?:array{EngineEdition?:string, InstanceVcpu?:float, InstanceMemory?:float, StorageSize?:int, StorageIops?:int, DeploymentOption?:string, EngineVersion?:string}, TargetConfiguration?:array{EngineEdition?:string, InstanceType?:string, InstanceVcpu?:float, InstanceMemory?:float, StorageType?:string, StorageSize?:int, StorageIops?:int, DeploymentOption?:string, EngineVersion?:string}}}}>}>
     */
    public function describeRecommendations(array $args = []): \AWS\Result { }

    /**
     * @param array{Filters?:array<array{Name:string, Values:array<string>}>, MaxRecords?:int, NextToken?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{NextToken?:string, Recommendations?:array<array{DatabaseId?:string, EngineName?:string, CreatedDate?:string, Status?:string, Preferred?:bool, Settings?:array{InstanceSizingType:string, WorkloadType:string}, Data?:array{RdsEngine?:array{RequirementsToTarget?:array{EngineEdition?:string, InstanceVcpu?:float, InstanceMemory?:float, StorageSize?:int, StorageIops?:int, DeploymentOption?:string, EngineVersion?:string}, TargetConfiguration?:array{EngineEdition?:string, InstanceType?:string, InstanceVcpu?:float, InstanceMemory?:float, StorageType?:string, StorageSize?:int, StorageIops?:int, DeploymentOption?:string, EngineVersion?:string}}}}>}>
     */
    public function describeRecommendationsAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{EndpointArn:string} $args
     * @return \AWS\Result<array{RefreshSchemasStatus?:array{EndpointArn?:string, ReplicationInstanceArn?:string, Status?:"successful"|"failed"|"refreshing", LastRefreshDate?:int|string|\DateTimeInterface, LastFailureMessage?:string}}>
     */
    public function describeRefreshSchemasStatus(array $args): \AWS\Result { }

    /**
     * @param array{EndpointArn:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{RefreshSchemasStatus?:array{EndpointArn?:string, ReplicationInstanceArn?:string, Status?:"successful"|"failed"|"refreshing", LastRefreshDate?:int|string|\DateTimeInterface, LastFailureMessage?:string}}>
     */
    public function describeRefreshSchemasStatusAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Filters?:array<array{Name:string, Values:array<string>}>, MaxRecords?:int, Marker?:string} $args
     * @return \AWS\Result<array{Marker?:string, ReplicationConfigs?:array<array{ReplicationConfigIdentifier?:string, ReplicationConfigArn?:string, SourceEndpointArn?:string, TargetEndpointArn?:string, ReplicationType?:"full-load"|"cdc"|"full-load-and-cdc", ComputeConfig?:array{AvailabilityZone?:string, DnsNameServers?:string, KmsKeyId?:string, MaxCapacityUnits?:int, MinCapacityUnits?:int, MultiAZ?:bool, PreferredMaintenanceWindow?:string, ReplicationSubnetGroupId?:string, VpcSecurityGroupIds?:array<string>}, ReplicationSettings?:string, SupplementalSettings?:string, TableMappings?:string, ReplicationConfigCreateTime?:int|string|\DateTimeInterface, ReplicationConfigUpdateTime?:int|string|\DateTimeInterface}>}>
     */
    public function describeReplicationConfigs(array $args = []): \AWS\Result { }

    /**
     * @param array{Filters?:array<array{Name:string, Values:array<string>}>, MaxRecords?:int, Marker?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Marker?:string, ReplicationConfigs?:array<array{ReplicationConfigIdentifier?:string, ReplicationConfigArn?:string, SourceEndpointArn?:string, TargetEndpointArn?:string, ReplicationType?:"full-load"|"cdc"|"full-load-and-cdc", ComputeConfig?:array{AvailabilityZone?:string, DnsNameServers?:string, KmsKeyId?:string, MaxCapacityUnits?:int, MinCapacityUnits?:int, MultiAZ?:bool, PreferredMaintenanceWindow?:string, ReplicationSubnetGroupId?:string, VpcSecurityGroupIds?:array<string>}, ReplicationSettings?:string, SupplementalSettings?:string, TableMappings?:string, ReplicationConfigCreateTime?:int|string|\DateTimeInterface, ReplicationConfigUpdateTime?:int|string|\DateTimeInterface}>}>
     */
    public function describeReplicationConfigsAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ReplicationInstanceArn:string, MaxRecords?:int, Marker?:string} $args
     * @return \AWS\Result<array{ReplicationInstanceArn?:string, ReplicationInstanceTaskLogs?:array<array{ReplicationTaskName?:string, ReplicationTaskArn?:string, ReplicationInstanceTaskLogSize?:int}>, Marker?:string}>
     */
    public function describeReplicationInstanceTaskLogs(array $args): \AWS\Result { }

    /**
     * @param array{ReplicationInstanceArn:string, MaxRecords?:int, Marker?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{ReplicationInstanceArn?:string, ReplicationInstanceTaskLogs?:array<array{ReplicationTaskName?:string, ReplicationTaskArn?:string, ReplicationInstanceTaskLogSize?:int}>, Marker?:string}>
     */
    public function describeReplicationInstanceTaskLogsAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Filters?:array<array{Name:string, Values:array<string>}>, MaxRecords?:int, Marker?:string} $args
     * @return \AWS\Result<array{Marker?:string, ReplicationInstances?:array<array{ReplicationInstanceIdentifier?:string, ReplicationInstanceClass?:string, ReplicationInstanceStatus?:string, AllocatedStorage?:int, InstanceCreateTime?:int|string|\DateTimeInterface, VpcSecurityGroups?:array<array{VpcSecurityGroupId?:string, Status?:string}>, AvailabilityZone?:string, ReplicationSubnetGroup?:array{ReplicationSubnetGroupIdentifier?:string, ReplicationSubnetGroupDescription?:string, VpcId?:string, SubnetGroupStatus?:string, Subnets?:array<array{SubnetIdentifier?:string, SubnetAvailabilityZone?:array{Name?:string}, SubnetStatus?:string}>, SupportedNetworkTypes?:array<string>}, PreferredMaintenanceWindow?:string, PendingModifiedValues?:array{ReplicationInstanceClass?:string, AllocatedStorage?:int, MultiAZ?:bool, EngineVersion?:string, NetworkType?:string}, MultiAZ?:bool, EngineVersion?:string, AutoMinorVersionUpgrade?:bool, KmsKeyId?:string, ReplicationInstanceArn?:string, ReplicationInstancePublicIpAddress?:string, ReplicationInstancePrivateIpAddress?:string, ReplicationInstancePublicIpAddresses?:array<string>, ReplicationInstancePrivateIpAddresses?:array<string>, ReplicationInstanceIpv6Addresses?:array<string>, PubliclyAccessible?:bool, SecondaryAvailabilityZone?:string, FreeUntil?:int|string|\DateTimeInterface, DnsNameServers?:string, NetworkType?:string, KerberosAuthenticationSettings?:array{KeyCacheSecretId?:string, KeyCacheSecretIamArn?:string, Krb5FileContents?:string}}>}>
     */
    public function describeReplicationInstances(array $args = []): \AWS\Result { }

    /**
     * @param array{Filters?:array<array{Name:string, Values:array<string>}>, MaxRecords?:int, Marker?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Marker?:string, ReplicationInstances?:array<array{ReplicationInstanceIdentifier?:string, ReplicationInstanceClass?:string, ReplicationInstanceStatus?:string, AllocatedStorage?:int, InstanceCreateTime?:int|string|\DateTimeInterface, VpcSecurityGroups?:array<array{VpcSecurityGroupId?:string, Status?:string}>, AvailabilityZone?:string, ReplicationSubnetGroup?:array{ReplicationSubnetGroupIdentifier?:string, ReplicationSubnetGroupDescription?:string, VpcId?:string, SubnetGroupStatus?:string, Subnets?:array<array{SubnetIdentifier?:string, SubnetAvailabilityZone?:array{Name?:string}, SubnetStatus?:string}>, SupportedNetworkTypes?:array<string>}, PreferredMaintenanceWindow?:string, PendingModifiedValues?:array{ReplicationInstanceClass?:string, AllocatedStorage?:int, MultiAZ?:bool, EngineVersion?:string, NetworkType?:string}, MultiAZ?:bool, EngineVersion?:string, AutoMinorVersionUpgrade?:bool, KmsKeyId?:string, ReplicationInstanceArn?:string, ReplicationInstancePublicIpAddress?:string, ReplicationInstancePrivateIpAddress?:string, ReplicationInstancePublicIpAddresses?:array<string>, ReplicationInstancePrivateIpAddresses?:array<string>, ReplicationInstanceIpv6Addresses?:array<string>, PubliclyAccessible?:bool, SecondaryAvailabilityZone?:string, FreeUntil?:int|string|\DateTimeInterface, DnsNameServers?:string, NetworkType?:string, KerberosAuthenticationSettings?:array{KeyCacheSecretId?:string, KeyCacheSecretIamArn?:string, Krb5FileContents?:string}}>}>
     */
    public function describeReplicationInstancesAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Filters?:array<array{Name:string, Values:array<string>}>, MaxRecords?:int, Marker?:string} $args
     * @return \AWS\Result<array{Marker?:string, ReplicationSubnetGroups?:array<array{ReplicationSubnetGroupIdentifier?:string, ReplicationSubnetGroupDescription?:string, VpcId?:string, SubnetGroupStatus?:string, Subnets?:array<array{SubnetIdentifier?:string, SubnetAvailabilityZone?:array{Name?:string}, SubnetStatus?:string}>, SupportedNetworkTypes?:array<string>}>}>
     */
    public function describeReplicationSubnetGroups(array $args = []): \AWS\Result { }

    /**
     * @param array{Filters?:array<array{Name:string, Values:array<string>}>, MaxRecords?:int, Marker?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Marker?:string, ReplicationSubnetGroups?:array<array{ReplicationSubnetGroupIdentifier?:string, ReplicationSubnetGroupDescription?:string, VpcId?:string, SubnetGroupStatus?:string, Subnets?:array<array{SubnetIdentifier?:string, SubnetAvailabilityZone?:array{Name?:string}, SubnetStatus?:string}>, SupportedNetworkTypes?:array<string>}>}>
     */
    public function describeReplicationSubnetGroupsAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ReplicationConfigArn:string, MaxRecords?:int, Marker?:string, Filters?:array<array{Name:string, Values:array<string>}>} $args
     * @return \AWS\Result<array{ReplicationConfigArn?:string, Marker?:string, ReplicationTableStatistics?:array<array{SchemaName?:string, TableName?:string, Inserts?:int, Deletes?:int, Updates?:int, Ddls?:int, AppliedInserts?:int, AppliedDeletes?:int, AppliedUpdates?:int, AppliedDdls?:int, FullLoadRows?:int, FullLoadCondtnlChkFailedRows?:int, FullLoadErrorRows?:int, FullLoadStartTime?:int|string|\DateTimeInterface, FullLoadEndTime?:int|string|\DateTimeInterface, FullLoadReloaded?:bool, LastUpdateTime?:int|string|\DateTimeInterface, TableState?:string, ValidationPendingRecords?:int, ValidationFailedRecords?:int, ValidationSuspendedRecords?:int, ValidationState?:string, ValidationStateDetails?:string}>}>
     */
    public function describeReplicationTableStatistics(array $args): \AWS\Result { }

    /**
     * @param array{ReplicationConfigArn:string, MaxRecords?:int, Marker?:string, Filters?:array<array{Name:string, Values:array<string>}>} $args
     * @return \GuzzleHttp\Promise\Promise<array{ReplicationConfigArn?:string, Marker?:string, ReplicationTableStatistics?:array<array{SchemaName?:string, TableName?:string, Inserts?:int, Deletes?:int, Updates?:int, Ddls?:int, AppliedInserts?:int, AppliedDeletes?:int, AppliedUpdates?:int, AppliedDdls?:int, FullLoadRows?:int, FullLoadCondtnlChkFailedRows?:int, FullLoadErrorRows?:int, FullLoadStartTime?:int|string|\DateTimeInterface, FullLoadEndTime?:int|string|\DateTimeInterface, FullLoadReloaded?:bool, LastUpdateTime?:int|string|\DateTimeInterface, TableState?:string, ValidationPendingRecords?:int, ValidationFailedRecords?:int, ValidationSuspendedRecords?:int, ValidationState?:string, ValidationStateDetails?:string}>}>
     */
    public function describeReplicationTableStatisticsAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ReplicationTaskArn?:string, MaxRecords?:int, Marker?:string} $args
     * @return \AWS\Result<array{Marker?:string, BucketName?:string, ReplicationTaskAssessmentResults?:array<array{ReplicationTaskIdentifier?:string, ReplicationTaskArn?:string, ReplicationTaskLastAssessmentDate?:int|string|\DateTimeInterface, AssessmentStatus?:string, AssessmentResultsFile?:string, AssessmentResults?:string, S3ObjectUrl?:string}>}>
     */
    public function describeReplicationTaskAssessmentResults(array $args = []): \AWS\Result { }

    /**
     * @param array{ReplicationTaskArn?:string, MaxRecords?:int, Marker?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Marker?:string, BucketName?:string, ReplicationTaskAssessmentResults?:array<array{ReplicationTaskIdentifier?:string, ReplicationTaskArn?:string, ReplicationTaskLastAssessmentDate?:int|string|\DateTimeInterface, AssessmentStatus?:string, AssessmentResultsFile?:string, AssessmentResults?:string, S3ObjectUrl?:string}>}>
     */
    public function describeReplicationTaskAssessmentResultsAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Filters?:array<array{Name:string, Values:array<string>}>, MaxRecords?:int, Marker?:string} $args
     * @return \AWS\Result<array{Marker?:string, ReplicationTaskAssessmentRuns?:array<array{ReplicationTaskAssessmentRunArn?:string, ReplicationTaskArn?:string, Status?:string, ReplicationTaskAssessmentRunCreationDate?:int|string|\DateTimeInterface, AssessmentProgress?:array{IndividualAssessmentCount?:int, IndividualAssessmentCompletedCount?:int}, LastFailureMessage?:string, ServiceAccessRoleArn?:string, ResultLocationBucket?:string, ResultLocationFolder?:string, ResultEncryptionMode?:string, ResultKmsKeyArn?:string, AssessmentRunName?:string, IsLatestTaskAssessmentRun?:bool, ResultStatistic?:array{Passed?:int, Failed?:int, Error?:int, Warning?:int, Cancelled?:int}}>}>
     */
    public function describeReplicationTaskAssessmentRuns(array $args = []): \AWS\Result { }

    /**
     * @param array{Filters?:array<array{Name:string, Values:array<string>}>, MaxRecords?:int, Marker?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Marker?:string, ReplicationTaskAssessmentRuns?:array<array{ReplicationTaskAssessmentRunArn?:string, ReplicationTaskArn?:string, Status?:string, ReplicationTaskAssessmentRunCreationDate?:int|string|\DateTimeInterface, AssessmentProgress?:array{IndividualAssessmentCount?:int, IndividualAssessmentCompletedCount?:int}, LastFailureMessage?:string, ServiceAccessRoleArn?:string, ResultLocationBucket?:string, ResultLocationFolder?:string, ResultEncryptionMode?:string, ResultKmsKeyArn?:string, AssessmentRunName?:string, IsLatestTaskAssessmentRun?:bool, ResultStatistic?:array{Passed?:int, Failed?:int, Error?:int, Warning?:int, Cancelled?:int}}>}>
     */
    public function describeReplicationTaskAssessmentRunsAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Filters?:array<array{Name:string, Values:array<string>}>, MaxRecords?:int, Marker?:string} $args
     * @return \AWS\Result<array{Marker?:string, ReplicationTaskIndividualAssessments?:array<array{ReplicationTaskIndividualAssessmentArn?:string, ReplicationTaskAssessmentRunArn?:string, IndividualAssessmentName?:string, Status?:string, ReplicationTaskIndividualAssessmentStartDate?:int|string|\DateTimeInterface}>}>
     */
    public function describeReplicationTaskIndividualAssessments(array $args = []): \AWS\Result { }

    /**
     * @param array{Filters?:array<array{Name:string, Values:array<string>}>, MaxRecords?:int, Marker?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Marker?:string, ReplicationTaskIndividualAssessments?:array<array{ReplicationTaskIndividualAssessmentArn?:string, ReplicationTaskAssessmentRunArn?:string, IndividualAssessmentName?:string, Status?:string, ReplicationTaskIndividualAssessmentStartDate?:int|string|\DateTimeInterface}>}>
     */
    public function describeReplicationTaskIndividualAssessmentsAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Filters?:array<array{Name:string, Values:array<string>}>, MaxRecords?:int, Marker?:string, WithoutSettings?:bool} $args
     * @return \AWS\Result<array{Marker?:string, ReplicationTasks?:array<array{ReplicationTaskIdentifier?:string, SourceEndpointArn?:string, TargetEndpointArn?:string, ReplicationInstanceArn?:string, MigrationType?:"full-load"|"cdc"|"full-load-and-cdc", TableMappings?:string, ReplicationTaskSettings?:string, Status?:string, LastFailureMessage?:string, StopReason?:string, ReplicationTaskCreationDate?:int|string|\DateTimeInterface, ReplicationTaskStartDate?:int|string|\DateTimeInterface, CdcStartPosition?:string, CdcStopPosition?:string, RecoveryCheckpoint?:string, ReplicationTaskArn?:string, ReplicationTaskStats?:array{FullLoadProgressPercent?:int, ElapsedTimeMillis?:int, TablesLoaded?:int, TablesLoading?:int, TablesQueued?:int, TablesErrored?:int, FreshStartDate?:int|string|\DateTimeInterface, StartDate?:int|string|\DateTimeInterface, StopDate?:int|string|\DateTimeInterface, FullLoadStartDate?:int|string|\DateTimeInterface, FullLoadFinishDate?:int|string|\DateTimeInterface}, TaskData?:string, TargetReplicationInstanceArn?:string}>}>
     */
    public function describeReplicationTasks(array $args = []): \AWS\Result { }

    /**
     * @param array{Filters?:array<array{Name:string, Values:array<string>}>, MaxRecords?:int, Marker?:string, WithoutSettings?:bool} $args
     * @return \GuzzleHttp\Promise\Promise<array{Marker?:string, ReplicationTasks?:array<array{ReplicationTaskIdentifier?:string, SourceEndpointArn?:string, TargetEndpointArn?:string, ReplicationInstanceArn?:string, MigrationType?:"full-load"|"cdc"|"full-load-and-cdc", TableMappings?:string, ReplicationTaskSettings?:string, Status?:string, LastFailureMessage?:string, StopReason?:string, ReplicationTaskCreationDate?:int|string|\DateTimeInterface, ReplicationTaskStartDate?:int|string|\DateTimeInterface, CdcStartPosition?:string, CdcStopPosition?:string, RecoveryCheckpoint?:string, ReplicationTaskArn?:string, ReplicationTaskStats?:array{FullLoadProgressPercent?:int, ElapsedTimeMillis?:int, TablesLoaded?:int, TablesLoading?:int, TablesQueued?:int, TablesErrored?:int, FreshStartDate?:int|string|\DateTimeInterface, StartDate?:int|string|\DateTimeInterface, StopDate?:int|string|\DateTimeInterface, FullLoadStartDate?:int|string|\DateTimeInterface, FullLoadFinishDate?:int|string|\DateTimeInterface}, TaskData?:string, TargetReplicationInstanceArn?:string}>}>
     */
    public function describeReplicationTasksAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{Filters?:array<array{Name:string, Values:array<string>}>, MaxRecords?:int, Marker?:string} $args
     * @return \AWS\Result<array{Marker?:string, Replications?:array<array{ReplicationConfigIdentifier?:string, ReplicationConfigArn?:string, SourceEndpointArn?:string, TargetEndpointArn?:string, ReplicationType?:"full-load"|"cdc"|"full-load-and-cdc", Status?:string, ProvisionData?:array{ProvisionState?:string, ProvisionedCapacityUnits?:int, DateProvisioned?:int|string|\DateTimeInterface, IsNewProvisioningAvailable?:bool, DateNewProvisioningDataAvailable?:int|string|\DateTimeInterface, ReasonForNewProvisioningData?:string}, StopReason?:string, FailureMessages?:array<string>, ReplicationStats?:array{FullLoadProgressPercent?:int, ElapsedTimeMillis?:int, TablesLoaded?:int, TablesLoading?:int, TablesQueued?:int, TablesErrored?:int, FreshStartDate?:int|string|\DateTimeInterface, StartDate?:int|string|\DateTimeInterface, StopDate?:int|string|\DateTimeInterface, FullLoadStartDate?:int|string|\DateTimeInterface, FullLoadFinishDate?:int|string|\DateTimeInterface}, StartReplicationType?:string, CdcStartTime?:int|string|\DateTimeInterface, CdcStartPosition?:string, CdcStopPosition?:string, RecoveryCheckpoint?:string, ReplicationCreateTime?:int|string|\DateTimeInterface, ReplicationUpdateTime?:int|string|\DateTimeInterface, ReplicationLastStopTime?:int|string|\DateTimeInterface, ReplicationDeprovisionTime?:int|string|\DateTimeInterface}>}>
     */
    public function describeReplications(array $args = []): \AWS\Result { }

    /**
     * @param array{Filters?:array<array{Name:string, Values:array<string>}>, MaxRecords?:int, Marker?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Marker?:string, Replications?:array<array{ReplicationConfigIdentifier?:string, ReplicationConfigArn?:string, SourceEndpointArn?:string, TargetEndpointArn?:string, ReplicationType?:"full-load"|"cdc"|"full-load-and-cdc", Status?:string, ProvisionData?:array{ProvisionState?:string, ProvisionedCapacityUnits?:int, DateProvisioned?:int|string|\DateTimeInterface, IsNewProvisioningAvailable?:bool, DateNewProvisioningDataAvailable?:int|string|\DateTimeInterface, ReasonForNewProvisioningData?:string}, StopReason?:string, FailureMessages?:array<string>, ReplicationStats?:array{FullLoadProgressPercent?:int, ElapsedTimeMillis?:int, TablesLoaded?:int, TablesLoading?:int, TablesQueued?:int, TablesErrored?:int, FreshStartDate?:int|string|\DateTimeInterface, StartDate?:int|string|\DateTimeInterface, StopDate?:int|string|\DateTimeInterface, FullLoadStartDate?:int|string|\DateTimeInterface, FullLoadFinishDate?:int|string|\DateTimeInterface}, StartReplicationType?:string, CdcStartTime?:int|string|\DateTimeInterface, CdcStartPosition?:string, CdcStopPosition?:string, RecoveryCheckpoint?:string, ReplicationCreateTime?:int|string|\DateTimeInterface, ReplicationUpdateTime?:int|string|\DateTimeInterface, ReplicationLastStopTime?:int|string|\DateTimeInterface, ReplicationDeprovisionTime?:int|string|\DateTimeInterface}>}>
     */
    public function describeReplicationsAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{EndpointArn:string, MaxRecords?:int, Marker?:string} $args
     * @return \AWS\Result<array{Marker?:string, Schemas?:array<string>}>
     */
    public function describeSchemas(array $args): \AWS\Result { }

    /**
     * @param array{EndpointArn:string, MaxRecords?:int, Marker?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Marker?:string, Schemas?:array<string>}>
     */
    public function describeSchemasAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ReplicationTaskArn:string, MaxRecords?:int, Marker?:string, Filters?:array<array{Name:string, Values:array<string>}>} $args
     * @return \AWS\Result<array{ReplicationTaskArn?:string, TableStatistics?:array<array{SchemaName?:string, TableName?:string, Inserts?:int, Deletes?:int, Updates?:int, Ddls?:int, AppliedInserts?:int, AppliedDeletes?:int, AppliedUpdates?:int, AppliedDdls?:int, FullLoadRows?:int, FullLoadCondtnlChkFailedRows?:int, FullLoadErrorRows?:int, FullLoadStartTime?:int|string|\DateTimeInterface, FullLoadEndTime?:int|string|\DateTimeInterface, FullLoadReloaded?:bool, LastUpdateTime?:int|string|\DateTimeInterface, TableState?:string, ValidationPendingRecords?:int, ValidationFailedRecords?:int, ValidationSuspendedRecords?:int, ValidationState?:string, ValidationStateDetails?:string}>, Marker?:string}>
     */
    public function describeTableStatistics(array $args): \AWS\Result { }

    /**
     * @param array{ReplicationTaskArn:string, MaxRecords?:int, Marker?:string, Filters?:array<array{Name:string, Values:array<string>}>} $args
     * @return \GuzzleHttp\Promise\Promise<array{ReplicationTaskArn?:string, TableStatistics?:array<array{SchemaName?:string, TableName?:string, Inserts?:int, Deletes?:int, Updates?:int, Ddls?:int, AppliedInserts?:int, AppliedDeletes?:int, AppliedUpdates?:int, AppliedDdls?:int, FullLoadRows?:int, FullLoadCondtnlChkFailedRows?:int, FullLoadErrorRows?:int, FullLoadStartTime?:int|string|\DateTimeInterface, FullLoadEndTime?:int|string|\DateTimeInterface, FullLoadReloaded?:bool, LastUpdateTime?:int|string|\DateTimeInterface, TableState?:string, ValidationPendingRecords?:int, ValidationFailedRecords?:int, ValidationSuspendedRecords?:int, ValidationState?:string, ValidationStateDetails?:string}>, Marker?:string}>
     */
    public function describeTableStatisticsAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{MigrationProjectIdentifier:string, SelectionRules:string, FileName?:string, AssessmentReportTypes?:array<"pdf"|"csv">} $args
     * @return \AWS\Result<array{PdfReport?:array{S3ObjectKey?:string, ObjectURL?:string}, CsvReport?:array{S3ObjectKey?:string, ObjectURL?:string}}>
     */
    public function exportMetadataModelAssessment(array $args): \AWS\Result { }

    /**
     * @param array{MigrationProjectIdentifier:string, SelectionRules:string, FileName?:string, AssessmentReportTypes?:array<"pdf"|"csv">} $args
     * @return \GuzzleHttp\Promise\Promise<array{PdfReport?:array{S3ObjectKey?:string, ObjectURL?:string}, CsvReport?:array{S3ObjectKey?:string, ObjectURL?:string}}>
     */
    public function exportMetadataModelAssessmentAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{CertificateIdentifier:string, CertificatePem?:string, CertificateWallet?:string|resource|\Psr\Http\Message\StreamInterface, Tags?:array<array{Key?:string, Value?:string, ResourceArn?:string}>} $args
     * @return \AWS\Result<array{Certificate?:array{CertificateIdentifier?:string, CertificateCreationDate?:int|string|\DateTimeInterface, CertificatePem?:string, CertificateWallet?:string|resource|\Psr\Http\Message\StreamInterface, CertificateArn?:string, CertificateOwner?:string, ValidFromDate?:int|string|\DateTimeInterface, ValidToDate?:int|string|\DateTimeInterface, SigningAlgorithm?:string, KeyLength?:int}}>
     */
    public function importCertificate(array $args): \AWS\Result { }

    /**
     * @param array{CertificateIdentifier:string, CertificatePem?:string, CertificateWallet?:string|resource|\Psr\Http\Message\StreamInterface, Tags?:array<array{Key?:string, Value?:string, ResourceArn?:string}>} $args
     * @return \GuzzleHttp\Promise\Promise<array{Certificate?:array{CertificateIdentifier?:string, CertificateCreationDate?:int|string|\DateTimeInterface, CertificatePem?:string, CertificateWallet?:string|resource|\Psr\Http\Message\StreamInterface, CertificateArn?:string, CertificateOwner?:string, ValidFromDate?:int|string|\DateTimeInterface, ValidToDate?:int|string|\DateTimeInterface, SigningAlgorithm?:string, KeyLength?:int}}>
     */
    public function importCertificateAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ResourceArn?:string, ResourceArnList?:array<string>} $args
     * @return \AWS\Result<array{TagList?:array<array{Key?:string, Value?:string, ResourceArn?:string}>}>
     */
    public function listTagsForResource(array $args = []): \AWS\Result { }

    /**
     * @param array{ResourceArn?:string, ResourceArnList?:array<string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{TagList?:array<array{Key?:string, Value?:string, ResourceArn?:string}>}>
     */
    public function listTagsForResourceAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{MigrationProjectIdentifier:string, ConversionConfiguration:string} $args
     * @return \AWS\Result<array{MigrationProjectIdentifier?:string}>
     */
    public function modifyConversionConfiguration(array $args): \AWS\Result { }

    /**
     * @param array{MigrationProjectIdentifier:string, ConversionConfiguration:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{MigrationProjectIdentifier?:string}>
     */
    public function modifyConversionConfigurationAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{DataMigrationIdentifier:string, DataMigrationName?:string, EnableCloudwatchLogs?:bool, ServiceAccessRoleArn?:string, DataMigrationType?:"full-load"|"cdc"|"full-load-and-cdc", SourceDataSettings?:array<array{CDCStartPosition?:string, CDCStartTime?:int|string|\DateTimeInterface, CDCStopTime?:int|string|\DateTimeInterface, SlotName?:string}>, NumberOfJobs?:int, SelectionRules?:string} $args
     * @return \AWS\Result<array{DataMigration?:array{DataMigrationName?:string, DataMigrationArn?:string, DataMigrationCreateTime?:int|string|\DateTimeInterface, DataMigrationStartTime?:int|string|\DateTimeInterface, DataMigrationEndTime?:int|string|\DateTimeInterface, ServiceAccessRoleArn?:string, MigrationProjectArn?:string, DataMigrationType?:"full-load"|"cdc"|"full-load-and-cdc", DataMigrationSettings?:array{NumberOfJobs?:int, CloudwatchLogsEnabled?:bool, SelectionRules?:string}, SourceDataSettings?:array<array{CDCStartPosition?:string, CDCStartTime?:int|string|\DateTimeInterface, CDCStopTime?:int|string|\DateTimeInterface, SlotName?:string}>, DataMigrationStatistics?:array{TablesLoaded?:int, ElapsedTimeMillis?:int, TablesLoading?:int, FullLoadPercentage?:int, CDCLatency?:int, TablesQueued?:int, TablesErrored?:int, StartTime?:int|string|\DateTimeInterface, StopTime?:int|string|\DateTimeInterface}, DataMigrationStatus?:string, PublicIpAddresses?:array<string>, DataMigrationCidrBlocks?:array<string>, LastFailureMessage?:string, StopReason?:string}}>
     */
    public function modifyDataMigration(array $args): \AWS\Result { }

    /**
     * @param array{DataMigrationIdentifier:string, DataMigrationName?:string, EnableCloudwatchLogs?:bool, ServiceAccessRoleArn?:string, DataMigrationType?:"full-load"|"cdc"|"full-load-and-cdc", SourceDataSettings?:array<array{CDCStartPosition?:string, CDCStartTime?:int|string|\DateTimeInterface, CDCStopTime?:int|string|\DateTimeInterface, SlotName?:string}>, NumberOfJobs?:int, SelectionRules?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{DataMigration?:array{DataMigrationName?:string, DataMigrationArn?:string, DataMigrationCreateTime?:int|string|\DateTimeInterface, DataMigrationStartTime?:int|string|\DateTimeInterface, DataMigrationEndTime?:int|string|\DateTimeInterface, ServiceAccessRoleArn?:string, MigrationProjectArn?:string, DataMigrationType?:"full-load"|"cdc"|"full-load-and-cdc", DataMigrationSettings?:array{NumberOfJobs?:int, CloudwatchLogsEnabled?:bool, SelectionRules?:string}, SourceDataSettings?:array<array{CDCStartPosition?:string, CDCStartTime?:int|string|\DateTimeInterface, CDCStopTime?:int|string|\DateTimeInterface, SlotName?:string}>, DataMigrationStatistics?:array{TablesLoaded?:int, ElapsedTimeMillis?:int, TablesLoading?:int, FullLoadPercentage?:int, CDCLatency?:int, TablesQueued?:int, TablesErrored?:int, StartTime?:int|string|\DateTimeInterface, StopTime?:int|string|\DateTimeInterface}, DataMigrationStatus?:string, PublicIpAddresses?:array<string>, DataMigrationCidrBlocks?:array<string>, LastFailureMessage?:string, StopReason?:string}}>
     */
    public function modifyDataMigrationAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{DataProviderIdentifier:string, DataProviderName?:string, Description?:string, Engine?:string, ExactSettings?:bool, Settings?:array{RedshiftSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string}, PostgreSqlSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, MySqlSettings?:array{ServerName?:string, Port?:int, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, OracleSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string, AsmServer?:string, SecretsManagerOracleAsmSecretId?:string, SecretsManagerOracleAsmAccessRoleArn?:string, SecretsManagerSecurityDbEncryptionSecretId?:string, SecretsManagerSecurityDbEncryptionAccessRoleArn?:string}, MicrosoftSqlServerSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, DocDbSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, MariaDbSettings?:array{ServerName?:string, Port?:int, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, MongoDbSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string, AuthType?:"no"|"password", AuthSource?:string, AuthMechanism?:"default"|"mongodb_cr"|"scram_sha_1"}}} $args
     * @return \AWS\Result<array{DataProvider?:array{DataProviderName?:string, DataProviderArn?:string, DataProviderCreationTime?:int|string|\DateTimeInterface, Description?:string, Engine?:string, Settings?:array{RedshiftSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string}, PostgreSqlSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, MySqlSettings?:array{ServerName?:string, Port?:int, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, OracleSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string, AsmServer?:string, SecretsManagerOracleAsmSecretId?:string, SecretsManagerOracleAsmAccessRoleArn?:string, SecretsManagerSecurityDbEncryptionSecretId?:string, SecretsManagerSecurityDbEncryptionAccessRoleArn?:string}, MicrosoftSqlServerSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, DocDbSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, MariaDbSettings?:array{ServerName?:string, Port?:int, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, MongoDbSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string, AuthType?:"no"|"password", AuthSource?:string, AuthMechanism?:"default"|"mongodb_cr"|"scram_sha_1"}}}}>
     */
    public function modifyDataProvider(array $args): \AWS\Result { }

    /**
     * @param array{DataProviderIdentifier:string, DataProviderName?:string, Description?:string, Engine?:string, ExactSettings?:bool, Settings?:array{RedshiftSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string}, PostgreSqlSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, MySqlSettings?:array{ServerName?:string, Port?:int, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, OracleSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string, AsmServer?:string, SecretsManagerOracleAsmSecretId?:string, SecretsManagerOracleAsmAccessRoleArn?:string, SecretsManagerSecurityDbEncryptionSecretId?:string, SecretsManagerSecurityDbEncryptionAccessRoleArn?:string}, MicrosoftSqlServerSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, DocDbSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, MariaDbSettings?:array{ServerName?:string, Port?:int, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, MongoDbSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string, AuthType?:"no"|"password", AuthSource?:string, AuthMechanism?:"default"|"mongodb_cr"|"scram_sha_1"}}} $args
     * @return \GuzzleHttp\Promise\Promise<array{DataProvider?:array{DataProviderName?:string, DataProviderArn?:string, DataProviderCreationTime?:int|string|\DateTimeInterface, Description?:string, Engine?:string, Settings?:array{RedshiftSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string}, PostgreSqlSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, MySqlSettings?:array{ServerName?:string, Port?:int, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, OracleSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string, AsmServer?:string, SecretsManagerOracleAsmSecretId?:string, SecretsManagerOracleAsmAccessRoleArn?:string, SecretsManagerSecurityDbEncryptionSecretId?:string, SecretsManagerSecurityDbEncryptionAccessRoleArn?:string}, MicrosoftSqlServerSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, DocDbSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, MariaDbSettings?:array{ServerName?:string, Port?:int, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string}, MongoDbSettings?:array{ServerName?:string, Port?:int, DatabaseName?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", CertificateArn?:string, AuthType?:"no"|"password", AuthSource?:string, AuthMechanism?:"default"|"mongodb_cr"|"scram_sha_1"}}}}>
     */
    public function modifyDataProviderAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{EndpointArn:string, EndpointIdentifier?:string, EndpointType?:"source"|"target", EngineName?:string, Username?:string, Password?:string, ServerName?:string, Port?:int, DatabaseName?:string, ExtraConnectionAttributes?:string, CertificateArn?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", ServiceAccessRoleArn?:string, ExternalTableDefinition?:string, DynamoDbSettings?:array{ServiceAccessRoleArn:string}, S3Settings?:array{ServiceAccessRoleArn?:string, ExternalTableDefinition?:string, CsvRowDelimiter?:string, CsvDelimiter?:string, BucketFolder?:string, BucketName?:string, CompressionType?:"none"|"gzip", EncryptionMode?:"sse-s3"|"sse-kms", ServerSideEncryptionKmsKeyId?:string, DataFormat?:"csv"|"parquet", EncodingType?:"plain"|"plain-dictionary"|"rle-dictionary", DictPageSizeLimit?:int, RowGroupLength?:int, DataPageSize?:int, ParquetVersion?:"parquet-1-0"|"parquet-2-0", EnableStatistics?:bool, IncludeOpForFullLoad?:bool, CdcInsertsOnly?:bool, TimestampColumnName?:string, ParquetTimestampInMillisecond?:bool, CdcInsertsAndUpdates?:bool, DatePartitionEnabled?:bool, DatePartitionSequence?:"YYYYMMDD"|"YYYYMMDDHH"|"YYYYMM"|"MMYYYYDD"|"DDMMYYYY", DatePartitionDelimiter?:"SLASH"|"UNDERSCORE"|"DASH"|"NONE", UseCsvNoSupValue?:bool, CsvNoSupValue?:string, PreserveTransactions?:bool, CdcPath?:string, UseTaskStartTimeForFullLoadTimestamp?:bool, CannedAclForObjects?:"none"|"private"|"public-read"|"public-read-write"|"authenticated-read"|"aws-exec-read"|"bucket-owner-read"|"bucket-owner-full-control", AddColumnName?:bool, CdcMaxBatchInterval?:int, CdcMinFileSize?:int, CsvNullValue?:string, IgnoreHeaderRows?:int, MaxFileSize?:int, Rfc4180?:bool, DatePartitionTimezone?:string, AddTrailingPaddingCharacter?:bool, ExpectedBucketOwner?:string, GlueCatalogGeneration?:bool}, DmsTransferSettings?:array{ServiceAccessRoleArn?:string, BucketName?:string}, MongoDbSettings?:array{Username?:string, Password?:string, ServerName?:string, Port?:int, DatabaseName?:string, AuthType?:"no"|"password", AuthMechanism?:"default"|"mongodb_cr"|"scram_sha_1", NestingLevel?:"none"|"one", ExtractDocId?:string, DocsToInvestigate?:string, AuthSource?:string, KmsKeyId?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, UseUpdateLookUp?:bool, ReplicateShardCollections?:bool}, KinesisSettings?:array{StreamArn?:string, MessageFormat?:"json"|"json-unformatted", ServiceAccessRoleArn?:string, IncludeTransactionDetails?:bool, IncludePartitionValue?:bool, PartitionIncludeSchemaTable?:bool, IncludeTableAlterOperations?:bool, IncludeControlDetails?:bool, IncludeNullAndEmpty?:bool, NoHexPrefix?:bool, UseLargeIntegerValue?:bool}, KafkaSettings?:array{Broker?:string, Topic?:string, MessageFormat?:"json"|"json-unformatted", IncludeTransactionDetails?:bool, IncludePartitionValue?:bool, PartitionIncludeSchemaTable?:bool, IncludeTableAlterOperations?:bool, IncludeControlDetails?:bool, MessageMaxBytes?:int, IncludeNullAndEmpty?:bool, SecurityProtocol?:"plaintext"|"ssl-authentication"|"ssl-encryption"|"sasl-ssl", SslClientCertificateArn?:string, SslClientKeyArn?:string, SslClientKeyPassword?:string, SslCaCertificateArn?:string, SaslUsername?:string, SaslPassword?:string, NoHexPrefix?:bool, SaslMechanism?:"scram-sha-512"|"plain", SslEndpointIdentificationAlgorithm?:"none"|"https", UseLargeIntegerValue?:bool}, ElasticsearchSettings?:array{ServiceAccessRoleArn:string, EndpointUri:string, FullLoadErrorPercentage?:int, ErrorRetryDuration?:int, UseNewMappingType?:bool}, NeptuneSettings?:array{ServiceAccessRoleArn?:string, S3BucketName:string, S3BucketFolder:string, ErrorRetryDuration?:int, MaxFileSize?:int, MaxRetryCount?:int, IamAuthEnabled?:bool}, RedshiftSettings?:array{AcceptAnyDate?:bool, AfterConnectScript?:string, BucketFolder?:string, BucketName?:string, CaseSensitiveNames?:bool, CompUpdate?:bool, ConnectionTimeout?:int, DatabaseName?:string, DateFormat?:string, EmptyAsNull?:bool, EncryptionMode?:"sse-s3"|"sse-kms", ExplicitIds?:bool, FileTransferUploadStreams?:int, LoadTimeout?:int, MaxFileSize?:int, Password?:string, Port?:int, RemoveQuotes?:bool, ReplaceInvalidChars?:string, ReplaceChars?:string, ServerName?:string, ServiceAccessRoleArn?:string, ServerSideEncryptionKmsKeyId?:string, TimeFormat?:string, TrimBlanks?:bool, TruncateColumns?:bool, Username?:string, WriteBufferSize?:int, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, MapBooleanAsBoolean?:bool}, PostgreSQLSettings?:array{AfterConnectScript?:string, CaptureDdls?:bool, MaxFileSize?:int, DatabaseName?:string, DdlArtifactsSchema?:string, ExecuteTimeout?:int, FailTasksOnLobTruncation?:bool, HeartbeatEnable?:bool, HeartbeatSchema?:string, HeartbeatFrequency?:int, Password?:string, Port?:int, ServerName?:string, Username?:string, SlotName?:string, PluginName?:"no-preference"|"test-decoding"|"pglogical", SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, TrimSpaceInChar?:bool, MapBooleanAsBoolean?:bool, MapJsonbAsClob?:bool, MapLongVarcharAs?:"wstring"|"clob"|"nclob", DatabaseMode?:"default"|"babelfish", BabelfishDatabaseName?:string, DisableUnicodeSourceFilter?:bool}, MySQLSettings?:array{AfterConnectScript?:string, CleanSourceMetadataOnMismatch?:bool, DatabaseName?:string, EventsPollInterval?:int, TargetDbType?:"specific-database"|"multiple-databases", MaxFileSize?:int, ParallelLoadThreads?:int, Password?:string, Port?:int, ServerName?:string, ServerTimezone?:string, Username?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, ExecuteTimeout?:int}, OracleSettings?:array{AddSupplementalLogging?:bool, ArchivedLogDestId?:int, AdditionalArchivedLogDestId?:int, ExtraArchivedLogDestIds?:array<int>, AllowSelectNestedTables?:bool, ParallelAsmReadThreads?:int, ReadAheadBlocks?:int, AccessAlternateDirectly?:bool, UseAlternateFolderForOnline?:bool, OraclePathPrefix?:string, UsePathPrefix?:string, ReplacePathPrefix?:bool, EnableHomogenousTablespace?:bool, DirectPathNoLog?:bool, ArchivedLogsOnly?:bool, AsmPassword?:string, AsmServer?:string, AsmUser?:string, CharLengthSemantics?:"default"|"char"|"byte", DatabaseName?:string, DirectPathParallelLoad?:bool, FailTasksOnLobTruncation?:bool, NumberDatatypeScale?:int, Password?:string, Port?:int, ReadTableSpaceName?:bool, RetryInterval?:int, SecurityDbEncryption?:string, SecurityDbEncryptionName?:string, ServerName?:string, SpatialDataOptionToGeoJsonFunctionName?:string, StandbyDelayTime?:int, Username?:string, UseBFile?:bool, UseDirectPathFullLoad?:bool, UseLogminerReader?:bool, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, SecretsManagerOracleAsmAccessRoleArn?:string, SecretsManagerOracleAsmSecretId?:string, TrimSpaceInChar?:bool, ConvertTimestampWithZoneToUTC?:bool, OpenTransactionWindow?:int, AuthenticationMethod?:"password"|"kerberos"}, SybaseSettings?:array{DatabaseName?:string, Password?:string, Port?:int, ServerName?:string, Username?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string}, MicrosoftSQLServerSettings?:array{Port?:int, BcpPacketSize?:int, DatabaseName?:string, ControlTablesFileGroup?:string, Password?:string, QuerySingleAlwaysOnNode?:bool, ReadBackupOnly?:bool, SafeguardPolicy?:"rely-on-sql-server-replication-agent"|"exclusive-automatic-truncation"|"shared-automatic-truncation", ServerName?:string, Username?:string, UseBcpFullLoad?:bool, UseThirdPartyBackupDevice?:bool, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, TrimSpaceInChar?:bool, TlogAccessMode?:"BackupOnly"|"PreferBackup"|"PreferTlog"|"TlogOnly", ForceLobLookup?:bool, AuthenticationMethod?:"password"|"kerberos"}, IBMDb2Settings?:array{DatabaseName?:string, Password?:string, Port?:int, ServerName?:string, SetDataCaptureChanges?:bool, CurrentLsn?:string, MaxKBytesPerRead?:int, Username?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, LoadTimeout?:int, WriteBufferSize?:int, MaxFileSize?:int, KeepCsvFiles?:bool}, DocDbSettings?:array{Username?:string, Password?:string, ServerName?:string, Port?:int, DatabaseName?:string, NestingLevel?:"none"|"one", ExtractDocId?:bool, DocsToInvestigate?:int, KmsKeyId?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, UseUpdateLookUp?:bool, ReplicateShardCollections?:bool}, RedisSettings?:array{ServerName:string, Port:int, SslSecurityProtocol?:"plaintext"|"ssl-encryption", AuthType?:"none"|"auth-role"|"auth-token", AuthUserName?:string, AuthPassword?:string, SslCaCertificateArn?:string}, ExactSettings?:bool, GcpMySQLSettings?:array{AfterConnectScript?:string, CleanSourceMetadataOnMismatch?:bool, DatabaseName?:string, EventsPollInterval?:int, TargetDbType?:"specific-database"|"multiple-databases", MaxFileSize?:int, ParallelLoadThreads?:int, Password?:string, Port?:int, ServerName?:string, ServerTimezone?:string, Username?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string}, TimestreamSettings?:array{DatabaseName:string, MemoryDuration:int, MagneticDuration:int, CdcInsertsAndUpdates?:bool, EnableMagneticStoreWrites?:bool}} $args
     * @return \AWS\Result<array{Endpoint?:array{EndpointIdentifier?:string, EndpointType?:"source"|"target", EngineName?:string, EngineDisplayName?:string, Username?:string, ServerName?:string, Port?:int, DatabaseName?:string, ExtraConnectionAttributes?:string, Status?:string, KmsKeyId?:string, EndpointArn?:string, CertificateArn?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", ServiceAccessRoleArn?:string, ExternalTableDefinition?:string, ExternalId?:string, DynamoDbSettings?:array{ServiceAccessRoleArn:string}, S3Settings?:array{ServiceAccessRoleArn?:string, ExternalTableDefinition?:string, CsvRowDelimiter?:string, CsvDelimiter?:string, BucketFolder?:string, BucketName?:string, CompressionType?:"none"|"gzip", EncryptionMode?:"sse-s3"|"sse-kms", ServerSideEncryptionKmsKeyId?:string, DataFormat?:"csv"|"parquet", EncodingType?:"plain"|"plain-dictionary"|"rle-dictionary", DictPageSizeLimit?:int, RowGroupLength?:int, DataPageSize?:int, ParquetVersion?:"parquet-1-0"|"parquet-2-0", EnableStatistics?:bool, IncludeOpForFullLoad?:bool, CdcInsertsOnly?:bool, TimestampColumnName?:string, ParquetTimestampInMillisecond?:bool, CdcInsertsAndUpdates?:bool, DatePartitionEnabled?:bool, DatePartitionSequence?:"YYYYMMDD"|"YYYYMMDDHH"|"YYYYMM"|"MMYYYYDD"|"DDMMYYYY", DatePartitionDelimiter?:"SLASH"|"UNDERSCORE"|"DASH"|"NONE", UseCsvNoSupValue?:bool, CsvNoSupValue?:string, PreserveTransactions?:bool, CdcPath?:string, UseTaskStartTimeForFullLoadTimestamp?:bool, CannedAclForObjects?:"none"|"private"|"public-read"|"public-read-write"|"authenticated-read"|"aws-exec-read"|"bucket-owner-read"|"bucket-owner-full-control", AddColumnName?:bool, CdcMaxBatchInterval?:int, CdcMinFileSize?:int, CsvNullValue?:string, IgnoreHeaderRows?:int, MaxFileSize?:int, Rfc4180?:bool, DatePartitionTimezone?:string, AddTrailingPaddingCharacter?:bool, ExpectedBucketOwner?:string, GlueCatalogGeneration?:bool}, DmsTransferSettings?:array{ServiceAccessRoleArn?:string, BucketName?:string}, MongoDbSettings?:array{Username?:string, Password?:string, ServerName?:string, Port?:int, DatabaseName?:string, AuthType?:"no"|"password", AuthMechanism?:"default"|"mongodb_cr"|"scram_sha_1", NestingLevel?:"none"|"one", ExtractDocId?:string, DocsToInvestigate?:string, AuthSource?:string, KmsKeyId?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, UseUpdateLookUp?:bool, ReplicateShardCollections?:bool}, KinesisSettings?:array{StreamArn?:string, MessageFormat?:"json"|"json-unformatted", ServiceAccessRoleArn?:string, IncludeTransactionDetails?:bool, IncludePartitionValue?:bool, PartitionIncludeSchemaTable?:bool, IncludeTableAlterOperations?:bool, IncludeControlDetails?:bool, IncludeNullAndEmpty?:bool, NoHexPrefix?:bool, UseLargeIntegerValue?:bool}, KafkaSettings?:array{Broker?:string, Topic?:string, MessageFormat?:"json"|"json-unformatted", IncludeTransactionDetails?:bool, IncludePartitionValue?:bool, PartitionIncludeSchemaTable?:bool, IncludeTableAlterOperations?:bool, IncludeControlDetails?:bool, MessageMaxBytes?:int, IncludeNullAndEmpty?:bool, SecurityProtocol?:"plaintext"|"ssl-authentication"|"ssl-encryption"|"sasl-ssl", SslClientCertificateArn?:string, SslClientKeyArn?:string, SslClientKeyPassword?:string, SslCaCertificateArn?:string, SaslUsername?:string, SaslPassword?:string, NoHexPrefix?:bool, SaslMechanism?:"scram-sha-512"|"plain", SslEndpointIdentificationAlgorithm?:"none"|"https", UseLargeIntegerValue?:bool}, ElasticsearchSettings?:array{ServiceAccessRoleArn:string, EndpointUri:string, FullLoadErrorPercentage?:int, ErrorRetryDuration?:int, UseNewMappingType?:bool}, NeptuneSettings?:array{ServiceAccessRoleArn?:string, S3BucketName:string, S3BucketFolder:string, ErrorRetryDuration?:int, MaxFileSize?:int, MaxRetryCount?:int, IamAuthEnabled?:bool}, RedshiftSettings?:array{AcceptAnyDate?:bool, AfterConnectScript?:string, BucketFolder?:string, BucketName?:string, CaseSensitiveNames?:bool, CompUpdate?:bool, ConnectionTimeout?:int, DatabaseName?:string, DateFormat?:string, EmptyAsNull?:bool, EncryptionMode?:"sse-s3"|"sse-kms", ExplicitIds?:bool, FileTransferUploadStreams?:int, LoadTimeout?:int, MaxFileSize?:int, Password?:string, Port?:int, RemoveQuotes?:bool, ReplaceInvalidChars?:string, ReplaceChars?:string, ServerName?:string, ServiceAccessRoleArn?:string, ServerSideEncryptionKmsKeyId?:string, TimeFormat?:string, TrimBlanks?:bool, TruncateColumns?:bool, Username?:string, WriteBufferSize?:int, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, MapBooleanAsBoolean?:bool}, PostgreSQLSettings?:array{AfterConnectScript?:string, CaptureDdls?:bool, MaxFileSize?:int, DatabaseName?:string, DdlArtifactsSchema?:string, ExecuteTimeout?:int, FailTasksOnLobTruncation?:bool, HeartbeatEnable?:bool, HeartbeatSchema?:string, HeartbeatFrequency?:int, Password?:string, Port?:int, ServerName?:string, Username?:string, SlotName?:string, PluginName?:"no-preference"|"test-decoding"|"pglogical", SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, TrimSpaceInChar?:bool, MapBooleanAsBoolean?:bool, MapJsonbAsClob?:bool, MapLongVarcharAs?:"wstring"|"clob"|"nclob", DatabaseMode?:"default"|"babelfish", BabelfishDatabaseName?:string, DisableUnicodeSourceFilter?:bool}, MySQLSettings?:array{AfterConnectScript?:string, CleanSourceMetadataOnMismatch?:bool, DatabaseName?:string, EventsPollInterval?:int, TargetDbType?:"specific-database"|"multiple-databases", MaxFileSize?:int, ParallelLoadThreads?:int, Password?:string, Port?:int, ServerName?:string, ServerTimezone?:string, Username?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, ExecuteTimeout?:int}, OracleSettings?:array{AddSupplementalLogging?:bool, ArchivedLogDestId?:int, AdditionalArchivedLogDestId?:int, ExtraArchivedLogDestIds?:array<int>, AllowSelectNestedTables?:bool, ParallelAsmReadThreads?:int, ReadAheadBlocks?:int, AccessAlternateDirectly?:bool, UseAlternateFolderForOnline?:bool, OraclePathPrefix?:string, UsePathPrefix?:string, ReplacePathPrefix?:bool, EnableHomogenousTablespace?:bool, DirectPathNoLog?:bool, ArchivedLogsOnly?:bool, AsmPassword?:string, AsmServer?:string, AsmUser?:string, CharLengthSemantics?:"default"|"char"|"byte", DatabaseName?:string, DirectPathParallelLoad?:bool, FailTasksOnLobTruncation?:bool, NumberDatatypeScale?:int, Password?:string, Port?:int, ReadTableSpaceName?:bool, RetryInterval?:int, SecurityDbEncryption?:string, SecurityDbEncryptionName?:string, ServerName?:string, SpatialDataOptionToGeoJsonFunctionName?:string, StandbyDelayTime?:int, Username?:string, UseBFile?:bool, UseDirectPathFullLoad?:bool, UseLogminerReader?:bool, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, SecretsManagerOracleAsmAccessRoleArn?:string, SecretsManagerOracleAsmSecretId?:string, TrimSpaceInChar?:bool, ConvertTimestampWithZoneToUTC?:bool, OpenTransactionWindow?:int, AuthenticationMethod?:"password"|"kerberos"}, SybaseSettings?:array{DatabaseName?:string, Password?:string, Port?:int, ServerName?:string, Username?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string}, MicrosoftSQLServerSettings?:array{Port?:int, BcpPacketSize?:int, DatabaseName?:string, ControlTablesFileGroup?:string, Password?:string, QuerySingleAlwaysOnNode?:bool, ReadBackupOnly?:bool, SafeguardPolicy?:"rely-on-sql-server-replication-agent"|"exclusive-automatic-truncation"|"shared-automatic-truncation", ServerName?:string, Username?:string, UseBcpFullLoad?:bool, UseThirdPartyBackupDevice?:bool, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, TrimSpaceInChar?:bool, TlogAccessMode?:"BackupOnly"|"PreferBackup"|"PreferTlog"|"TlogOnly", ForceLobLookup?:bool, AuthenticationMethod?:"password"|"kerberos"}, IBMDb2Settings?:array{DatabaseName?:string, Password?:string, Port?:int, ServerName?:string, SetDataCaptureChanges?:bool, CurrentLsn?:string, MaxKBytesPerRead?:int, Username?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, LoadTimeout?:int, WriteBufferSize?:int, MaxFileSize?:int, KeepCsvFiles?:bool}, DocDbSettings?:array{Username?:string, Password?:string, ServerName?:string, Port?:int, DatabaseName?:string, NestingLevel?:"none"|"one", ExtractDocId?:bool, DocsToInvestigate?:int, KmsKeyId?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, UseUpdateLookUp?:bool, ReplicateShardCollections?:bool}, RedisSettings?:array{ServerName:string, Port:int, SslSecurityProtocol?:"plaintext"|"ssl-encryption", AuthType?:"none"|"auth-role"|"auth-token", AuthUserName?:string, AuthPassword?:string, SslCaCertificateArn?:string}, GcpMySQLSettings?:array{AfterConnectScript?:string, CleanSourceMetadataOnMismatch?:bool, DatabaseName?:string, EventsPollInterval?:int, TargetDbType?:"specific-database"|"multiple-databases", MaxFileSize?:int, ParallelLoadThreads?:int, Password?:string, Port?:int, ServerName?:string, ServerTimezone?:string, Username?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string}, TimestreamSettings?:array{DatabaseName:string, MemoryDuration:int, MagneticDuration:int, CdcInsertsAndUpdates?:bool, EnableMagneticStoreWrites?:bool}}}>
     */
    public function modifyEndpoint(array $args): \AWS\Result { }

    /**
     * @param array{EndpointArn:string, EndpointIdentifier?:string, EndpointType?:"source"|"target", EngineName?:string, Username?:string, Password?:string, ServerName?:string, Port?:int, DatabaseName?:string, ExtraConnectionAttributes?:string, CertificateArn?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", ServiceAccessRoleArn?:string, ExternalTableDefinition?:string, DynamoDbSettings?:array{ServiceAccessRoleArn:string}, S3Settings?:array{ServiceAccessRoleArn?:string, ExternalTableDefinition?:string, CsvRowDelimiter?:string, CsvDelimiter?:string, BucketFolder?:string, BucketName?:string, CompressionType?:"none"|"gzip", EncryptionMode?:"sse-s3"|"sse-kms", ServerSideEncryptionKmsKeyId?:string, DataFormat?:"csv"|"parquet", EncodingType?:"plain"|"plain-dictionary"|"rle-dictionary", DictPageSizeLimit?:int, RowGroupLength?:int, DataPageSize?:int, ParquetVersion?:"parquet-1-0"|"parquet-2-0", EnableStatistics?:bool, IncludeOpForFullLoad?:bool, CdcInsertsOnly?:bool, TimestampColumnName?:string, ParquetTimestampInMillisecond?:bool, CdcInsertsAndUpdates?:bool, DatePartitionEnabled?:bool, DatePartitionSequence?:"YYYYMMDD"|"YYYYMMDDHH"|"YYYYMM"|"MMYYYYDD"|"DDMMYYYY", DatePartitionDelimiter?:"SLASH"|"UNDERSCORE"|"DASH"|"NONE", UseCsvNoSupValue?:bool, CsvNoSupValue?:string, PreserveTransactions?:bool, CdcPath?:string, UseTaskStartTimeForFullLoadTimestamp?:bool, CannedAclForObjects?:"none"|"private"|"public-read"|"public-read-write"|"authenticated-read"|"aws-exec-read"|"bucket-owner-read"|"bucket-owner-full-control", AddColumnName?:bool, CdcMaxBatchInterval?:int, CdcMinFileSize?:int, CsvNullValue?:string, IgnoreHeaderRows?:int, MaxFileSize?:int, Rfc4180?:bool, DatePartitionTimezone?:string, AddTrailingPaddingCharacter?:bool, ExpectedBucketOwner?:string, GlueCatalogGeneration?:bool}, DmsTransferSettings?:array{ServiceAccessRoleArn?:string, BucketName?:string}, MongoDbSettings?:array{Username?:string, Password?:string, ServerName?:string, Port?:int, DatabaseName?:string, AuthType?:"no"|"password", AuthMechanism?:"default"|"mongodb_cr"|"scram_sha_1", NestingLevel?:"none"|"one", ExtractDocId?:string, DocsToInvestigate?:string, AuthSource?:string, KmsKeyId?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, UseUpdateLookUp?:bool, ReplicateShardCollections?:bool}, KinesisSettings?:array{StreamArn?:string, MessageFormat?:"json"|"json-unformatted", ServiceAccessRoleArn?:string, IncludeTransactionDetails?:bool, IncludePartitionValue?:bool, PartitionIncludeSchemaTable?:bool, IncludeTableAlterOperations?:bool, IncludeControlDetails?:bool, IncludeNullAndEmpty?:bool, NoHexPrefix?:bool, UseLargeIntegerValue?:bool}, KafkaSettings?:array{Broker?:string, Topic?:string, MessageFormat?:"json"|"json-unformatted", IncludeTransactionDetails?:bool, IncludePartitionValue?:bool, PartitionIncludeSchemaTable?:bool, IncludeTableAlterOperations?:bool, IncludeControlDetails?:bool, MessageMaxBytes?:int, IncludeNullAndEmpty?:bool, SecurityProtocol?:"plaintext"|"ssl-authentication"|"ssl-encryption"|"sasl-ssl", SslClientCertificateArn?:string, SslClientKeyArn?:string, SslClientKeyPassword?:string, SslCaCertificateArn?:string, SaslUsername?:string, SaslPassword?:string, NoHexPrefix?:bool, SaslMechanism?:"scram-sha-512"|"plain", SslEndpointIdentificationAlgorithm?:"none"|"https", UseLargeIntegerValue?:bool}, ElasticsearchSettings?:array{ServiceAccessRoleArn:string, EndpointUri:string, FullLoadErrorPercentage?:int, ErrorRetryDuration?:int, UseNewMappingType?:bool}, NeptuneSettings?:array{ServiceAccessRoleArn?:string, S3BucketName:string, S3BucketFolder:string, ErrorRetryDuration?:int, MaxFileSize?:int, MaxRetryCount?:int, IamAuthEnabled?:bool}, RedshiftSettings?:array{AcceptAnyDate?:bool, AfterConnectScript?:string, BucketFolder?:string, BucketName?:string, CaseSensitiveNames?:bool, CompUpdate?:bool, ConnectionTimeout?:int, DatabaseName?:string, DateFormat?:string, EmptyAsNull?:bool, EncryptionMode?:"sse-s3"|"sse-kms", ExplicitIds?:bool, FileTransferUploadStreams?:int, LoadTimeout?:int, MaxFileSize?:int, Password?:string, Port?:int, RemoveQuotes?:bool, ReplaceInvalidChars?:string, ReplaceChars?:string, ServerName?:string, ServiceAccessRoleArn?:string, ServerSideEncryptionKmsKeyId?:string, TimeFormat?:string, TrimBlanks?:bool, TruncateColumns?:bool, Username?:string, WriteBufferSize?:int, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, MapBooleanAsBoolean?:bool}, PostgreSQLSettings?:array{AfterConnectScript?:string, CaptureDdls?:bool, MaxFileSize?:int, DatabaseName?:string, DdlArtifactsSchema?:string, ExecuteTimeout?:int, FailTasksOnLobTruncation?:bool, HeartbeatEnable?:bool, HeartbeatSchema?:string, HeartbeatFrequency?:int, Password?:string, Port?:int, ServerName?:string, Username?:string, SlotName?:string, PluginName?:"no-preference"|"test-decoding"|"pglogical", SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, TrimSpaceInChar?:bool, MapBooleanAsBoolean?:bool, MapJsonbAsClob?:bool, MapLongVarcharAs?:"wstring"|"clob"|"nclob", DatabaseMode?:"default"|"babelfish", BabelfishDatabaseName?:string, DisableUnicodeSourceFilter?:bool}, MySQLSettings?:array{AfterConnectScript?:string, CleanSourceMetadataOnMismatch?:bool, DatabaseName?:string, EventsPollInterval?:int, TargetDbType?:"specific-database"|"multiple-databases", MaxFileSize?:int, ParallelLoadThreads?:int, Password?:string, Port?:int, ServerName?:string, ServerTimezone?:string, Username?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, ExecuteTimeout?:int}, OracleSettings?:array{AddSupplementalLogging?:bool, ArchivedLogDestId?:int, AdditionalArchivedLogDestId?:int, ExtraArchivedLogDestIds?:array<int>, AllowSelectNestedTables?:bool, ParallelAsmReadThreads?:int, ReadAheadBlocks?:int, AccessAlternateDirectly?:bool, UseAlternateFolderForOnline?:bool, OraclePathPrefix?:string, UsePathPrefix?:string, ReplacePathPrefix?:bool, EnableHomogenousTablespace?:bool, DirectPathNoLog?:bool, ArchivedLogsOnly?:bool, AsmPassword?:string, AsmServer?:string, AsmUser?:string, CharLengthSemantics?:"default"|"char"|"byte", DatabaseName?:string, DirectPathParallelLoad?:bool, FailTasksOnLobTruncation?:bool, NumberDatatypeScale?:int, Password?:string, Port?:int, ReadTableSpaceName?:bool, RetryInterval?:int, SecurityDbEncryption?:string, SecurityDbEncryptionName?:string, ServerName?:string, SpatialDataOptionToGeoJsonFunctionName?:string, StandbyDelayTime?:int, Username?:string, UseBFile?:bool, UseDirectPathFullLoad?:bool, UseLogminerReader?:bool, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, SecretsManagerOracleAsmAccessRoleArn?:string, SecretsManagerOracleAsmSecretId?:string, TrimSpaceInChar?:bool, ConvertTimestampWithZoneToUTC?:bool, OpenTransactionWindow?:int, AuthenticationMethod?:"password"|"kerberos"}, SybaseSettings?:array{DatabaseName?:string, Password?:string, Port?:int, ServerName?:string, Username?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string}, MicrosoftSQLServerSettings?:array{Port?:int, BcpPacketSize?:int, DatabaseName?:string, ControlTablesFileGroup?:string, Password?:string, QuerySingleAlwaysOnNode?:bool, ReadBackupOnly?:bool, SafeguardPolicy?:"rely-on-sql-server-replication-agent"|"exclusive-automatic-truncation"|"shared-automatic-truncation", ServerName?:string, Username?:string, UseBcpFullLoad?:bool, UseThirdPartyBackupDevice?:bool, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, TrimSpaceInChar?:bool, TlogAccessMode?:"BackupOnly"|"PreferBackup"|"PreferTlog"|"TlogOnly", ForceLobLookup?:bool, AuthenticationMethod?:"password"|"kerberos"}, IBMDb2Settings?:array{DatabaseName?:string, Password?:string, Port?:int, ServerName?:string, SetDataCaptureChanges?:bool, CurrentLsn?:string, MaxKBytesPerRead?:int, Username?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, LoadTimeout?:int, WriteBufferSize?:int, MaxFileSize?:int, KeepCsvFiles?:bool}, DocDbSettings?:array{Username?:string, Password?:string, ServerName?:string, Port?:int, DatabaseName?:string, NestingLevel?:"none"|"one", ExtractDocId?:bool, DocsToInvestigate?:int, KmsKeyId?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, UseUpdateLookUp?:bool, ReplicateShardCollections?:bool}, RedisSettings?:array{ServerName:string, Port:int, SslSecurityProtocol?:"plaintext"|"ssl-encryption", AuthType?:"none"|"auth-role"|"auth-token", AuthUserName?:string, AuthPassword?:string, SslCaCertificateArn?:string}, ExactSettings?:bool, GcpMySQLSettings?:array{AfterConnectScript?:string, CleanSourceMetadataOnMismatch?:bool, DatabaseName?:string, EventsPollInterval?:int, TargetDbType?:"specific-database"|"multiple-databases", MaxFileSize?:int, ParallelLoadThreads?:int, Password?:string, Port?:int, ServerName?:string, ServerTimezone?:string, Username?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string}, TimestreamSettings?:array{DatabaseName:string, MemoryDuration:int, MagneticDuration:int, CdcInsertsAndUpdates?:bool, EnableMagneticStoreWrites?:bool}} $args
     * @return \GuzzleHttp\Promise\Promise<array{Endpoint?:array{EndpointIdentifier?:string, EndpointType?:"source"|"target", EngineName?:string, EngineDisplayName?:string, Username?:string, ServerName?:string, Port?:int, DatabaseName?:string, ExtraConnectionAttributes?:string, Status?:string, KmsKeyId?:string, EndpointArn?:string, CertificateArn?:string, SslMode?:"none"|"require"|"verify-ca"|"verify-full", ServiceAccessRoleArn?:string, ExternalTableDefinition?:string, ExternalId?:string, DynamoDbSettings?:array{ServiceAccessRoleArn:string}, S3Settings?:array{ServiceAccessRoleArn?:string, ExternalTableDefinition?:string, CsvRowDelimiter?:string, CsvDelimiter?:string, BucketFolder?:string, BucketName?:string, CompressionType?:"none"|"gzip", EncryptionMode?:"sse-s3"|"sse-kms", ServerSideEncryptionKmsKeyId?:string, DataFormat?:"csv"|"parquet", EncodingType?:"plain"|"plain-dictionary"|"rle-dictionary", DictPageSizeLimit?:int, RowGroupLength?:int, DataPageSize?:int, ParquetVersion?:"parquet-1-0"|"parquet-2-0", EnableStatistics?:bool, IncludeOpForFullLoad?:bool, CdcInsertsOnly?:bool, TimestampColumnName?:string, ParquetTimestampInMillisecond?:bool, CdcInsertsAndUpdates?:bool, DatePartitionEnabled?:bool, DatePartitionSequence?:"YYYYMMDD"|"YYYYMMDDHH"|"YYYYMM"|"MMYYYYDD"|"DDMMYYYY", DatePartitionDelimiter?:"SLASH"|"UNDERSCORE"|"DASH"|"NONE", UseCsvNoSupValue?:bool, CsvNoSupValue?:string, PreserveTransactions?:bool, CdcPath?:string, UseTaskStartTimeForFullLoadTimestamp?:bool, CannedAclForObjects?:"none"|"private"|"public-read"|"public-read-write"|"authenticated-read"|"aws-exec-read"|"bucket-owner-read"|"bucket-owner-full-control", AddColumnName?:bool, CdcMaxBatchInterval?:int, CdcMinFileSize?:int, CsvNullValue?:string, IgnoreHeaderRows?:int, MaxFileSize?:int, Rfc4180?:bool, DatePartitionTimezone?:string, AddTrailingPaddingCharacter?:bool, ExpectedBucketOwner?:string, GlueCatalogGeneration?:bool}, DmsTransferSettings?:array{ServiceAccessRoleArn?:string, BucketName?:string}, MongoDbSettings?:array{Username?:string, Password?:string, ServerName?:string, Port?:int, DatabaseName?:string, AuthType?:"no"|"password", AuthMechanism?:"default"|"mongodb_cr"|"scram_sha_1", NestingLevel?:"none"|"one", ExtractDocId?:string, DocsToInvestigate?:string, AuthSource?:string, KmsKeyId?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, UseUpdateLookUp?:bool, ReplicateShardCollections?:bool}, KinesisSettings?:array{StreamArn?:string, MessageFormat?:"json"|"json-unformatted", ServiceAccessRoleArn?:string, IncludeTransactionDetails?:bool, IncludePartitionValue?:bool, PartitionIncludeSchemaTable?:bool, IncludeTableAlterOperations?:bool, IncludeControlDetails?:bool, IncludeNullAndEmpty?:bool, NoHexPrefix?:bool, UseLargeIntegerValue?:bool}, KafkaSettings?:array{Broker?:string, Topic?:string, MessageFormat?:"json"|"json-unformatted", IncludeTransactionDetails?:bool, IncludePartitionValue?:bool, PartitionIncludeSchemaTable?:bool, IncludeTableAlterOperations?:bool, IncludeControlDetails?:bool, MessageMaxBytes?:int, IncludeNullAndEmpty?:bool, SecurityProtocol?:"plaintext"|"ssl-authentication"|"ssl-encryption"|"sasl-ssl", SslClientCertificateArn?:string, SslClientKeyArn?:string, SslClientKeyPassword?:string, SslCaCertificateArn?:string, SaslUsername?:string, SaslPassword?:string, NoHexPrefix?:bool, SaslMechanism?:"scram-sha-512"|"plain", SslEndpointIdentificationAlgorithm?:"none"|"https", UseLargeIntegerValue?:bool}, ElasticsearchSettings?:array{ServiceAccessRoleArn:string, EndpointUri:string, FullLoadErrorPercentage?:int, ErrorRetryDuration?:int, UseNewMappingType?:bool}, NeptuneSettings?:array{ServiceAccessRoleArn?:string, S3BucketName:string, S3BucketFolder:string, ErrorRetryDuration?:int, MaxFileSize?:int, MaxRetryCount?:int, IamAuthEnabled?:bool}, RedshiftSettings?:array{AcceptAnyDate?:bool, AfterConnectScript?:string, BucketFolder?:string, BucketName?:string, CaseSensitiveNames?:bool, CompUpdate?:bool, ConnectionTimeout?:int, DatabaseName?:string, DateFormat?:string, EmptyAsNull?:bool, EncryptionMode?:"sse-s3"|"sse-kms", ExplicitIds?:bool, FileTransferUploadStreams?:int, LoadTimeout?:int, MaxFileSize?:int, Password?:string, Port?:int, RemoveQuotes?:bool, ReplaceInvalidChars?:string, ReplaceChars?:string, ServerName?:string, ServiceAccessRoleArn?:string, ServerSideEncryptionKmsKeyId?:string, TimeFormat?:string, TrimBlanks?:bool, TruncateColumns?:bool, Username?:string, WriteBufferSize?:int, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, MapBooleanAsBoolean?:bool}, PostgreSQLSettings?:array{AfterConnectScript?:string, CaptureDdls?:bool, MaxFileSize?:int, DatabaseName?:string, DdlArtifactsSchema?:string, ExecuteTimeout?:int, FailTasksOnLobTruncation?:bool, HeartbeatEnable?:bool, HeartbeatSchema?:string, HeartbeatFrequency?:int, Password?:string, Port?:int, ServerName?:string, Username?:string, SlotName?:string, PluginName?:"no-preference"|"test-decoding"|"pglogical", SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, TrimSpaceInChar?:bool, MapBooleanAsBoolean?:bool, MapJsonbAsClob?:bool, MapLongVarcharAs?:"wstring"|"clob"|"nclob", DatabaseMode?:"default"|"babelfish", BabelfishDatabaseName?:string, DisableUnicodeSourceFilter?:bool}, MySQLSettings?:array{AfterConnectScript?:string, CleanSourceMetadataOnMismatch?:bool, DatabaseName?:string, EventsPollInterval?:int, TargetDbType?:"specific-database"|"multiple-databases", MaxFileSize?:int, ParallelLoadThreads?:int, Password?:string, Port?:int, ServerName?:string, ServerTimezone?:string, Username?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, ExecuteTimeout?:int}, OracleSettings?:array{AddSupplementalLogging?:bool, ArchivedLogDestId?:int, AdditionalArchivedLogDestId?:int, ExtraArchivedLogDestIds?:array<int>, AllowSelectNestedTables?:bool, ParallelAsmReadThreads?:int, ReadAheadBlocks?:int, AccessAlternateDirectly?:bool, UseAlternateFolderForOnline?:bool, OraclePathPrefix?:string, UsePathPrefix?:string, ReplacePathPrefix?:bool, EnableHomogenousTablespace?:bool, DirectPathNoLog?:bool, ArchivedLogsOnly?:bool, AsmPassword?:string, AsmServer?:string, AsmUser?:string, CharLengthSemantics?:"default"|"char"|"byte", DatabaseName?:string, DirectPathParallelLoad?:bool, FailTasksOnLobTruncation?:bool, NumberDatatypeScale?:int, Password?:string, Port?:int, ReadTableSpaceName?:bool, RetryInterval?:int, SecurityDbEncryption?:string, SecurityDbEncryptionName?:string, ServerName?:string, SpatialDataOptionToGeoJsonFunctionName?:string, StandbyDelayTime?:int, Username?:string, UseBFile?:bool, UseDirectPathFullLoad?:bool, UseLogminerReader?:bool, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, SecretsManagerOracleAsmAccessRoleArn?:string, SecretsManagerOracleAsmSecretId?:string, TrimSpaceInChar?:bool, ConvertTimestampWithZoneToUTC?:bool, OpenTransactionWindow?:int, AuthenticationMethod?:"password"|"kerberos"}, SybaseSettings?:array{DatabaseName?:string, Password?:string, Port?:int, ServerName?:string, Username?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string}, MicrosoftSQLServerSettings?:array{Port?:int, BcpPacketSize?:int, DatabaseName?:string, ControlTablesFileGroup?:string, Password?:string, QuerySingleAlwaysOnNode?:bool, ReadBackupOnly?:bool, SafeguardPolicy?:"rely-on-sql-server-replication-agent"|"exclusive-automatic-truncation"|"shared-automatic-truncation", ServerName?:string, Username?:string, UseBcpFullLoad?:bool, UseThirdPartyBackupDevice?:bool, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, TrimSpaceInChar?:bool, TlogAccessMode?:"BackupOnly"|"PreferBackup"|"PreferTlog"|"TlogOnly", ForceLobLookup?:bool, AuthenticationMethod?:"password"|"kerberos"}, IBMDb2Settings?:array{DatabaseName?:string, Password?:string, Port?:int, ServerName?:string, SetDataCaptureChanges?:bool, CurrentLsn?:string, MaxKBytesPerRead?:int, Username?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, LoadTimeout?:int, WriteBufferSize?:int, MaxFileSize?:int, KeepCsvFiles?:bool}, DocDbSettings?:array{Username?:string, Password?:string, ServerName?:string, Port?:int, DatabaseName?:string, NestingLevel?:"none"|"one", ExtractDocId?:bool, DocsToInvestigate?:int, KmsKeyId?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string, UseUpdateLookUp?:bool, ReplicateShardCollections?:bool}, RedisSettings?:array{ServerName:string, Port:int, SslSecurityProtocol?:"plaintext"|"ssl-encryption", AuthType?:"none"|"auth-role"|"auth-token", AuthUserName?:string, AuthPassword?:string, SslCaCertificateArn?:string}, GcpMySQLSettings?:array{AfterConnectScript?:string, CleanSourceMetadataOnMismatch?:bool, DatabaseName?:string, EventsPollInterval?:int, TargetDbType?:"specific-database"|"multiple-databases", MaxFileSize?:int, ParallelLoadThreads?:int, Password?:string, Port?:int, ServerName?:string, ServerTimezone?:string, Username?:string, SecretsManagerAccessRoleArn?:string, SecretsManagerSecretId?:string}, TimestreamSettings?:array{DatabaseName:string, MemoryDuration:int, MagneticDuration:int, CdcInsertsAndUpdates?:bool, EnableMagneticStoreWrites?:bool}}}>
     */
    public function modifyEndpointAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{SubscriptionName:string, SnsTopicArn?:string, SourceType?:string, EventCategories?:array<string>, Enabled?:bool} $args
     * @return \AWS\Result<array{EventSubscription?:array{CustomerAwsId?:string, CustSubscriptionId?:string, SnsTopicArn?:string, Status?:string, SubscriptionCreationTime?:string, SourceType?:string, SourceIdsList?:array<string>, EventCategoriesList?:array<string>, Enabled?:bool}}>
     */
    public function modifyEventSubscription(array $args): \AWS\Result { }

    /**
     * @param array{SubscriptionName:string, SnsTopicArn?:string, SourceType?:string, EventCategories?:array<string>, Enabled?:bool} $args
     * @return \GuzzleHttp\Promise\Promise<array{EventSubscription?:array{CustomerAwsId?:string, CustSubscriptionId?:string, SnsTopicArn?:string, Status?:string, SubscriptionCreationTime?:string, SourceType?:string, SourceIdsList?:array<string>, EventCategoriesList?:array<string>, Enabled?:bool}}>
     */
    public function modifyEventSubscriptionAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{InstanceProfileIdentifier:string, AvailabilityZone?:string, KmsKeyArn?:string, PubliclyAccessible?:bool, NetworkType?:string, InstanceProfileName?:string, Description?:string, SubnetGroupIdentifier?:string, VpcSecurityGroups?:array<string>} $args
     * @return \AWS\Result<array{InstanceProfile?:array{InstanceProfileArn?:string, AvailabilityZone?:string, KmsKeyArn?:string, PubliclyAccessible?:bool, NetworkType?:string, InstanceProfileName?:string, Description?:string, InstanceProfileCreationTime?:int|string|\DateTimeInterface, SubnetGroupIdentifier?:string, VpcSecurityGroups?:array<string>}}>
     */
    public function modifyInstanceProfile(array $args): \AWS\Result { }

    /**
     * @param array{InstanceProfileIdentifier:string, AvailabilityZone?:string, KmsKeyArn?:string, PubliclyAccessible?:bool, NetworkType?:string, InstanceProfileName?:string, Description?:string, SubnetGroupIdentifier?:string, VpcSecurityGroups?:array<string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{InstanceProfile?:array{InstanceProfileArn?:string, AvailabilityZone?:string, KmsKeyArn?:string, PubliclyAccessible?:bool, NetworkType?:string, InstanceProfileName?:string, Description?:string, InstanceProfileCreationTime?:int|string|\DateTimeInterface, SubnetGroupIdentifier?:string, VpcSecurityGroups?:array<string>}}>
     */
    public function modifyInstanceProfileAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{MigrationProjectIdentifier:string, MigrationProjectName?:string, SourceDataProviderDescriptors?:array<array{DataProviderIdentifier:string, SecretsManagerSecretId?:string, SecretsManagerAccessRoleArn?:string}>, TargetDataProviderDescriptors?:array<array{DataProviderIdentifier:string, SecretsManagerSecretId?:string, SecretsManagerAccessRoleArn?:string}>, InstanceProfileIdentifier?:string, TransformationRules?:string, Description?:string, SchemaConversionApplicationAttributes?:array{S3BucketPath?:string, S3BucketRoleArn?:string}} $args
     * @return \AWS\Result<array{MigrationProject?:array{MigrationProjectName?:string, MigrationProjectArn?:string, MigrationProjectCreationTime?:int|string|\DateTimeInterface, SourceDataProviderDescriptors?:array<array{SecretsManagerSecretId?:string, SecretsManagerAccessRoleArn?:string, DataProviderName?:string, DataProviderArn?:string}>, TargetDataProviderDescriptors?:array<array{SecretsManagerSecretId?:string, SecretsManagerAccessRoleArn?:string, DataProviderName?:string, DataProviderArn?:string}>, InstanceProfileArn?:string, InstanceProfileName?:string, TransformationRules?:string, Description?:string, SchemaConversionApplicationAttributes?:array{S3BucketPath?:string, S3BucketRoleArn?:string}}}>
     */
    public function modifyMigrationProject(array $args): \AWS\Result { }

    /**
     * @param array{MigrationProjectIdentifier:string, MigrationProjectName?:string, SourceDataProviderDescriptors?:array<array{DataProviderIdentifier:string, SecretsManagerSecretId?:string, SecretsManagerAccessRoleArn?:string}>, TargetDataProviderDescriptors?:array<array{DataProviderIdentifier:string, SecretsManagerSecretId?:string, SecretsManagerAccessRoleArn?:string}>, InstanceProfileIdentifier?:string, TransformationRules?:string, Description?:string, SchemaConversionApplicationAttributes?:array{S3BucketPath?:string, S3BucketRoleArn?:string}} $args
     * @return \GuzzleHttp\Promise\Promise<array{MigrationProject?:array{MigrationProjectName?:string, MigrationProjectArn?:string, MigrationProjectCreationTime?:int|string|\DateTimeInterface, SourceDataProviderDescriptors?:array<array{SecretsManagerSecretId?:string, SecretsManagerAccessRoleArn?:string, DataProviderName?:string, DataProviderArn?:string}>, TargetDataProviderDescriptors?:array<array{SecretsManagerSecretId?:string, SecretsManagerAccessRoleArn?:string, DataProviderName?:string, DataProviderArn?:string}>, InstanceProfileArn?:string, InstanceProfileName?:string, TransformationRules?:string, Description?:string, SchemaConversionApplicationAttributes?:array{S3BucketPath?:string, S3BucketRoleArn?:string}}}>
     */
    public function modifyMigrationProjectAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ReplicationConfigArn:string, ReplicationConfigIdentifier?:string, ReplicationType?:"full-load"|"cdc"|"full-load-and-cdc", TableMappings?:string, ReplicationSettings?:string, SupplementalSettings?:string, ComputeConfig?:array{AvailabilityZone?:string, DnsNameServers?:string, KmsKeyId?:string, MaxCapacityUnits?:int, MinCapacityUnits?:int, MultiAZ?:bool, PreferredMaintenanceWindow?:string, ReplicationSubnetGroupId?:string, VpcSecurityGroupIds?:array<string>}, SourceEndpointArn?:string, TargetEndpointArn?:string} $args
     * @return \AWS\Result<array{ReplicationConfig?:array{ReplicationConfigIdentifier?:string, ReplicationConfigArn?:string, SourceEndpointArn?:string, TargetEndpointArn?:string, ReplicationType?:"full-load"|"cdc"|"full-load-and-cdc", ComputeConfig?:array{AvailabilityZone?:string, DnsNameServers?:string, KmsKeyId?:string, MaxCapacityUnits?:int, MinCapacityUnits?:int, MultiAZ?:bool, PreferredMaintenanceWindow?:string, ReplicationSubnetGroupId?:string, VpcSecurityGroupIds?:array<string>}, ReplicationSettings?:string, SupplementalSettings?:string, TableMappings?:string, ReplicationConfigCreateTime?:int|string|\DateTimeInterface, ReplicationConfigUpdateTime?:int|string|\DateTimeInterface}}>
     */
    public function modifyReplicationConfig(array $args): \AWS\Result { }

    /**
     * @param array{ReplicationConfigArn:string, ReplicationConfigIdentifier?:string, ReplicationType?:"full-load"|"cdc"|"full-load-and-cdc", TableMappings?:string, ReplicationSettings?:string, SupplementalSettings?:string, ComputeConfig?:array{AvailabilityZone?:string, DnsNameServers?:string, KmsKeyId?:string, MaxCapacityUnits?:int, MinCapacityUnits?:int, MultiAZ?:bool, PreferredMaintenanceWindow?:string, ReplicationSubnetGroupId?:string, VpcSecurityGroupIds?:array<string>}, SourceEndpointArn?:string, TargetEndpointArn?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{ReplicationConfig?:array{ReplicationConfigIdentifier?:string, ReplicationConfigArn?:string, SourceEndpointArn?:string, TargetEndpointArn?:string, ReplicationType?:"full-load"|"cdc"|"full-load-and-cdc", ComputeConfig?:array{AvailabilityZone?:string, DnsNameServers?:string, KmsKeyId?:string, MaxCapacityUnits?:int, MinCapacityUnits?:int, MultiAZ?:bool, PreferredMaintenanceWindow?:string, ReplicationSubnetGroupId?:string, VpcSecurityGroupIds?:array<string>}, ReplicationSettings?:string, SupplementalSettings?:string, TableMappings?:string, ReplicationConfigCreateTime?:int|string|\DateTimeInterface, ReplicationConfigUpdateTime?:int|string|\DateTimeInterface}}>
     */
    public function modifyReplicationConfigAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ReplicationInstanceArn:string, AllocatedStorage?:int, ApplyImmediately?:bool, ReplicationInstanceClass?:string, VpcSecurityGroupIds?:array<string>, PreferredMaintenanceWindow?:string, MultiAZ?:bool, EngineVersion?:string, AllowMajorVersionUpgrade?:bool, AutoMinorVersionUpgrade?:bool, ReplicationInstanceIdentifier?:string, NetworkType?:string, KerberosAuthenticationSettings?:array{KeyCacheSecretId?:string, KeyCacheSecretIamArn?:string, Krb5FileContents?:string}} $args
     * @return \AWS\Result<array{ReplicationInstance?:array{ReplicationInstanceIdentifier?:string, ReplicationInstanceClass?:string, ReplicationInstanceStatus?:string, AllocatedStorage?:int, InstanceCreateTime?:int|string|\DateTimeInterface, VpcSecurityGroups?:array<array{VpcSecurityGroupId?:string, Status?:string}>, AvailabilityZone?:string, ReplicationSubnetGroup?:array{ReplicationSubnetGroupIdentifier?:string, ReplicationSubnetGroupDescription?:string, VpcId?:string, SubnetGroupStatus?:string, Subnets?:array<array{SubnetIdentifier?:string, SubnetAvailabilityZone?:array{Name?:string}, SubnetStatus?:string}>, SupportedNetworkTypes?:array<string>}, PreferredMaintenanceWindow?:string, PendingModifiedValues?:array{ReplicationInstanceClass?:string, AllocatedStorage?:int, MultiAZ?:bool, EngineVersion?:string, NetworkType?:string}, MultiAZ?:bool, EngineVersion?:string, AutoMinorVersionUpgrade?:bool, KmsKeyId?:string, ReplicationInstanceArn?:string, ReplicationInstancePublicIpAddress?:string, ReplicationInstancePrivateIpAddress?:string, ReplicationInstancePublicIpAddresses?:array<string>, ReplicationInstancePrivateIpAddresses?:array<string>, ReplicationInstanceIpv6Addresses?:array<string>, PubliclyAccessible?:bool, SecondaryAvailabilityZone?:string, FreeUntil?:int|string|\DateTimeInterface, DnsNameServers?:string, NetworkType?:string, KerberosAuthenticationSettings?:array{KeyCacheSecretId?:string, KeyCacheSecretIamArn?:string, Krb5FileContents?:string}}}>
     */
    public function modifyReplicationInstance(array $args): \AWS\Result { }

    /**
     * @param array{ReplicationInstanceArn:string, AllocatedStorage?:int, ApplyImmediately?:bool, ReplicationInstanceClass?:string, VpcSecurityGroupIds?:array<string>, PreferredMaintenanceWindow?:string, MultiAZ?:bool, EngineVersion?:string, AllowMajorVersionUpgrade?:bool, AutoMinorVersionUpgrade?:bool, ReplicationInstanceIdentifier?:string, NetworkType?:string, KerberosAuthenticationSettings?:array{KeyCacheSecretId?:string, KeyCacheSecretIamArn?:string, Krb5FileContents?:string}} $args
     * @return \GuzzleHttp\Promise\Promise<array{ReplicationInstance?:array{ReplicationInstanceIdentifier?:string, ReplicationInstanceClass?:string, ReplicationInstanceStatus?:string, AllocatedStorage?:int, InstanceCreateTime?:int|string|\DateTimeInterface, VpcSecurityGroups?:array<array{VpcSecurityGroupId?:string, Status?:string}>, AvailabilityZone?:string, ReplicationSubnetGroup?:array{ReplicationSubnetGroupIdentifier?:string, ReplicationSubnetGroupDescription?:string, VpcId?:string, SubnetGroupStatus?:string, Subnets?:array<array{SubnetIdentifier?:string, SubnetAvailabilityZone?:array{Name?:string}, SubnetStatus?:string}>, SupportedNetworkTypes?:array<string>}, PreferredMaintenanceWindow?:string, PendingModifiedValues?:array{ReplicationInstanceClass?:string, AllocatedStorage?:int, MultiAZ?:bool, EngineVersion?:string, NetworkType?:string}, MultiAZ?:bool, EngineVersion?:string, AutoMinorVersionUpgrade?:bool, KmsKeyId?:string, ReplicationInstanceArn?:string, ReplicationInstancePublicIpAddress?:string, ReplicationInstancePrivateIpAddress?:string, ReplicationInstancePublicIpAddresses?:array<string>, ReplicationInstancePrivateIpAddresses?:array<string>, ReplicationInstanceIpv6Addresses?:array<string>, PubliclyAccessible?:bool, SecondaryAvailabilityZone?:string, FreeUntil?:int|string|\DateTimeInterface, DnsNameServers?:string, NetworkType?:string, KerberosAuthenticationSettings?:array{KeyCacheSecretId?:string, KeyCacheSecretIamArn?:string, Krb5FileContents?:string}}}>
     */
    public function modifyReplicationInstanceAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ReplicationSubnetGroupIdentifier:string, ReplicationSubnetGroupDescription?:string, SubnetIds:array<string>} $args
     * @return \AWS\Result<array{ReplicationSubnetGroup?:array{ReplicationSubnetGroupIdentifier?:string, ReplicationSubnetGroupDescription?:string, VpcId?:string, SubnetGroupStatus?:string, Subnets?:array<array{SubnetIdentifier?:string, SubnetAvailabilityZone?:array{Name?:string}, SubnetStatus?:string}>, SupportedNetworkTypes?:array<string>}}>
     */
    public function modifyReplicationSubnetGroup(array $args): \AWS\Result { }

    /**
     * @param array{ReplicationSubnetGroupIdentifier:string, ReplicationSubnetGroupDescription?:string, SubnetIds:array<string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{ReplicationSubnetGroup?:array{ReplicationSubnetGroupIdentifier?:string, ReplicationSubnetGroupDescription?:string, VpcId?:string, SubnetGroupStatus?:string, Subnets?:array<array{SubnetIdentifier?:string, SubnetAvailabilityZone?:array{Name?:string}, SubnetStatus?:string}>, SupportedNetworkTypes?:array<string>}}>
     */
    public function modifyReplicationSubnetGroupAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ReplicationTaskArn:string, ReplicationTaskIdentifier?:string, MigrationType?:"full-load"|"cdc"|"full-load-and-cdc", TableMappings?:string, ReplicationTaskSettings?:string, CdcStartTime?:int|string|\DateTimeInterface, CdcStartPosition?:string, CdcStopPosition?:string, TaskData?:string} $args
     * @return \AWS\Result<array{ReplicationTask?:array{ReplicationTaskIdentifier?:string, SourceEndpointArn?:string, TargetEndpointArn?:string, ReplicationInstanceArn?:string, MigrationType?:"full-load"|"cdc"|"full-load-and-cdc", TableMappings?:string, ReplicationTaskSettings?:string, Status?:string, LastFailureMessage?:string, StopReason?:string, ReplicationTaskCreationDate?:int|string|\DateTimeInterface, ReplicationTaskStartDate?:int|string|\DateTimeInterface, CdcStartPosition?:string, CdcStopPosition?:string, RecoveryCheckpoint?:string, ReplicationTaskArn?:string, ReplicationTaskStats?:array{FullLoadProgressPercent?:int, ElapsedTimeMillis?:int, TablesLoaded?:int, TablesLoading?:int, TablesQueued?:int, TablesErrored?:int, FreshStartDate?:int|string|\DateTimeInterface, StartDate?:int|string|\DateTimeInterface, StopDate?:int|string|\DateTimeInterface, FullLoadStartDate?:int|string|\DateTimeInterface, FullLoadFinishDate?:int|string|\DateTimeInterface}, TaskData?:string, TargetReplicationInstanceArn?:string}}>
     */
    public function modifyReplicationTask(array $args): \AWS\Result { }

    /**
     * @param array{ReplicationTaskArn:string, ReplicationTaskIdentifier?:string, MigrationType?:"full-load"|"cdc"|"full-load-and-cdc", TableMappings?:string, ReplicationTaskSettings?:string, CdcStartTime?:int|string|\DateTimeInterface, CdcStartPosition?:string, CdcStopPosition?:string, TaskData?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{ReplicationTask?:array{ReplicationTaskIdentifier?:string, SourceEndpointArn?:string, TargetEndpointArn?:string, ReplicationInstanceArn?:string, MigrationType?:"full-load"|"cdc"|"full-load-and-cdc", TableMappings?:string, ReplicationTaskSettings?:string, Status?:string, LastFailureMessage?:string, StopReason?:string, ReplicationTaskCreationDate?:int|string|\DateTimeInterface, ReplicationTaskStartDate?:int|string|\DateTimeInterface, CdcStartPosition?:string, CdcStopPosition?:string, RecoveryCheckpoint?:string, ReplicationTaskArn?:string, ReplicationTaskStats?:array{FullLoadProgressPercent?:int, ElapsedTimeMillis?:int, TablesLoaded?:int, TablesLoading?:int, TablesQueued?:int, TablesErrored?:int, FreshStartDate?:int|string|\DateTimeInterface, StartDate?:int|string|\DateTimeInterface, StopDate?:int|string|\DateTimeInterface, FullLoadStartDate?:int|string|\DateTimeInterface, FullLoadFinishDate?:int|string|\DateTimeInterface}, TaskData?:string, TargetReplicationInstanceArn?:string}}>
     */
    public function modifyReplicationTaskAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ReplicationTaskArn:string, TargetReplicationInstanceArn:string} $args
     * @return \AWS\Result<array{ReplicationTask?:array{ReplicationTaskIdentifier?:string, SourceEndpointArn?:string, TargetEndpointArn?:string, ReplicationInstanceArn?:string, MigrationType?:"full-load"|"cdc"|"full-load-and-cdc", TableMappings?:string, ReplicationTaskSettings?:string, Status?:string, LastFailureMessage?:string, StopReason?:string, ReplicationTaskCreationDate?:int|string|\DateTimeInterface, ReplicationTaskStartDate?:int|string|\DateTimeInterface, CdcStartPosition?:string, CdcStopPosition?:string, RecoveryCheckpoint?:string, ReplicationTaskArn?:string, ReplicationTaskStats?:array{FullLoadProgressPercent?:int, ElapsedTimeMillis?:int, TablesLoaded?:int, TablesLoading?:int, TablesQueued?:int, TablesErrored?:int, FreshStartDate?:int|string|\DateTimeInterface, StartDate?:int|string|\DateTimeInterface, StopDate?:int|string|\DateTimeInterface, FullLoadStartDate?:int|string|\DateTimeInterface, FullLoadFinishDate?:int|string|\DateTimeInterface}, TaskData?:string, TargetReplicationInstanceArn?:string}}>
     */
    public function moveReplicationTask(array $args): \AWS\Result { }

    /**
     * @param array{ReplicationTaskArn:string, TargetReplicationInstanceArn:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{ReplicationTask?:array{ReplicationTaskIdentifier?:string, SourceEndpointArn?:string, TargetEndpointArn?:string, ReplicationInstanceArn?:string, MigrationType?:"full-load"|"cdc"|"full-load-and-cdc", TableMappings?:string, ReplicationTaskSettings?:string, Status?:string, LastFailureMessage?:string, StopReason?:string, ReplicationTaskCreationDate?:int|string|\DateTimeInterface, ReplicationTaskStartDate?:int|string|\DateTimeInterface, CdcStartPosition?:string, CdcStopPosition?:string, RecoveryCheckpoint?:string, ReplicationTaskArn?:string, ReplicationTaskStats?:array{FullLoadProgressPercent?:int, ElapsedTimeMillis?:int, TablesLoaded?:int, TablesLoading?:int, TablesQueued?:int, TablesErrored?:int, FreshStartDate?:int|string|\DateTimeInterface, StartDate?:int|string|\DateTimeInterface, StopDate?:int|string|\DateTimeInterface, FullLoadStartDate?:int|string|\DateTimeInterface, FullLoadFinishDate?:int|string|\DateTimeInterface}, TaskData?:string, TargetReplicationInstanceArn?:string}}>
     */
    public function moveReplicationTaskAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ReplicationInstanceArn:string, ForceFailover?:bool, ForcePlannedFailover?:bool} $args
     * @return \AWS\Result<array{ReplicationInstance?:array{ReplicationInstanceIdentifier?:string, ReplicationInstanceClass?:string, ReplicationInstanceStatus?:string, AllocatedStorage?:int, InstanceCreateTime?:int|string|\DateTimeInterface, VpcSecurityGroups?:array<array{VpcSecurityGroupId?:string, Status?:string}>, AvailabilityZone?:string, ReplicationSubnetGroup?:array{ReplicationSubnetGroupIdentifier?:string, ReplicationSubnetGroupDescription?:string, VpcId?:string, SubnetGroupStatus?:string, Subnets?:array<array{SubnetIdentifier?:string, SubnetAvailabilityZone?:array{Name?:string}, SubnetStatus?:string}>, SupportedNetworkTypes?:array<string>}, PreferredMaintenanceWindow?:string, PendingModifiedValues?:array{ReplicationInstanceClass?:string, AllocatedStorage?:int, MultiAZ?:bool, EngineVersion?:string, NetworkType?:string}, MultiAZ?:bool, EngineVersion?:string, AutoMinorVersionUpgrade?:bool, KmsKeyId?:string, ReplicationInstanceArn?:string, ReplicationInstancePublicIpAddress?:string, ReplicationInstancePrivateIpAddress?:string, ReplicationInstancePublicIpAddresses?:array<string>, ReplicationInstancePrivateIpAddresses?:array<string>, ReplicationInstanceIpv6Addresses?:array<string>, PubliclyAccessible?:bool, SecondaryAvailabilityZone?:string, FreeUntil?:int|string|\DateTimeInterface, DnsNameServers?:string, NetworkType?:string, KerberosAuthenticationSettings?:array{KeyCacheSecretId?:string, KeyCacheSecretIamArn?:string, Krb5FileContents?:string}}}>
     */
    public function rebootReplicationInstance(array $args): \AWS\Result { }

    /**
     * @param array{ReplicationInstanceArn:string, ForceFailover?:bool, ForcePlannedFailover?:bool} $args
     * @return \GuzzleHttp\Promise\Promise<array{ReplicationInstance?:array{ReplicationInstanceIdentifier?:string, ReplicationInstanceClass?:string, ReplicationInstanceStatus?:string, AllocatedStorage?:int, InstanceCreateTime?:int|string|\DateTimeInterface, VpcSecurityGroups?:array<array{VpcSecurityGroupId?:string, Status?:string}>, AvailabilityZone?:string, ReplicationSubnetGroup?:array{ReplicationSubnetGroupIdentifier?:string, ReplicationSubnetGroupDescription?:string, VpcId?:string, SubnetGroupStatus?:string, Subnets?:array<array{SubnetIdentifier?:string, SubnetAvailabilityZone?:array{Name?:string}, SubnetStatus?:string}>, SupportedNetworkTypes?:array<string>}, PreferredMaintenanceWindow?:string, PendingModifiedValues?:array{ReplicationInstanceClass?:string, AllocatedStorage?:int, MultiAZ?:bool, EngineVersion?:string, NetworkType?:string}, MultiAZ?:bool, EngineVersion?:string, AutoMinorVersionUpgrade?:bool, KmsKeyId?:string, ReplicationInstanceArn?:string, ReplicationInstancePublicIpAddress?:string, ReplicationInstancePrivateIpAddress?:string, ReplicationInstancePublicIpAddresses?:array<string>, ReplicationInstancePrivateIpAddresses?:array<string>, ReplicationInstanceIpv6Addresses?:array<string>, PubliclyAccessible?:bool, SecondaryAvailabilityZone?:string, FreeUntil?:int|string|\DateTimeInterface, DnsNameServers?:string, NetworkType?:string, KerberosAuthenticationSettings?:array{KeyCacheSecretId?:string, KeyCacheSecretIamArn?:string, Krb5FileContents?:string}}}>
     */
    public function rebootReplicationInstanceAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{EndpointArn:string, ReplicationInstanceArn:string} $args
     * @return \AWS\Result<array{RefreshSchemasStatus?:array{EndpointArn?:string, ReplicationInstanceArn?:string, Status?:"successful"|"failed"|"refreshing", LastRefreshDate?:int|string|\DateTimeInterface, LastFailureMessage?:string}}>
     */
    public function refreshSchemas(array $args): \AWS\Result { }

    /**
     * @param array{EndpointArn:string, ReplicationInstanceArn:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{RefreshSchemasStatus?:array{EndpointArn?:string, ReplicationInstanceArn?:string, Status?:"successful"|"failed"|"refreshing", LastRefreshDate?:int|string|\DateTimeInterface, LastFailureMessage?:string}}>
     */
    public function refreshSchemasAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ReplicationConfigArn:string, TablesToReload:array<array{SchemaName:string, TableName:string}>, ReloadOption?:"data-reload"|"validate-only"} $args
     * @return \AWS\Result<array{ReplicationConfigArn?:string}>
     */
    public function reloadReplicationTables(array $args): \AWS\Result { }

    /**
     * @param array{ReplicationConfigArn:string, TablesToReload:array<array{SchemaName:string, TableName:string}>, ReloadOption?:"data-reload"|"validate-only"} $args
     * @return \GuzzleHttp\Promise\Promise<array{ReplicationConfigArn?:string}>
     */
    public function reloadReplicationTablesAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ReplicationTaskArn:string, TablesToReload:array<array{SchemaName:string, TableName:string}>, ReloadOption?:"data-reload"|"validate-only"} $args
     * @return \AWS\Result<array{ReplicationTaskArn?:string}>
     */
    public function reloadTables(array $args): \AWS\Result { }

    /**
     * @param array{ReplicationTaskArn:string, TablesToReload:array<array{SchemaName:string, TableName:string}>, ReloadOption?:"data-reload"|"validate-only"} $args
     * @return \GuzzleHttp\Promise\Promise<array{ReplicationTaskArn?:string}>
     */
    public function reloadTablesAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ResourceArn:string, TagKeys:array<string>} $args
     * @return \AWS\Result<array{}>
     */
    public function removeTagsFromResource(array $args): \AWS\Result { }

    /**
     * @param array{ResourceArn:string, TagKeys:array<string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function removeTagsFromResourceAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array $args
     * @return \AWS\Result<array{LsaAnalysisId?:string, Status?:string}>
     */
    public function runFleetAdvisorLsaAnalysis(array $args = []): \AWS\Result { }

    /**
     * @param array $args
     * @return \GuzzleHttp\Promise\Promise<array{LsaAnalysisId?:string, Status?:string}>
     */
    public function runFleetAdvisorLsaAnalysisAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{DataMigrationIdentifier:string, StartType:"reload-target"|"resume-processing"|"start-replication"} $args
     * @return \AWS\Result<array{DataMigration?:array{DataMigrationName?:string, DataMigrationArn?:string, DataMigrationCreateTime?:int|string|\DateTimeInterface, DataMigrationStartTime?:int|string|\DateTimeInterface, DataMigrationEndTime?:int|string|\DateTimeInterface, ServiceAccessRoleArn?:string, MigrationProjectArn?:string, DataMigrationType?:"full-load"|"cdc"|"full-load-and-cdc", DataMigrationSettings?:array{NumberOfJobs?:int, CloudwatchLogsEnabled?:bool, SelectionRules?:string}, SourceDataSettings?:array<array{CDCStartPosition?:string, CDCStartTime?:int|string|\DateTimeInterface, CDCStopTime?:int|string|\DateTimeInterface, SlotName?:string}>, DataMigrationStatistics?:array{TablesLoaded?:int, ElapsedTimeMillis?:int, TablesLoading?:int, FullLoadPercentage?:int, CDCLatency?:int, TablesQueued?:int, TablesErrored?:int, StartTime?:int|string|\DateTimeInterface, StopTime?:int|string|\DateTimeInterface}, DataMigrationStatus?:string, PublicIpAddresses?:array<string>, DataMigrationCidrBlocks?:array<string>, LastFailureMessage?:string, StopReason?:string}}>
     */
    public function startDataMigration(array $args): \AWS\Result { }

    /**
     * @param array{DataMigrationIdentifier:string, StartType:"reload-target"|"resume-processing"|"start-replication"} $args
     * @return \GuzzleHttp\Promise\Promise<array{DataMigration?:array{DataMigrationName?:string, DataMigrationArn?:string, DataMigrationCreateTime?:int|string|\DateTimeInterface, DataMigrationStartTime?:int|string|\DateTimeInterface, DataMigrationEndTime?:int|string|\DateTimeInterface, ServiceAccessRoleArn?:string, MigrationProjectArn?:string, DataMigrationType?:"full-load"|"cdc"|"full-load-and-cdc", DataMigrationSettings?:array{NumberOfJobs?:int, CloudwatchLogsEnabled?:bool, SelectionRules?:string}, SourceDataSettings?:array<array{CDCStartPosition?:string, CDCStartTime?:int|string|\DateTimeInterface, CDCStopTime?:int|string|\DateTimeInterface, SlotName?:string}>, DataMigrationStatistics?:array{TablesLoaded?:int, ElapsedTimeMillis?:int, TablesLoading?:int, FullLoadPercentage?:int, CDCLatency?:int, TablesQueued?:int, TablesErrored?:int, StartTime?:int|string|\DateTimeInterface, StopTime?:int|string|\DateTimeInterface}, DataMigrationStatus?:string, PublicIpAddresses?:array<string>, DataMigrationCidrBlocks?:array<string>, LastFailureMessage?:string, StopReason?:string}}>
     */
    public function startDataMigrationAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{MigrationProjectIdentifier:string} $args
     * @return \AWS\Result<array{RequestIdentifier?:string}>
     */
    public function startExtensionPackAssociation(array $args): \AWS\Result { }

    /**
     * @param array{MigrationProjectIdentifier:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{RequestIdentifier?:string}>
     */
    public function startExtensionPackAssociationAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{MigrationProjectIdentifier:string, SelectionRules:string} $args
     * @return \AWS\Result<array{RequestIdentifier?:string}>
     */
    public function startMetadataModelAssessment(array $args): \AWS\Result { }

    /**
     * @param array{MigrationProjectIdentifier:string, SelectionRules:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{RequestIdentifier?:string}>
     */
    public function startMetadataModelAssessmentAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{MigrationProjectIdentifier:string, SelectionRules:string} $args
     * @return \AWS\Result<array{RequestIdentifier?:string}>
     */
    public function startMetadataModelConversion(array $args): \AWS\Result { }

    /**
     * @param array{MigrationProjectIdentifier:string, SelectionRules:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{RequestIdentifier?:string}>
     */
    public function startMetadataModelConversionAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{MigrationProjectIdentifier:string, SelectionRules:string, Origin:"SOURCE"|"TARGET", FileName?:string} $args
     * @return \AWS\Result<array{RequestIdentifier?:string}>
     */
    public function startMetadataModelExportAsScript(array $args): \AWS\Result { }

    /**
     * @param array{MigrationProjectIdentifier:string, SelectionRules:string, Origin:"SOURCE"|"TARGET", FileName?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{RequestIdentifier?:string}>
     */
    public function startMetadataModelExportAsScriptAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{MigrationProjectIdentifier:string, SelectionRules:string, OverwriteExtensionPack?:bool} $args
     * @return \AWS\Result<array{RequestIdentifier?:string}>
     */
    public function startMetadataModelExportToTarget(array $args): \AWS\Result { }

    /**
     * @param array{MigrationProjectIdentifier:string, SelectionRules:string, OverwriteExtensionPack?:bool} $args
     * @return \GuzzleHttp\Promise\Promise<array{RequestIdentifier?:string}>
     */
    public function startMetadataModelExportToTargetAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{MigrationProjectIdentifier:string, SelectionRules:string, Origin:"SOURCE"|"TARGET", Refresh?:bool} $args
     * @return \AWS\Result<array{RequestIdentifier?:string}>
     */
    public function startMetadataModelImport(array $args): \AWS\Result { }

    /**
     * @param array{MigrationProjectIdentifier:string, SelectionRules:string, Origin:"SOURCE"|"TARGET", Refresh?:bool} $args
     * @return \GuzzleHttp\Promise\Promise<array{RequestIdentifier?:string}>
     */
    public function startMetadataModelImportAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{DatabaseId:string, Settings:array{InstanceSizingType:string, WorkloadType:string}} $args
     * @return \AWS\Result<void>
     */
    public function startRecommendations(array $args): \AWS\Result { }

    /**
     * @param array{DatabaseId:string, Settings:array{InstanceSizingType:string, WorkloadType:string}} $args
     * @return \GuzzleHttp\Promise\Promise<void>
     */
    public function startRecommendationsAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ReplicationConfigArn:string, StartReplicationType:string, CdcStartTime?:int|string|\DateTimeInterface, CdcStartPosition?:string, CdcStopPosition?:string} $args
     * @return \AWS\Result<array{Replication?:array{ReplicationConfigIdentifier?:string, ReplicationConfigArn?:string, SourceEndpointArn?:string, TargetEndpointArn?:string, ReplicationType?:"full-load"|"cdc"|"full-load-and-cdc", Status?:string, ProvisionData?:array{ProvisionState?:string, ProvisionedCapacityUnits?:int, DateProvisioned?:int|string|\DateTimeInterface, IsNewProvisioningAvailable?:bool, DateNewProvisioningDataAvailable?:int|string|\DateTimeInterface, ReasonForNewProvisioningData?:string}, StopReason?:string, FailureMessages?:array<string>, ReplicationStats?:array{FullLoadProgressPercent?:int, ElapsedTimeMillis?:int, TablesLoaded?:int, TablesLoading?:int, TablesQueued?:int, TablesErrored?:int, FreshStartDate?:int|string|\DateTimeInterface, StartDate?:int|string|\DateTimeInterface, StopDate?:int|string|\DateTimeInterface, FullLoadStartDate?:int|string|\DateTimeInterface, FullLoadFinishDate?:int|string|\DateTimeInterface}, StartReplicationType?:string, CdcStartTime?:int|string|\DateTimeInterface, CdcStartPosition?:string, CdcStopPosition?:string, RecoveryCheckpoint?:string, ReplicationCreateTime?:int|string|\DateTimeInterface, ReplicationUpdateTime?:int|string|\DateTimeInterface, ReplicationLastStopTime?:int|string|\DateTimeInterface, ReplicationDeprovisionTime?:int|string|\DateTimeInterface}}>
     */
    public function startReplication(array $args): \AWS\Result { }

    /**
     * @param array{ReplicationConfigArn:string, StartReplicationType:string, CdcStartTime?:int|string|\DateTimeInterface, CdcStartPosition?:string, CdcStopPosition?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Replication?:array{ReplicationConfigIdentifier?:string, ReplicationConfigArn?:string, SourceEndpointArn?:string, TargetEndpointArn?:string, ReplicationType?:"full-load"|"cdc"|"full-load-and-cdc", Status?:string, ProvisionData?:array{ProvisionState?:string, ProvisionedCapacityUnits?:int, DateProvisioned?:int|string|\DateTimeInterface, IsNewProvisioningAvailable?:bool, DateNewProvisioningDataAvailable?:int|string|\DateTimeInterface, ReasonForNewProvisioningData?:string}, StopReason?:string, FailureMessages?:array<string>, ReplicationStats?:array{FullLoadProgressPercent?:int, ElapsedTimeMillis?:int, TablesLoaded?:int, TablesLoading?:int, TablesQueued?:int, TablesErrored?:int, FreshStartDate?:int|string|\DateTimeInterface, StartDate?:int|string|\DateTimeInterface, StopDate?:int|string|\DateTimeInterface, FullLoadStartDate?:int|string|\DateTimeInterface, FullLoadFinishDate?:int|string|\DateTimeInterface}, StartReplicationType?:string, CdcStartTime?:int|string|\DateTimeInterface, CdcStartPosition?:string, CdcStopPosition?:string, RecoveryCheckpoint?:string, ReplicationCreateTime?:int|string|\DateTimeInterface, ReplicationUpdateTime?:int|string|\DateTimeInterface, ReplicationLastStopTime?:int|string|\DateTimeInterface, ReplicationDeprovisionTime?:int|string|\DateTimeInterface}}>
     */
    public function startReplicationAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ReplicationTaskArn:string, StartReplicationTaskType:"start-replication"|"resume-processing"|"reload-target", CdcStartTime?:int|string|\DateTimeInterface, CdcStartPosition?:string, CdcStopPosition?:string} $args
     * @return \AWS\Result<array{ReplicationTask?:array{ReplicationTaskIdentifier?:string, SourceEndpointArn?:string, TargetEndpointArn?:string, ReplicationInstanceArn?:string, MigrationType?:"full-load"|"cdc"|"full-load-and-cdc", TableMappings?:string, ReplicationTaskSettings?:string, Status?:string, LastFailureMessage?:string, StopReason?:string, ReplicationTaskCreationDate?:int|string|\DateTimeInterface, ReplicationTaskStartDate?:int|string|\DateTimeInterface, CdcStartPosition?:string, CdcStopPosition?:string, RecoveryCheckpoint?:string, ReplicationTaskArn?:string, ReplicationTaskStats?:array{FullLoadProgressPercent?:int, ElapsedTimeMillis?:int, TablesLoaded?:int, TablesLoading?:int, TablesQueued?:int, TablesErrored?:int, FreshStartDate?:int|string|\DateTimeInterface, StartDate?:int|string|\DateTimeInterface, StopDate?:int|string|\DateTimeInterface, FullLoadStartDate?:int|string|\DateTimeInterface, FullLoadFinishDate?:int|string|\DateTimeInterface}, TaskData?:string, TargetReplicationInstanceArn?:string}}>
     */
    public function startReplicationTask(array $args): \AWS\Result { }

    /**
     * @param array{ReplicationTaskArn:string, StartReplicationTaskType:"start-replication"|"resume-processing"|"reload-target", CdcStartTime?:int|string|\DateTimeInterface, CdcStartPosition?:string, CdcStopPosition?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{ReplicationTask?:array{ReplicationTaskIdentifier?:string, SourceEndpointArn?:string, TargetEndpointArn?:string, ReplicationInstanceArn?:string, MigrationType?:"full-load"|"cdc"|"full-load-and-cdc", TableMappings?:string, ReplicationTaskSettings?:string, Status?:string, LastFailureMessage?:string, StopReason?:string, ReplicationTaskCreationDate?:int|string|\DateTimeInterface, ReplicationTaskStartDate?:int|string|\DateTimeInterface, CdcStartPosition?:string, CdcStopPosition?:string, RecoveryCheckpoint?:string, ReplicationTaskArn?:string, ReplicationTaskStats?:array{FullLoadProgressPercent?:int, ElapsedTimeMillis?:int, TablesLoaded?:int, TablesLoading?:int, TablesQueued?:int, TablesErrored?:int, FreshStartDate?:int|string|\DateTimeInterface, StartDate?:int|string|\DateTimeInterface, StopDate?:int|string|\DateTimeInterface, FullLoadStartDate?:int|string|\DateTimeInterface, FullLoadFinishDate?:int|string|\DateTimeInterface}, TaskData?:string, TargetReplicationInstanceArn?:string}}>
     */
    public function startReplicationTaskAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ReplicationTaskArn:string} $args
     * @return \AWS\Result<array{ReplicationTask?:array{ReplicationTaskIdentifier?:string, SourceEndpointArn?:string, TargetEndpointArn?:string, ReplicationInstanceArn?:string, MigrationType?:"full-load"|"cdc"|"full-load-and-cdc", TableMappings?:string, ReplicationTaskSettings?:string, Status?:string, LastFailureMessage?:string, StopReason?:string, ReplicationTaskCreationDate?:int|string|\DateTimeInterface, ReplicationTaskStartDate?:int|string|\DateTimeInterface, CdcStartPosition?:string, CdcStopPosition?:string, RecoveryCheckpoint?:string, ReplicationTaskArn?:string, ReplicationTaskStats?:array{FullLoadProgressPercent?:int, ElapsedTimeMillis?:int, TablesLoaded?:int, TablesLoading?:int, TablesQueued?:int, TablesErrored?:int, FreshStartDate?:int|string|\DateTimeInterface, StartDate?:int|string|\DateTimeInterface, StopDate?:int|string|\DateTimeInterface, FullLoadStartDate?:int|string|\DateTimeInterface, FullLoadFinishDate?:int|string|\DateTimeInterface}, TaskData?:string, TargetReplicationInstanceArn?:string}}>
     */
    public function startReplicationTaskAssessment(array $args): \AWS\Result { }

    /**
     * @param array{ReplicationTaskArn:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{ReplicationTask?:array{ReplicationTaskIdentifier?:string, SourceEndpointArn?:string, TargetEndpointArn?:string, ReplicationInstanceArn?:string, MigrationType?:"full-load"|"cdc"|"full-load-and-cdc", TableMappings?:string, ReplicationTaskSettings?:string, Status?:string, LastFailureMessage?:string, StopReason?:string, ReplicationTaskCreationDate?:int|string|\DateTimeInterface, ReplicationTaskStartDate?:int|string|\DateTimeInterface, CdcStartPosition?:string, CdcStopPosition?:string, RecoveryCheckpoint?:string, ReplicationTaskArn?:string, ReplicationTaskStats?:array{FullLoadProgressPercent?:int, ElapsedTimeMillis?:int, TablesLoaded?:int, TablesLoading?:int, TablesQueued?:int, TablesErrored?:int, FreshStartDate?:int|string|\DateTimeInterface, StartDate?:int|string|\DateTimeInterface, StopDate?:int|string|\DateTimeInterface, FullLoadStartDate?:int|string|\DateTimeInterface, FullLoadFinishDate?:int|string|\DateTimeInterface}, TaskData?:string, TargetReplicationInstanceArn?:string}}>
     */
    public function startReplicationTaskAssessmentAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ReplicationTaskArn:string, ServiceAccessRoleArn:string, ResultLocationBucket:string, ResultLocationFolder?:string, ResultEncryptionMode?:string, ResultKmsKeyArn?:string, AssessmentRunName:string, IncludeOnly?:array<string>, Exclude?:array<string>, Tags?:array<array{Key?:string, Value?:string, ResourceArn?:string}>} $args
     * @return \AWS\Result<array{ReplicationTaskAssessmentRun?:array{ReplicationTaskAssessmentRunArn?:string, ReplicationTaskArn?:string, Status?:string, ReplicationTaskAssessmentRunCreationDate?:int|string|\DateTimeInterface, AssessmentProgress?:array{IndividualAssessmentCount?:int, IndividualAssessmentCompletedCount?:int}, LastFailureMessage?:string, ServiceAccessRoleArn?:string, ResultLocationBucket?:string, ResultLocationFolder?:string, ResultEncryptionMode?:string, ResultKmsKeyArn?:string, AssessmentRunName?:string, IsLatestTaskAssessmentRun?:bool, ResultStatistic?:array{Passed?:int, Failed?:int, Error?:int, Warning?:int, Cancelled?:int}}}>
     */
    public function startReplicationTaskAssessmentRun(array $args): \AWS\Result { }

    /**
     * @param array{ReplicationTaskArn:string, ServiceAccessRoleArn:string, ResultLocationBucket:string, ResultLocationFolder?:string, ResultEncryptionMode?:string, ResultKmsKeyArn?:string, AssessmentRunName:string, IncludeOnly?:array<string>, Exclude?:array<string>, Tags?:array<array{Key?:string, Value?:string, ResourceArn?:string}>} $args
     * @return \GuzzleHttp\Promise\Promise<array{ReplicationTaskAssessmentRun?:array{ReplicationTaskAssessmentRunArn?:string, ReplicationTaskArn?:string, Status?:string, ReplicationTaskAssessmentRunCreationDate?:int|string|\DateTimeInterface, AssessmentProgress?:array{IndividualAssessmentCount?:int, IndividualAssessmentCompletedCount?:int}, LastFailureMessage?:string, ServiceAccessRoleArn?:string, ResultLocationBucket?:string, ResultLocationFolder?:string, ResultEncryptionMode?:string, ResultKmsKeyArn?:string, AssessmentRunName?:string, IsLatestTaskAssessmentRun?:bool, ResultStatistic?:array{Passed?:int, Failed?:int, Error?:int, Warning?:int, Cancelled?:int}}}>
     */
    public function startReplicationTaskAssessmentRunAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{DataMigrationIdentifier:string} $args
     * @return \AWS\Result<array{DataMigration?:array{DataMigrationName?:string, DataMigrationArn?:string, DataMigrationCreateTime?:int|string|\DateTimeInterface, DataMigrationStartTime?:int|string|\DateTimeInterface, DataMigrationEndTime?:int|string|\DateTimeInterface, ServiceAccessRoleArn?:string, MigrationProjectArn?:string, DataMigrationType?:"full-load"|"cdc"|"full-load-and-cdc", DataMigrationSettings?:array{NumberOfJobs?:int, CloudwatchLogsEnabled?:bool, SelectionRules?:string}, SourceDataSettings?:array<array{CDCStartPosition?:string, CDCStartTime?:int|string|\DateTimeInterface, CDCStopTime?:int|string|\DateTimeInterface, SlotName?:string}>, DataMigrationStatistics?:array{TablesLoaded?:int, ElapsedTimeMillis?:int, TablesLoading?:int, FullLoadPercentage?:int, CDCLatency?:int, TablesQueued?:int, TablesErrored?:int, StartTime?:int|string|\DateTimeInterface, StopTime?:int|string|\DateTimeInterface}, DataMigrationStatus?:string, PublicIpAddresses?:array<string>, DataMigrationCidrBlocks?:array<string>, LastFailureMessage?:string, StopReason?:string}}>
     */
    public function stopDataMigration(array $args): \AWS\Result { }

    /**
     * @param array{DataMigrationIdentifier:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{DataMigration?:array{DataMigrationName?:string, DataMigrationArn?:string, DataMigrationCreateTime?:int|string|\DateTimeInterface, DataMigrationStartTime?:int|string|\DateTimeInterface, DataMigrationEndTime?:int|string|\DateTimeInterface, ServiceAccessRoleArn?:string, MigrationProjectArn?:string, DataMigrationType?:"full-load"|"cdc"|"full-load-and-cdc", DataMigrationSettings?:array{NumberOfJobs?:int, CloudwatchLogsEnabled?:bool, SelectionRules?:string}, SourceDataSettings?:array<array{CDCStartPosition?:string, CDCStartTime?:int|string|\DateTimeInterface, CDCStopTime?:int|string|\DateTimeInterface, SlotName?:string}>, DataMigrationStatistics?:array{TablesLoaded?:int, ElapsedTimeMillis?:int, TablesLoading?:int, FullLoadPercentage?:int, CDCLatency?:int, TablesQueued?:int, TablesErrored?:int, StartTime?:int|string|\DateTimeInterface, StopTime?:int|string|\DateTimeInterface}, DataMigrationStatus?:string, PublicIpAddresses?:array<string>, DataMigrationCidrBlocks?:array<string>, LastFailureMessage?:string, StopReason?:string}}>
     */
    public function stopDataMigrationAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ReplicationConfigArn:string} $args
     * @return \AWS\Result<array{Replication?:array{ReplicationConfigIdentifier?:string, ReplicationConfigArn?:string, SourceEndpointArn?:string, TargetEndpointArn?:string, ReplicationType?:"full-load"|"cdc"|"full-load-and-cdc", Status?:string, ProvisionData?:array{ProvisionState?:string, ProvisionedCapacityUnits?:int, DateProvisioned?:int|string|\DateTimeInterface, IsNewProvisioningAvailable?:bool, DateNewProvisioningDataAvailable?:int|string|\DateTimeInterface, ReasonForNewProvisioningData?:string}, StopReason?:string, FailureMessages?:array<string>, ReplicationStats?:array{FullLoadProgressPercent?:int, ElapsedTimeMillis?:int, TablesLoaded?:int, TablesLoading?:int, TablesQueued?:int, TablesErrored?:int, FreshStartDate?:int|string|\DateTimeInterface, StartDate?:int|string|\DateTimeInterface, StopDate?:int|string|\DateTimeInterface, FullLoadStartDate?:int|string|\DateTimeInterface, FullLoadFinishDate?:int|string|\DateTimeInterface}, StartReplicationType?:string, CdcStartTime?:int|string|\DateTimeInterface, CdcStartPosition?:string, CdcStopPosition?:string, RecoveryCheckpoint?:string, ReplicationCreateTime?:int|string|\DateTimeInterface, ReplicationUpdateTime?:int|string|\DateTimeInterface, ReplicationLastStopTime?:int|string|\DateTimeInterface, ReplicationDeprovisionTime?:int|string|\DateTimeInterface}}>
     */
    public function stopReplication(array $args): \AWS\Result { }

    /**
     * @param array{ReplicationConfigArn:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Replication?:array{ReplicationConfigIdentifier?:string, ReplicationConfigArn?:string, SourceEndpointArn?:string, TargetEndpointArn?:string, ReplicationType?:"full-load"|"cdc"|"full-load-and-cdc", Status?:string, ProvisionData?:array{ProvisionState?:string, ProvisionedCapacityUnits?:int, DateProvisioned?:int|string|\DateTimeInterface, IsNewProvisioningAvailable?:bool, DateNewProvisioningDataAvailable?:int|string|\DateTimeInterface, ReasonForNewProvisioningData?:string}, StopReason?:string, FailureMessages?:array<string>, ReplicationStats?:array{FullLoadProgressPercent?:int, ElapsedTimeMillis?:int, TablesLoaded?:int, TablesLoading?:int, TablesQueued?:int, TablesErrored?:int, FreshStartDate?:int|string|\DateTimeInterface, StartDate?:int|string|\DateTimeInterface, StopDate?:int|string|\DateTimeInterface, FullLoadStartDate?:int|string|\DateTimeInterface, FullLoadFinishDate?:int|string|\DateTimeInterface}, StartReplicationType?:string, CdcStartTime?:int|string|\DateTimeInterface, CdcStartPosition?:string, CdcStopPosition?:string, RecoveryCheckpoint?:string, ReplicationCreateTime?:int|string|\DateTimeInterface, ReplicationUpdateTime?:int|string|\DateTimeInterface, ReplicationLastStopTime?:int|string|\DateTimeInterface, ReplicationDeprovisionTime?:int|string|\DateTimeInterface}}>
     */
    public function stopReplicationAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ReplicationTaskArn:string} $args
     * @return \AWS\Result<array{ReplicationTask?:array{ReplicationTaskIdentifier?:string, SourceEndpointArn?:string, TargetEndpointArn?:string, ReplicationInstanceArn?:string, MigrationType?:"full-load"|"cdc"|"full-load-and-cdc", TableMappings?:string, ReplicationTaskSettings?:string, Status?:string, LastFailureMessage?:string, StopReason?:string, ReplicationTaskCreationDate?:int|string|\DateTimeInterface, ReplicationTaskStartDate?:int|string|\DateTimeInterface, CdcStartPosition?:string, CdcStopPosition?:string, RecoveryCheckpoint?:string, ReplicationTaskArn?:string, ReplicationTaskStats?:array{FullLoadProgressPercent?:int, ElapsedTimeMillis?:int, TablesLoaded?:int, TablesLoading?:int, TablesQueued?:int, TablesErrored?:int, FreshStartDate?:int|string|\DateTimeInterface, StartDate?:int|string|\DateTimeInterface, StopDate?:int|string|\DateTimeInterface, FullLoadStartDate?:int|string|\DateTimeInterface, FullLoadFinishDate?:int|string|\DateTimeInterface}, TaskData?:string, TargetReplicationInstanceArn?:string}}>
     */
    public function stopReplicationTask(array $args): \AWS\Result { }

    /**
     * @param array{ReplicationTaskArn:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{ReplicationTask?:array{ReplicationTaskIdentifier?:string, SourceEndpointArn?:string, TargetEndpointArn?:string, ReplicationInstanceArn?:string, MigrationType?:"full-load"|"cdc"|"full-load-and-cdc", TableMappings?:string, ReplicationTaskSettings?:string, Status?:string, LastFailureMessage?:string, StopReason?:string, ReplicationTaskCreationDate?:int|string|\DateTimeInterface, ReplicationTaskStartDate?:int|string|\DateTimeInterface, CdcStartPosition?:string, CdcStopPosition?:string, RecoveryCheckpoint?:string, ReplicationTaskArn?:string, ReplicationTaskStats?:array{FullLoadProgressPercent?:int, ElapsedTimeMillis?:int, TablesLoaded?:int, TablesLoading?:int, TablesQueued?:int, TablesErrored?:int, FreshStartDate?:int|string|\DateTimeInterface, StartDate?:int|string|\DateTimeInterface, StopDate?:int|string|\DateTimeInterface, FullLoadStartDate?:int|string|\DateTimeInterface, FullLoadFinishDate?:int|string|\DateTimeInterface}, TaskData?:string, TargetReplicationInstanceArn?:string}}>
     */
    public function stopReplicationTaskAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ReplicationInstanceArn:string, EndpointArn:string} $args
     * @return \AWS\Result<array{Connection?:array{ReplicationInstanceArn?:string, EndpointArn?:string, Status?:string, LastFailureMessage?:string, EndpointIdentifier?:string, ReplicationInstanceIdentifier?:string}}>
     */
    public function testConnection(array $args): \AWS\Result { }

    /**
     * @param array{ReplicationInstanceArn:string, EndpointArn:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{Connection?:array{ReplicationInstanceArn?:string, EndpointArn?:string, Status?:string, LastFailureMessage?:string, EndpointIdentifier?:string, ReplicationInstanceIdentifier?:string}}>
     */
    public function testConnectionAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{ForceMove?:bool} $args
     * @return \AWS\Result<array{Result?:string}>
     */
    public function updateSubscriptionsToEventBridge(array $args = []): \AWS\Result { }

    /**
     * @param array{ForceMove?:bool} $args
     * @return \GuzzleHttp\Promise\Promise<array{Result?:string}>
     */
    public function updateSubscriptionsToEventBridgeAsync(array $args = []): \GuzzleHttp\Promise\Promise { }
}
