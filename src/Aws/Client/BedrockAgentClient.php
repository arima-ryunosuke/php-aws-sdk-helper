<?php
namespace AWS\BedrockAgent;

class BedrockAgentClient
{
    /**
     * @param array{agentDescriptor:array{aliasArn?:string}, agentId:string, agentVersion:string, clientToken?:string, collaborationInstruction:string, collaboratorName:string, relayConversationHistory?:"TO_COLLABORATOR"|"DISABLED"} $args
     * @return \AWS\Result<array{agentCollaborator:array{agentDescriptor:array{aliasArn?:string}, agentId:string, agentVersion:string, clientToken?:string, collaborationInstruction:string, collaboratorId:string, collaboratorName:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, relayConversationHistory?:"TO_COLLABORATOR"|"DISABLED"}}>
     */
    public function associateAgentCollaborator(array $args): \AWS\Result { }

    /**
     * @param array{agentDescriptor:array{aliasArn?:string}, agentId:string, agentVersion:string, clientToken?:string, collaborationInstruction:string, collaboratorName:string, relayConversationHistory?:"TO_COLLABORATOR"|"DISABLED"} $args
     * @return \GuzzleHttp\Promise\Promise<array{agentCollaborator:array{agentDescriptor:array{aliasArn?:string}, agentId:string, agentVersion:string, clientToken?:string, collaborationInstruction:string, collaboratorId:string, collaboratorName:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, relayConversationHistory?:"TO_COLLABORATOR"|"DISABLED"}}>
     */
    public function associateAgentCollaboratorAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{agentId:string, agentVersion:string, description:string, knowledgeBaseId:string, knowledgeBaseState?:"ENABLED"|"DISABLED"} $args
     * @return \AWS\Result<array{agentKnowledgeBase:array{agentId:string, agentVersion:string, createdAt:int|string|\DateTimeInterface, description:string, knowledgeBaseId:string, knowledgeBaseState:"ENABLED"|"DISABLED", updatedAt:int|string|\DateTimeInterface}}>
     */
    public function associateAgentKnowledgeBase(array $args): \AWS\Result { }

    /**
     * @param array{agentId:string, agentVersion:string, description:string, knowledgeBaseId:string, knowledgeBaseState?:"ENABLED"|"DISABLED"} $args
     * @return \GuzzleHttp\Promise\Promise<array{agentKnowledgeBase:array{agentId:string, agentVersion:string, createdAt:int|string|\DateTimeInterface, description:string, knowledgeBaseId:string, knowledgeBaseState:"ENABLED"|"DISABLED", updatedAt:int|string|\DateTimeInterface}}>
     */
    public function associateAgentKnowledgeBaseAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{agentCollaboration?:"SUPERVISOR"|"SUPERVISOR_ROUTER"|"DISABLED", agentName:string, agentResourceRoleArn?:string, clientToken?:string, customOrchestration?:array{executor?:array{lambda?:string}}, customerEncryptionKeyArn?:string, description?:string, foundationModel?:string, guardrailConfiguration?:array{guardrailIdentifier?:string, guardrailVersion?:string}, idleSessionTTLInSeconds?:int, instruction?:string, memoryConfiguration?:array{enabledMemoryTypes:array<"SESSION_SUMMARY">, sessionSummaryConfiguration?:array{maxRecentSessions?:int}, storageDays?:int}, orchestrationType?:"DEFAULT"|"CUSTOM_ORCHESTRATION", promptOverrideConfiguration?:array{overrideLambda?:string, promptConfigurations:array<array{basePromptTemplate?:string, foundationModel?:string, inferenceConfiguration?:array{maximumLength?:int, stopSequences?:array<string>, temperature?:float, topK?:int, topP?:float}, parserMode?:"DEFAULT"|"OVERRIDDEN", promptCreationMode?:"DEFAULT"|"OVERRIDDEN", promptState?:"ENABLED"|"DISABLED", promptType?:"PRE_PROCESSING"|"ORCHESTRATION"|"POST_PROCESSING"|"KNOWLEDGE_BASE_RESPONSE_GENERATION"|"MEMORY_SUMMARIZATION"}>}, tags?:array<string, string>} $args
     * @return \AWS\Result<array{agent:array{agentArn:string, agentCollaboration?:"SUPERVISOR"|"SUPERVISOR_ROUTER"|"DISABLED", agentId:string, agentName:string, agentResourceRoleArn:string, agentStatus:"CREATING"|"PREPARING"|"PREPARED"|"NOT_PREPARED"|"DELETING"|"FAILED"|"VERSIONING"|"UPDATING", agentVersion:string, clientToken?:string, createdAt:int|string|\DateTimeInterface, customOrchestration?:array{executor?:array{lambda?:string}}, customerEncryptionKeyArn?:string, description?:string, failureReasons?:array<string>, foundationModel?:string, guardrailConfiguration?:array{guardrailIdentifier?:string, guardrailVersion?:string}, idleSessionTTLInSeconds:int, instruction?:string, memoryConfiguration?:array{enabledMemoryTypes:array<"SESSION_SUMMARY">, sessionSummaryConfiguration?:array{maxRecentSessions?:int}, storageDays?:int}, orchestrationType?:"DEFAULT"|"CUSTOM_ORCHESTRATION", preparedAt?:int|string|\DateTimeInterface, promptOverrideConfiguration?:array{overrideLambda?:string, promptConfigurations:array<array{basePromptTemplate?:string, foundationModel?:string, inferenceConfiguration?:array{maximumLength?:int, stopSequences?:array<string>, temperature?:float, topK?:int, topP?:float}, parserMode?:"DEFAULT"|"OVERRIDDEN", promptCreationMode?:"DEFAULT"|"OVERRIDDEN", promptState?:"ENABLED"|"DISABLED", promptType?:"PRE_PROCESSING"|"ORCHESTRATION"|"POST_PROCESSING"|"KNOWLEDGE_BASE_RESPONSE_GENERATION"|"MEMORY_SUMMARIZATION"}>}, recommendedActions?:array<string>, updatedAt:int|string|\DateTimeInterface}}>
     */
    public function createAgent(array $args): \AWS\Result { }

    /**
     * @param array{agentCollaboration?:"SUPERVISOR"|"SUPERVISOR_ROUTER"|"DISABLED", agentName:string, agentResourceRoleArn?:string, clientToken?:string, customOrchestration?:array{executor?:array{lambda?:string}}, customerEncryptionKeyArn?:string, description?:string, foundationModel?:string, guardrailConfiguration?:array{guardrailIdentifier?:string, guardrailVersion?:string}, idleSessionTTLInSeconds?:int, instruction?:string, memoryConfiguration?:array{enabledMemoryTypes:array<"SESSION_SUMMARY">, sessionSummaryConfiguration?:array{maxRecentSessions?:int}, storageDays?:int}, orchestrationType?:"DEFAULT"|"CUSTOM_ORCHESTRATION", promptOverrideConfiguration?:array{overrideLambda?:string, promptConfigurations:array<array{basePromptTemplate?:string, foundationModel?:string, inferenceConfiguration?:array{maximumLength?:int, stopSequences?:array<string>, temperature?:float, topK?:int, topP?:float}, parserMode?:"DEFAULT"|"OVERRIDDEN", promptCreationMode?:"DEFAULT"|"OVERRIDDEN", promptState?:"ENABLED"|"DISABLED", promptType?:"PRE_PROCESSING"|"ORCHESTRATION"|"POST_PROCESSING"|"KNOWLEDGE_BASE_RESPONSE_GENERATION"|"MEMORY_SUMMARIZATION"}>}, tags?:array<string, string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{agent:array{agentArn:string, agentCollaboration?:"SUPERVISOR"|"SUPERVISOR_ROUTER"|"DISABLED", agentId:string, agentName:string, agentResourceRoleArn:string, agentStatus:"CREATING"|"PREPARING"|"PREPARED"|"NOT_PREPARED"|"DELETING"|"FAILED"|"VERSIONING"|"UPDATING", agentVersion:string, clientToken?:string, createdAt:int|string|\DateTimeInterface, customOrchestration?:array{executor?:array{lambda?:string}}, customerEncryptionKeyArn?:string, description?:string, failureReasons?:array<string>, foundationModel?:string, guardrailConfiguration?:array{guardrailIdentifier?:string, guardrailVersion?:string}, idleSessionTTLInSeconds:int, instruction?:string, memoryConfiguration?:array{enabledMemoryTypes:array<"SESSION_SUMMARY">, sessionSummaryConfiguration?:array{maxRecentSessions?:int}, storageDays?:int}, orchestrationType?:"DEFAULT"|"CUSTOM_ORCHESTRATION", preparedAt?:int|string|\DateTimeInterface, promptOverrideConfiguration?:array{overrideLambda?:string, promptConfigurations:array<array{basePromptTemplate?:string, foundationModel?:string, inferenceConfiguration?:array{maximumLength?:int, stopSequences?:array<string>, temperature?:float, topK?:int, topP?:float}, parserMode?:"DEFAULT"|"OVERRIDDEN", promptCreationMode?:"DEFAULT"|"OVERRIDDEN", promptState?:"ENABLED"|"DISABLED", promptType?:"PRE_PROCESSING"|"ORCHESTRATION"|"POST_PROCESSING"|"KNOWLEDGE_BASE_RESPONSE_GENERATION"|"MEMORY_SUMMARIZATION"}>}, recommendedActions?:array<string>, updatedAt:int|string|\DateTimeInterface}}>
     */
    public function createAgentAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{actionGroupExecutor?:array{customControl?:"RETURN_CONTROL", lambda?:string}, actionGroupName:string, actionGroupState?:"ENABLED"|"DISABLED", agentId:string, agentVersion:string, apiSchema?:array{payload?:string, s3?:array{s3BucketName?:string, s3ObjectKey?:string}}, clientToken?:string, description?:string, functionSchema?:array{functions?:array<array{description?:string, name:string, parameters?:array<string, array{description?:string, required?:bool, type:"string"|"number"|"integer"|"boolean"|"array"}>, requireConfirmation?:"ENABLED"|"DISABLED"}>}, parentActionGroupSignature?:"AMAZON.UserInput"|"AMAZON.CodeInterpreter"} $args
     * @return \AWS\Result<array{agentActionGroup:array{actionGroupExecutor?:array{customControl?:"RETURN_CONTROL", lambda?:string}, actionGroupId:string, actionGroupName:string, actionGroupState:"ENABLED"|"DISABLED", agentId:string, agentVersion:string, apiSchema?:array{payload?:string, s3?:array{s3BucketName?:string, s3ObjectKey?:string}}, clientToken?:string, createdAt:int|string|\DateTimeInterface, description?:string, functionSchema?:array{functions?:array<array{description?:string, name:string, parameters?:array<string, array{description?:string, required?:bool, type:"string"|"number"|"integer"|"boolean"|"array"}>, requireConfirmation?:"ENABLED"|"DISABLED"}>}, parentActionSignature?:"AMAZON.UserInput"|"AMAZON.CodeInterpreter", updatedAt:int|string|\DateTimeInterface}}>
     */
    public function createAgentActionGroup(array $args): \AWS\Result { }

    /**
     * @param array{actionGroupExecutor?:array{customControl?:"RETURN_CONTROL", lambda?:string}, actionGroupName:string, actionGroupState?:"ENABLED"|"DISABLED", agentId:string, agentVersion:string, apiSchema?:array{payload?:string, s3?:array{s3BucketName?:string, s3ObjectKey?:string}}, clientToken?:string, description?:string, functionSchema?:array{functions?:array<array{description?:string, name:string, parameters?:array<string, array{description?:string, required?:bool, type:"string"|"number"|"integer"|"boolean"|"array"}>, requireConfirmation?:"ENABLED"|"DISABLED"}>}, parentActionGroupSignature?:"AMAZON.UserInput"|"AMAZON.CodeInterpreter"} $args
     * @return \GuzzleHttp\Promise\Promise<array{agentActionGroup:array{actionGroupExecutor?:array{customControl?:"RETURN_CONTROL", lambda?:string}, actionGroupId:string, actionGroupName:string, actionGroupState:"ENABLED"|"DISABLED", agentId:string, agentVersion:string, apiSchema?:array{payload?:string, s3?:array{s3BucketName?:string, s3ObjectKey?:string}}, clientToken?:string, createdAt:int|string|\DateTimeInterface, description?:string, functionSchema?:array{functions?:array<array{description?:string, name:string, parameters?:array<string, array{description?:string, required?:bool, type:"string"|"number"|"integer"|"boolean"|"array"}>, requireConfirmation?:"ENABLED"|"DISABLED"}>}, parentActionSignature?:"AMAZON.UserInput"|"AMAZON.CodeInterpreter", updatedAt:int|string|\DateTimeInterface}}>
     */
    public function createAgentActionGroupAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{agentAliasName:string, agentId:string, clientToken?:string, description?:string, routingConfiguration?:array<array{agentVersion?:string, provisionedThroughput?:string}>, tags?:array<string, string>} $args
     * @return \AWS\Result<array{agentAlias:array{agentAliasArn:string, agentAliasHistoryEvents?:array<array{endDate?:int|string|\DateTimeInterface, routingConfiguration?:array<array{agentVersion?:string, provisionedThroughput?:string}>, startDate?:int|string|\DateTimeInterface}>, agentAliasId:string, agentAliasName:string, agentAliasStatus:"CREATING"|"PREPARED"|"FAILED"|"UPDATING"|"DELETING", agentId:string, clientToken?:string, createdAt:int|string|\DateTimeInterface, description?:string, failureReasons?:array<string>, routingConfiguration:array<array{agentVersion?:string, provisionedThroughput?:string}>, updatedAt:int|string|\DateTimeInterface}}>
     */
    public function createAgentAlias(array $args): \AWS\Result { }

    /**
     * @param array{agentAliasName:string, agentId:string, clientToken?:string, description?:string, routingConfiguration?:array<array{agentVersion?:string, provisionedThroughput?:string}>, tags?:array<string, string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{agentAlias:array{agentAliasArn:string, agentAliasHistoryEvents?:array<array{endDate?:int|string|\DateTimeInterface, routingConfiguration?:array<array{agentVersion?:string, provisionedThroughput?:string}>, startDate?:int|string|\DateTimeInterface}>, agentAliasId:string, agentAliasName:string, agentAliasStatus:"CREATING"|"PREPARED"|"FAILED"|"UPDATING"|"DELETING", agentId:string, clientToken?:string, createdAt:int|string|\DateTimeInterface, description?:string, failureReasons?:array<string>, routingConfiguration:array<array{agentVersion?:string, provisionedThroughput?:string}>, updatedAt:int|string|\DateTimeInterface}}>
     */
    public function createAgentAliasAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{clientToken?:string, dataDeletionPolicy?:"RETAIN"|"DELETE", dataSourceConfiguration:array{confluenceConfiguration?:array{crawlerConfiguration?:array{filterConfiguration?:array{patternObjectFilter?:array{filters:array<array{exclusionFilters?:array<string>, inclusionFilters?:array<string>, objectType:string}>}, type:"PATTERN"}}, sourceConfiguration:array{authType:"BASIC"|"OAUTH2_CLIENT_CREDENTIALS", credentialsSecretArn:string, hostType:"SAAS", hostUrl:string}}, s3Configuration?:array{bucketArn:string, bucketOwnerAccountId?:string, inclusionPrefixes?:array<string>}, salesforceConfiguration?:array{crawlerConfiguration?:array{filterConfiguration?:array{patternObjectFilter?:array{filters:array<array{exclusionFilters?:array<string>, inclusionFilters?:array<string>, objectType:string}>}, type:"PATTERN"}}, sourceConfiguration:array{authType:"OAUTH2_CLIENT_CREDENTIALS", credentialsSecretArn:string, hostUrl:string}}, sharePointConfiguration?:array{crawlerConfiguration?:array{filterConfiguration?:array{patternObjectFilter?:array{filters:array<array{exclusionFilters?:array<string>, inclusionFilters?:array<string>, objectType:string}>}, type:"PATTERN"}}, sourceConfiguration:array{authType:"OAUTH2_CLIENT_CREDENTIALS"|"OAUTH2_SHAREPOINT_APP_ONLY_CLIENT_CREDENTIALS", credentialsSecretArn:string, domain:string, hostType:"ONLINE", siteUrls:array<string>, tenantId?:string}}, type:"S3"|"WEB"|"CONFLUENCE"|"SALESFORCE"|"SHAREPOINT"|"CUSTOM"|"REDSHIFT_METADATA", webConfiguration?:array{crawlerConfiguration?:array{crawlerLimits?:array{maxPages?:int, rateLimit?:int}, exclusionFilters?:array<string>, inclusionFilters?:array<string>, scope?:"HOST_ONLY"|"SUBDOMAINS", userAgent?:string}, sourceConfiguration:array{urlConfiguration:array{seedUrls?:array<array{url?:string}>}}}}, description?:string, knowledgeBaseId:string, name:string, serverSideEncryptionConfiguration?:array{kmsKeyArn?:string}, vectorIngestionConfiguration?:array{chunkingConfiguration?:array{chunkingStrategy:"FIXED_SIZE"|"NONE"|"HIERARCHICAL"|"SEMANTIC", fixedSizeChunkingConfiguration?:array{maxTokens:int, overlapPercentage:int}, hierarchicalChunkingConfiguration?:array{levelConfigurations:array<array{maxTokens:int}>, overlapTokens:int}, semanticChunkingConfiguration?:array{breakpointPercentileThreshold:int, bufferSize:int, maxTokens:int}}, customTransformationConfiguration?:array{intermediateStorage:array{s3Location:array{uri:string}}, transformations:array<array{stepToApply:"POST_CHUNKING", transformationFunction:array{transformationLambdaConfiguration:array{lambdaArn:string}}}>}, parsingConfiguration?:array{bedrockDataAutomationConfiguration?:array{parsingModality?:"MULTIMODAL"}, bedrockFoundationModelConfiguration?:array{modelArn:string, parsingModality?:"MULTIMODAL", parsingPrompt?:array{parsingPromptText:string}}, parsingStrategy:"BEDROCK_FOUNDATION_MODEL"|"BEDROCK_DATA_AUTOMATION"}}} $args
     * @return \AWS\Result<array{dataSource:array{createdAt:int|string|\DateTimeInterface, dataDeletionPolicy?:"RETAIN"|"DELETE", dataSourceConfiguration:array{confluenceConfiguration?:array{crawlerConfiguration?:array{filterConfiguration?:array{patternObjectFilter?:array{filters:array<array{exclusionFilters?:array<string>, inclusionFilters?:array<string>, objectType:string}>}, type:"PATTERN"}}, sourceConfiguration:array{authType:"BASIC"|"OAUTH2_CLIENT_CREDENTIALS", credentialsSecretArn:string, hostType:"SAAS", hostUrl:string}}, s3Configuration?:array{bucketArn:string, bucketOwnerAccountId?:string, inclusionPrefixes?:array<string>}, salesforceConfiguration?:array{crawlerConfiguration?:array{filterConfiguration?:array{patternObjectFilter?:array{filters:array<array{exclusionFilters?:array<string>, inclusionFilters?:array<string>, objectType:string}>}, type:"PATTERN"}}, sourceConfiguration:array{authType:"OAUTH2_CLIENT_CREDENTIALS", credentialsSecretArn:string, hostUrl:string}}, sharePointConfiguration?:array{crawlerConfiguration?:array{filterConfiguration?:array{patternObjectFilter?:array{filters:array<array{exclusionFilters?:array<string>, inclusionFilters?:array<string>, objectType:string}>}, type:"PATTERN"}}, sourceConfiguration:array{authType:"OAUTH2_CLIENT_CREDENTIALS"|"OAUTH2_SHAREPOINT_APP_ONLY_CLIENT_CREDENTIALS", credentialsSecretArn:string, domain:string, hostType:"ONLINE", siteUrls:array<string>, tenantId?:string}}, type:"S3"|"WEB"|"CONFLUENCE"|"SALESFORCE"|"SHAREPOINT"|"CUSTOM"|"REDSHIFT_METADATA", webConfiguration?:array{crawlerConfiguration?:array{crawlerLimits?:array{maxPages?:int, rateLimit?:int}, exclusionFilters?:array<string>, inclusionFilters?:array<string>, scope?:"HOST_ONLY"|"SUBDOMAINS", userAgent?:string}, sourceConfiguration:array{urlConfiguration:array{seedUrls?:array<array{url?:string}>}}}}, dataSourceId:string, description?:string, failureReasons?:array<string>, knowledgeBaseId:string, name:string, serverSideEncryptionConfiguration?:array{kmsKeyArn?:string}, status:"AVAILABLE"|"DELETING"|"DELETE_UNSUCCESSFUL", updatedAt:int|string|\DateTimeInterface, vectorIngestionConfiguration?:array{chunkingConfiguration?:array{chunkingStrategy:"FIXED_SIZE"|"NONE"|"HIERARCHICAL"|"SEMANTIC", fixedSizeChunkingConfiguration?:array{maxTokens:int, overlapPercentage:int}, hierarchicalChunkingConfiguration?:array{levelConfigurations:array<array{maxTokens:int}>, overlapTokens:int}, semanticChunkingConfiguration?:array{breakpointPercentileThreshold:int, bufferSize:int, maxTokens:int}}, customTransformationConfiguration?:array{intermediateStorage:array{s3Location:array{uri:string}}, transformations:array<array{stepToApply:"POST_CHUNKING", transformationFunction:array{transformationLambdaConfiguration:array{lambdaArn:string}}}>}, parsingConfiguration?:array{bedrockDataAutomationConfiguration?:array{parsingModality?:"MULTIMODAL"}, bedrockFoundationModelConfiguration?:array{modelArn:string, parsingModality?:"MULTIMODAL", parsingPrompt?:array{parsingPromptText:string}}, parsingStrategy:"BEDROCK_FOUNDATION_MODEL"|"BEDROCK_DATA_AUTOMATION"}}}}>
     */
    public function createDataSource(array $args): \AWS\Result { }

    /**
     * @param array{clientToken?:string, dataDeletionPolicy?:"RETAIN"|"DELETE", dataSourceConfiguration:array{confluenceConfiguration?:array{crawlerConfiguration?:array{filterConfiguration?:array{patternObjectFilter?:array{filters:array<array{exclusionFilters?:array<string>, inclusionFilters?:array<string>, objectType:string}>}, type:"PATTERN"}}, sourceConfiguration:array{authType:"BASIC"|"OAUTH2_CLIENT_CREDENTIALS", credentialsSecretArn:string, hostType:"SAAS", hostUrl:string}}, s3Configuration?:array{bucketArn:string, bucketOwnerAccountId?:string, inclusionPrefixes?:array<string>}, salesforceConfiguration?:array{crawlerConfiguration?:array{filterConfiguration?:array{patternObjectFilter?:array{filters:array<array{exclusionFilters?:array<string>, inclusionFilters?:array<string>, objectType:string}>}, type:"PATTERN"}}, sourceConfiguration:array{authType:"OAUTH2_CLIENT_CREDENTIALS", credentialsSecretArn:string, hostUrl:string}}, sharePointConfiguration?:array{crawlerConfiguration?:array{filterConfiguration?:array{patternObjectFilter?:array{filters:array<array{exclusionFilters?:array<string>, inclusionFilters?:array<string>, objectType:string}>}, type:"PATTERN"}}, sourceConfiguration:array{authType:"OAUTH2_CLIENT_CREDENTIALS"|"OAUTH2_SHAREPOINT_APP_ONLY_CLIENT_CREDENTIALS", credentialsSecretArn:string, domain:string, hostType:"ONLINE", siteUrls:array<string>, tenantId?:string}}, type:"S3"|"WEB"|"CONFLUENCE"|"SALESFORCE"|"SHAREPOINT"|"CUSTOM"|"REDSHIFT_METADATA", webConfiguration?:array{crawlerConfiguration?:array{crawlerLimits?:array{maxPages?:int, rateLimit?:int}, exclusionFilters?:array<string>, inclusionFilters?:array<string>, scope?:"HOST_ONLY"|"SUBDOMAINS", userAgent?:string}, sourceConfiguration:array{urlConfiguration:array{seedUrls?:array<array{url?:string}>}}}}, description?:string, knowledgeBaseId:string, name:string, serverSideEncryptionConfiguration?:array{kmsKeyArn?:string}, vectorIngestionConfiguration?:array{chunkingConfiguration?:array{chunkingStrategy:"FIXED_SIZE"|"NONE"|"HIERARCHICAL"|"SEMANTIC", fixedSizeChunkingConfiguration?:array{maxTokens:int, overlapPercentage:int}, hierarchicalChunkingConfiguration?:array{levelConfigurations:array<array{maxTokens:int}>, overlapTokens:int}, semanticChunkingConfiguration?:array{breakpointPercentileThreshold:int, bufferSize:int, maxTokens:int}}, customTransformationConfiguration?:array{intermediateStorage:array{s3Location:array{uri:string}}, transformations:array<array{stepToApply:"POST_CHUNKING", transformationFunction:array{transformationLambdaConfiguration:array{lambdaArn:string}}}>}, parsingConfiguration?:array{bedrockDataAutomationConfiguration?:array{parsingModality?:"MULTIMODAL"}, bedrockFoundationModelConfiguration?:array{modelArn:string, parsingModality?:"MULTIMODAL", parsingPrompt?:array{parsingPromptText:string}}, parsingStrategy:"BEDROCK_FOUNDATION_MODEL"|"BEDROCK_DATA_AUTOMATION"}}} $args
     * @return \GuzzleHttp\Promise\Promise<array{dataSource:array{createdAt:int|string|\DateTimeInterface, dataDeletionPolicy?:"RETAIN"|"DELETE", dataSourceConfiguration:array{confluenceConfiguration?:array{crawlerConfiguration?:array{filterConfiguration?:array{patternObjectFilter?:array{filters:array<array{exclusionFilters?:array<string>, inclusionFilters?:array<string>, objectType:string}>}, type:"PATTERN"}}, sourceConfiguration:array{authType:"BASIC"|"OAUTH2_CLIENT_CREDENTIALS", credentialsSecretArn:string, hostType:"SAAS", hostUrl:string}}, s3Configuration?:array{bucketArn:string, bucketOwnerAccountId?:string, inclusionPrefixes?:array<string>}, salesforceConfiguration?:array{crawlerConfiguration?:array{filterConfiguration?:array{patternObjectFilter?:array{filters:array<array{exclusionFilters?:array<string>, inclusionFilters?:array<string>, objectType:string}>}, type:"PATTERN"}}, sourceConfiguration:array{authType:"OAUTH2_CLIENT_CREDENTIALS", credentialsSecretArn:string, hostUrl:string}}, sharePointConfiguration?:array{crawlerConfiguration?:array{filterConfiguration?:array{patternObjectFilter?:array{filters:array<array{exclusionFilters?:array<string>, inclusionFilters?:array<string>, objectType:string}>}, type:"PATTERN"}}, sourceConfiguration:array{authType:"OAUTH2_CLIENT_CREDENTIALS"|"OAUTH2_SHAREPOINT_APP_ONLY_CLIENT_CREDENTIALS", credentialsSecretArn:string, domain:string, hostType:"ONLINE", siteUrls:array<string>, tenantId?:string}}, type:"S3"|"WEB"|"CONFLUENCE"|"SALESFORCE"|"SHAREPOINT"|"CUSTOM"|"REDSHIFT_METADATA", webConfiguration?:array{crawlerConfiguration?:array{crawlerLimits?:array{maxPages?:int, rateLimit?:int}, exclusionFilters?:array<string>, inclusionFilters?:array<string>, scope?:"HOST_ONLY"|"SUBDOMAINS", userAgent?:string}, sourceConfiguration:array{urlConfiguration:array{seedUrls?:array<array{url?:string}>}}}}, dataSourceId:string, description?:string, failureReasons?:array<string>, knowledgeBaseId:string, name:string, serverSideEncryptionConfiguration?:array{kmsKeyArn?:string}, status:"AVAILABLE"|"DELETING"|"DELETE_UNSUCCESSFUL", updatedAt:int|string|\DateTimeInterface, vectorIngestionConfiguration?:array{chunkingConfiguration?:array{chunkingStrategy:"FIXED_SIZE"|"NONE"|"HIERARCHICAL"|"SEMANTIC", fixedSizeChunkingConfiguration?:array{maxTokens:int, overlapPercentage:int}, hierarchicalChunkingConfiguration?:array{levelConfigurations:array<array{maxTokens:int}>, overlapTokens:int}, semanticChunkingConfiguration?:array{breakpointPercentileThreshold:int, bufferSize:int, maxTokens:int}}, customTransformationConfiguration?:array{intermediateStorage:array{s3Location:array{uri:string}}, transformations:array<array{stepToApply:"POST_CHUNKING", transformationFunction:array{transformationLambdaConfiguration:array{lambdaArn:string}}}>}, parsingConfiguration?:array{bedrockDataAutomationConfiguration?:array{parsingModality?:"MULTIMODAL"}, bedrockFoundationModelConfiguration?:array{modelArn:string, parsingModality?:"MULTIMODAL", parsingPrompt?:array{parsingPromptText:string}}, parsingStrategy:"BEDROCK_FOUNDATION_MODEL"|"BEDROCK_DATA_AUTOMATION"}}}}>
     */
    public function createDataSourceAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{clientToken?:string, customerEncryptionKeyArn?:string, definition?:array{connections?:array<array{configuration?:array{conditional?:array{condition:string}, data?:array{sourceOutput:string, targetInput:string}}, name:string, source:string, target:string, type:"Data"|"Conditional"}>, nodes?:array<array{configuration?:array{agent?:array{agentAliasArn:string}, collector?:array{}, condition?:array{conditions:array<array{expression?:string, name:string}>}, input?:array{}, iterator?:array{}, knowledgeBase?:array{guardrailConfiguration?:array{guardrailIdentifier?:string, guardrailVersion?:string}, knowledgeBaseId:string, modelId?:string}, lambdaFunction?:array{lambdaArn:string}, lex?:array{botAliasArn:string, localeId:string}, output?:array{}, prompt?:array{guardrailConfiguration?:array{guardrailIdentifier?:string, guardrailVersion?:string}, sourceConfiguration:array{inline?:array{additionalModelRequestFields?:array{}, inferenceConfiguration?:array{text?:array{maxTokens?:int, stopSequences?:array<string>, temperature?:float, topP?:float}}, modelId:string, templateConfiguration:array{chat?:array{inputVariables?:array<array{name?:string}>, messages:array<array{content:array<array{text?:string}>, role:"user"|"assistant"}>, system?:array<array{text?:string}>, toolConfiguration?:array{toolChoice?:array{any?:array{}, auto?:array{}, tool?:array{name:string}}, tools:array<array{toolSpec?:array{description?:string, inputSchema:array{json?:array{}}, name:string}}>}}, text?:array{inputVariables?:array<array{name?:string}>, text:mixed}}, templateType:"TEXT"|"CHAT"}, resource?:array{promptArn:string}}}, retrieval?:array{serviceConfiguration:array{s3?:array{bucketName:string}}}, storage?:array{serviceConfiguration:array{s3?:array{bucketName:string}}}}, inputs?:array<array{expression:string, name:string, type:"String"|"Number"|"Boolean"|"Object"|"Array"}>, name:string, outputs?:array<array{name:string, type:"String"|"Number"|"Boolean"|"Object"|"Array"}>, type:"Input"|"Output"|"KnowledgeBase"|"Condition"|"Lex"|"Prompt"|"LambdaFunction"|"Storage"|"Agent"|"Retrieval"|"Iterator"|"Collector"}>}, description?:string, executionRoleArn:string, name:string, tags?:array<string, string>} $args
     * @return \AWS\Result<array{arn:string, createdAt:int|string|\DateTimeInterface, customerEncryptionKeyArn?:string, definition?:array{connections?:array<array{configuration?:array{conditional?:array{condition:string}, data?:array{sourceOutput:string, targetInput:string}}, name:string, source:string, target:string, type:"Data"|"Conditional"}>, nodes?:array<array{configuration?:array{agent?:array{agentAliasArn:string}, collector?:array{}, condition?:array{conditions:array<array{expression?:string, name:string}>}, input?:array{}, iterator?:array{}, knowledgeBase?:array{guardrailConfiguration?:array{guardrailIdentifier?:string, guardrailVersion?:string}, knowledgeBaseId:string, modelId?:string}, lambdaFunction?:array{lambdaArn:string}, lex?:array{botAliasArn:string, localeId:string}, output?:array{}, prompt?:array{guardrailConfiguration?:array{guardrailIdentifier?:string, guardrailVersion?:string}, sourceConfiguration:array{inline?:array{additionalModelRequestFields?:array{}, inferenceConfiguration?:array{text?:array{maxTokens?:int, stopSequences?:array<string>, temperature?:float, topP?:float}}, modelId:string, templateConfiguration:array{chat?:array{inputVariables?:array<array{name?:string}>, messages:array<array{content:array<array{text?:string}>, role:"user"|"assistant"}>, system?:array<array{text?:string}>, toolConfiguration?:array{toolChoice?:array{any?:array{}, auto?:array{}, tool?:array{name:string}}, tools:array<array{toolSpec?:array{description?:string, inputSchema:array{json?:array{}}, name:string}}>}}, text?:array{inputVariables?:array<array{name?:string}>, text:mixed}}, templateType:"TEXT"|"CHAT"}, resource?:array{promptArn:string}}}, retrieval?:array{serviceConfiguration:array{s3?:array{bucketName:string}}}, storage?:array{serviceConfiguration:array{s3?:array{bucketName:string}}}}, inputs?:array<array{expression:string, name:string, type:"String"|"Number"|"Boolean"|"Object"|"Array"}>, name:string, outputs?:array<array{name:string, type:"String"|"Number"|"Boolean"|"Object"|"Array"}>, type:"Input"|"Output"|"KnowledgeBase"|"Condition"|"Lex"|"Prompt"|"LambdaFunction"|"Storage"|"Agent"|"Retrieval"|"Iterator"|"Collector"}>}, description?:string, executionRoleArn:string, id:string, name:string, status:"Failed"|"Prepared"|"Preparing"|"NotPrepared", updatedAt:int|string|\DateTimeInterface, version:string}>
     */
    public function createFlow(array $args): \AWS\Result { }

    /**
     * @param array{clientToken?:string, customerEncryptionKeyArn?:string, definition?:array{connections?:array<array{configuration?:array{conditional?:array{condition:string}, data?:array{sourceOutput:string, targetInput:string}}, name:string, source:string, target:string, type:"Data"|"Conditional"}>, nodes?:array<array{configuration?:array{agent?:array{agentAliasArn:string}, collector?:array{}, condition?:array{conditions:array<array{expression?:string, name:string}>}, input?:array{}, iterator?:array{}, knowledgeBase?:array{guardrailConfiguration?:array{guardrailIdentifier?:string, guardrailVersion?:string}, knowledgeBaseId:string, modelId?:string}, lambdaFunction?:array{lambdaArn:string}, lex?:array{botAliasArn:string, localeId:string}, output?:array{}, prompt?:array{guardrailConfiguration?:array{guardrailIdentifier?:string, guardrailVersion?:string}, sourceConfiguration:array{inline?:array{additionalModelRequestFields?:array{}, inferenceConfiguration?:array{text?:array{maxTokens?:int, stopSequences?:array<string>, temperature?:float, topP?:float}}, modelId:string, templateConfiguration:array{chat?:array{inputVariables?:array<array{name?:string}>, messages:array<array{content:array<array{text?:string}>, role:"user"|"assistant"}>, system?:array<array{text?:string}>, toolConfiguration?:array{toolChoice?:array{any?:array{}, auto?:array{}, tool?:array{name:string}}, tools:array<array{toolSpec?:array{description?:string, inputSchema:array{json?:array{}}, name:string}}>}}, text?:array{inputVariables?:array<array{name?:string}>, text:mixed}}, templateType:"TEXT"|"CHAT"}, resource?:array{promptArn:string}}}, retrieval?:array{serviceConfiguration:array{s3?:array{bucketName:string}}}, storage?:array{serviceConfiguration:array{s3?:array{bucketName:string}}}}, inputs?:array<array{expression:string, name:string, type:"String"|"Number"|"Boolean"|"Object"|"Array"}>, name:string, outputs?:array<array{name:string, type:"String"|"Number"|"Boolean"|"Object"|"Array"}>, type:"Input"|"Output"|"KnowledgeBase"|"Condition"|"Lex"|"Prompt"|"LambdaFunction"|"Storage"|"Agent"|"Retrieval"|"Iterator"|"Collector"}>}, description?:string, executionRoleArn:string, name:string, tags?:array<string, string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{arn:string, createdAt:int|string|\DateTimeInterface, customerEncryptionKeyArn?:string, definition?:array{connections?:array<array{configuration?:array{conditional?:array{condition:string}, data?:array{sourceOutput:string, targetInput:string}}, name:string, source:string, target:string, type:"Data"|"Conditional"}>, nodes?:array<array{configuration?:array{agent?:array{agentAliasArn:string}, collector?:array{}, condition?:array{conditions:array<array{expression?:string, name:string}>}, input?:array{}, iterator?:array{}, knowledgeBase?:array{guardrailConfiguration?:array{guardrailIdentifier?:string, guardrailVersion?:string}, knowledgeBaseId:string, modelId?:string}, lambdaFunction?:array{lambdaArn:string}, lex?:array{botAliasArn:string, localeId:string}, output?:array{}, prompt?:array{guardrailConfiguration?:array{guardrailIdentifier?:string, guardrailVersion?:string}, sourceConfiguration:array{inline?:array{additionalModelRequestFields?:array{}, inferenceConfiguration?:array{text?:array{maxTokens?:int, stopSequences?:array<string>, temperature?:float, topP?:float}}, modelId:string, templateConfiguration:array{chat?:array{inputVariables?:array<array{name?:string}>, messages:array<array{content:array<array{text?:string}>, role:"user"|"assistant"}>, system?:array<array{text?:string}>, toolConfiguration?:array{toolChoice?:array{any?:array{}, auto?:array{}, tool?:array{name:string}}, tools:array<array{toolSpec?:array{description?:string, inputSchema:array{json?:array{}}, name:string}}>}}, text?:array{inputVariables?:array<array{name?:string}>, text:mixed}}, templateType:"TEXT"|"CHAT"}, resource?:array{promptArn:string}}}, retrieval?:array{serviceConfiguration:array{s3?:array{bucketName:string}}}, storage?:array{serviceConfiguration:array{s3?:array{bucketName:string}}}}, inputs?:array<array{expression:string, name:string, type:"String"|"Number"|"Boolean"|"Object"|"Array"}>, name:string, outputs?:array<array{name:string, type:"String"|"Number"|"Boolean"|"Object"|"Array"}>, type:"Input"|"Output"|"KnowledgeBase"|"Condition"|"Lex"|"Prompt"|"LambdaFunction"|"Storage"|"Agent"|"Retrieval"|"Iterator"|"Collector"}>}, description?:string, executionRoleArn:string, id:string, name:string, status:"Failed"|"Prepared"|"Preparing"|"NotPrepared", updatedAt:int|string|\DateTimeInterface, version:string}>
     */
    public function createFlowAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{clientToken?:string, description?:string, flowIdentifier:string, name:string, routingConfiguration:array<array{flowVersion?:string}>, tags?:array<string, string>} $args
     * @return \AWS\Result<array{arn:string, createdAt:int|string|\DateTimeInterface, description?:string, flowId:string, id:string, name:string, routingConfiguration:array<array{flowVersion?:string}>, updatedAt:int|string|\DateTimeInterface}>
     */
    public function createFlowAlias(array $args): \AWS\Result { }

    /**
     * @param array{clientToken?:string, description?:string, flowIdentifier:string, name:string, routingConfiguration:array<array{flowVersion?:string}>, tags?:array<string, string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{arn:string, createdAt:int|string|\DateTimeInterface, description?:string, flowId:string, id:string, name:string, routingConfiguration:array<array{flowVersion?:string}>, updatedAt:int|string|\DateTimeInterface}>
     */
    public function createFlowAliasAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{clientToken?:string, description?:string, flowIdentifier:string} $args
     * @return \AWS\Result<array{arn:string, createdAt:int|string|\DateTimeInterface, customerEncryptionKeyArn?:string, definition?:array{connections?:array<array{configuration?:array{conditional?:array{condition:string}, data?:array{sourceOutput:string, targetInput:string}}, name:string, source:string, target:string, type:"Data"|"Conditional"}>, nodes?:array<array{configuration?:array{agent?:array{agentAliasArn:string}, collector?:array{}, condition?:array{conditions:array<array{expression?:string, name:string}>}, input?:array{}, iterator?:array{}, knowledgeBase?:array{guardrailConfiguration?:array{guardrailIdentifier?:string, guardrailVersion?:string}, knowledgeBaseId:string, modelId?:string}, lambdaFunction?:array{lambdaArn:string}, lex?:array{botAliasArn:string, localeId:string}, output?:array{}, prompt?:array{guardrailConfiguration?:array{guardrailIdentifier?:string, guardrailVersion?:string}, sourceConfiguration:array{inline?:array{additionalModelRequestFields?:array{}, inferenceConfiguration?:array{text?:array{maxTokens?:int, stopSequences?:array<string>, temperature?:float, topP?:float}}, modelId:string, templateConfiguration:array{chat?:array{inputVariables?:array<array{name?:string}>, messages:array<array{content:array<array{text?:string}>, role:"user"|"assistant"}>, system?:array<array{text?:string}>, toolConfiguration?:array{toolChoice?:array{any?:array{}, auto?:array{}, tool?:array{name:string}}, tools:array<array{toolSpec?:array{description?:string, inputSchema:array{json?:array{}}, name:string}}>}}, text?:array{inputVariables?:array<array{name?:string}>, text:mixed}}, templateType:"TEXT"|"CHAT"}, resource?:array{promptArn:string}}}, retrieval?:array{serviceConfiguration:array{s3?:array{bucketName:string}}}, storage?:array{serviceConfiguration:array{s3?:array{bucketName:string}}}}, inputs?:array<array{expression:string, name:string, type:"String"|"Number"|"Boolean"|"Object"|"Array"}>, name:string, outputs?:array<array{name:string, type:"String"|"Number"|"Boolean"|"Object"|"Array"}>, type:"Input"|"Output"|"KnowledgeBase"|"Condition"|"Lex"|"Prompt"|"LambdaFunction"|"Storage"|"Agent"|"Retrieval"|"Iterator"|"Collector"}>}, description?:string, executionRoleArn:string, id:string, name:string, status:"Failed"|"Prepared"|"Preparing"|"NotPrepared", version:string}>
     */
    public function createFlowVersion(array $args): \AWS\Result { }

    /**
     * @param array{clientToken?:string, description?:string, flowIdentifier:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{arn:string, createdAt:int|string|\DateTimeInterface, customerEncryptionKeyArn?:string, definition?:array{connections?:array<array{configuration?:array{conditional?:array{condition:string}, data?:array{sourceOutput:string, targetInput:string}}, name:string, source:string, target:string, type:"Data"|"Conditional"}>, nodes?:array<array{configuration?:array{agent?:array{agentAliasArn:string}, collector?:array{}, condition?:array{conditions:array<array{expression?:string, name:string}>}, input?:array{}, iterator?:array{}, knowledgeBase?:array{guardrailConfiguration?:array{guardrailIdentifier?:string, guardrailVersion?:string}, knowledgeBaseId:string, modelId?:string}, lambdaFunction?:array{lambdaArn:string}, lex?:array{botAliasArn:string, localeId:string}, output?:array{}, prompt?:array{guardrailConfiguration?:array{guardrailIdentifier?:string, guardrailVersion?:string}, sourceConfiguration:array{inline?:array{additionalModelRequestFields?:array{}, inferenceConfiguration?:array{text?:array{maxTokens?:int, stopSequences?:array<string>, temperature?:float, topP?:float}}, modelId:string, templateConfiguration:array{chat?:array{inputVariables?:array<array{name?:string}>, messages:array<array{content:array<array{text?:string}>, role:"user"|"assistant"}>, system?:array<array{text?:string}>, toolConfiguration?:array{toolChoice?:array{any?:array{}, auto?:array{}, tool?:array{name:string}}, tools:array<array{toolSpec?:array{description?:string, inputSchema:array{json?:array{}}, name:string}}>}}, text?:array{inputVariables?:array<array{name?:string}>, text:mixed}}, templateType:"TEXT"|"CHAT"}, resource?:array{promptArn:string}}}, retrieval?:array{serviceConfiguration:array{s3?:array{bucketName:string}}}, storage?:array{serviceConfiguration:array{s3?:array{bucketName:string}}}}, inputs?:array<array{expression:string, name:string, type:"String"|"Number"|"Boolean"|"Object"|"Array"}>, name:string, outputs?:array<array{name:string, type:"String"|"Number"|"Boolean"|"Object"|"Array"}>, type:"Input"|"Output"|"KnowledgeBase"|"Condition"|"Lex"|"Prompt"|"LambdaFunction"|"Storage"|"Agent"|"Retrieval"|"Iterator"|"Collector"}>}, description?:string, executionRoleArn:string, id:string, name:string, status:"Failed"|"Prepared"|"Preparing"|"NotPrepared", version:string}>
     */
    public function createFlowVersionAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{clientToken?:string, description?:string, knowledgeBaseConfiguration:array{kendraKnowledgeBaseConfiguration?:array{kendraIndexArn:string}, sqlKnowledgeBaseConfiguration?:array{redshiftConfiguration?:array{queryEngineConfiguration:array{provisionedConfiguration?:array{authConfiguration:array{databaseUser?:string, type:"IAM"|"USERNAME_PASSWORD"|"USERNAME", usernamePasswordSecretArn?:string}, clusterIdentifier:string}, serverlessConfiguration?:array{authConfiguration:array{type:"IAM"|"USERNAME_PASSWORD", usernamePasswordSecretArn?:string}, workgroupArn:string}, type:"SERVERLESS"|"PROVISIONED"}, queryGenerationConfiguration?:array{executionTimeoutSeconds?:int, generationContext?:array{curatedQueries?:array<array{naturalLanguage:string, sql:string}>, tables?:array<array{columns?:array<array{description?:string, inclusion?:"INCLUDE"|"EXCLUDE", name?:string}>, description?:string, inclusion?:"INCLUDE"|"EXCLUDE", name:string}>}}, storageConfigurations:array<array{awsDataCatalogConfiguration?:array{tableNames:array<string>}, redshiftConfiguration?:mixed, type:"REDSHIFT"|"AWS_DATA_CATALOG"}>}, type:"REDSHIFT"}, type:"VECTOR"|"KENDRA"|"SQL", vectorKnowledgeBaseConfiguration?:array{embeddingModelArn:string, embeddingModelConfiguration?:array{bedrockEmbeddingModelConfiguration?:array{dimensions?:int, embeddingDataType?:"FLOAT32"|"BINARY"}}, supplementalDataStorageConfiguration?:array{storageLocations:array<array{s3Location?:array{uri:string}, type:"S3"}>}}}, name:string, roleArn:string, storageConfiguration?:array{mongoDbAtlasConfiguration?:array{collectionName:string, credentialsSecretArn:string, databaseName:string, endpoint:string, endpointServiceName?:string, fieldMapping:array{metadataField:string, textField:string, vectorField:string}, vectorIndexName:string}, opensearchServerlessConfiguration?:array{collectionArn:string, fieldMapping:array{metadataField:string, textField:string, vectorField:string}, vectorIndexName:string}, pineconeConfiguration?:array{connectionString:string, credentialsSecretArn:string, fieldMapping:array{metadataField:string, textField:string}, namespace?:string}, rdsConfiguration?:array{credentialsSecretArn:string, databaseName:string, fieldMapping:array{metadataField:string, primaryKeyField:string, textField:string, vectorField:string}, resourceArn:string, tableName:string}, redisEnterpriseCloudConfiguration?:array{credentialsSecretArn:string, endpoint:string, fieldMapping:array{metadataField:string, textField:string, vectorField:string}, vectorIndexName:string}, type:"OPENSEARCH_SERVERLESS"|"PINECONE"|"REDIS_ENTERPRISE_CLOUD"|"RDS"|"MONGO_DB_ATLAS"}, tags?:array<string, string>} $args
     * @return \AWS\Result<array{knowledgeBase:array{createdAt:int|string|\DateTimeInterface, description?:string, failureReasons?:array<string>, knowledgeBaseArn:string, knowledgeBaseConfiguration:array{kendraKnowledgeBaseConfiguration?:array{kendraIndexArn:string}, sqlKnowledgeBaseConfiguration?:array{redshiftConfiguration?:array{queryEngineConfiguration:array{provisionedConfiguration?:array{authConfiguration:array{databaseUser?:string, type:"IAM"|"USERNAME_PASSWORD"|"USERNAME", usernamePasswordSecretArn?:string}, clusterIdentifier:string}, serverlessConfiguration?:array{authConfiguration:array{type:"IAM"|"USERNAME_PASSWORD", usernamePasswordSecretArn?:string}, workgroupArn:string}, type:"SERVERLESS"|"PROVISIONED"}, queryGenerationConfiguration?:array{executionTimeoutSeconds?:int, generationContext?:array{curatedQueries?:array<array{naturalLanguage:string, sql:string}>, tables?:array<array{columns?:array<array{description?:string, inclusion?:"INCLUDE"|"EXCLUDE", name?:string}>, description?:string, inclusion?:"INCLUDE"|"EXCLUDE", name:string}>}}, storageConfigurations:array<array{awsDataCatalogConfiguration?:array{tableNames:array<string>}, redshiftConfiguration?:mixed, type:"REDSHIFT"|"AWS_DATA_CATALOG"}>}, type:"REDSHIFT"}, type:"VECTOR"|"KENDRA"|"SQL", vectorKnowledgeBaseConfiguration?:array{embeddingModelArn:string, embeddingModelConfiguration?:array{bedrockEmbeddingModelConfiguration?:array{dimensions?:int, embeddingDataType?:"FLOAT32"|"BINARY"}}, supplementalDataStorageConfiguration?:array{storageLocations:array<array{s3Location?:array{uri:string}, type:"S3"}>}}}, knowledgeBaseId:string, name:string, roleArn:string, status:"CREATING"|"ACTIVE"|"DELETING"|"UPDATING"|"FAILED"|"DELETE_UNSUCCESSFUL", storageConfiguration?:array{mongoDbAtlasConfiguration?:array{collectionName:string, credentialsSecretArn:string, databaseName:string, endpoint:string, endpointServiceName?:string, fieldMapping:array{metadataField:string, textField:string, vectorField:string}, vectorIndexName:string}, opensearchServerlessConfiguration?:array{collectionArn:string, fieldMapping:array{metadataField:string, textField:string, vectorField:string}, vectorIndexName:string}, pineconeConfiguration?:array{connectionString:string, credentialsSecretArn:string, fieldMapping:array{metadataField:string, textField:string}, namespace?:string}, rdsConfiguration?:array{credentialsSecretArn:string, databaseName:string, fieldMapping:array{metadataField:string, primaryKeyField:string, textField:string, vectorField:string}, resourceArn:string, tableName:string}, redisEnterpriseCloudConfiguration?:array{credentialsSecretArn:string, endpoint:string, fieldMapping:array{metadataField:string, textField:string, vectorField:string}, vectorIndexName:string}, type:"OPENSEARCH_SERVERLESS"|"PINECONE"|"REDIS_ENTERPRISE_CLOUD"|"RDS"|"MONGO_DB_ATLAS"}, updatedAt:int|string|\DateTimeInterface}}>
     */
    public function createKnowledgeBase(array $args): \AWS\Result { }

    /**
     * @param array{clientToken?:string, description?:string, knowledgeBaseConfiguration:array{kendraKnowledgeBaseConfiguration?:array{kendraIndexArn:string}, sqlKnowledgeBaseConfiguration?:array{redshiftConfiguration?:array{queryEngineConfiguration:array{provisionedConfiguration?:array{authConfiguration:array{databaseUser?:string, type:"IAM"|"USERNAME_PASSWORD"|"USERNAME", usernamePasswordSecretArn?:string}, clusterIdentifier:string}, serverlessConfiguration?:array{authConfiguration:array{type:"IAM"|"USERNAME_PASSWORD", usernamePasswordSecretArn?:string}, workgroupArn:string}, type:"SERVERLESS"|"PROVISIONED"}, queryGenerationConfiguration?:array{executionTimeoutSeconds?:int, generationContext?:array{curatedQueries?:array<array{naturalLanguage:string, sql:string}>, tables?:array<array{columns?:array<array{description?:string, inclusion?:"INCLUDE"|"EXCLUDE", name?:string}>, description?:string, inclusion?:"INCLUDE"|"EXCLUDE", name:string}>}}, storageConfigurations:array<array{awsDataCatalogConfiguration?:array{tableNames:array<string>}, redshiftConfiguration?:mixed, type:"REDSHIFT"|"AWS_DATA_CATALOG"}>}, type:"REDSHIFT"}, type:"VECTOR"|"KENDRA"|"SQL", vectorKnowledgeBaseConfiguration?:array{embeddingModelArn:string, embeddingModelConfiguration?:array{bedrockEmbeddingModelConfiguration?:array{dimensions?:int, embeddingDataType?:"FLOAT32"|"BINARY"}}, supplementalDataStorageConfiguration?:array{storageLocations:array<array{s3Location?:array{uri:string}, type:"S3"}>}}}, name:string, roleArn:string, storageConfiguration?:array{mongoDbAtlasConfiguration?:array{collectionName:string, credentialsSecretArn:string, databaseName:string, endpoint:string, endpointServiceName?:string, fieldMapping:array{metadataField:string, textField:string, vectorField:string}, vectorIndexName:string}, opensearchServerlessConfiguration?:array{collectionArn:string, fieldMapping:array{metadataField:string, textField:string, vectorField:string}, vectorIndexName:string}, pineconeConfiguration?:array{connectionString:string, credentialsSecretArn:string, fieldMapping:array{metadataField:string, textField:string}, namespace?:string}, rdsConfiguration?:array{credentialsSecretArn:string, databaseName:string, fieldMapping:array{metadataField:string, primaryKeyField:string, textField:string, vectorField:string}, resourceArn:string, tableName:string}, redisEnterpriseCloudConfiguration?:array{credentialsSecretArn:string, endpoint:string, fieldMapping:array{metadataField:string, textField:string, vectorField:string}, vectorIndexName:string}, type:"OPENSEARCH_SERVERLESS"|"PINECONE"|"REDIS_ENTERPRISE_CLOUD"|"RDS"|"MONGO_DB_ATLAS"}, tags?:array<string, string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{knowledgeBase:array{createdAt:int|string|\DateTimeInterface, description?:string, failureReasons?:array<string>, knowledgeBaseArn:string, knowledgeBaseConfiguration:array{kendraKnowledgeBaseConfiguration?:array{kendraIndexArn:string}, sqlKnowledgeBaseConfiguration?:array{redshiftConfiguration?:array{queryEngineConfiguration:array{provisionedConfiguration?:array{authConfiguration:array{databaseUser?:string, type:"IAM"|"USERNAME_PASSWORD"|"USERNAME", usernamePasswordSecretArn?:string}, clusterIdentifier:string}, serverlessConfiguration?:array{authConfiguration:array{type:"IAM"|"USERNAME_PASSWORD", usernamePasswordSecretArn?:string}, workgroupArn:string}, type:"SERVERLESS"|"PROVISIONED"}, queryGenerationConfiguration?:array{executionTimeoutSeconds?:int, generationContext?:array{curatedQueries?:array<array{naturalLanguage:string, sql:string}>, tables?:array<array{columns?:array<array{description?:string, inclusion?:"INCLUDE"|"EXCLUDE", name?:string}>, description?:string, inclusion?:"INCLUDE"|"EXCLUDE", name:string}>}}, storageConfigurations:array<array{awsDataCatalogConfiguration?:array{tableNames:array<string>}, redshiftConfiguration?:mixed, type:"REDSHIFT"|"AWS_DATA_CATALOG"}>}, type:"REDSHIFT"}, type:"VECTOR"|"KENDRA"|"SQL", vectorKnowledgeBaseConfiguration?:array{embeddingModelArn:string, embeddingModelConfiguration?:array{bedrockEmbeddingModelConfiguration?:array{dimensions?:int, embeddingDataType?:"FLOAT32"|"BINARY"}}, supplementalDataStorageConfiguration?:array{storageLocations:array<array{s3Location?:array{uri:string}, type:"S3"}>}}}, knowledgeBaseId:string, name:string, roleArn:string, status:"CREATING"|"ACTIVE"|"DELETING"|"UPDATING"|"FAILED"|"DELETE_UNSUCCESSFUL", storageConfiguration?:array{mongoDbAtlasConfiguration?:array{collectionName:string, credentialsSecretArn:string, databaseName:string, endpoint:string, endpointServiceName?:string, fieldMapping:array{metadataField:string, textField:string, vectorField:string}, vectorIndexName:string}, opensearchServerlessConfiguration?:array{collectionArn:string, fieldMapping:array{metadataField:string, textField:string, vectorField:string}, vectorIndexName:string}, pineconeConfiguration?:array{connectionString:string, credentialsSecretArn:string, fieldMapping:array{metadataField:string, textField:string}, namespace?:string}, rdsConfiguration?:array{credentialsSecretArn:string, databaseName:string, fieldMapping:array{metadataField:string, primaryKeyField:string, textField:string, vectorField:string}, resourceArn:string, tableName:string}, redisEnterpriseCloudConfiguration?:array{credentialsSecretArn:string, endpoint:string, fieldMapping:array{metadataField:string, textField:string, vectorField:string}, vectorIndexName:string}, type:"OPENSEARCH_SERVERLESS"|"PINECONE"|"REDIS_ENTERPRISE_CLOUD"|"RDS"|"MONGO_DB_ATLAS"}, updatedAt:int|string|\DateTimeInterface}}>
     */
    public function createKnowledgeBaseAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{clientToken?:string, customerEncryptionKeyArn?:string, defaultVariant?:string, description?:string, name:string, tags?:array<string, string>, variants?:array<array{additionalModelRequestFields?:array{}, genAiResource?:array{agent?:array{agentIdentifier:string}}, inferenceConfiguration?:array{text?:array{maxTokens?:int, stopSequences?:array<string>, temperature?:float, topP?:float}}, metadata?:array<array{key:string, value:string}>, modelId?:string, name:string, templateConfiguration:array{chat?:array{inputVariables?:array<array{name?:string}>, messages:array<array{content:array<array{text?:string}>, role:"user"|"assistant"}>, system?:array<array{text?:string}>, toolConfiguration?:array{toolChoice?:array{any?:array{}, auto?:array{}, tool?:array{name:string}}, tools:array<array{toolSpec?:array{description?:string, inputSchema:array{json?:array{}}, name:string}}>}}, text?:array{inputVariables?:array<array{name?:string}>, text:mixed}}, templateType:"TEXT"|"CHAT"}>} $args
     * @return \AWS\Result<array{arn:string, createdAt:int|string|\DateTimeInterface, customerEncryptionKeyArn?:string, defaultVariant?:string, description?:string, id:string, name:string, updatedAt:int|string|\DateTimeInterface, variants?:array<array{additionalModelRequestFields?:array{}, genAiResource?:array{agent?:array{agentIdentifier:string}}, inferenceConfiguration?:array{text?:array{maxTokens?:int, stopSequences?:array<string>, temperature?:float, topP?:float}}, metadata?:array<array{key:string, value:string}>, modelId?:string, name:string, templateConfiguration:array{chat?:array{inputVariables?:array<array{name?:string}>, messages:array<array{content:array<array{text?:string}>, role:"user"|"assistant"}>, system?:array<array{text?:string}>, toolConfiguration?:array{toolChoice?:array{any?:array{}, auto?:array{}, tool?:array{name:string}}, tools:array<array{toolSpec?:array{description?:string, inputSchema:array{json?:array{}}, name:string}}>}}, text?:array{inputVariables?:array<array{name?:string}>, text:mixed}}, templateType:"TEXT"|"CHAT"}>, version:string}>
     */
    public function createPrompt(array $args): \AWS\Result { }

    /**
     * @param array{clientToken?:string, customerEncryptionKeyArn?:string, defaultVariant?:string, description?:string, name:string, tags?:array<string, string>, variants?:array<array{additionalModelRequestFields?:array{}, genAiResource?:array{agent?:array{agentIdentifier:string}}, inferenceConfiguration?:array{text?:array{maxTokens?:int, stopSequences?:array<string>, temperature?:float, topP?:float}}, metadata?:array<array{key:string, value:string}>, modelId?:string, name:string, templateConfiguration:array{chat?:array{inputVariables?:array<array{name?:string}>, messages:array<array{content:array<array{text?:string}>, role:"user"|"assistant"}>, system?:array<array{text?:string}>, toolConfiguration?:array{toolChoice?:array{any?:array{}, auto?:array{}, tool?:array{name:string}}, tools:array<array{toolSpec?:array{description?:string, inputSchema:array{json?:array{}}, name:string}}>}}, text?:array{inputVariables?:array<array{name?:string}>, text:mixed}}, templateType:"TEXT"|"CHAT"}>} $args
     * @return \GuzzleHttp\Promise\Promise<array{arn:string, createdAt:int|string|\DateTimeInterface, customerEncryptionKeyArn?:string, defaultVariant?:string, description?:string, id:string, name:string, updatedAt:int|string|\DateTimeInterface, variants?:array<array{additionalModelRequestFields?:array{}, genAiResource?:array{agent?:array{agentIdentifier:string}}, inferenceConfiguration?:array{text?:array{maxTokens?:int, stopSequences?:array<string>, temperature?:float, topP?:float}}, metadata?:array<array{key:string, value:string}>, modelId?:string, name:string, templateConfiguration:array{chat?:array{inputVariables?:array<array{name?:string}>, messages:array<array{content:array<array{text?:string}>, role:"user"|"assistant"}>, system?:array<array{text?:string}>, toolConfiguration?:array{toolChoice?:array{any?:array{}, auto?:array{}, tool?:array{name:string}}, tools:array<array{toolSpec?:array{description?:string, inputSchema:array{json?:array{}}, name:string}}>}}, text?:array{inputVariables?:array<array{name?:string}>, text:mixed}}, templateType:"TEXT"|"CHAT"}>, version:string}>
     */
    public function createPromptAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{clientToken?:string, description?:string, promptIdentifier:string, tags?:array<string, string>} $args
     * @return \AWS\Result<array{arn:string, createdAt:int|string|\DateTimeInterface, customerEncryptionKeyArn?:string, defaultVariant?:string, description?:string, id:string, name:string, updatedAt:int|string|\DateTimeInterface, variants?:array<array{additionalModelRequestFields?:array{}, genAiResource?:array{agent?:array{agentIdentifier:string}}, inferenceConfiguration?:array{text?:array{maxTokens?:int, stopSequences?:array<string>, temperature?:float, topP?:float}}, metadata?:array<array{key:string, value:string}>, modelId?:string, name:string, templateConfiguration:array{chat?:array{inputVariables?:array<array{name?:string}>, messages:array<array{content:array<array{text?:string}>, role:"user"|"assistant"}>, system?:array<array{text?:string}>, toolConfiguration?:array{toolChoice?:array{any?:array{}, auto?:array{}, tool?:array{name:string}}, tools:array<array{toolSpec?:array{description?:string, inputSchema:array{json?:array{}}, name:string}}>}}, text?:array{inputVariables?:array<array{name?:string}>, text:mixed}}, templateType:"TEXT"|"CHAT"}>, version:string}>
     */
    public function createPromptVersion(array $args): \AWS\Result { }

    /**
     * @param array{clientToken?:string, description?:string, promptIdentifier:string, tags?:array<string, string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{arn:string, createdAt:int|string|\DateTimeInterface, customerEncryptionKeyArn?:string, defaultVariant?:string, description?:string, id:string, name:string, updatedAt:int|string|\DateTimeInterface, variants?:array<array{additionalModelRequestFields?:array{}, genAiResource?:array{agent?:array{agentIdentifier:string}}, inferenceConfiguration?:array{text?:array{maxTokens?:int, stopSequences?:array<string>, temperature?:float, topP?:float}}, metadata?:array<array{key:string, value:string}>, modelId?:string, name:string, templateConfiguration:array{chat?:array{inputVariables?:array<array{name?:string}>, messages:array<array{content:array<array{text?:string}>, role:"user"|"assistant"}>, system?:array<array{text?:string}>, toolConfiguration?:array{toolChoice?:array{any?:array{}, auto?:array{}, tool?:array{name:string}}, tools:array<array{toolSpec?:array{description?:string, inputSchema:array{json?:array{}}, name:string}}>}}, text?:array{inputVariables?:array<array{name?:string}>, text:mixed}}, templateType:"TEXT"|"CHAT"}>, version:string}>
     */
    public function createPromptVersionAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{agentId:string, skipResourceInUseCheck?:bool} $args
     * @return \AWS\Result<array{agentId:string, agentStatus:"CREATING"|"PREPARING"|"PREPARED"|"NOT_PREPARED"|"DELETING"|"FAILED"|"VERSIONING"|"UPDATING"}>
     */
    public function deleteAgent(array $args): \AWS\Result { }

    /**
     * @param array{agentId:string, skipResourceInUseCheck?:bool} $args
     * @return \GuzzleHttp\Promise\Promise<array{agentId:string, agentStatus:"CREATING"|"PREPARING"|"PREPARED"|"NOT_PREPARED"|"DELETING"|"FAILED"|"VERSIONING"|"UPDATING"}>
     */
    public function deleteAgentAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{actionGroupId:string, agentId:string, agentVersion:string, skipResourceInUseCheck?:bool} $args
     * @return \AWS\Result<array{}>
     */
    public function deleteAgentActionGroup(array $args): \AWS\Result { }

    /**
     * @param array{actionGroupId:string, agentId:string, agentVersion:string, skipResourceInUseCheck?:bool} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function deleteAgentActionGroupAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{agentAliasId:string, agentId:string} $args
     * @return \AWS\Result<array{agentAliasId:string, agentAliasStatus:"CREATING"|"PREPARED"|"FAILED"|"UPDATING"|"DELETING", agentId:string}>
     */
    public function deleteAgentAlias(array $args): \AWS\Result { }

    /**
     * @param array{agentAliasId:string, agentId:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{agentAliasId:string, agentAliasStatus:"CREATING"|"PREPARED"|"FAILED"|"UPDATING"|"DELETING", agentId:string}>
     */
    public function deleteAgentAliasAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{agentId:string, agentVersion:string, skipResourceInUseCheck?:bool} $args
     * @return \AWS\Result<array{agentId:string, agentStatus:"CREATING"|"PREPARING"|"PREPARED"|"NOT_PREPARED"|"DELETING"|"FAILED"|"VERSIONING"|"UPDATING", agentVersion:string}>
     */
    public function deleteAgentVersion(array $args): \AWS\Result { }

    /**
     * @param array{agentId:string, agentVersion:string, skipResourceInUseCheck?:bool} $args
     * @return \GuzzleHttp\Promise\Promise<array{agentId:string, agentStatus:"CREATING"|"PREPARING"|"PREPARED"|"NOT_PREPARED"|"DELETING"|"FAILED"|"VERSIONING"|"UPDATING", agentVersion:string}>
     */
    public function deleteAgentVersionAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{dataSourceId:string, knowledgeBaseId:string} $args
     * @return \AWS\Result<array{dataSourceId:string, knowledgeBaseId:string, status:"AVAILABLE"|"DELETING"|"DELETE_UNSUCCESSFUL"}>
     */
    public function deleteDataSource(array $args): \AWS\Result { }

    /**
     * @param array{dataSourceId:string, knowledgeBaseId:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{dataSourceId:string, knowledgeBaseId:string, status:"AVAILABLE"|"DELETING"|"DELETE_UNSUCCESSFUL"}>
     */
    public function deleteDataSourceAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{flowIdentifier:string, skipResourceInUseCheck?:bool} $args
     * @return \AWS\Result<array{id:string}>
     */
    public function deleteFlow(array $args): \AWS\Result { }

    /**
     * @param array{flowIdentifier:string, skipResourceInUseCheck?:bool} $args
     * @return \GuzzleHttp\Promise\Promise<array{id:string}>
     */
    public function deleteFlowAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{aliasIdentifier:string, flowIdentifier:string} $args
     * @return \AWS\Result<array{flowId:string, id:string}>
     */
    public function deleteFlowAlias(array $args): \AWS\Result { }

    /**
     * @param array{aliasIdentifier:string, flowIdentifier:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{flowId:string, id:string}>
     */
    public function deleteFlowAliasAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{flowIdentifier:string, flowVersion:string, skipResourceInUseCheck?:bool} $args
     * @return \AWS\Result<array{id:string, version:string}>
     */
    public function deleteFlowVersion(array $args): \AWS\Result { }

    /**
     * @param array{flowIdentifier:string, flowVersion:string, skipResourceInUseCheck?:bool} $args
     * @return \GuzzleHttp\Promise\Promise<array{id:string, version:string}>
     */
    public function deleteFlowVersionAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{knowledgeBaseId:string} $args
     * @return \AWS\Result<array{knowledgeBaseId:string, status:"CREATING"|"ACTIVE"|"DELETING"|"UPDATING"|"FAILED"|"DELETE_UNSUCCESSFUL"}>
     */
    public function deleteKnowledgeBase(array $args): \AWS\Result { }

    /**
     * @param array{knowledgeBaseId:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{knowledgeBaseId:string, status:"CREATING"|"ACTIVE"|"DELETING"|"UPDATING"|"FAILED"|"DELETE_UNSUCCESSFUL"}>
     */
    public function deleteKnowledgeBaseAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{clientToken?:string, dataSourceId:string, documentIdentifiers:array<array{custom?:array{id:string}, dataSourceType:"CUSTOM"|"S3", s3?:array{uri:string}}>, knowledgeBaseId:string} $args
     * @return \AWS\Result<array{documentDetails?:array<array{dataSourceId:string, identifier:array{custom?:array{id:string}, dataSourceType:"CUSTOM"|"S3", s3?:array{uri:string}}, knowledgeBaseId:string, status:"INDEXED"|"PARTIALLY_INDEXED"|"PENDING"|"FAILED"|"METADATA_PARTIALLY_INDEXED"|"METADATA_UPDATE_FAILED"|"IGNORED"|"NOT_FOUND"|"STARTING"|"IN_PROGRESS"|"DELETING"|"DELETE_IN_PROGRESS", statusReason?:string, updatedAt?:int|string|\DateTimeInterface}>}>
     */
    public function deleteKnowledgeBaseDocuments(array $args): \AWS\Result { }

    /**
     * @param array{clientToken?:string, dataSourceId:string, documentIdentifiers:array<array{custom?:array{id:string}, dataSourceType:"CUSTOM"|"S3", s3?:array{uri:string}}>, knowledgeBaseId:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{documentDetails?:array<array{dataSourceId:string, identifier:array{custom?:array{id:string}, dataSourceType:"CUSTOM"|"S3", s3?:array{uri:string}}, knowledgeBaseId:string, status:"INDEXED"|"PARTIALLY_INDEXED"|"PENDING"|"FAILED"|"METADATA_PARTIALLY_INDEXED"|"METADATA_UPDATE_FAILED"|"IGNORED"|"NOT_FOUND"|"STARTING"|"IN_PROGRESS"|"DELETING"|"DELETE_IN_PROGRESS", statusReason?:string, updatedAt?:int|string|\DateTimeInterface}>}>
     */
    public function deleteKnowledgeBaseDocumentsAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{promptIdentifier:string, promptVersion?:string} $args
     * @return \AWS\Result<array{id:string, version?:string}>
     */
    public function deletePrompt(array $args): \AWS\Result { }

    /**
     * @param array{promptIdentifier:string, promptVersion?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{id:string, version?:string}>
     */
    public function deletePromptAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{agentId:string, agentVersion:string, collaboratorId:string} $args
     * @return \AWS\Result<array{}>
     */
    public function disassociateAgentCollaborator(array $args): \AWS\Result { }

    /**
     * @param array{agentId:string, agentVersion:string, collaboratorId:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function disassociateAgentCollaboratorAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{agentId:string, agentVersion:string, knowledgeBaseId:string} $args
     * @return \AWS\Result<array{}>
     */
    public function disassociateAgentKnowledgeBase(array $args): \AWS\Result { }

    /**
     * @param array{agentId:string, agentVersion:string, knowledgeBaseId:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function disassociateAgentKnowledgeBaseAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{agentId:string} $args
     * @return \AWS\Result<array{agent:array{agentArn:string, agentCollaboration?:"SUPERVISOR"|"SUPERVISOR_ROUTER"|"DISABLED", agentId:string, agentName:string, agentResourceRoleArn:string, agentStatus:"CREATING"|"PREPARING"|"PREPARED"|"NOT_PREPARED"|"DELETING"|"FAILED"|"VERSIONING"|"UPDATING", agentVersion:string, clientToken?:string, createdAt:int|string|\DateTimeInterface, customOrchestration?:array{executor?:array{lambda?:string}}, customerEncryptionKeyArn?:string, description?:string, failureReasons?:array<string>, foundationModel?:string, guardrailConfiguration?:array{guardrailIdentifier?:string, guardrailVersion?:string}, idleSessionTTLInSeconds:int, instruction?:string, memoryConfiguration?:array{enabledMemoryTypes:array<"SESSION_SUMMARY">, sessionSummaryConfiguration?:array{maxRecentSessions?:int}, storageDays?:int}, orchestrationType?:"DEFAULT"|"CUSTOM_ORCHESTRATION", preparedAt?:int|string|\DateTimeInterface, promptOverrideConfiguration?:array{overrideLambda?:string, promptConfigurations:array<array{basePromptTemplate?:string, foundationModel?:string, inferenceConfiguration?:array{maximumLength?:int, stopSequences?:array<string>, temperature?:float, topK?:int, topP?:float}, parserMode?:"DEFAULT"|"OVERRIDDEN", promptCreationMode?:"DEFAULT"|"OVERRIDDEN", promptState?:"ENABLED"|"DISABLED", promptType?:"PRE_PROCESSING"|"ORCHESTRATION"|"POST_PROCESSING"|"KNOWLEDGE_BASE_RESPONSE_GENERATION"|"MEMORY_SUMMARIZATION"}>}, recommendedActions?:array<string>, updatedAt:int|string|\DateTimeInterface}}>
     */
    public function getAgent(array $args): \AWS\Result { }

    /**
     * @param array{agentId:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{agent:array{agentArn:string, agentCollaboration?:"SUPERVISOR"|"SUPERVISOR_ROUTER"|"DISABLED", agentId:string, agentName:string, agentResourceRoleArn:string, agentStatus:"CREATING"|"PREPARING"|"PREPARED"|"NOT_PREPARED"|"DELETING"|"FAILED"|"VERSIONING"|"UPDATING", agentVersion:string, clientToken?:string, createdAt:int|string|\DateTimeInterface, customOrchestration?:array{executor?:array{lambda?:string}}, customerEncryptionKeyArn?:string, description?:string, failureReasons?:array<string>, foundationModel?:string, guardrailConfiguration?:array{guardrailIdentifier?:string, guardrailVersion?:string}, idleSessionTTLInSeconds:int, instruction?:string, memoryConfiguration?:array{enabledMemoryTypes:array<"SESSION_SUMMARY">, sessionSummaryConfiguration?:array{maxRecentSessions?:int}, storageDays?:int}, orchestrationType?:"DEFAULT"|"CUSTOM_ORCHESTRATION", preparedAt?:int|string|\DateTimeInterface, promptOverrideConfiguration?:array{overrideLambda?:string, promptConfigurations:array<array{basePromptTemplate?:string, foundationModel?:string, inferenceConfiguration?:array{maximumLength?:int, stopSequences?:array<string>, temperature?:float, topK?:int, topP?:float}, parserMode?:"DEFAULT"|"OVERRIDDEN", promptCreationMode?:"DEFAULT"|"OVERRIDDEN", promptState?:"ENABLED"|"DISABLED", promptType?:"PRE_PROCESSING"|"ORCHESTRATION"|"POST_PROCESSING"|"KNOWLEDGE_BASE_RESPONSE_GENERATION"|"MEMORY_SUMMARIZATION"}>}, recommendedActions?:array<string>, updatedAt:int|string|\DateTimeInterface}}>
     */
    public function getAgentAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{actionGroupId:string, agentId:string, agentVersion:string} $args
     * @return \AWS\Result<array{agentActionGroup:array{actionGroupExecutor?:array{customControl?:"RETURN_CONTROL", lambda?:string}, actionGroupId:string, actionGroupName:string, actionGroupState:"ENABLED"|"DISABLED", agentId:string, agentVersion:string, apiSchema?:array{payload?:string, s3?:array{s3BucketName?:string, s3ObjectKey?:string}}, clientToken?:string, createdAt:int|string|\DateTimeInterface, description?:string, functionSchema?:array{functions?:array<array{description?:string, name:string, parameters?:array<string, array{description?:string, required?:bool, type:"string"|"number"|"integer"|"boolean"|"array"}>, requireConfirmation?:"ENABLED"|"DISABLED"}>}, parentActionSignature?:"AMAZON.UserInput"|"AMAZON.CodeInterpreter", updatedAt:int|string|\DateTimeInterface}}>
     */
    public function getAgentActionGroup(array $args): \AWS\Result { }

    /**
     * @param array{actionGroupId:string, agentId:string, agentVersion:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{agentActionGroup:array{actionGroupExecutor?:array{customControl?:"RETURN_CONTROL", lambda?:string}, actionGroupId:string, actionGroupName:string, actionGroupState:"ENABLED"|"DISABLED", agentId:string, agentVersion:string, apiSchema?:array{payload?:string, s3?:array{s3BucketName?:string, s3ObjectKey?:string}}, clientToken?:string, createdAt:int|string|\DateTimeInterface, description?:string, functionSchema?:array{functions?:array<array{description?:string, name:string, parameters?:array<string, array{description?:string, required?:bool, type:"string"|"number"|"integer"|"boolean"|"array"}>, requireConfirmation?:"ENABLED"|"DISABLED"}>}, parentActionSignature?:"AMAZON.UserInput"|"AMAZON.CodeInterpreter", updatedAt:int|string|\DateTimeInterface}}>
     */
    public function getAgentActionGroupAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{agentAliasId:string, agentId:string} $args
     * @return \AWS\Result<array{agentAlias:array{agentAliasArn:string, agentAliasHistoryEvents?:array<array{endDate?:int|string|\DateTimeInterface, routingConfiguration?:array<array{agentVersion?:string, provisionedThroughput?:string}>, startDate?:int|string|\DateTimeInterface}>, agentAliasId:string, agentAliasName:string, agentAliasStatus:"CREATING"|"PREPARED"|"FAILED"|"UPDATING"|"DELETING", agentId:string, clientToken?:string, createdAt:int|string|\DateTimeInterface, description?:string, failureReasons?:array<string>, routingConfiguration:array<array{agentVersion?:string, provisionedThroughput?:string}>, updatedAt:int|string|\DateTimeInterface}}>
     */
    public function getAgentAlias(array $args): \AWS\Result { }

    /**
     * @param array{agentAliasId:string, agentId:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{agentAlias:array{agentAliasArn:string, agentAliasHistoryEvents?:array<array{endDate?:int|string|\DateTimeInterface, routingConfiguration?:array<array{agentVersion?:string, provisionedThroughput?:string}>, startDate?:int|string|\DateTimeInterface}>, agentAliasId:string, agentAliasName:string, agentAliasStatus:"CREATING"|"PREPARED"|"FAILED"|"UPDATING"|"DELETING", agentId:string, clientToken?:string, createdAt:int|string|\DateTimeInterface, description?:string, failureReasons?:array<string>, routingConfiguration:array<array{agentVersion?:string, provisionedThroughput?:string}>, updatedAt:int|string|\DateTimeInterface}}>
     */
    public function getAgentAliasAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{agentId:string, agentVersion:string, collaboratorId:string} $args
     * @return \AWS\Result<array{agentCollaborator:array{agentDescriptor:array{aliasArn?:string}, agentId:string, agentVersion:string, clientToken?:string, collaborationInstruction:string, collaboratorId:string, collaboratorName:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, relayConversationHistory?:"TO_COLLABORATOR"|"DISABLED"}}>
     */
    public function getAgentCollaborator(array $args): \AWS\Result { }

    /**
     * @param array{agentId:string, agentVersion:string, collaboratorId:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{agentCollaborator:array{agentDescriptor:array{aliasArn?:string}, agentId:string, agentVersion:string, clientToken?:string, collaborationInstruction:string, collaboratorId:string, collaboratorName:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, relayConversationHistory?:"TO_COLLABORATOR"|"DISABLED"}}>
     */
    public function getAgentCollaboratorAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{agentId:string, agentVersion:string, knowledgeBaseId:string} $args
     * @return \AWS\Result<array{agentKnowledgeBase:array{agentId:string, agentVersion:string, createdAt:int|string|\DateTimeInterface, description:string, knowledgeBaseId:string, knowledgeBaseState:"ENABLED"|"DISABLED", updatedAt:int|string|\DateTimeInterface}}>
     */
    public function getAgentKnowledgeBase(array $args): \AWS\Result { }

    /**
     * @param array{agentId:string, agentVersion:string, knowledgeBaseId:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{agentKnowledgeBase:array{agentId:string, agentVersion:string, createdAt:int|string|\DateTimeInterface, description:string, knowledgeBaseId:string, knowledgeBaseState:"ENABLED"|"DISABLED", updatedAt:int|string|\DateTimeInterface}}>
     */
    public function getAgentKnowledgeBaseAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{agentId:string, agentVersion:string} $args
     * @return \AWS\Result<array{agentVersion:array{agentArn:string, agentCollaboration?:"SUPERVISOR"|"SUPERVISOR_ROUTER"|"DISABLED", agentId:string, agentName:string, agentResourceRoleArn:string, agentStatus:"CREATING"|"PREPARING"|"PREPARED"|"NOT_PREPARED"|"DELETING"|"FAILED"|"VERSIONING"|"UPDATING", createdAt:int|string|\DateTimeInterface, customerEncryptionKeyArn?:string, description?:string, failureReasons?:array<string>, foundationModel?:string, guardrailConfiguration?:array{guardrailIdentifier?:string, guardrailVersion?:string}, idleSessionTTLInSeconds:int, instruction?:string, memoryConfiguration?:array{enabledMemoryTypes:array<"SESSION_SUMMARY">, sessionSummaryConfiguration?:array{maxRecentSessions?:int}, storageDays?:int}, promptOverrideConfiguration?:array{overrideLambda?:string, promptConfigurations:array<array{basePromptTemplate?:string, foundationModel?:string, inferenceConfiguration?:array{maximumLength?:int, stopSequences?:array<string>, temperature?:float, topK?:int, topP?:float}, parserMode?:"DEFAULT"|"OVERRIDDEN", promptCreationMode?:"DEFAULT"|"OVERRIDDEN", promptState?:"ENABLED"|"DISABLED", promptType?:"PRE_PROCESSING"|"ORCHESTRATION"|"POST_PROCESSING"|"KNOWLEDGE_BASE_RESPONSE_GENERATION"|"MEMORY_SUMMARIZATION"}>}, recommendedActions?:array<string>, updatedAt:int|string|\DateTimeInterface, version:string}}>
     */
    public function getAgentVersion(array $args): \AWS\Result { }

    /**
     * @param array{agentId:string, agentVersion:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{agentVersion:array{agentArn:string, agentCollaboration?:"SUPERVISOR"|"SUPERVISOR_ROUTER"|"DISABLED", agentId:string, agentName:string, agentResourceRoleArn:string, agentStatus:"CREATING"|"PREPARING"|"PREPARED"|"NOT_PREPARED"|"DELETING"|"FAILED"|"VERSIONING"|"UPDATING", createdAt:int|string|\DateTimeInterface, customerEncryptionKeyArn?:string, description?:string, failureReasons?:array<string>, foundationModel?:string, guardrailConfiguration?:array{guardrailIdentifier?:string, guardrailVersion?:string}, idleSessionTTLInSeconds:int, instruction?:string, memoryConfiguration?:array{enabledMemoryTypes:array<"SESSION_SUMMARY">, sessionSummaryConfiguration?:array{maxRecentSessions?:int}, storageDays?:int}, promptOverrideConfiguration?:array{overrideLambda?:string, promptConfigurations:array<array{basePromptTemplate?:string, foundationModel?:string, inferenceConfiguration?:array{maximumLength?:int, stopSequences?:array<string>, temperature?:float, topK?:int, topP?:float}, parserMode?:"DEFAULT"|"OVERRIDDEN", promptCreationMode?:"DEFAULT"|"OVERRIDDEN", promptState?:"ENABLED"|"DISABLED", promptType?:"PRE_PROCESSING"|"ORCHESTRATION"|"POST_PROCESSING"|"KNOWLEDGE_BASE_RESPONSE_GENERATION"|"MEMORY_SUMMARIZATION"}>}, recommendedActions?:array<string>, updatedAt:int|string|\DateTimeInterface, version:string}}>
     */
    public function getAgentVersionAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{dataSourceId:string, knowledgeBaseId:string} $args
     * @return \AWS\Result<array{dataSource:array{createdAt:int|string|\DateTimeInterface, dataDeletionPolicy?:"RETAIN"|"DELETE", dataSourceConfiguration:array{confluenceConfiguration?:array{crawlerConfiguration?:array{filterConfiguration?:array{patternObjectFilter?:array{filters:array<array{exclusionFilters?:array<string>, inclusionFilters?:array<string>, objectType:string}>}, type:"PATTERN"}}, sourceConfiguration:array{authType:"BASIC"|"OAUTH2_CLIENT_CREDENTIALS", credentialsSecretArn:string, hostType:"SAAS", hostUrl:string}}, s3Configuration?:array{bucketArn:string, bucketOwnerAccountId?:string, inclusionPrefixes?:array<string>}, salesforceConfiguration?:array{crawlerConfiguration?:array{filterConfiguration?:array{patternObjectFilter?:array{filters:array<array{exclusionFilters?:array<string>, inclusionFilters?:array<string>, objectType:string}>}, type:"PATTERN"}}, sourceConfiguration:array{authType:"OAUTH2_CLIENT_CREDENTIALS", credentialsSecretArn:string, hostUrl:string}}, sharePointConfiguration?:array{crawlerConfiguration?:array{filterConfiguration?:array{patternObjectFilter?:array{filters:array<array{exclusionFilters?:array<string>, inclusionFilters?:array<string>, objectType:string}>}, type:"PATTERN"}}, sourceConfiguration:array{authType:"OAUTH2_CLIENT_CREDENTIALS"|"OAUTH2_SHAREPOINT_APP_ONLY_CLIENT_CREDENTIALS", credentialsSecretArn:string, domain:string, hostType:"ONLINE", siteUrls:array<string>, tenantId?:string}}, type:"S3"|"WEB"|"CONFLUENCE"|"SALESFORCE"|"SHAREPOINT"|"CUSTOM"|"REDSHIFT_METADATA", webConfiguration?:array{crawlerConfiguration?:array{crawlerLimits?:array{maxPages?:int, rateLimit?:int}, exclusionFilters?:array<string>, inclusionFilters?:array<string>, scope?:"HOST_ONLY"|"SUBDOMAINS", userAgent?:string}, sourceConfiguration:array{urlConfiguration:array{seedUrls?:array<array{url?:string}>}}}}, dataSourceId:string, description?:string, failureReasons?:array<string>, knowledgeBaseId:string, name:string, serverSideEncryptionConfiguration?:array{kmsKeyArn?:string}, status:"AVAILABLE"|"DELETING"|"DELETE_UNSUCCESSFUL", updatedAt:int|string|\DateTimeInterface, vectorIngestionConfiguration?:array{chunkingConfiguration?:array{chunkingStrategy:"FIXED_SIZE"|"NONE"|"HIERARCHICAL"|"SEMANTIC", fixedSizeChunkingConfiguration?:array{maxTokens:int, overlapPercentage:int}, hierarchicalChunkingConfiguration?:array{levelConfigurations:array<array{maxTokens:int}>, overlapTokens:int}, semanticChunkingConfiguration?:array{breakpointPercentileThreshold:int, bufferSize:int, maxTokens:int}}, customTransformationConfiguration?:array{intermediateStorage:array{s3Location:array{uri:string}}, transformations:array<array{stepToApply:"POST_CHUNKING", transformationFunction:array{transformationLambdaConfiguration:array{lambdaArn:string}}}>}, parsingConfiguration?:array{bedrockDataAutomationConfiguration?:array{parsingModality?:"MULTIMODAL"}, bedrockFoundationModelConfiguration?:array{modelArn:string, parsingModality?:"MULTIMODAL", parsingPrompt?:array{parsingPromptText:string}}, parsingStrategy:"BEDROCK_FOUNDATION_MODEL"|"BEDROCK_DATA_AUTOMATION"}}}}>
     */
    public function getDataSource(array $args): \AWS\Result { }

    /**
     * @param array{dataSourceId:string, knowledgeBaseId:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{dataSource:array{createdAt:int|string|\DateTimeInterface, dataDeletionPolicy?:"RETAIN"|"DELETE", dataSourceConfiguration:array{confluenceConfiguration?:array{crawlerConfiguration?:array{filterConfiguration?:array{patternObjectFilter?:array{filters:array<array{exclusionFilters?:array<string>, inclusionFilters?:array<string>, objectType:string}>}, type:"PATTERN"}}, sourceConfiguration:array{authType:"BASIC"|"OAUTH2_CLIENT_CREDENTIALS", credentialsSecretArn:string, hostType:"SAAS", hostUrl:string}}, s3Configuration?:array{bucketArn:string, bucketOwnerAccountId?:string, inclusionPrefixes?:array<string>}, salesforceConfiguration?:array{crawlerConfiguration?:array{filterConfiguration?:array{patternObjectFilter?:array{filters:array<array{exclusionFilters?:array<string>, inclusionFilters?:array<string>, objectType:string}>}, type:"PATTERN"}}, sourceConfiguration:array{authType:"OAUTH2_CLIENT_CREDENTIALS", credentialsSecretArn:string, hostUrl:string}}, sharePointConfiguration?:array{crawlerConfiguration?:array{filterConfiguration?:array{patternObjectFilter?:array{filters:array<array{exclusionFilters?:array<string>, inclusionFilters?:array<string>, objectType:string}>}, type:"PATTERN"}}, sourceConfiguration:array{authType:"OAUTH2_CLIENT_CREDENTIALS"|"OAUTH2_SHAREPOINT_APP_ONLY_CLIENT_CREDENTIALS", credentialsSecretArn:string, domain:string, hostType:"ONLINE", siteUrls:array<string>, tenantId?:string}}, type:"S3"|"WEB"|"CONFLUENCE"|"SALESFORCE"|"SHAREPOINT"|"CUSTOM"|"REDSHIFT_METADATA", webConfiguration?:array{crawlerConfiguration?:array{crawlerLimits?:array{maxPages?:int, rateLimit?:int}, exclusionFilters?:array<string>, inclusionFilters?:array<string>, scope?:"HOST_ONLY"|"SUBDOMAINS", userAgent?:string}, sourceConfiguration:array{urlConfiguration:array{seedUrls?:array<array{url?:string}>}}}}, dataSourceId:string, description?:string, failureReasons?:array<string>, knowledgeBaseId:string, name:string, serverSideEncryptionConfiguration?:array{kmsKeyArn?:string}, status:"AVAILABLE"|"DELETING"|"DELETE_UNSUCCESSFUL", updatedAt:int|string|\DateTimeInterface, vectorIngestionConfiguration?:array{chunkingConfiguration?:array{chunkingStrategy:"FIXED_SIZE"|"NONE"|"HIERARCHICAL"|"SEMANTIC", fixedSizeChunkingConfiguration?:array{maxTokens:int, overlapPercentage:int}, hierarchicalChunkingConfiguration?:array{levelConfigurations:array<array{maxTokens:int}>, overlapTokens:int}, semanticChunkingConfiguration?:array{breakpointPercentileThreshold:int, bufferSize:int, maxTokens:int}}, customTransformationConfiguration?:array{intermediateStorage:array{s3Location:array{uri:string}}, transformations:array<array{stepToApply:"POST_CHUNKING", transformationFunction:array{transformationLambdaConfiguration:array{lambdaArn:string}}}>}, parsingConfiguration?:array{bedrockDataAutomationConfiguration?:array{parsingModality?:"MULTIMODAL"}, bedrockFoundationModelConfiguration?:array{modelArn:string, parsingModality?:"MULTIMODAL", parsingPrompt?:array{parsingPromptText:string}}, parsingStrategy:"BEDROCK_FOUNDATION_MODEL"|"BEDROCK_DATA_AUTOMATION"}}}}>
     */
    public function getDataSourceAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{flowIdentifier:string} $args
     * @return \AWS\Result<array{arn:string, createdAt:int|string|\DateTimeInterface, customerEncryptionKeyArn?:string, definition?:array{connections?:array<array{configuration?:array{conditional?:array{condition:string}, data?:array{sourceOutput:string, targetInput:string}}, name:string, source:string, target:string, type:"Data"|"Conditional"}>, nodes?:array<array{configuration?:array{agent?:array{agentAliasArn:string}, collector?:array{}, condition?:array{conditions:array<array{expression?:string, name:string}>}, input?:array{}, iterator?:array{}, knowledgeBase?:array{guardrailConfiguration?:array{guardrailIdentifier?:string, guardrailVersion?:string}, knowledgeBaseId:string, modelId?:string}, lambdaFunction?:array{lambdaArn:string}, lex?:array{botAliasArn:string, localeId:string}, output?:array{}, prompt?:array{guardrailConfiguration?:array{guardrailIdentifier?:string, guardrailVersion?:string}, sourceConfiguration:array{inline?:array{additionalModelRequestFields?:array{}, inferenceConfiguration?:array{text?:array{maxTokens?:int, stopSequences?:array<string>, temperature?:float, topP?:float}}, modelId:string, templateConfiguration:array{chat?:array{inputVariables?:array<array{name?:string}>, messages:array<array{content:array<array{text?:string}>, role:"user"|"assistant"}>, system?:array<array{text?:string}>, toolConfiguration?:array{toolChoice?:array{any?:array{}, auto?:array{}, tool?:array{name:string}}, tools:array<array{toolSpec?:array{description?:string, inputSchema:array{json?:array{}}, name:string}}>}}, text?:array{inputVariables?:array<array{name?:string}>, text:mixed}}, templateType:"TEXT"|"CHAT"}, resource?:array{promptArn:string}}}, retrieval?:array{serviceConfiguration:array{s3?:array{bucketName:string}}}, storage?:array{serviceConfiguration:array{s3?:array{bucketName:string}}}}, inputs?:array<array{expression:string, name:string, type:"String"|"Number"|"Boolean"|"Object"|"Array"}>, name:string, outputs?:array<array{name:string, type:"String"|"Number"|"Boolean"|"Object"|"Array"}>, type:"Input"|"Output"|"KnowledgeBase"|"Condition"|"Lex"|"Prompt"|"LambdaFunction"|"Storage"|"Agent"|"Retrieval"|"Iterator"|"Collector"}>}, description?:string, executionRoleArn:string, id:string, name:string, status:"Failed"|"Prepared"|"Preparing"|"NotPrepared", updatedAt:int|string|\DateTimeInterface, validations?:array<array{details?:array{cyclicConnection?:array{connection:string}, duplicateConditionExpression?:array{expression:string, node:string}, duplicateConnections?:array{source:string, target:string}, incompatibleConnectionDataType?:array{connection:string}, malformedConditionExpression?:array{cause:string, condition:string, node:string}, malformedNodeInputExpression?:array{cause:string, input:string, node:string}, mismatchedNodeInputType?:array{expectedType:"String"|"Number"|"Boolean"|"Object"|"Array", input:string, node:string}, mismatchedNodeOutputType?:array{expectedType:"String"|"Number"|"Boolean"|"Object"|"Array", node:string, output:string}, missingConnectionConfiguration?:array{connection:string}, missingDefaultCondition?:array{node:string}, missingEndingNodes?:array{}, missingNodeConfiguration?:array{node:string}, missingNodeInput?:array{input:string, node:string}, missingNodeOutput?:array{node:string, output:string}, missingStartingNodes?:array{}, multipleNodeInputConnections?:array{input:string, node:string}, unfulfilledNodeInput?:array{input:string, node:string}, unknownConnectionCondition?:array{connection:string}, unknownConnectionSource?:array{connection:string}, unknownConnectionSourceOutput?:array{connection:string}, unknownConnectionTarget?:array{connection:string}, unknownConnectionTargetInput?:array{connection:string}, unreachableNode?:array{node:string}, unsatisfiedConnectionConditions?:array{connection:string}, unspecified?:array{}}, message:string, severity:"Warning"|"Error", type?:"CyclicConnection"|"DuplicateConnections"|"DuplicateConditionExpression"|"UnreachableNode"|"UnknownConnectionSource"|"UnknownConnectionSourceOutput"|"UnknownConnectionTarget"|"UnknownConnectionTargetInput"|"UnknownConnectionCondition"|"MalformedConditionExpression"|"MalformedNodeInputExpression"|"MismatchedNodeInputType"|"MismatchedNodeOutputType"|"IncompatibleConnectionDataType"|"MissingConnectionConfiguration"|"MissingDefaultCondition"|"MissingEndingNodes"|"MissingNodeConfiguration"|"MissingNodeInput"|"MissingNodeOutput"|"MissingStartingNodes"|"MultipleNodeInputConnections"|"UnfulfilledNodeInput"|"UnsatisfiedConnectionConditions"|"Unspecified"}>, version:string}>
     */
    public function getFlow(array $args): \AWS\Result { }

    /**
     * @param array{flowIdentifier:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{arn:string, createdAt:int|string|\DateTimeInterface, customerEncryptionKeyArn?:string, definition?:array{connections?:array<array{configuration?:array{conditional?:array{condition:string}, data?:array{sourceOutput:string, targetInput:string}}, name:string, source:string, target:string, type:"Data"|"Conditional"}>, nodes?:array<array{configuration?:array{agent?:array{agentAliasArn:string}, collector?:array{}, condition?:array{conditions:array<array{expression?:string, name:string}>}, input?:array{}, iterator?:array{}, knowledgeBase?:array{guardrailConfiguration?:array{guardrailIdentifier?:string, guardrailVersion?:string}, knowledgeBaseId:string, modelId?:string}, lambdaFunction?:array{lambdaArn:string}, lex?:array{botAliasArn:string, localeId:string}, output?:array{}, prompt?:array{guardrailConfiguration?:array{guardrailIdentifier?:string, guardrailVersion?:string}, sourceConfiguration:array{inline?:array{additionalModelRequestFields?:array{}, inferenceConfiguration?:array{text?:array{maxTokens?:int, stopSequences?:array<string>, temperature?:float, topP?:float}}, modelId:string, templateConfiguration:array{chat?:array{inputVariables?:array<array{name?:string}>, messages:array<array{content:array<array{text?:string}>, role:"user"|"assistant"}>, system?:array<array{text?:string}>, toolConfiguration?:array{toolChoice?:array{any?:array{}, auto?:array{}, tool?:array{name:string}}, tools:array<array{toolSpec?:array{description?:string, inputSchema:array{json?:array{}}, name:string}}>}}, text?:array{inputVariables?:array<array{name?:string}>, text:mixed}}, templateType:"TEXT"|"CHAT"}, resource?:array{promptArn:string}}}, retrieval?:array{serviceConfiguration:array{s3?:array{bucketName:string}}}, storage?:array{serviceConfiguration:array{s3?:array{bucketName:string}}}}, inputs?:array<array{expression:string, name:string, type:"String"|"Number"|"Boolean"|"Object"|"Array"}>, name:string, outputs?:array<array{name:string, type:"String"|"Number"|"Boolean"|"Object"|"Array"}>, type:"Input"|"Output"|"KnowledgeBase"|"Condition"|"Lex"|"Prompt"|"LambdaFunction"|"Storage"|"Agent"|"Retrieval"|"Iterator"|"Collector"}>}, description?:string, executionRoleArn:string, id:string, name:string, status:"Failed"|"Prepared"|"Preparing"|"NotPrepared", updatedAt:int|string|\DateTimeInterface, validations?:array<array{details?:array{cyclicConnection?:array{connection:string}, duplicateConditionExpression?:array{expression:string, node:string}, duplicateConnections?:array{source:string, target:string}, incompatibleConnectionDataType?:array{connection:string}, malformedConditionExpression?:array{cause:string, condition:string, node:string}, malformedNodeInputExpression?:array{cause:string, input:string, node:string}, mismatchedNodeInputType?:array{expectedType:"String"|"Number"|"Boolean"|"Object"|"Array", input:string, node:string}, mismatchedNodeOutputType?:array{expectedType:"String"|"Number"|"Boolean"|"Object"|"Array", node:string, output:string}, missingConnectionConfiguration?:array{connection:string}, missingDefaultCondition?:array{node:string}, missingEndingNodes?:array{}, missingNodeConfiguration?:array{node:string}, missingNodeInput?:array{input:string, node:string}, missingNodeOutput?:array{node:string, output:string}, missingStartingNodes?:array{}, multipleNodeInputConnections?:array{input:string, node:string}, unfulfilledNodeInput?:array{input:string, node:string}, unknownConnectionCondition?:array{connection:string}, unknownConnectionSource?:array{connection:string}, unknownConnectionSourceOutput?:array{connection:string}, unknownConnectionTarget?:array{connection:string}, unknownConnectionTargetInput?:array{connection:string}, unreachableNode?:array{node:string}, unsatisfiedConnectionConditions?:array{connection:string}, unspecified?:array{}}, message:string, severity:"Warning"|"Error", type?:"CyclicConnection"|"DuplicateConnections"|"DuplicateConditionExpression"|"UnreachableNode"|"UnknownConnectionSource"|"UnknownConnectionSourceOutput"|"UnknownConnectionTarget"|"UnknownConnectionTargetInput"|"UnknownConnectionCondition"|"MalformedConditionExpression"|"MalformedNodeInputExpression"|"MismatchedNodeInputType"|"MismatchedNodeOutputType"|"IncompatibleConnectionDataType"|"MissingConnectionConfiguration"|"MissingDefaultCondition"|"MissingEndingNodes"|"MissingNodeConfiguration"|"MissingNodeInput"|"MissingNodeOutput"|"MissingStartingNodes"|"MultipleNodeInputConnections"|"UnfulfilledNodeInput"|"UnsatisfiedConnectionConditions"|"Unspecified"}>, version:string}>
     */
    public function getFlowAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{aliasIdentifier:string, flowIdentifier:string} $args
     * @return \AWS\Result<array{arn:string, createdAt:int|string|\DateTimeInterface, description?:string, flowId:string, id:string, name:string, routingConfiguration:array<array{flowVersion?:string}>, updatedAt:int|string|\DateTimeInterface}>
     */
    public function getFlowAlias(array $args): \AWS\Result { }

    /**
     * @param array{aliasIdentifier:string, flowIdentifier:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{arn:string, createdAt:int|string|\DateTimeInterface, description?:string, flowId:string, id:string, name:string, routingConfiguration:array<array{flowVersion?:string}>, updatedAt:int|string|\DateTimeInterface}>
     */
    public function getFlowAliasAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{flowIdentifier:string, flowVersion:string} $args
     * @return \AWS\Result<array{arn:string, createdAt:int|string|\DateTimeInterface, customerEncryptionKeyArn?:string, definition?:array{connections?:array<array{configuration?:array{conditional?:array{condition:string}, data?:array{sourceOutput:string, targetInput:string}}, name:string, source:string, target:string, type:"Data"|"Conditional"}>, nodes?:array<array{configuration?:array{agent?:array{agentAliasArn:string}, collector?:array{}, condition?:array{conditions:array<array{expression?:string, name:string}>}, input?:array{}, iterator?:array{}, knowledgeBase?:array{guardrailConfiguration?:array{guardrailIdentifier?:string, guardrailVersion?:string}, knowledgeBaseId:string, modelId?:string}, lambdaFunction?:array{lambdaArn:string}, lex?:array{botAliasArn:string, localeId:string}, output?:array{}, prompt?:array{guardrailConfiguration?:array{guardrailIdentifier?:string, guardrailVersion?:string}, sourceConfiguration:array{inline?:array{additionalModelRequestFields?:array{}, inferenceConfiguration?:array{text?:array{maxTokens?:int, stopSequences?:array<string>, temperature?:float, topP?:float}}, modelId:string, templateConfiguration:array{chat?:array{inputVariables?:array<array{name?:string}>, messages:array<array{content:array<array{text?:string}>, role:"user"|"assistant"}>, system?:array<array{text?:string}>, toolConfiguration?:array{toolChoice?:array{any?:array{}, auto?:array{}, tool?:array{name:string}}, tools:array<array{toolSpec?:array{description?:string, inputSchema:array{json?:array{}}, name:string}}>}}, text?:array{inputVariables?:array<array{name?:string}>, text:mixed}}, templateType:"TEXT"|"CHAT"}, resource?:array{promptArn:string}}}, retrieval?:array{serviceConfiguration:array{s3?:array{bucketName:string}}}, storage?:array{serviceConfiguration:array{s3?:array{bucketName:string}}}}, inputs?:array<array{expression:string, name:string, type:"String"|"Number"|"Boolean"|"Object"|"Array"}>, name:string, outputs?:array<array{name:string, type:"String"|"Number"|"Boolean"|"Object"|"Array"}>, type:"Input"|"Output"|"KnowledgeBase"|"Condition"|"Lex"|"Prompt"|"LambdaFunction"|"Storage"|"Agent"|"Retrieval"|"Iterator"|"Collector"}>}, description?:string, executionRoleArn:string, id:string, name:string, status:"Failed"|"Prepared"|"Preparing"|"NotPrepared", version:string}>
     */
    public function getFlowVersion(array $args): \AWS\Result { }

    /**
     * @param array{flowIdentifier:string, flowVersion:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{arn:string, createdAt:int|string|\DateTimeInterface, customerEncryptionKeyArn?:string, definition?:array{connections?:array<array{configuration?:array{conditional?:array{condition:string}, data?:array{sourceOutput:string, targetInput:string}}, name:string, source:string, target:string, type:"Data"|"Conditional"}>, nodes?:array<array{configuration?:array{agent?:array{agentAliasArn:string}, collector?:array{}, condition?:array{conditions:array<array{expression?:string, name:string}>}, input?:array{}, iterator?:array{}, knowledgeBase?:array{guardrailConfiguration?:array{guardrailIdentifier?:string, guardrailVersion?:string}, knowledgeBaseId:string, modelId?:string}, lambdaFunction?:array{lambdaArn:string}, lex?:array{botAliasArn:string, localeId:string}, output?:array{}, prompt?:array{guardrailConfiguration?:array{guardrailIdentifier?:string, guardrailVersion?:string}, sourceConfiguration:array{inline?:array{additionalModelRequestFields?:array{}, inferenceConfiguration?:array{text?:array{maxTokens?:int, stopSequences?:array<string>, temperature?:float, topP?:float}}, modelId:string, templateConfiguration:array{chat?:array{inputVariables?:array<array{name?:string}>, messages:array<array{content:array<array{text?:string}>, role:"user"|"assistant"}>, system?:array<array{text?:string}>, toolConfiguration?:array{toolChoice?:array{any?:array{}, auto?:array{}, tool?:array{name:string}}, tools:array<array{toolSpec?:array{description?:string, inputSchema:array{json?:array{}}, name:string}}>}}, text?:array{inputVariables?:array<array{name?:string}>, text:mixed}}, templateType:"TEXT"|"CHAT"}, resource?:array{promptArn:string}}}, retrieval?:array{serviceConfiguration:array{s3?:array{bucketName:string}}}, storage?:array{serviceConfiguration:array{s3?:array{bucketName:string}}}}, inputs?:array<array{expression:string, name:string, type:"String"|"Number"|"Boolean"|"Object"|"Array"}>, name:string, outputs?:array<array{name:string, type:"String"|"Number"|"Boolean"|"Object"|"Array"}>, type:"Input"|"Output"|"KnowledgeBase"|"Condition"|"Lex"|"Prompt"|"LambdaFunction"|"Storage"|"Agent"|"Retrieval"|"Iterator"|"Collector"}>}, description?:string, executionRoleArn:string, id:string, name:string, status:"Failed"|"Prepared"|"Preparing"|"NotPrepared", version:string}>
     */
    public function getFlowVersionAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{dataSourceId:string, ingestionJobId:string, knowledgeBaseId:string} $args
     * @return \AWS\Result<array{ingestionJob:array{dataSourceId:string, description?:string, failureReasons?:array<string>, ingestionJobId:string, knowledgeBaseId:string, startedAt:int|string|\DateTimeInterface, statistics?:array{numberOfDocumentsDeleted?:int, numberOfDocumentsFailed?:int, numberOfDocumentsScanned?:int, numberOfMetadataDocumentsModified?:int, numberOfMetadataDocumentsScanned?:int, numberOfModifiedDocumentsIndexed?:int, numberOfNewDocumentsIndexed?:int}, status:"STARTING"|"IN_PROGRESS"|"COMPLETE"|"FAILED"|"STOPPING"|"STOPPED", updatedAt:int|string|\DateTimeInterface}}>
     */
    public function getIngestionJob(array $args): \AWS\Result { }

    /**
     * @param array{dataSourceId:string, ingestionJobId:string, knowledgeBaseId:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{ingestionJob:array{dataSourceId:string, description?:string, failureReasons?:array<string>, ingestionJobId:string, knowledgeBaseId:string, startedAt:int|string|\DateTimeInterface, statistics?:array{numberOfDocumentsDeleted?:int, numberOfDocumentsFailed?:int, numberOfDocumentsScanned?:int, numberOfMetadataDocumentsModified?:int, numberOfMetadataDocumentsScanned?:int, numberOfModifiedDocumentsIndexed?:int, numberOfNewDocumentsIndexed?:int}, status:"STARTING"|"IN_PROGRESS"|"COMPLETE"|"FAILED"|"STOPPING"|"STOPPED", updatedAt:int|string|\DateTimeInterface}}>
     */
    public function getIngestionJobAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{knowledgeBaseId:string} $args
     * @return \AWS\Result<array{knowledgeBase:array{createdAt:int|string|\DateTimeInterface, description?:string, failureReasons?:array<string>, knowledgeBaseArn:string, knowledgeBaseConfiguration:array{kendraKnowledgeBaseConfiguration?:array{kendraIndexArn:string}, sqlKnowledgeBaseConfiguration?:array{redshiftConfiguration?:array{queryEngineConfiguration:array{provisionedConfiguration?:array{authConfiguration:array{databaseUser?:string, type:"IAM"|"USERNAME_PASSWORD"|"USERNAME", usernamePasswordSecretArn?:string}, clusterIdentifier:string}, serverlessConfiguration?:array{authConfiguration:array{type:"IAM"|"USERNAME_PASSWORD", usernamePasswordSecretArn?:string}, workgroupArn:string}, type:"SERVERLESS"|"PROVISIONED"}, queryGenerationConfiguration?:array{executionTimeoutSeconds?:int, generationContext?:array{curatedQueries?:array<array{naturalLanguage:string, sql:string}>, tables?:array<array{columns?:array<array{description?:string, inclusion?:"INCLUDE"|"EXCLUDE", name?:string}>, description?:string, inclusion?:"INCLUDE"|"EXCLUDE", name:string}>}}, storageConfigurations:array<array{awsDataCatalogConfiguration?:array{tableNames:array<string>}, redshiftConfiguration?:mixed, type:"REDSHIFT"|"AWS_DATA_CATALOG"}>}, type:"REDSHIFT"}, type:"VECTOR"|"KENDRA"|"SQL", vectorKnowledgeBaseConfiguration?:array{embeddingModelArn:string, embeddingModelConfiguration?:array{bedrockEmbeddingModelConfiguration?:array{dimensions?:int, embeddingDataType?:"FLOAT32"|"BINARY"}}, supplementalDataStorageConfiguration?:array{storageLocations:array<array{s3Location?:array{uri:string}, type:"S3"}>}}}, knowledgeBaseId:string, name:string, roleArn:string, status:"CREATING"|"ACTIVE"|"DELETING"|"UPDATING"|"FAILED"|"DELETE_UNSUCCESSFUL", storageConfiguration?:array{mongoDbAtlasConfiguration?:array{collectionName:string, credentialsSecretArn:string, databaseName:string, endpoint:string, endpointServiceName?:string, fieldMapping:array{metadataField:string, textField:string, vectorField:string}, vectorIndexName:string}, opensearchServerlessConfiguration?:array{collectionArn:string, fieldMapping:array{metadataField:string, textField:string, vectorField:string}, vectorIndexName:string}, pineconeConfiguration?:array{connectionString:string, credentialsSecretArn:string, fieldMapping:array{metadataField:string, textField:string}, namespace?:string}, rdsConfiguration?:array{credentialsSecretArn:string, databaseName:string, fieldMapping:array{metadataField:string, primaryKeyField:string, textField:string, vectorField:string}, resourceArn:string, tableName:string}, redisEnterpriseCloudConfiguration?:array{credentialsSecretArn:string, endpoint:string, fieldMapping:array{metadataField:string, textField:string, vectorField:string}, vectorIndexName:string}, type:"OPENSEARCH_SERVERLESS"|"PINECONE"|"REDIS_ENTERPRISE_CLOUD"|"RDS"|"MONGO_DB_ATLAS"}, updatedAt:int|string|\DateTimeInterface}}>
     */
    public function getKnowledgeBase(array $args): \AWS\Result { }

    /**
     * @param array{knowledgeBaseId:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{knowledgeBase:array{createdAt:int|string|\DateTimeInterface, description?:string, failureReasons?:array<string>, knowledgeBaseArn:string, knowledgeBaseConfiguration:array{kendraKnowledgeBaseConfiguration?:array{kendraIndexArn:string}, sqlKnowledgeBaseConfiguration?:array{redshiftConfiguration?:array{queryEngineConfiguration:array{provisionedConfiguration?:array{authConfiguration:array{databaseUser?:string, type:"IAM"|"USERNAME_PASSWORD"|"USERNAME", usernamePasswordSecretArn?:string}, clusterIdentifier:string}, serverlessConfiguration?:array{authConfiguration:array{type:"IAM"|"USERNAME_PASSWORD", usernamePasswordSecretArn?:string}, workgroupArn:string}, type:"SERVERLESS"|"PROVISIONED"}, queryGenerationConfiguration?:array{executionTimeoutSeconds?:int, generationContext?:array{curatedQueries?:array<array{naturalLanguage:string, sql:string}>, tables?:array<array{columns?:array<array{description?:string, inclusion?:"INCLUDE"|"EXCLUDE", name?:string}>, description?:string, inclusion?:"INCLUDE"|"EXCLUDE", name:string}>}}, storageConfigurations:array<array{awsDataCatalogConfiguration?:array{tableNames:array<string>}, redshiftConfiguration?:mixed, type:"REDSHIFT"|"AWS_DATA_CATALOG"}>}, type:"REDSHIFT"}, type:"VECTOR"|"KENDRA"|"SQL", vectorKnowledgeBaseConfiguration?:array{embeddingModelArn:string, embeddingModelConfiguration?:array{bedrockEmbeddingModelConfiguration?:array{dimensions?:int, embeddingDataType?:"FLOAT32"|"BINARY"}}, supplementalDataStorageConfiguration?:array{storageLocations:array<array{s3Location?:array{uri:string}, type:"S3"}>}}}, knowledgeBaseId:string, name:string, roleArn:string, status:"CREATING"|"ACTIVE"|"DELETING"|"UPDATING"|"FAILED"|"DELETE_UNSUCCESSFUL", storageConfiguration?:array{mongoDbAtlasConfiguration?:array{collectionName:string, credentialsSecretArn:string, databaseName:string, endpoint:string, endpointServiceName?:string, fieldMapping:array{metadataField:string, textField:string, vectorField:string}, vectorIndexName:string}, opensearchServerlessConfiguration?:array{collectionArn:string, fieldMapping:array{metadataField:string, textField:string, vectorField:string}, vectorIndexName:string}, pineconeConfiguration?:array{connectionString:string, credentialsSecretArn:string, fieldMapping:array{metadataField:string, textField:string}, namespace?:string}, rdsConfiguration?:array{credentialsSecretArn:string, databaseName:string, fieldMapping:array{metadataField:string, primaryKeyField:string, textField:string, vectorField:string}, resourceArn:string, tableName:string}, redisEnterpriseCloudConfiguration?:array{credentialsSecretArn:string, endpoint:string, fieldMapping:array{metadataField:string, textField:string, vectorField:string}, vectorIndexName:string}, type:"OPENSEARCH_SERVERLESS"|"PINECONE"|"REDIS_ENTERPRISE_CLOUD"|"RDS"|"MONGO_DB_ATLAS"}, updatedAt:int|string|\DateTimeInterface}}>
     */
    public function getKnowledgeBaseAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{dataSourceId:string, documentIdentifiers:array<array{custom?:array{id:string}, dataSourceType:"CUSTOM"|"S3", s3?:array{uri:string}}>, knowledgeBaseId:string} $args
     * @return \AWS\Result<array{documentDetails?:array<array{dataSourceId:string, identifier:array{custom?:array{id:string}, dataSourceType:"CUSTOM"|"S3", s3?:array{uri:string}}, knowledgeBaseId:string, status:"INDEXED"|"PARTIALLY_INDEXED"|"PENDING"|"FAILED"|"METADATA_PARTIALLY_INDEXED"|"METADATA_UPDATE_FAILED"|"IGNORED"|"NOT_FOUND"|"STARTING"|"IN_PROGRESS"|"DELETING"|"DELETE_IN_PROGRESS", statusReason?:string, updatedAt?:int|string|\DateTimeInterface}>}>
     */
    public function getKnowledgeBaseDocuments(array $args): \AWS\Result { }

    /**
     * @param array{dataSourceId:string, documentIdentifiers:array<array{custom?:array{id:string}, dataSourceType:"CUSTOM"|"S3", s3?:array{uri:string}}>, knowledgeBaseId:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{documentDetails?:array<array{dataSourceId:string, identifier:array{custom?:array{id:string}, dataSourceType:"CUSTOM"|"S3", s3?:array{uri:string}}, knowledgeBaseId:string, status:"INDEXED"|"PARTIALLY_INDEXED"|"PENDING"|"FAILED"|"METADATA_PARTIALLY_INDEXED"|"METADATA_UPDATE_FAILED"|"IGNORED"|"NOT_FOUND"|"STARTING"|"IN_PROGRESS"|"DELETING"|"DELETE_IN_PROGRESS", statusReason?:string, updatedAt?:int|string|\DateTimeInterface}>}>
     */
    public function getKnowledgeBaseDocumentsAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{promptIdentifier:string, promptVersion?:string} $args
     * @return \AWS\Result<array{arn:string, createdAt:int|string|\DateTimeInterface, customerEncryptionKeyArn?:string, defaultVariant?:string, description?:string, id:string, name:string, updatedAt:int|string|\DateTimeInterface, variants?:array<array{additionalModelRequestFields?:array{}, genAiResource?:array{agent?:array{agentIdentifier:string}}, inferenceConfiguration?:array{text?:array{maxTokens?:int, stopSequences?:array<string>, temperature?:float, topP?:float}}, metadata?:array<array{key:string, value:string}>, modelId?:string, name:string, templateConfiguration:array{chat?:array{inputVariables?:array<array{name?:string}>, messages:array<array{content:array<array{text?:string}>, role:"user"|"assistant"}>, system?:array<array{text?:string}>, toolConfiguration?:array{toolChoice?:array{any?:array{}, auto?:array{}, tool?:array{name:string}}, tools:array<array{toolSpec?:array{description?:string, inputSchema:array{json?:array{}}, name:string}}>}}, text?:array{inputVariables?:array<array{name?:string}>, text:mixed}}, templateType:"TEXT"|"CHAT"}>, version:string}>
     */
    public function getPrompt(array $args): \AWS\Result { }

    /**
     * @param array{promptIdentifier:string, promptVersion?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{arn:string, createdAt:int|string|\DateTimeInterface, customerEncryptionKeyArn?:string, defaultVariant?:string, description?:string, id:string, name:string, updatedAt:int|string|\DateTimeInterface, variants?:array<array{additionalModelRequestFields?:array{}, genAiResource?:array{agent?:array{agentIdentifier:string}}, inferenceConfiguration?:array{text?:array{maxTokens?:int, stopSequences?:array<string>, temperature?:float, topP?:float}}, metadata?:array<array{key:string, value:string}>, modelId?:string, name:string, templateConfiguration:array{chat?:array{inputVariables?:array<array{name?:string}>, messages:array<array{content:array<array{text?:string}>, role:"user"|"assistant"}>, system?:array<array{text?:string}>, toolConfiguration?:array{toolChoice?:array{any?:array{}, auto?:array{}, tool?:array{name:string}}, tools:array<array{toolSpec?:array{description?:string, inputSchema:array{json?:array{}}, name:string}}>}}, text?:array{inputVariables?:array<array{name?:string}>, text:mixed}}, templateType:"TEXT"|"CHAT"}>, version:string}>
     */
    public function getPromptAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{clientToken?:string, dataSourceId:string, documents:array<array{content:array{custom?:array{customDocumentIdentifier:array{id:string}, inlineContent?:array{byteContent?:array{data:string|resource|\Psr\Http\Message\StreamInterface, mimeType:string}, textContent?:array{data:string}, type:"BYTE"|"TEXT"}, s3Location?:array{bucketOwnerAccountId?:string, uri:string}, sourceType:"IN_LINE"|"S3_LOCATION"}, dataSourceType:"CUSTOM"|"S3", s3?:array{s3Location:array{uri:string}}}, metadata?:array{inlineAttributes?:array<array{key:string, value:array{booleanValue?:bool, numberValue?:float, stringListValue?:array<string>, stringValue?:string, type:"BOOLEAN"|"NUMBER"|"STRING"|"STRING_LIST"}}>, s3Location?:array{bucketOwnerAccountId?:string, uri:string}, type:"IN_LINE_ATTRIBUTE"|"S3_LOCATION"}}>, knowledgeBaseId:string} $args
     * @return \AWS\Result<array{documentDetails?:array<array{dataSourceId:string, identifier:array{custom?:array{id:string}, dataSourceType:"CUSTOM"|"S3", s3?:array{uri:string}}, knowledgeBaseId:string, status:"INDEXED"|"PARTIALLY_INDEXED"|"PENDING"|"FAILED"|"METADATA_PARTIALLY_INDEXED"|"METADATA_UPDATE_FAILED"|"IGNORED"|"NOT_FOUND"|"STARTING"|"IN_PROGRESS"|"DELETING"|"DELETE_IN_PROGRESS", statusReason?:string, updatedAt?:int|string|\DateTimeInterface}>}>
     */
    public function ingestKnowledgeBaseDocuments(array $args): \AWS\Result { }

    /**
     * @param array{clientToken?:string, dataSourceId:string, documents:array<array{content:array{custom?:array{customDocumentIdentifier:array{id:string}, inlineContent?:array{byteContent?:array{data:string|resource|\Psr\Http\Message\StreamInterface, mimeType:string}, textContent?:array{data:string}, type:"BYTE"|"TEXT"}, s3Location?:array{bucketOwnerAccountId?:string, uri:string}, sourceType:"IN_LINE"|"S3_LOCATION"}, dataSourceType:"CUSTOM"|"S3", s3?:array{s3Location:array{uri:string}}}, metadata?:array{inlineAttributes?:array<array{key:string, value:array{booleanValue?:bool, numberValue?:float, stringListValue?:array<string>, stringValue?:string, type:"BOOLEAN"|"NUMBER"|"STRING"|"STRING_LIST"}}>, s3Location?:array{bucketOwnerAccountId?:string, uri:string}, type:"IN_LINE_ATTRIBUTE"|"S3_LOCATION"}}>, knowledgeBaseId:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{documentDetails?:array<array{dataSourceId:string, identifier:array{custom?:array{id:string}, dataSourceType:"CUSTOM"|"S3", s3?:array{uri:string}}, knowledgeBaseId:string, status:"INDEXED"|"PARTIALLY_INDEXED"|"PENDING"|"FAILED"|"METADATA_PARTIALLY_INDEXED"|"METADATA_UPDATE_FAILED"|"IGNORED"|"NOT_FOUND"|"STARTING"|"IN_PROGRESS"|"DELETING"|"DELETE_IN_PROGRESS", statusReason?:string, updatedAt?:int|string|\DateTimeInterface}>}>
     */
    public function ingestKnowledgeBaseDocumentsAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{agentId:string, agentVersion:string, maxResults?:int, nextToken?:string} $args
     * @return \AWS\Result<array{actionGroupSummaries:array<array{actionGroupId:string, actionGroupName:string, actionGroupState:"ENABLED"|"DISABLED", description?:string, updatedAt:int|string|\DateTimeInterface}>, nextToken?:string}>
     */
    public function listAgentActionGroups(array $args): \AWS\Result { }

    /**
     * @param array{agentId:string, agentVersion:string, maxResults?:int, nextToken?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{actionGroupSummaries:array<array{actionGroupId:string, actionGroupName:string, actionGroupState:"ENABLED"|"DISABLED", description?:string, updatedAt:int|string|\DateTimeInterface}>, nextToken?:string}>
     */
    public function listAgentActionGroupsAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{agentId:string, maxResults?:int, nextToken?:string} $args
     * @return \AWS\Result<array{agentAliasSummaries:array<array{agentAliasId:string, agentAliasName:string, agentAliasStatus:"CREATING"|"PREPARED"|"FAILED"|"UPDATING"|"DELETING", createdAt:int|string|\DateTimeInterface, description?:string, routingConfiguration?:array<array{agentVersion?:string, provisionedThroughput?:string}>, updatedAt:int|string|\DateTimeInterface}>, nextToken?:string}>
     */
    public function listAgentAliases(array $args): \AWS\Result { }

    /**
     * @param array{agentId:string, maxResults?:int, nextToken?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{agentAliasSummaries:array<array{agentAliasId:string, agentAliasName:string, agentAliasStatus:"CREATING"|"PREPARED"|"FAILED"|"UPDATING"|"DELETING", createdAt:int|string|\DateTimeInterface, description?:string, routingConfiguration?:array<array{agentVersion?:string, provisionedThroughput?:string}>, updatedAt:int|string|\DateTimeInterface}>, nextToken?:string}>
     */
    public function listAgentAliasesAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{agentId:string, agentVersion:string, maxResults?:int, nextToken?:string} $args
     * @return \AWS\Result<array{agentCollaboratorSummaries:array<array{agentDescriptor:array{aliasArn?:string}, agentId:string, agentVersion:string, collaborationInstruction:string, collaboratorId:string, collaboratorName:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, relayConversationHistory:"TO_COLLABORATOR"|"DISABLED"}>, nextToken?:string}>
     */
    public function listAgentCollaborators(array $args): \AWS\Result { }

    /**
     * @param array{agentId:string, agentVersion:string, maxResults?:int, nextToken?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{agentCollaboratorSummaries:array<array{agentDescriptor:array{aliasArn?:string}, agentId:string, agentVersion:string, collaborationInstruction:string, collaboratorId:string, collaboratorName:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, relayConversationHistory:"TO_COLLABORATOR"|"DISABLED"}>, nextToken?:string}>
     */
    public function listAgentCollaboratorsAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{agentId:string, agentVersion:string, maxResults?:int, nextToken?:string} $args
     * @return \AWS\Result<array{agentKnowledgeBaseSummaries:array<array{description?:string, knowledgeBaseId:string, knowledgeBaseState:"ENABLED"|"DISABLED", updatedAt:int|string|\DateTimeInterface}>, nextToken?:string}>
     */
    public function listAgentKnowledgeBases(array $args): \AWS\Result { }

    /**
     * @param array{agentId:string, agentVersion:string, maxResults?:int, nextToken?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{agentKnowledgeBaseSummaries:array<array{description?:string, knowledgeBaseId:string, knowledgeBaseState:"ENABLED"|"DISABLED", updatedAt:int|string|\DateTimeInterface}>, nextToken?:string}>
     */
    public function listAgentKnowledgeBasesAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{agentId:string, maxResults?:int, nextToken?:string} $args
     * @return \AWS\Result<array{agentVersionSummaries:array<array{agentName:string, agentStatus:"CREATING"|"PREPARING"|"PREPARED"|"NOT_PREPARED"|"DELETING"|"FAILED"|"VERSIONING"|"UPDATING", agentVersion:string, createdAt:int|string|\DateTimeInterface, description?:string, guardrailConfiguration?:array{guardrailIdentifier?:string, guardrailVersion?:string}, updatedAt:int|string|\DateTimeInterface}>, nextToken?:string}>
     */
    public function listAgentVersions(array $args): \AWS\Result { }

    /**
     * @param array{agentId:string, maxResults?:int, nextToken?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{agentVersionSummaries:array<array{agentName:string, agentStatus:"CREATING"|"PREPARING"|"PREPARED"|"NOT_PREPARED"|"DELETING"|"FAILED"|"VERSIONING"|"UPDATING", agentVersion:string, createdAt:int|string|\DateTimeInterface, description?:string, guardrailConfiguration?:array{guardrailIdentifier?:string, guardrailVersion?:string}, updatedAt:int|string|\DateTimeInterface}>, nextToken?:string}>
     */
    public function listAgentVersionsAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{maxResults?:int, nextToken?:string} $args
     * @return \AWS\Result<array{agentSummaries:array<array{agentId:string, agentName:string, agentStatus:"CREATING"|"PREPARING"|"PREPARED"|"NOT_PREPARED"|"DELETING"|"FAILED"|"VERSIONING"|"UPDATING", description?:string, guardrailConfiguration?:array{guardrailIdentifier?:string, guardrailVersion?:string}, latestAgentVersion?:string, updatedAt:int|string|\DateTimeInterface}>, nextToken?:string}>
     */
    public function listAgents(array $args = []): \AWS\Result { }

    /**
     * @param array{maxResults?:int, nextToken?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{agentSummaries:array<array{agentId:string, agentName:string, agentStatus:"CREATING"|"PREPARING"|"PREPARED"|"NOT_PREPARED"|"DELETING"|"FAILED"|"VERSIONING"|"UPDATING", description?:string, guardrailConfiguration?:array{guardrailIdentifier?:string, guardrailVersion?:string}, latestAgentVersion?:string, updatedAt:int|string|\DateTimeInterface}>, nextToken?:string}>
     */
    public function listAgentsAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{knowledgeBaseId:string, maxResults?:int, nextToken?:string} $args
     * @return \AWS\Result<array{dataSourceSummaries:array<array{dataSourceId:string, description?:string, knowledgeBaseId:string, name:string, status:"AVAILABLE"|"DELETING"|"DELETE_UNSUCCESSFUL", updatedAt:int|string|\DateTimeInterface}>, nextToken?:string}>
     */
    public function listDataSources(array $args): \AWS\Result { }

    /**
     * @param array{knowledgeBaseId:string, maxResults?:int, nextToken?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{dataSourceSummaries:array<array{dataSourceId:string, description?:string, knowledgeBaseId:string, name:string, status:"AVAILABLE"|"DELETING"|"DELETE_UNSUCCESSFUL", updatedAt:int|string|\DateTimeInterface}>, nextToken?:string}>
     */
    public function listDataSourcesAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{flowIdentifier:string, maxResults?:int, nextToken?:string} $args
     * @return \AWS\Result<array{flowAliasSummaries:array<array{arn:string, createdAt:int|string|\DateTimeInterface, description?:string, flowId:string, id:string, name:string, routingConfiguration:array<array{flowVersion?:string}>, updatedAt:int|string|\DateTimeInterface}>, nextToken?:string}>
     */
    public function listFlowAliases(array $args): \AWS\Result { }

    /**
     * @param array{flowIdentifier:string, maxResults?:int, nextToken?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{flowAliasSummaries:array<array{arn:string, createdAt:int|string|\DateTimeInterface, description?:string, flowId:string, id:string, name:string, routingConfiguration:array<array{flowVersion?:string}>, updatedAt:int|string|\DateTimeInterface}>, nextToken?:string}>
     */
    public function listFlowAliasesAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{flowIdentifier:string, maxResults?:int, nextToken?:string} $args
     * @return \AWS\Result<array{flowVersionSummaries:array<array{arn:string, createdAt:int|string|\DateTimeInterface, id:string, status:"Failed"|"Prepared"|"Preparing"|"NotPrepared", version:string}>, nextToken?:string}>
     */
    public function listFlowVersions(array $args): \AWS\Result { }

    /**
     * @param array{flowIdentifier:string, maxResults?:int, nextToken?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{flowVersionSummaries:array<array{arn:string, createdAt:int|string|\DateTimeInterface, id:string, status:"Failed"|"Prepared"|"Preparing"|"NotPrepared", version:string}>, nextToken?:string}>
     */
    public function listFlowVersionsAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{maxResults?:int, nextToken?:string} $args
     * @return \AWS\Result<array{flowSummaries:array<array{arn:string, createdAt:int|string|\DateTimeInterface, description?:string, id:string, name:string, status:"Failed"|"Prepared"|"Preparing"|"NotPrepared", updatedAt:int|string|\DateTimeInterface, version:string}>, nextToken?:string}>
     */
    public function listFlows(array $args = []): \AWS\Result { }

    /**
     * @param array{maxResults?:int, nextToken?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{flowSummaries:array<array{arn:string, createdAt:int|string|\DateTimeInterface, description?:string, id:string, name:string, status:"Failed"|"Prepared"|"Preparing"|"NotPrepared", updatedAt:int|string|\DateTimeInterface, version:string}>, nextToken?:string}>
     */
    public function listFlowsAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{dataSourceId:string, filters?:array<array{attribute:"STATUS", operator:"EQ", values:array<string>}>, knowledgeBaseId:string, maxResults?:int, nextToken?:string, sortBy?:array{attribute:"STATUS"|"STARTED_AT", order:"ASCENDING"|"DESCENDING"}} $args
     * @return \AWS\Result<array{ingestionJobSummaries:array<array{dataSourceId:string, description?:string, ingestionJobId:string, knowledgeBaseId:string, startedAt:int|string|\DateTimeInterface, statistics?:array{numberOfDocumentsDeleted?:int, numberOfDocumentsFailed?:int, numberOfDocumentsScanned?:int, numberOfMetadataDocumentsModified?:int, numberOfMetadataDocumentsScanned?:int, numberOfModifiedDocumentsIndexed?:int, numberOfNewDocumentsIndexed?:int}, status:"STARTING"|"IN_PROGRESS"|"COMPLETE"|"FAILED"|"STOPPING"|"STOPPED", updatedAt:int|string|\DateTimeInterface}>, nextToken?:string}>
     */
    public function listIngestionJobs(array $args): \AWS\Result { }

    /**
     * @param array{dataSourceId:string, filters?:array<array{attribute:"STATUS", operator:"EQ", values:array<string>}>, knowledgeBaseId:string, maxResults?:int, nextToken?:string, sortBy?:array{attribute:"STATUS"|"STARTED_AT", order:"ASCENDING"|"DESCENDING"}} $args
     * @return \GuzzleHttp\Promise\Promise<array{ingestionJobSummaries:array<array{dataSourceId:string, description?:string, ingestionJobId:string, knowledgeBaseId:string, startedAt:int|string|\DateTimeInterface, statistics?:array{numberOfDocumentsDeleted?:int, numberOfDocumentsFailed?:int, numberOfDocumentsScanned?:int, numberOfMetadataDocumentsModified?:int, numberOfMetadataDocumentsScanned?:int, numberOfModifiedDocumentsIndexed?:int, numberOfNewDocumentsIndexed?:int}, status:"STARTING"|"IN_PROGRESS"|"COMPLETE"|"FAILED"|"STOPPING"|"STOPPED", updatedAt:int|string|\DateTimeInterface}>, nextToken?:string}>
     */
    public function listIngestionJobsAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{dataSourceId:string, knowledgeBaseId:string, maxResults?:int, nextToken?:string} $args
     * @return \AWS\Result<array{documentDetails:array<array{dataSourceId:string, identifier:array{custom?:array{id:string}, dataSourceType:"CUSTOM"|"S3", s3?:array{uri:string}}, knowledgeBaseId:string, status:"INDEXED"|"PARTIALLY_INDEXED"|"PENDING"|"FAILED"|"METADATA_PARTIALLY_INDEXED"|"METADATA_UPDATE_FAILED"|"IGNORED"|"NOT_FOUND"|"STARTING"|"IN_PROGRESS"|"DELETING"|"DELETE_IN_PROGRESS", statusReason?:string, updatedAt?:int|string|\DateTimeInterface}>, nextToken?:string}>
     */
    public function listKnowledgeBaseDocuments(array $args): \AWS\Result { }

    /**
     * @param array{dataSourceId:string, knowledgeBaseId:string, maxResults?:int, nextToken?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{documentDetails:array<array{dataSourceId:string, identifier:array{custom?:array{id:string}, dataSourceType:"CUSTOM"|"S3", s3?:array{uri:string}}, knowledgeBaseId:string, status:"INDEXED"|"PARTIALLY_INDEXED"|"PENDING"|"FAILED"|"METADATA_PARTIALLY_INDEXED"|"METADATA_UPDATE_FAILED"|"IGNORED"|"NOT_FOUND"|"STARTING"|"IN_PROGRESS"|"DELETING"|"DELETE_IN_PROGRESS", statusReason?:string, updatedAt?:int|string|\DateTimeInterface}>, nextToken?:string}>
     */
    public function listKnowledgeBaseDocumentsAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{maxResults?:int, nextToken?:string} $args
     * @return \AWS\Result<array{knowledgeBaseSummaries:array<array{description?:string, knowledgeBaseId:string, name:string, status:"CREATING"|"ACTIVE"|"DELETING"|"UPDATING"|"FAILED"|"DELETE_UNSUCCESSFUL", updatedAt:int|string|\DateTimeInterface}>, nextToken?:string}>
     */
    public function listKnowledgeBases(array $args = []): \AWS\Result { }

    /**
     * @param array{maxResults?:int, nextToken?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{knowledgeBaseSummaries:array<array{description?:string, knowledgeBaseId:string, name:string, status:"CREATING"|"ACTIVE"|"DELETING"|"UPDATING"|"FAILED"|"DELETE_UNSUCCESSFUL", updatedAt:int|string|\DateTimeInterface}>, nextToken?:string}>
     */
    public function listKnowledgeBasesAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{maxResults?:int, nextToken?:string, promptIdentifier?:string} $args
     * @return \AWS\Result<array{nextToken?:string, promptSummaries:array<array{arn:string, createdAt:int|string|\DateTimeInterface, description?:string, id:string, name:string, updatedAt:int|string|\DateTimeInterface, version:string}>}>
     */
    public function listPrompts(array $args = []): \AWS\Result { }

    /**
     * @param array{maxResults?:int, nextToken?:string, promptIdentifier?:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{nextToken?:string, promptSummaries:array<array{arn:string, createdAt:int|string|\DateTimeInterface, description?:string, id:string, name:string, updatedAt:int|string|\DateTimeInterface, version:string}>}>
     */
    public function listPromptsAsync(array $args = []): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{resourceArn:string} $args
     * @return \AWS\Result<array{tags?:array<string, string>}>
     */
    public function listTagsForResource(array $args): \AWS\Result { }

    /**
     * @param array{resourceArn:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{tags?:array<string, string>}>
     */
    public function listTagsForResourceAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{agentId:string} $args
     * @return \AWS\Result<array{agentId:string, agentStatus:"CREATING"|"PREPARING"|"PREPARED"|"NOT_PREPARED"|"DELETING"|"FAILED"|"VERSIONING"|"UPDATING", agentVersion:string, preparedAt:int|string|\DateTimeInterface}>
     */
    public function prepareAgent(array $args): \AWS\Result { }

    /**
     * @param array{agentId:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{agentId:string, agentStatus:"CREATING"|"PREPARING"|"PREPARED"|"NOT_PREPARED"|"DELETING"|"FAILED"|"VERSIONING"|"UPDATING", agentVersion:string, preparedAt:int|string|\DateTimeInterface}>
     */
    public function prepareAgentAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{flowIdentifier:string} $args
     * @return \AWS\Result<array{id:string, status:"Failed"|"Prepared"|"Preparing"|"NotPrepared"}>
     */
    public function prepareFlow(array $args): \AWS\Result { }

    /**
     * @param array{flowIdentifier:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{id:string, status:"Failed"|"Prepared"|"Preparing"|"NotPrepared"}>
     */
    public function prepareFlowAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{clientToken?:string, dataSourceId:string, description?:string, knowledgeBaseId:string} $args
     * @return \AWS\Result<array{ingestionJob:array{dataSourceId:string, description?:string, failureReasons?:array<string>, ingestionJobId:string, knowledgeBaseId:string, startedAt:int|string|\DateTimeInterface, statistics?:array{numberOfDocumentsDeleted?:int, numberOfDocumentsFailed?:int, numberOfDocumentsScanned?:int, numberOfMetadataDocumentsModified?:int, numberOfMetadataDocumentsScanned?:int, numberOfModifiedDocumentsIndexed?:int, numberOfNewDocumentsIndexed?:int}, status:"STARTING"|"IN_PROGRESS"|"COMPLETE"|"FAILED"|"STOPPING"|"STOPPED", updatedAt:int|string|\DateTimeInterface}}>
     */
    public function startIngestionJob(array $args): \AWS\Result { }

    /**
     * @param array{clientToken?:string, dataSourceId:string, description?:string, knowledgeBaseId:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{ingestionJob:array{dataSourceId:string, description?:string, failureReasons?:array<string>, ingestionJobId:string, knowledgeBaseId:string, startedAt:int|string|\DateTimeInterface, statistics?:array{numberOfDocumentsDeleted?:int, numberOfDocumentsFailed?:int, numberOfDocumentsScanned?:int, numberOfMetadataDocumentsModified?:int, numberOfMetadataDocumentsScanned?:int, numberOfModifiedDocumentsIndexed?:int, numberOfNewDocumentsIndexed?:int}, status:"STARTING"|"IN_PROGRESS"|"COMPLETE"|"FAILED"|"STOPPING"|"STOPPED", updatedAt:int|string|\DateTimeInterface}}>
     */
    public function startIngestionJobAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{dataSourceId:string, ingestionJobId:string, knowledgeBaseId:string} $args
     * @return \AWS\Result<array{ingestionJob:array{dataSourceId:string, description?:string, failureReasons?:array<string>, ingestionJobId:string, knowledgeBaseId:string, startedAt:int|string|\DateTimeInterface, statistics?:array{numberOfDocumentsDeleted?:int, numberOfDocumentsFailed?:int, numberOfDocumentsScanned?:int, numberOfMetadataDocumentsModified?:int, numberOfMetadataDocumentsScanned?:int, numberOfModifiedDocumentsIndexed?:int, numberOfNewDocumentsIndexed?:int}, status:"STARTING"|"IN_PROGRESS"|"COMPLETE"|"FAILED"|"STOPPING"|"STOPPED", updatedAt:int|string|\DateTimeInterface}}>
     */
    public function stopIngestionJob(array $args): \AWS\Result { }

    /**
     * @param array{dataSourceId:string, ingestionJobId:string, knowledgeBaseId:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{ingestionJob:array{dataSourceId:string, description?:string, failureReasons?:array<string>, ingestionJobId:string, knowledgeBaseId:string, startedAt:int|string|\DateTimeInterface, statistics?:array{numberOfDocumentsDeleted?:int, numberOfDocumentsFailed?:int, numberOfDocumentsScanned?:int, numberOfMetadataDocumentsModified?:int, numberOfMetadataDocumentsScanned?:int, numberOfModifiedDocumentsIndexed?:int, numberOfNewDocumentsIndexed?:int}, status:"STARTING"|"IN_PROGRESS"|"COMPLETE"|"FAILED"|"STOPPING"|"STOPPED", updatedAt:int|string|\DateTimeInterface}}>
     */
    public function stopIngestionJobAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{resourceArn:string, tags:array<string, string>} $args
     * @return \AWS\Result<array{}>
     */
    public function tagResource(array $args): \AWS\Result { }

    /**
     * @param array{resourceArn:string, tags:array<string, string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function tagResourceAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{resourceArn:string, tagKeys:array<string>} $args
     * @return \AWS\Result<array{}>
     */
    public function untagResource(array $args): \AWS\Result { }

    /**
     * @param array{resourceArn:string, tagKeys:array<string>} $args
     * @return \GuzzleHttp\Promise\Promise<array{}>
     */
    public function untagResourceAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{agentCollaboration?:"SUPERVISOR"|"SUPERVISOR_ROUTER"|"DISABLED", agentId:string, agentName:string, agentResourceRoleArn:string, customOrchestration?:array{executor?:array{lambda?:string}}, customerEncryptionKeyArn?:string, description?:string, foundationModel:string, guardrailConfiguration?:array{guardrailIdentifier?:string, guardrailVersion?:string}, idleSessionTTLInSeconds?:int, instruction?:string, memoryConfiguration?:array{enabledMemoryTypes:array<"SESSION_SUMMARY">, sessionSummaryConfiguration?:array{maxRecentSessions?:int}, storageDays?:int}, orchestrationType?:"DEFAULT"|"CUSTOM_ORCHESTRATION", promptOverrideConfiguration?:array{overrideLambda?:string, promptConfigurations:array<array{basePromptTemplate?:string, foundationModel?:string, inferenceConfiguration?:array{maximumLength?:int, stopSequences?:array<string>, temperature?:float, topK?:int, topP?:float}, parserMode?:"DEFAULT"|"OVERRIDDEN", promptCreationMode?:"DEFAULT"|"OVERRIDDEN", promptState?:"ENABLED"|"DISABLED", promptType?:"PRE_PROCESSING"|"ORCHESTRATION"|"POST_PROCESSING"|"KNOWLEDGE_BASE_RESPONSE_GENERATION"|"MEMORY_SUMMARIZATION"}>}} $args
     * @return \AWS\Result<array{agent:array{agentArn:string, agentCollaboration?:"SUPERVISOR"|"SUPERVISOR_ROUTER"|"DISABLED", agentId:string, agentName:string, agentResourceRoleArn:string, agentStatus:"CREATING"|"PREPARING"|"PREPARED"|"NOT_PREPARED"|"DELETING"|"FAILED"|"VERSIONING"|"UPDATING", agentVersion:string, clientToken?:string, createdAt:int|string|\DateTimeInterface, customOrchestration?:array{executor?:array{lambda?:string}}, customerEncryptionKeyArn?:string, description?:string, failureReasons?:array<string>, foundationModel?:string, guardrailConfiguration?:array{guardrailIdentifier?:string, guardrailVersion?:string}, idleSessionTTLInSeconds:int, instruction?:string, memoryConfiguration?:array{enabledMemoryTypes:array<"SESSION_SUMMARY">, sessionSummaryConfiguration?:array{maxRecentSessions?:int}, storageDays?:int}, orchestrationType?:"DEFAULT"|"CUSTOM_ORCHESTRATION", preparedAt?:int|string|\DateTimeInterface, promptOverrideConfiguration?:array{overrideLambda?:string, promptConfigurations:array<array{basePromptTemplate?:string, foundationModel?:string, inferenceConfiguration?:array{maximumLength?:int, stopSequences?:array<string>, temperature?:float, topK?:int, topP?:float}, parserMode?:"DEFAULT"|"OVERRIDDEN", promptCreationMode?:"DEFAULT"|"OVERRIDDEN", promptState?:"ENABLED"|"DISABLED", promptType?:"PRE_PROCESSING"|"ORCHESTRATION"|"POST_PROCESSING"|"KNOWLEDGE_BASE_RESPONSE_GENERATION"|"MEMORY_SUMMARIZATION"}>}, recommendedActions?:array<string>, updatedAt:int|string|\DateTimeInterface}}>
     */
    public function updateAgent(array $args): \AWS\Result { }

    /**
     * @param array{agentCollaboration?:"SUPERVISOR"|"SUPERVISOR_ROUTER"|"DISABLED", agentId:string, agentName:string, agentResourceRoleArn:string, customOrchestration?:array{executor?:array{lambda?:string}}, customerEncryptionKeyArn?:string, description?:string, foundationModel:string, guardrailConfiguration?:array{guardrailIdentifier?:string, guardrailVersion?:string}, idleSessionTTLInSeconds?:int, instruction?:string, memoryConfiguration?:array{enabledMemoryTypes:array<"SESSION_SUMMARY">, sessionSummaryConfiguration?:array{maxRecentSessions?:int}, storageDays?:int}, orchestrationType?:"DEFAULT"|"CUSTOM_ORCHESTRATION", promptOverrideConfiguration?:array{overrideLambda?:string, promptConfigurations:array<array{basePromptTemplate?:string, foundationModel?:string, inferenceConfiguration?:array{maximumLength?:int, stopSequences?:array<string>, temperature?:float, topK?:int, topP?:float}, parserMode?:"DEFAULT"|"OVERRIDDEN", promptCreationMode?:"DEFAULT"|"OVERRIDDEN", promptState?:"ENABLED"|"DISABLED", promptType?:"PRE_PROCESSING"|"ORCHESTRATION"|"POST_PROCESSING"|"KNOWLEDGE_BASE_RESPONSE_GENERATION"|"MEMORY_SUMMARIZATION"}>}} $args
     * @return \GuzzleHttp\Promise\Promise<array{agent:array{agentArn:string, agentCollaboration?:"SUPERVISOR"|"SUPERVISOR_ROUTER"|"DISABLED", agentId:string, agentName:string, agentResourceRoleArn:string, agentStatus:"CREATING"|"PREPARING"|"PREPARED"|"NOT_PREPARED"|"DELETING"|"FAILED"|"VERSIONING"|"UPDATING", agentVersion:string, clientToken?:string, createdAt:int|string|\DateTimeInterface, customOrchestration?:array{executor?:array{lambda?:string}}, customerEncryptionKeyArn?:string, description?:string, failureReasons?:array<string>, foundationModel?:string, guardrailConfiguration?:array{guardrailIdentifier?:string, guardrailVersion?:string}, idleSessionTTLInSeconds:int, instruction?:string, memoryConfiguration?:array{enabledMemoryTypes:array<"SESSION_SUMMARY">, sessionSummaryConfiguration?:array{maxRecentSessions?:int}, storageDays?:int}, orchestrationType?:"DEFAULT"|"CUSTOM_ORCHESTRATION", preparedAt?:int|string|\DateTimeInterface, promptOverrideConfiguration?:array{overrideLambda?:string, promptConfigurations:array<array{basePromptTemplate?:string, foundationModel?:string, inferenceConfiguration?:array{maximumLength?:int, stopSequences?:array<string>, temperature?:float, topK?:int, topP?:float}, parserMode?:"DEFAULT"|"OVERRIDDEN", promptCreationMode?:"DEFAULT"|"OVERRIDDEN", promptState?:"ENABLED"|"DISABLED", promptType?:"PRE_PROCESSING"|"ORCHESTRATION"|"POST_PROCESSING"|"KNOWLEDGE_BASE_RESPONSE_GENERATION"|"MEMORY_SUMMARIZATION"}>}, recommendedActions?:array<string>, updatedAt:int|string|\DateTimeInterface}}>
     */
    public function updateAgentAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{actionGroupExecutor?:array{customControl?:"RETURN_CONTROL", lambda?:string}, actionGroupId:string, actionGroupName:string, actionGroupState?:"ENABLED"|"DISABLED", agentId:string, agentVersion:string, apiSchema?:array{payload?:string, s3?:array{s3BucketName?:string, s3ObjectKey?:string}}, description?:string, functionSchema?:array{functions?:array<array{description?:string, name:string, parameters?:array<string, array{description?:string, required?:bool, type:"string"|"number"|"integer"|"boolean"|"array"}>, requireConfirmation?:"ENABLED"|"DISABLED"}>}, parentActionGroupSignature?:"AMAZON.UserInput"|"AMAZON.CodeInterpreter"} $args
     * @return \AWS\Result<array{agentActionGroup:array{actionGroupExecutor?:array{customControl?:"RETURN_CONTROL", lambda?:string}, actionGroupId:string, actionGroupName:string, actionGroupState:"ENABLED"|"DISABLED", agentId:string, agentVersion:string, apiSchema?:array{payload?:string, s3?:array{s3BucketName?:string, s3ObjectKey?:string}}, clientToken?:string, createdAt:int|string|\DateTimeInterface, description?:string, functionSchema?:array{functions?:array<array{description?:string, name:string, parameters?:array<string, array{description?:string, required?:bool, type:"string"|"number"|"integer"|"boolean"|"array"}>, requireConfirmation?:"ENABLED"|"DISABLED"}>}, parentActionSignature?:"AMAZON.UserInput"|"AMAZON.CodeInterpreter", updatedAt:int|string|\DateTimeInterface}}>
     */
    public function updateAgentActionGroup(array $args): \AWS\Result { }

    /**
     * @param array{actionGroupExecutor?:array{customControl?:"RETURN_CONTROL", lambda?:string}, actionGroupId:string, actionGroupName:string, actionGroupState?:"ENABLED"|"DISABLED", agentId:string, agentVersion:string, apiSchema?:array{payload?:string, s3?:array{s3BucketName?:string, s3ObjectKey?:string}}, description?:string, functionSchema?:array{functions?:array<array{description?:string, name:string, parameters?:array<string, array{description?:string, required?:bool, type:"string"|"number"|"integer"|"boolean"|"array"}>, requireConfirmation?:"ENABLED"|"DISABLED"}>}, parentActionGroupSignature?:"AMAZON.UserInput"|"AMAZON.CodeInterpreter"} $args
     * @return \GuzzleHttp\Promise\Promise<array{agentActionGroup:array{actionGroupExecutor?:array{customControl?:"RETURN_CONTROL", lambda?:string}, actionGroupId:string, actionGroupName:string, actionGroupState:"ENABLED"|"DISABLED", agentId:string, agentVersion:string, apiSchema?:array{payload?:string, s3?:array{s3BucketName?:string, s3ObjectKey?:string}}, clientToken?:string, createdAt:int|string|\DateTimeInterface, description?:string, functionSchema?:array{functions?:array<array{description?:string, name:string, parameters?:array<string, array{description?:string, required?:bool, type:"string"|"number"|"integer"|"boolean"|"array"}>, requireConfirmation?:"ENABLED"|"DISABLED"}>}, parentActionSignature?:"AMAZON.UserInput"|"AMAZON.CodeInterpreter", updatedAt:int|string|\DateTimeInterface}}>
     */
    public function updateAgentActionGroupAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{agentAliasId:string, agentAliasName:string, agentId:string, description?:string, routingConfiguration?:array<array{agentVersion?:string, provisionedThroughput?:string}>} $args
     * @return \AWS\Result<array{agentAlias:array{agentAliasArn:string, agentAliasHistoryEvents?:array<array{endDate?:int|string|\DateTimeInterface, routingConfiguration?:array<array{agentVersion?:string, provisionedThroughput?:string}>, startDate?:int|string|\DateTimeInterface}>, agentAliasId:string, agentAliasName:string, agentAliasStatus:"CREATING"|"PREPARED"|"FAILED"|"UPDATING"|"DELETING", agentId:string, clientToken?:string, createdAt:int|string|\DateTimeInterface, description?:string, failureReasons?:array<string>, routingConfiguration:array<array{agentVersion?:string, provisionedThroughput?:string}>, updatedAt:int|string|\DateTimeInterface}}>
     */
    public function updateAgentAlias(array $args): \AWS\Result { }

    /**
     * @param array{agentAliasId:string, agentAliasName:string, agentId:string, description?:string, routingConfiguration?:array<array{agentVersion?:string, provisionedThroughput?:string}>} $args
     * @return \GuzzleHttp\Promise\Promise<array{agentAlias:array{agentAliasArn:string, agentAliasHistoryEvents?:array<array{endDate?:int|string|\DateTimeInterface, routingConfiguration?:array<array{agentVersion?:string, provisionedThroughput?:string}>, startDate?:int|string|\DateTimeInterface}>, agentAliasId:string, agentAliasName:string, agentAliasStatus:"CREATING"|"PREPARED"|"FAILED"|"UPDATING"|"DELETING", agentId:string, clientToken?:string, createdAt:int|string|\DateTimeInterface, description?:string, failureReasons?:array<string>, routingConfiguration:array<array{agentVersion?:string, provisionedThroughput?:string}>, updatedAt:int|string|\DateTimeInterface}}>
     */
    public function updateAgentAliasAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{agentDescriptor:array{aliasArn?:string}, agentId:string, agentVersion:string, collaborationInstruction:string, collaboratorId:string, collaboratorName:string, relayConversationHistory?:"TO_COLLABORATOR"|"DISABLED"} $args
     * @return \AWS\Result<array{agentCollaborator:array{agentDescriptor:array{aliasArn?:string}, agentId:string, agentVersion:string, clientToken?:string, collaborationInstruction:string, collaboratorId:string, collaboratorName:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, relayConversationHistory?:"TO_COLLABORATOR"|"DISABLED"}}>
     */
    public function updateAgentCollaborator(array $args): \AWS\Result { }

    /**
     * @param array{agentDescriptor:array{aliasArn?:string}, agentId:string, agentVersion:string, collaborationInstruction:string, collaboratorId:string, collaboratorName:string, relayConversationHistory?:"TO_COLLABORATOR"|"DISABLED"} $args
     * @return \GuzzleHttp\Promise\Promise<array{agentCollaborator:array{agentDescriptor:array{aliasArn?:string}, agentId:string, agentVersion:string, clientToken?:string, collaborationInstruction:string, collaboratorId:string, collaboratorName:string, createdAt:int|string|\DateTimeInterface, lastUpdatedAt:int|string|\DateTimeInterface, relayConversationHistory?:"TO_COLLABORATOR"|"DISABLED"}}>
     */
    public function updateAgentCollaboratorAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{agentId:string, agentVersion:string, description?:string, knowledgeBaseId:string, knowledgeBaseState?:"ENABLED"|"DISABLED"} $args
     * @return \AWS\Result<array{agentKnowledgeBase:array{agentId:string, agentVersion:string, createdAt:int|string|\DateTimeInterface, description:string, knowledgeBaseId:string, knowledgeBaseState:"ENABLED"|"DISABLED", updatedAt:int|string|\DateTimeInterface}}>
     */
    public function updateAgentKnowledgeBase(array $args): \AWS\Result { }

    /**
     * @param array{agentId:string, agentVersion:string, description?:string, knowledgeBaseId:string, knowledgeBaseState?:"ENABLED"|"DISABLED"} $args
     * @return \GuzzleHttp\Promise\Promise<array{agentKnowledgeBase:array{agentId:string, agentVersion:string, createdAt:int|string|\DateTimeInterface, description:string, knowledgeBaseId:string, knowledgeBaseState:"ENABLED"|"DISABLED", updatedAt:int|string|\DateTimeInterface}}>
     */
    public function updateAgentKnowledgeBaseAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{dataDeletionPolicy?:"RETAIN"|"DELETE", dataSourceConfiguration:array{confluenceConfiguration?:array{crawlerConfiguration?:array{filterConfiguration?:array{patternObjectFilter?:array{filters:array<array{exclusionFilters?:array<string>, inclusionFilters?:array<string>, objectType:string}>}, type:"PATTERN"}}, sourceConfiguration:array{authType:"BASIC"|"OAUTH2_CLIENT_CREDENTIALS", credentialsSecretArn:string, hostType:"SAAS", hostUrl:string}}, s3Configuration?:array{bucketArn:string, bucketOwnerAccountId?:string, inclusionPrefixes?:array<string>}, salesforceConfiguration?:array{crawlerConfiguration?:array{filterConfiguration?:array{patternObjectFilter?:array{filters:array<array{exclusionFilters?:array<string>, inclusionFilters?:array<string>, objectType:string}>}, type:"PATTERN"}}, sourceConfiguration:array{authType:"OAUTH2_CLIENT_CREDENTIALS", credentialsSecretArn:string, hostUrl:string}}, sharePointConfiguration?:array{crawlerConfiguration?:array{filterConfiguration?:array{patternObjectFilter?:array{filters:array<array{exclusionFilters?:array<string>, inclusionFilters?:array<string>, objectType:string}>}, type:"PATTERN"}}, sourceConfiguration:array{authType:"OAUTH2_CLIENT_CREDENTIALS"|"OAUTH2_SHAREPOINT_APP_ONLY_CLIENT_CREDENTIALS", credentialsSecretArn:string, domain:string, hostType:"ONLINE", siteUrls:array<string>, tenantId?:string}}, type:"S3"|"WEB"|"CONFLUENCE"|"SALESFORCE"|"SHAREPOINT"|"CUSTOM"|"REDSHIFT_METADATA", webConfiguration?:array{crawlerConfiguration?:array{crawlerLimits?:array{maxPages?:int, rateLimit?:int}, exclusionFilters?:array<string>, inclusionFilters?:array<string>, scope?:"HOST_ONLY"|"SUBDOMAINS", userAgent?:string}, sourceConfiguration:array{urlConfiguration:array{seedUrls?:array<array{url?:string}>}}}}, dataSourceId:string, description?:string, knowledgeBaseId:string, name:string, serverSideEncryptionConfiguration?:array{kmsKeyArn?:string}, vectorIngestionConfiguration?:array{chunkingConfiguration?:array{chunkingStrategy:"FIXED_SIZE"|"NONE"|"HIERARCHICAL"|"SEMANTIC", fixedSizeChunkingConfiguration?:array{maxTokens:int, overlapPercentage:int}, hierarchicalChunkingConfiguration?:array{levelConfigurations:array<array{maxTokens:int}>, overlapTokens:int}, semanticChunkingConfiguration?:array{breakpointPercentileThreshold:int, bufferSize:int, maxTokens:int}}, customTransformationConfiguration?:array{intermediateStorage:array{s3Location:array{uri:string}}, transformations:array<array{stepToApply:"POST_CHUNKING", transformationFunction:array{transformationLambdaConfiguration:array{lambdaArn:string}}}>}, parsingConfiguration?:array{bedrockDataAutomationConfiguration?:array{parsingModality?:"MULTIMODAL"}, bedrockFoundationModelConfiguration?:array{modelArn:string, parsingModality?:"MULTIMODAL", parsingPrompt?:array{parsingPromptText:string}}, parsingStrategy:"BEDROCK_FOUNDATION_MODEL"|"BEDROCK_DATA_AUTOMATION"}}} $args
     * @return \AWS\Result<array{dataSource:array{createdAt:int|string|\DateTimeInterface, dataDeletionPolicy?:"RETAIN"|"DELETE", dataSourceConfiguration:array{confluenceConfiguration?:array{crawlerConfiguration?:array{filterConfiguration?:array{patternObjectFilter?:array{filters:array<array{exclusionFilters?:array<string>, inclusionFilters?:array<string>, objectType:string}>}, type:"PATTERN"}}, sourceConfiguration:array{authType:"BASIC"|"OAUTH2_CLIENT_CREDENTIALS", credentialsSecretArn:string, hostType:"SAAS", hostUrl:string}}, s3Configuration?:array{bucketArn:string, bucketOwnerAccountId?:string, inclusionPrefixes?:array<string>}, salesforceConfiguration?:array{crawlerConfiguration?:array{filterConfiguration?:array{patternObjectFilter?:array{filters:array<array{exclusionFilters?:array<string>, inclusionFilters?:array<string>, objectType:string}>}, type:"PATTERN"}}, sourceConfiguration:array{authType:"OAUTH2_CLIENT_CREDENTIALS", credentialsSecretArn:string, hostUrl:string}}, sharePointConfiguration?:array{crawlerConfiguration?:array{filterConfiguration?:array{patternObjectFilter?:array{filters:array<array{exclusionFilters?:array<string>, inclusionFilters?:array<string>, objectType:string}>}, type:"PATTERN"}}, sourceConfiguration:array{authType:"OAUTH2_CLIENT_CREDENTIALS"|"OAUTH2_SHAREPOINT_APP_ONLY_CLIENT_CREDENTIALS", credentialsSecretArn:string, domain:string, hostType:"ONLINE", siteUrls:array<string>, tenantId?:string}}, type:"S3"|"WEB"|"CONFLUENCE"|"SALESFORCE"|"SHAREPOINT"|"CUSTOM"|"REDSHIFT_METADATA", webConfiguration?:array{crawlerConfiguration?:array{crawlerLimits?:array{maxPages?:int, rateLimit?:int}, exclusionFilters?:array<string>, inclusionFilters?:array<string>, scope?:"HOST_ONLY"|"SUBDOMAINS", userAgent?:string}, sourceConfiguration:array{urlConfiguration:array{seedUrls?:array<array{url?:string}>}}}}, dataSourceId:string, description?:string, failureReasons?:array<string>, knowledgeBaseId:string, name:string, serverSideEncryptionConfiguration?:array{kmsKeyArn?:string}, status:"AVAILABLE"|"DELETING"|"DELETE_UNSUCCESSFUL", updatedAt:int|string|\DateTimeInterface, vectorIngestionConfiguration?:array{chunkingConfiguration?:array{chunkingStrategy:"FIXED_SIZE"|"NONE"|"HIERARCHICAL"|"SEMANTIC", fixedSizeChunkingConfiguration?:array{maxTokens:int, overlapPercentage:int}, hierarchicalChunkingConfiguration?:array{levelConfigurations:array<array{maxTokens:int}>, overlapTokens:int}, semanticChunkingConfiguration?:array{breakpointPercentileThreshold:int, bufferSize:int, maxTokens:int}}, customTransformationConfiguration?:array{intermediateStorage:array{s3Location:array{uri:string}}, transformations:array<array{stepToApply:"POST_CHUNKING", transformationFunction:array{transformationLambdaConfiguration:array{lambdaArn:string}}}>}, parsingConfiguration?:array{bedrockDataAutomationConfiguration?:array{parsingModality?:"MULTIMODAL"}, bedrockFoundationModelConfiguration?:array{modelArn:string, parsingModality?:"MULTIMODAL", parsingPrompt?:array{parsingPromptText:string}}, parsingStrategy:"BEDROCK_FOUNDATION_MODEL"|"BEDROCK_DATA_AUTOMATION"}}}}>
     */
    public function updateDataSource(array $args): \AWS\Result { }

    /**
     * @param array{dataDeletionPolicy?:"RETAIN"|"DELETE", dataSourceConfiguration:array{confluenceConfiguration?:array{crawlerConfiguration?:array{filterConfiguration?:array{patternObjectFilter?:array{filters:array<array{exclusionFilters?:array<string>, inclusionFilters?:array<string>, objectType:string}>}, type:"PATTERN"}}, sourceConfiguration:array{authType:"BASIC"|"OAUTH2_CLIENT_CREDENTIALS", credentialsSecretArn:string, hostType:"SAAS", hostUrl:string}}, s3Configuration?:array{bucketArn:string, bucketOwnerAccountId?:string, inclusionPrefixes?:array<string>}, salesforceConfiguration?:array{crawlerConfiguration?:array{filterConfiguration?:array{patternObjectFilter?:array{filters:array<array{exclusionFilters?:array<string>, inclusionFilters?:array<string>, objectType:string}>}, type:"PATTERN"}}, sourceConfiguration:array{authType:"OAUTH2_CLIENT_CREDENTIALS", credentialsSecretArn:string, hostUrl:string}}, sharePointConfiguration?:array{crawlerConfiguration?:array{filterConfiguration?:array{patternObjectFilter?:array{filters:array<array{exclusionFilters?:array<string>, inclusionFilters?:array<string>, objectType:string}>}, type:"PATTERN"}}, sourceConfiguration:array{authType:"OAUTH2_CLIENT_CREDENTIALS"|"OAUTH2_SHAREPOINT_APP_ONLY_CLIENT_CREDENTIALS", credentialsSecretArn:string, domain:string, hostType:"ONLINE", siteUrls:array<string>, tenantId?:string}}, type:"S3"|"WEB"|"CONFLUENCE"|"SALESFORCE"|"SHAREPOINT"|"CUSTOM"|"REDSHIFT_METADATA", webConfiguration?:array{crawlerConfiguration?:array{crawlerLimits?:array{maxPages?:int, rateLimit?:int}, exclusionFilters?:array<string>, inclusionFilters?:array<string>, scope?:"HOST_ONLY"|"SUBDOMAINS", userAgent?:string}, sourceConfiguration:array{urlConfiguration:array{seedUrls?:array<array{url?:string}>}}}}, dataSourceId:string, description?:string, knowledgeBaseId:string, name:string, serverSideEncryptionConfiguration?:array{kmsKeyArn?:string}, vectorIngestionConfiguration?:array{chunkingConfiguration?:array{chunkingStrategy:"FIXED_SIZE"|"NONE"|"HIERARCHICAL"|"SEMANTIC", fixedSizeChunkingConfiguration?:array{maxTokens:int, overlapPercentage:int}, hierarchicalChunkingConfiguration?:array{levelConfigurations:array<array{maxTokens:int}>, overlapTokens:int}, semanticChunkingConfiguration?:array{breakpointPercentileThreshold:int, bufferSize:int, maxTokens:int}}, customTransformationConfiguration?:array{intermediateStorage:array{s3Location:array{uri:string}}, transformations:array<array{stepToApply:"POST_CHUNKING", transformationFunction:array{transformationLambdaConfiguration:array{lambdaArn:string}}}>}, parsingConfiguration?:array{bedrockDataAutomationConfiguration?:array{parsingModality?:"MULTIMODAL"}, bedrockFoundationModelConfiguration?:array{modelArn:string, parsingModality?:"MULTIMODAL", parsingPrompt?:array{parsingPromptText:string}}, parsingStrategy:"BEDROCK_FOUNDATION_MODEL"|"BEDROCK_DATA_AUTOMATION"}}} $args
     * @return \GuzzleHttp\Promise\Promise<array{dataSource:array{createdAt:int|string|\DateTimeInterface, dataDeletionPolicy?:"RETAIN"|"DELETE", dataSourceConfiguration:array{confluenceConfiguration?:array{crawlerConfiguration?:array{filterConfiguration?:array{patternObjectFilter?:array{filters:array<array{exclusionFilters?:array<string>, inclusionFilters?:array<string>, objectType:string}>}, type:"PATTERN"}}, sourceConfiguration:array{authType:"BASIC"|"OAUTH2_CLIENT_CREDENTIALS", credentialsSecretArn:string, hostType:"SAAS", hostUrl:string}}, s3Configuration?:array{bucketArn:string, bucketOwnerAccountId?:string, inclusionPrefixes?:array<string>}, salesforceConfiguration?:array{crawlerConfiguration?:array{filterConfiguration?:array{patternObjectFilter?:array{filters:array<array{exclusionFilters?:array<string>, inclusionFilters?:array<string>, objectType:string}>}, type:"PATTERN"}}, sourceConfiguration:array{authType:"OAUTH2_CLIENT_CREDENTIALS", credentialsSecretArn:string, hostUrl:string}}, sharePointConfiguration?:array{crawlerConfiguration?:array{filterConfiguration?:array{patternObjectFilter?:array{filters:array<array{exclusionFilters?:array<string>, inclusionFilters?:array<string>, objectType:string}>}, type:"PATTERN"}}, sourceConfiguration:array{authType:"OAUTH2_CLIENT_CREDENTIALS"|"OAUTH2_SHAREPOINT_APP_ONLY_CLIENT_CREDENTIALS", credentialsSecretArn:string, domain:string, hostType:"ONLINE", siteUrls:array<string>, tenantId?:string}}, type:"S3"|"WEB"|"CONFLUENCE"|"SALESFORCE"|"SHAREPOINT"|"CUSTOM"|"REDSHIFT_METADATA", webConfiguration?:array{crawlerConfiguration?:array{crawlerLimits?:array{maxPages?:int, rateLimit?:int}, exclusionFilters?:array<string>, inclusionFilters?:array<string>, scope?:"HOST_ONLY"|"SUBDOMAINS", userAgent?:string}, sourceConfiguration:array{urlConfiguration:array{seedUrls?:array<array{url?:string}>}}}}, dataSourceId:string, description?:string, failureReasons?:array<string>, knowledgeBaseId:string, name:string, serverSideEncryptionConfiguration?:array{kmsKeyArn?:string}, status:"AVAILABLE"|"DELETING"|"DELETE_UNSUCCESSFUL", updatedAt:int|string|\DateTimeInterface, vectorIngestionConfiguration?:array{chunkingConfiguration?:array{chunkingStrategy:"FIXED_SIZE"|"NONE"|"HIERARCHICAL"|"SEMANTIC", fixedSizeChunkingConfiguration?:array{maxTokens:int, overlapPercentage:int}, hierarchicalChunkingConfiguration?:array{levelConfigurations:array<array{maxTokens:int}>, overlapTokens:int}, semanticChunkingConfiguration?:array{breakpointPercentileThreshold:int, bufferSize:int, maxTokens:int}}, customTransformationConfiguration?:array{intermediateStorage:array{s3Location:array{uri:string}}, transformations:array<array{stepToApply:"POST_CHUNKING", transformationFunction:array{transformationLambdaConfiguration:array{lambdaArn:string}}}>}, parsingConfiguration?:array{bedrockDataAutomationConfiguration?:array{parsingModality?:"MULTIMODAL"}, bedrockFoundationModelConfiguration?:array{modelArn:string, parsingModality?:"MULTIMODAL", parsingPrompt?:array{parsingPromptText:string}}, parsingStrategy:"BEDROCK_FOUNDATION_MODEL"|"BEDROCK_DATA_AUTOMATION"}}}}>
     */
    public function updateDataSourceAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{customerEncryptionKeyArn?:string, definition?:array{connections?:array<array{configuration?:array{conditional?:array{condition:string}, data?:array{sourceOutput:string, targetInput:string}}, name:string, source:string, target:string, type:"Data"|"Conditional"}>, nodes?:array<array{configuration?:array{agent?:array{agentAliasArn:string}, collector?:array{}, condition?:array{conditions:array<array{expression?:string, name:string}>}, input?:array{}, iterator?:array{}, knowledgeBase?:array{guardrailConfiguration?:array{guardrailIdentifier?:string, guardrailVersion?:string}, knowledgeBaseId:string, modelId?:string}, lambdaFunction?:array{lambdaArn:string}, lex?:array{botAliasArn:string, localeId:string}, output?:array{}, prompt?:array{guardrailConfiguration?:array{guardrailIdentifier?:string, guardrailVersion?:string}, sourceConfiguration:array{inline?:array{additionalModelRequestFields?:array{}, inferenceConfiguration?:array{text?:array{maxTokens?:int, stopSequences?:array<string>, temperature?:float, topP?:float}}, modelId:string, templateConfiguration:array{chat?:array{inputVariables?:array<array{name?:string}>, messages:array<array{content:array<array{text?:string}>, role:"user"|"assistant"}>, system?:array<array{text?:string}>, toolConfiguration?:array{toolChoice?:array{any?:array{}, auto?:array{}, tool?:array{name:string}}, tools:array<array{toolSpec?:array{description?:string, inputSchema:array{json?:array{}}, name:string}}>}}, text?:array{inputVariables?:array<array{name?:string}>, text:mixed}}, templateType:"TEXT"|"CHAT"}, resource?:array{promptArn:string}}}, retrieval?:array{serviceConfiguration:array{s3?:array{bucketName:string}}}, storage?:array{serviceConfiguration:array{s3?:array{bucketName:string}}}}, inputs?:array<array{expression:string, name:string, type:"String"|"Number"|"Boolean"|"Object"|"Array"}>, name:string, outputs?:array<array{name:string, type:"String"|"Number"|"Boolean"|"Object"|"Array"}>, type:"Input"|"Output"|"KnowledgeBase"|"Condition"|"Lex"|"Prompt"|"LambdaFunction"|"Storage"|"Agent"|"Retrieval"|"Iterator"|"Collector"}>}, description?:string, executionRoleArn:string, flowIdentifier:string, name:string} $args
     * @return \AWS\Result<array{arn:string, createdAt:int|string|\DateTimeInterface, customerEncryptionKeyArn?:string, definition?:array{connections?:array<array{configuration?:array{conditional?:array{condition:string}, data?:array{sourceOutput:string, targetInput:string}}, name:string, source:string, target:string, type:"Data"|"Conditional"}>, nodes?:array<array{configuration?:array{agent?:array{agentAliasArn:string}, collector?:array{}, condition?:array{conditions:array<array{expression?:string, name:string}>}, input?:array{}, iterator?:array{}, knowledgeBase?:array{guardrailConfiguration?:array{guardrailIdentifier?:string, guardrailVersion?:string}, knowledgeBaseId:string, modelId?:string}, lambdaFunction?:array{lambdaArn:string}, lex?:array{botAliasArn:string, localeId:string}, output?:array{}, prompt?:array{guardrailConfiguration?:array{guardrailIdentifier?:string, guardrailVersion?:string}, sourceConfiguration:array{inline?:array{additionalModelRequestFields?:array{}, inferenceConfiguration?:array{text?:array{maxTokens?:int, stopSequences?:array<string>, temperature?:float, topP?:float}}, modelId:string, templateConfiguration:array{chat?:array{inputVariables?:array<array{name?:string}>, messages:array<array{content:array<array{text?:string}>, role:"user"|"assistant"}>, system?:array<array{text?:string}>, toolConfiguration?:array{toolChoice?:array{any?:array{}, auto?:array{}, tool?:array{name:string}}, tools:array<array{toolSpec?:array{description?:string, inputSchema:array{json?:array{}}, name:string}}>}}, text?:array{inputVariables?:array<array{name?:string}>, text:mixed}}, templateType:"TEXT"|"CHAT"}, resource?:array{promptArn:string}}}, retrieval?:array{serviceConfiguration:array{s3?:array{bucketName:string}}}, storage?:array{serviceConfiguration:array{s3?:array{bucketName:string}}}}, inputs?:array<array{expression:string, name:string, type:"String"|"Number"|"Boolean"|"Object"|"Array"}>, name:string, outputs?:array<array{name:string, type:"String"|"Number"|"Boolean"|"Object"|"Array"}>, type:"Input"|"Output"|"KnowledgeBase"|"Condition"|"Lex"|"Prompt"|"LambdaFunction"|"Storage"|"Agent"|"Retrieval"|"Iterator"|"Collector"}>}, description?:string, executionRoleArn:string, id:string, name:string, status:"Failed"|"Prepared"|"Preparing"|"NotPrepared", updatedAt:int|string|\DateTimeInterface, version:string}>
     */
    public function updateFlow(array $args): \AWS\Result { }

    /**
     * @param array{customerEncryptionKeyArn?:string, definition?:array{connections?:array<array{configuration?:array{conditional?:array{condition:string}, data?:array{sourceOutput:string, targetInput:string}}, name:string, source:string, target:string, type:"Data"|"Conditional"}>, nodes?:array<array{configuration?:array{agent?:array{agentAliasArn:string}, collector?:array{}, condition?:array{conditions:array<array{expression?:string, name:string}>}, input?:array{}, iterator?:array{}, knowledgeBase?:array{guardrailConfiguration?:array{guardrailIdentifier?:string, guardrailVersion?:string}, knowledgeBaseId:string, modelId?:string}, lambdaFunction?:array{lambdaArn:string}, lex?:array{botAliasArn:string, localeId:string}, output?:array{}, prompt?:array{guardrailConfiguration?:array{guardrailIdentifier?:string, guardrailVersion?:string}, sourceConfiguration:array{inline?:array{additionalModelRequestFields?:array{}, inferenceConfiguration?:array{text?:array{maxTokens?:int, stopSequences?:array<string>, temperature?:float, topP?:float}}, modelId:string, templateConfiguration:array{chat?:array{inputVariables?:array<array{name?:string}>, messages:array<array{content:array<array{text?:string}>, role:"user"|"assistant"}>, system?:array<array{text?:string}>, toolConfiguration?:array{toolChoice?:array{any?:array{}, auto?:array{}, tool?:array{name:string}}, tools:array<array{toolSpec?:array{description?:string, inputSchema:array{json?:array{}}, name:string}}>}}, text?:array{inputVariables?:array<array{name?:string}>, text:mixed}}, templateType:"TEXT"|"CHAT"}, resource?:array{promptArn:string}}}, retrieval?:array{serviceConfiguration:array{s3?:array{bucketName:string}}}, storage?:array{serviceConfiguration:array{s3?:array{bucketName:string}}}}, inputs?:array<array{expression:string, name:string, type:"String"|"Number"|"Boolean"|"Object"|"Array"}>, name:string, outputs?:array<array{name:string, type:"String"|"Number"|"Boolean"|"Object"|"Array"}>, type:"Input"|"Output"|"KnowledgeBase"|"Condition"|"Lex"|"Prompt"|"LambdaFunction"|"Storage"|"Agent"|"Retrieval"|"Iterator"|"Collector"}>}, description?:string, executionRoleArn:string, flowIdentifier:string, name:string} $args
     * @return \GuzzleHttp\Promise\Promise<array{arn:string, createdAt:int|string|\DateTimeInterface, customerEncryptionKeyArn?:string, definition?:array{connections?:array<array{configuration?:array{conditional?:array{condition:string}, data?:array{sourceOutput:string, targetInput:string}}, name:string, source:string, target:string, type:"Data"|"Conditional"}>, nodes?:array<array{configuration?:array{agent?:array{agentAliasArn:string}, collector?:array{}, condition?:array{conditions:array<array{expression?:string, name:string}>}, input?:array{}, iterator?:array{}, knowledgeBase?:array{guardrailConfiguration?:array{guardrailIdentifier?:string, guardrailVersion?:string}, knowledgeBaseId:string, modelId?:string}, lambdaFunction?:array{lambdaArn:string}, lex?:array{botAliasArn:string, localeId:string}, output?:array{}, prompt?:array{guardrailConfiguration?:array{guardrailIdentifier?:string, guardrailVersion?:string}, sourceConfiguration:array{inline?:array{additionalModelRequestFields?:array{}, inferenceConfiguration?:array{text?:array{maxTokens?:int, stopSequences?:array<string>, temperature?:float, topP?:float}}, modelId:string, templateConfiguration:array{chat?:array{inputVariables?:array<array{name?:string}>, messages:array<array{content:array<array{text?:string}>, role:"user"|"assistant"}>, system?:array<array{text?:string}>, toolConfiguration?:array{toolChoice?:array{any?:array{}, auto?:array{}, tool?:array{name:string}}, tools:array<array{toolSpec?:array{description?:string, inputSchema:array{json?:array{}}, name:string}}>}}, text?:array{inputVariables?:array<array{name?:string}>, text:mixed}}, templateType:"TEXT"|"CHAT"}, resource?:array{promptArn:string}}}, retrieval?:array{serviceConfiguration:array{s3?:array{bucketName:string}}}, storage?:array{serviceConfiguration:array{s3?:array{bucketName:string}}}}, inputs?:array<array{expression:string, name:string, type:"String"|"Number"|"Boolean"|"Object"|"Array"}>, name:string, outputs?:array<array{name:string, type:"String"|"Number"|"Boolean"|"Object"|"Array"}>, type:"Input"|"Output"|"KnowledgeBase"|"Condition"|"Lex"|"Prompt"|"LambdaFunction"|"Storage"|"Agent"|"Retrieval"|"Iterator"|"Collector"}>}, description?:string, executionRoleArn:string, id:string, name:string, status:"Failed"|"Prepared"|"Preparing"|"NotPrepared", updatedAt:int|string|\DateTimeInterface, version:string}>
     */
    public function updateFlowAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{aliasIdentifier:string, description?:string, flowIdentifier:string, name:string, routingConfiguration:array<array{flowVersion?:string}>} $args
     * @return \AWS\Result<array{arn:string, createdAt:int|string|\DateTimeInterface, description?:string, flowId:string, id:string, name:string, routingConfiguration:array<array{flowVersion?:string}>, updatedAt:int|string|\DateTimeInterface}>
     */
    public function updateFlowAlias(array $args): \AWS\Result { }

    /**
     * @param array{aliasIdentifier:string, description?:string, flowIdentifier:string, name:string, routingConfiguration:array<array{flowVersion?:string}>} $args
     * @return \GuzzleHttp\Promise\Promise<array{arn:string, createdAt:int|string|\DateTimeInterface, description?:string, flowId:string, id:string, name:string, routingConfiguration:array<array{flowVersion?:string}>, updatedAt:int|string|\DateTimeInterface}>
     */
    public function updateFlowAliasAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{description?:string, knowledgeBaseConfiguration:array{kendraKnowledgeBaseConfiguration?:array{kendraIndexArn:string}, sqlKnowledgeBaseConfiguration?:array{redshiftConfiguration?:array{queryEngineConfiguration:array{provisionedConfiguration?:array{authConfiguration:array{databaseUser?:string, type:"IAM"|"USERNAME_PASSWORD"|"USERNAME", usernamePasswordSecretArn?:string}, clusterIdentifier:string}, serverlessConfiguration?:array{authConfiguration:array{type:"IAM"|"USERNAME_PASSWORD", usernamePasswordSecretArn?:string}, workgroupArn:string}, type:"SERVERLESS"|"PROVISIONED"}, queryGenerationConfiguration?:array{executionTimeoutSeconds?:int, generationContext?:array{curatedQueries?:array<array{naturalLanguage:string, sql:string}>, tables?:array<array{columns?:array<array{description?:string, inclusion?:"INCLUDE"|"EXCLUDE", name?:string}>, description?:string, inclusion?:"INCLUDE"|"EXCLUDE", name:string}>}}, storageConfigurations:array<array{awsDataCatalogConfiguration?:array{tableNames:array<string>}, redshiftConfiguration?:mixed, type:"REDSHIFT"|"AWS_DATA_CATALOG"}>}, type:"REDSHIFT"}, type:"VECTOR"|"KENDRA"|"SQL", vectorKnowledgeBaseConfiguration?:array{embeddingModelArn:string, embeddingModelConfiguration?:array{bedrockEmbeddingModelConfiguration?:array{dimensions?:int, embeddingDataType?:"FLOAT32"|"BINARY"}}, supplementalDataStorageConfiguration?:array{storageLocations:array<array{s3Location?:array{uri:string}, type:"S3"}>}}}, knowledgeBaseId:string, name:string, roleArn:string, storageConfiguration?:array{mongoDbAtlasConfiguration?:array{collectionName:string, credentialsSecretArn:string, databaseName:string, endpoint:string, endpointServiceName?:string, fieldMapping:array{metadataField:string, textField:string, vectorField:string}, vectorIndexName:string}, opensearchServerlessConfiguration?:array{collectionArn:string, fieldMapping:array{metadataField:string, textField:string, vectorField:string}, vectorIndexName:string}, pineconeConfiguration?:array{connectionString:string, credentialsSecretArn:string, fieldMapping:array{metadataField:string, textField:string}, namespace?:string}, rdsConfiguration?:array{credentialsSecretArn:string, databaseName:string, fieldMapping:array{metadataField:string, primaryKeyField:string, textField:string, vectorField:string}, resourceArn:string, tableName:string}, redisEnterpriseCloudConfiguration?:array{credentialsSecretArn:string, endpoint:string, fieldMapping:array{metadataField:string, textField:string, vectorField:string}, vectorIndexName:string}, type:"OPENSEARCH_SERVERLESS"|"PINECONE"|"REDIS_ENTERPRISE_CLOUD"|"RDS"|"MONGO_DB_ATLAS"}} $args
     * @return \AWS\Result<array{knowledgeBase:array{createdAt:int|string|\DateTimeInterface, description?:string, failureReasons?:array<string>, knowledgeBaseArn:string, knowledgeBaseConfiguration:array{kendraKnowledgeBaseConfiguration?:array{kendraIndexArn:string}, sqlKnowledgeBaseConfiguration?:array{redshiftConfiguration?:array{queryEngineConfiguration:array{provisionedConfiguration?:array{authConfiguration:array{databaseUser?:string, type:"IAM"|"USERNAME_PASSWORD"|"USERNAME", usernamePasswordSecretArn?:string}, clusterIdentifier:string}, serverlessConfiguration?:array{authConfiguration:array{type:"IAM"|"USERNAME_PASSWORD", usernamePasswordSecretArn?:string}, workgroupArn:string}, type:"SERVERLESS"|"PROVISIONED"}, queryGenerationConfiguration?:array{executionTimeoutSeconds?:int, generationContext?:array{curatedQueries?:array<array{naturalLanguage:string, sql:string}>, tables?:array<array{columns?:array<array{description?:string, inclusion?:"INCLUDE"|"EXCLUDE", name?:string}>, description?:string, inclusion?:"INCLUDE"|"EXCLUDE", name:string}>}}, storageConfigurations:array<array{awsDataCatalogConfiguration?:array{tableNames:array<string>}, redshiftConfiguration?:mixed, type:"REDSHIFT"|"AWS_DATA_CATALOG"}>}, type:"REDSHIFT"}, type:"VECTOR"|"KENDRA"|"SQL", vectorKnowledgeBaseConfiguration?:array{embeddingModelArn:string, embeddingModelConfiguration?:array{bedrockEmbeddingModelConfiguration?:array{dimensions?:int, embeddingDataType?:"FLOAT32"|"BINARY"}}, supplementalDataStorageConfiguration?:array{storageLocations:array<array{s3Location?:array{uri:string}, type:"S3"}>}}}, knowledgeBaseId:string, name:string, roleArn:string, status:"CREATING"|"ACTIVE"|"DELETING"|"UPDATING"|"FAILED"|"DELETE_UNSUCCESSFUL", storageConfiguration?:array{mongoDbAtlasConfiguration?:array{collectionName:string, credentialsSecretArn:string, databaseName:string, endpoint:string, endpointServiceName?:string, fieldMapping:array{metadataField:string, textField:string, vectorField:string}, vectorIndexName:string}, opensearchServerlessConfiguration?:array{collectionArn:string, fieldMapping:array{metadataField:string, textField:string, vectorField:string}, vectorIndexName:string}, pineconeConfiguration?:array{connectionString:string, credentialsSecretArn:string, fieldMapping:array{metadataField:string, textField:string}, namespace?:string}, rdsConfiguration?:array{credentialsSecretArn:string, databaseName:string, fieldMapping:array{metadataField:string, primaryKeyField:string, textField:string, vectorField:string}, resourceArn:string, tableName:string}, redisEnterpriseCloudConfiguration?:array{credentialsSecretArn:string, endpoint:string, fieldMapping:array{metadataField:string, textField:string, vectorField:string}, vectorIndexName:string}, type:"OPENSEARCH_SERVERLESS"|"PINECONE"|"REDIS_ENTERPRISE_CLOUD"|"RDS"|"MONGO_DB_ATLAS"}, updatedAt:int|string|\DateTimeInterface}}>
     */
    public function updateKnowledgeBase(array $args): \AWS\Result { }

    /**
     * @param array{description?:string, knowledgeBaseConfiguration:array{kendraKnowledgeBaseConfiguration?:array{kendraIndexArn:string}, sqlKnowledgeBaseConfiguration?:array{redshiftConfiguration?:array{queryEngineConfiguration:array{provisionedConfiguration?:array{authConfiguration:array{databaseUser?:string, type:"IAM"|"USERNAME_PASSWORD"|"USERNAME", usernamePasswordSecretArn?:string}, clusterIdentifier:string}, serverlessConfiguration?:array{authConfiguration:array{type:"IAM"|"USERNAME_PASSWORD", usernamePasswordSecretArn?:string}, workgroupArn:string}, type:"SERVERLESS"|"PROVISIONED"}, queryGenerationConfiguration?:array{executionTimeoutSeconds?:int, generationContext?:array{curatedQueries?:array<array{naturalLanguage:string, sql:string}>, tables?:array<array{columns?:array<array{description?:string, inclusion?:"INCLUDE"|"EXCLUDE", name?:string}>, description?:string, inclusion?:"INCLUDE"|"EXCLUDE", name:string}>}}, storageConfigurations:array<array{awsDataCatalogConfiguration?:array{tableNames:array<string>}, redshiftConfiguration?:mixed, type:"REDSHIFT"|"AWS_DATA_CATALOG"}>}, type:"REDSHIFT"}, type:"VECTOR"|"KENDRA"|"SQL", vectorKnowledgeBaseConfiguration?:array{embeddingModelArn:string, embeddingModelConfiguration?:array{bedrockEmbeddingModelConfiguration?:array{dimensions?:int, embeddingDataType?:"FLOAT32"|"BINARY"}}, supplementalDataStorageConfiguration?:array{storageLocations:array<array{s3Location?:array{uri:string}, type:"S3"}>}}}, knowledgeBaseId:string, name:string, roleArn:string, storageConfiguration?:array{mongoDbAtlasConfiguration?:array{collectionName:string, credentialsSecretArn:string, databaseName:string, endpoint:string, endpointServiceName?:string, fieldMapping:array{metadataField:string, textField:string, vectorField:string}, vectorIndexName:string}, opensearchServerlessConfiguration?:array{collectionArn:string, fieldMapping:array{metadataField:string, textField:string, vectorField:string}, vectorIndexName:string}, pineconeConfiguration?:array{connectionString:string, credentialsSecretArn:string, fieldMapping:array{metadataField:string, textField:string}, namespace?:string}, rdsConfiguration?:array{credentialsSecretArn:string, databaseName:string, fieldMapping:array{metadataField:string, primaryKeyField:string, textField:string, vectorField:string}, resourceArn:string, tableName:string}, redisEnterpriseCloudConfiguration?:array{credentialsSecretArn:string, endpoint:string, fieldMapping:array{metadataField:string, textField:string, vectorField:string}, vectorIndexName:string}, type:"OPENSEARCH_SERVERLESS"|"PINECONE"|"REDIS_ENTERPRISE_CLOUD"|"RDS"|"MONGO_DB_ATLAS"}} $args
     * @return \GuzzleHttp\Promise\Promise<array{knowledgeBase:array{createdAt:int|string|\DateTimeInterface, description?:string, failureReasons?:array<string>, knowledgeBaseArn:string, knowledgeBaseConfiguration:array{kendraKnowledgeBaseConfiguration?:array{kendraIndexArn:string}, sqlKnowledgeBaseConfiguration?:array{redshiftConfiguration?:array{queryEngineConfiguration:array{provisionedConfiguration?:array{authConfiguration:array{databaseUser?:string, type:"IAM"|"USERNAME_PASSWORD"|"USERNAME", usernamePasswordSecretArn?:string}, clusterIdentifier:string}, serverlessConfiguration?:array{authConfiguration:array{type:"IAM"|"USERNAME_PASSWORD", usernamePasswordSecretArn?:string}, workgroupArn:string}, type:"SERVERLESS"|"PROVISIONED"}, queryGenerationConfiguration?:array{executionTimeoutSeconds?:int, generationContext?:array{curatedQueries?:array<array{naturalLanguage:string, sql:string}>, tables?:array<array{columns?:array<array{description?:string, inclusion?:"INCLUDE"|"EXCLUDE", name?:string}>, description?:string, inclusion?:"INCLUDE"|"EXCLUDE", name:string}>}}, storageConfigurations:array<array{awsDataCatalogConfiguration?:array{tableNames:array<string>}, redshiftConfiguration?:mixed, type:"REDSHIFT"|"AWS_DATA_CATALOG"}>}, type:"REDSHIFT"}, type:"VECTOR"|"KENDRA"|"SQL", vectorKnowledgeBaseConfiguration?:array{embeddingModelArn:string, embeddingModelConfiguration?:array{bedrockEmbeddingModelConfiguration?:array{dimensions?:int, embeddingDataType?:"FLOAT32"|"BINARY"}}, supplementalDataStorageConfiguration?:array{storageLocations:array<array{s3Location?:array{uri:string}, type:"S3"}>}}}, knowledgeBaseId:string, name:string, roleArn:string, status:"CREATING"|"ACTIVE"|"DELETING"|"UPDATING"|"FAILED"|"DELETE_UNSUCCESSFUL", storageConfiguration?:array{mongoDbAtlasConfiguration?:array{collectionName:string, credentialsSecretArn:string, databaseName:string, endpoint:string, endpointServiceName?:string, fieldMapping:array{metadataField:string, textField:string, vectorField:string}, vectorIndexName:string}, opensearchServerlessConfiguration?:array{collectionArn:string, fieldMapping:array{metadataField:string, textField:string, vectorField:string}, vectorIndexName:string}, pineconeConfiguration?:array{connectionString:string, credentialsSecretArn:string, fieldMapping:array{metadataField:string, textField:string}, namespace?:string}, rdsConfiguration?:array{credentialsSecretArn:string, databaseName:string, fieldMapping:array{metadataField:string, primaryKeyField:string, textField:string, vectorField:string}, resourceArn:string, tableName:string}, redisEnterpriseCloudConfiguration?:array{credentialsSecretArn:string, endpoint:string, fieldMapping:array{metadataField:string, textField:string, vectorField:string}, vectorIndexName:string}, type:"OPENSEARCH_SERVERLESS"|"PINECONE"|"REDIS_ENTERPRISE_CLOUD"|"RDS"|"MONGO_DB_ATLAS"}, updatedAt:int|string|\DateTimeInterface}}>
     */
    public function updateKnowledgeBaseAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{customerEncryptionKeyArn?:string, defaultVariant?:string, description?:string, name:string, promptIdentifier:string, variants?:array<array{additionalModelRequestFields?:array{}, genAiResource?:array{agent?:array{agentIdentifier:string}}, inferenceConfiguration?:array{text?:array{maxTokens?:int, stopSequences?:array<string>, temperature?:float, topP?:float}}, metadata?:array<array{key:string, value:string}>, modelId?:string, name:string, templateConfiguration:array{chat?:array{inputVariables?:array<array{name?:string}>, messages:array<array{content:array<array{text?:string}>, role:"user"|"assistant"}>, system?:array<array{text?:string}>, toolConfiguration?:array{toolChoice?:array{any?:array{}, auto?:array{}, tool?:array{name:string}}, tools:array<array{toolSpec?:array{description?:string, inputSchema:array{json?:array{}}, name:string}}>}}, text?:array{inputVariables?:array<array{name?:string}>, text:mixed}}, templateType:"TEXT"|"CHAT"}>} $args
     * @return \AWS\Result<array{arn:string, createdAt:int|string|\DateTimeInterface, customerEncryptionKeyArn?:string, defaultVariant?:string, description?:string, id:string, name:string, updatedAt:int|string|\DateTimeInterface, variants?:array<array{additionalModelRequestFields?:array{}, genAiResource?:array{agent?:array{agentIdentifier:string}}, inferenceConfiguration?:array{text?:array{maxTokens?:int, stopSequences?:array<string>, temperature?:float, topP?:float}}, metadata?:array<array{key:string, value:string}>, modelId?:string, name:string, templateConfiguration:array{chat?:array{inputVariables?:array<array{name?:string}>, messages:array<array{content:array<array{text?:string}>, role:"user"|"assistant"}>, system?:array<array{text?:string}>, toolConfiguration?:array{toolChoice?:array{any?:array{}, auto?:array{}, tool?:array{name:string}}, tools:array<array{toolSpec?:array{description?:string, inputSchema:array{json?:array{}}, name:string}}>}}, text?:array{inputVariables?:array<array{name?:string}>, text:mixed}}, templateType:"TEXT"|"CHAT"}>, version:string}>
     */
    public function updatePrompt(array $args): \AWS\Result { }

    /**
     * @param array{customerEncryptionKeyArn?:string, defaultVariant?:string, description?:string, name:string, promptIdentifier:string, variants?:array<array{additionalModelRequestFields?:array{}, genAiResource?:array{agent?:array{agentIdentifier:string}}, inferenceConfiguration?:array{text?:array{maxTokens?:int, stopSequences?:array<string>, temperature?:float, topP?:float}}, metadata?:array<array{key:string, value:string}>, modelId?:string, name:string, templateConfiguration:array{chat?:array{inputVariables?:array<array{name?:string}>, messages:array<array{content:array<array{text?:string}>, role:"user"|"assistant"}>, system?:array<array{text?:string}>, toolConfiguration?:array{toolChoice?:array{any?:array{}, auto?:array{}, tool?:array{name:string}}, tools:array<array{toolSpec?:array{description?:string, inputSchema:array{json?:array{}}, name:string}}>}}, text?:array{inputVariables?:array<array{name?:string}>, text:mixed}}, templateType:"TEXT"|"CHAT"}>} $args
     * @return \GuzzleHttp\Promise\Promise<array{arn:string, createdAt:int|string|\DateTimeInterface, customerEncryptionKeyArn?:string, defaultVariant?:string, description?:string, id:string, name:string, updatedAt:int|string|\DateTimeInterface, variants?:array<array{additionalModelRequestFields?:array{}, genAiResource?:array{agent?:array{agentIdentifier:string}}, inferenceConfiguration?:array{text?:array{maxTokens?:int, stopSequences?:array<string>, temperature?:float, topP?:float}}, metadata?:array<array{key:string, value:string}>, modelId?:string, name:string, templateConfiguration:array{chat?:array{inputVariables?:array<array{name?:string}>, messages:array<array{content:array<array{text?:string}>, role:"user"|"assistant"}>, system?:array<array{text?:string}>, toolConfiguration?:array{toolChoice?:array{any?:array{}, auto?:array{}, tool?:array{name:string}}, tools:array<array{toolSpec?:array{description?:string, inputSchema:array{json?:array{}}, name:string}}>}}, text?:array{inputVariables?:array<array{name?:string}>, text:mixed}}, templateType:"TEXT"|"CHAT"}>, version:string}>
     */
    public function updatePromptAsync(array $args): \GuzzleHttp\Promise\Promise { }

    /**
     * @param array{definition:array{connections?:array<array{configuration?:array{conditional?:array{condition:string}, data?:array{sourceOutput:string, targetInput:string}}, name:string, source:string, target:string, type:"Data"|"Conditional"}>, nodes?:array<array{configuration?:array{agent?:array{agentAliasArn:string}, collector?:array{}, condition?:array{conditions:array<array{expression?:string, name:string}>}, input?:array{}, iterator?:array{}, knowledgeBase?:array{guardrailConfiguration?:array{guardrailIdentifier?:string, guardrailVersion?:string}, knowledgeBaseId:string, modelId?:string}, lambdaFunction?:array{lambdaArn:string}, lex?:array{botAliasArn:string, localeId:string}, output?:array{}, prompt?:array{guardrailConfiguration?:array{guardrailIdentifier?:string, guardrailVersion?:string}, sourceConfiguration:array{inline?:array{additionalModelRequestFields?:array{}, inferenceConfiguration?:array{text?:array{maxTokens?:int, stopSequences?:array<string>, temperature?:float, topP?:float}}, modelId:string, templateConfiguration:array{chat?:array{inputVariables?:array<array{name?:string}>, messages:array<array{content:array<array{text?:string}>, role:"user"|"assistant"}>, system?:array<array{text?:string}>, toolConfiguration?:array{toolChoice?:array{any?:array{}, auto?:array{}, tool?:array{name:string}}, tools:array<array{toolSpec?:array{description?:string, inputSchema:array{json?:array{}}, name:string}}>}}, text?:array{inputVariables?:array<array{name?:string}>, text:mixed}}, templateType:"TEXT"|"CHAT"}, resource?:array{promptArn:string}}}, retrieval?:array{serviceConfiguration:array{s3?:array{bucketName:string}}}, storage?:array{serviceConfiguration:array{s3?:array{bucketName:string}}}}, inputs?:array<array{expression:string, name:string, type:"String"|"Number"|"Boolean"|"Object"|"Array"}>, name:string, outputs?:array<array{name:string, type:"String"|"Number"|"Boolean"|"Object"|"Array"}>, type:"Input"|"Output"|"KnowledgeBase"|"Condition"|"Lex"|"Prompt"|"LambdaFunction"|"Storage"|"Agent"|"Retrieval"|"Iterator"|"Collector"}>}} $args
     * @return \AWS\Result<array{validations:array<array{details?:array{cyclicConnection?:array{connection:string}, duplicateConditionExpression?:array{expression:string, node:string}, duplicateConnections?:array{source:string, target:string}, incompatibleConnectionDataType?:array{connection:string}, malformedConditionExpression?:array{cause:string, condition:string, node:string}, malformedNodeInputExpression?:array{cause:string, input:string, node:string}, mismatchedNodeInputType?:array{expectedType:"String"|"Number"|"Boolean"|"Object"|"Array", input:string, node:string}, mismatchedNodeOutputType?:array{expectedType:"String"|"Number"|"Boolean"|"Object"|"Array", node:string, output:string}, missingConnectionConfiguration?:array{connection:string}, missingDefaultCondition?:array{node:string}, missingEndingNodes?:array{}, missingNodeConfiguration?:array{node:string}, missingNodeInput?:array{input:string, node:string}, missingNodeOutput?:array{node:string, output:string}, missingStartingNodes?:array{}, multipleNodeInputConnections?:array{input:string, node:string}, unfulfilledNodeInput?:array{input:string, node:string}, unknownConnectionCondition?:array{connection:string}, unknownConnectionSource?:array{connection:string}, unknownConnectionSourceOutput?:array{connection:string}, unknownConnectionTarget?:array{connection:string}, unknownConnectionTargetInput?:array{connection:string}, unreachableNode?:array{node:string}, unsatisfiedConnectionConditions?:array{connection:string}, unspecified?:array{}}, message:string, severity:"Warning"|"Error", type?:"CyclicConnection"|"DuplicateConnections"|"DuplicateConditionExpression"|"UnreachableNode"|"UnknownConnectionSource"|"UnknownConnectionSourceOutput"|"UnknownConnectionTarget"|"UnknownConnectionTargetInput"|"UnknownConnectionCondition"|"MalformedConditionExpression"|"MalformedNodeInputExpression"|"MismatchedNodeInputType"|"MismatchedNodeOutputType"|"IncompatibleConnectionDataType"|"MissingConnectionConfiguration"|"MissingDefaultCondition"|"MissingEndingNodes"|"MissingNodeConfiguration"|"MissingNodeInput"|"MissingNodeOutput"|"MissingStartingNodes"|"MultipleNodeInputConnections"|"UnfulfilledNodeInput"|"UnsatisfiedConnectionConditions"|"Unspecified"}>}>
     */
    public function validateFlowDefinition(array $args): \AWS\Result { }

    /**
     * @param array{definition:array{connections?:array<array{configuration?:array{conditional?:array{condition:string}, data?:array{sourceOutput:string, targetInput:string}}, name:string, source:string, target:string, type:"Data"|"Conditional"}>, nodes?:array<array{configuration?:array{agent?:array{agentAliasArn:string}, collector?:array{}, condition?:array{conditions:array<array{expression?:string, name:string}>}, input?:array{}, iterator?:array{}, knowledgeBase?:array{guardrailConfiguration?:array{guardrailIdentifier?:string, guardrailVersion?:string}, knowledgeBaseId:string, modelId?:string}, lambdaFunction?:array{lambdaArn:string}, lex?:array{botAliasArn:string, localeId:string}, output?:array{}, prompt?:array{guardrailConfiguration?:array{guardrailIdentifier?:string, guardrailVersion?:string}, sourceConfiguration:array{inline?:array{additionalModelRequestFields?:array{}, inferenceConfiguration?:array{text?:array{maxTokens?:int, stopSequences?:array<string>, temperature?:float, topP?:float}}, modelId:string, templateConfiguration:array{chat?:array{inputVariables?:array<array{name?:string}>, messages:array<array{content:array<array{text?:string}>, role:"user"|"assistant"}>, system?:array<array{text?:string}>, toolConfiguration?:array{toolChoice?:array{any?:array{}, auto?:array{}, tool?:array{name:string}}, tools:array<array{toolSpec?:array{description?:string, inputSchema:array{json?:array{}}, name:string}}>}}, text?:array{inputVariables?:array<array{name?:string}>, text:mixed}}, templateType:"TEXT"|"CHAT"}, resource?:array{promptArn:string}}}, retrieval?:array{serviceConfiguration:array{s3?:array{bucketName:string}}}, storage?:array{serviceConfiguration:array{s3?:array{bucketName:string}}}}, inputs?:array<array{expression:string, name:string, type:"String"|"Number"|"Boolean"|"Object"|"Array"}>, name:string, outputs?:array<array{name:string, type:"String"|"Number"|"Boolean"|"Object"|"Array"}>, type:"Input"|"Output"|"KnowledgeBase"|"Condition"|"Lex"|"Prompt"|"LambdaFunction"|"Storage"|"Agent"|"Retrieval"|"Iterator"|"Collector"}>}} $args
     * @return \GuzzleHttp\Promise\Promise<array{validations:array<array{details?:array{cyclicConnection?:array{connection:string}, duplicateConditionExpression?:array{expression:string, node:string}, duplicateConnections?:array{source:string, target:string}, incompatibleConnectionDataType?:array{connection:string}, malformedConditionExpression?:array{cause:string, condition:string, node:string}, malformedNodeInputExpression?:array{cause:string, input:string, node:string}, mismatchedNodeInputType?:array{expectedType:"String"|"Number"|"Boolean"|"Object"|"Array", input:string, node:string}, mismatchedNodeOutputType?:array{expectedType:"String"|"Number"|"Boolean"|"Object"|"Array", node:string, output:string}, missingConnectionConfiguration?:array{connection:string}, missingDefaultCondition?:array{node:string}, missingEndingNodes?:array{}, missingNodeConfiguration?:array{node:string}, missingNodeInput?:array{input:string, node:string}, missingNodeOutput?:array{node:string, output:string}, missingStartingNodes?:array{}, multipleNodeInputConnections?:array{input:string, node:string}, unfulfilledNodeInput?:array{input:string, node:string}, unknownConnectionCondition?:array{connection:string}, unknownConnectionSource?:array{connection:string}, unknownConnectionSourceOutput?:array{connection:string}, unknownConnectionTarget?:array{connection:string}, unknownConnectionTargetInput?:array{connection:string}, unreachableNode?:array{node:string}, unsatisfiedConnectionConditions?:array{connection:string}, unspecified?:array{}}, message:string, severity:"Warning"|"Error", type?:"CyclicConnection"|"DuplicateConnections"|"DuplicateConditionExpression"|"UnreachableNode"|"UnknownConnectionSource"|"UnknownConnectionSourceOutput"|"UnknownConnectionTarget"|"UnknownConnectionTargetInput"|"UnknownConnectionCondition"|"MalformedConditionExpression"|"MalformedNodeInputExpression"|"MismatchedNodeInputType"|"MismatchedNodeOutputType"|"IncompatibleConnectionDataType"|"MissingConnectionConfiguration"|"MissingDefaultCondition"|"MissingEndingNodes"|"MissingNodeConfiguration"|"MissingNodeInput"|"MissingNodeOutput"|"MissingStartingNodes"|"MultipleNodeInputConnections"|"UnfulfilledNodeInput"|"UnsatisfiedConnectionConditions"|"Unspecified"}>}>
     */
    public function validateFlowDefinitionAsync(array $args): \GuzzleHttp\Promise\Promise { }
}
